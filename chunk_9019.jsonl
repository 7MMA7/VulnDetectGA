{"idx": 442189, "project": "qemu", "commit_id": "1caff0340f49c93d535c6558a5138d20d475315c", "project_url": "https://github.com/bonzini/qemu", "commit_url": "https://git.qemu.org/?p=qemu.git;a=commit;h=1caff0340f49c93d535c6558a5138d20d475315c", "commit_message": "e1000: switch to use qemu_receive_packet() for loopback\n\nThis patch switches to use qemu_receive_packet() which can detect\nreentrancy and return early.\n\nThis is intended to address CVE-2021-3416.\n\nCc: Prasad J Pandit <ppandit@redhat.com>\nCc: qemu-stable@nongnu.org\nReviewed-by: Philippe Mathieu-Daud\u00e9 <philmd@redhat.com>\nSigned-off-by: Jason Wang <jasowang@redhat.com>", "target": 0, "func": "e1000_send_packet(E1000State *s, const uint8_t *buf, int size)\n{\n    static const int PTCregs[6] = { PTC64, PTC127, PTC255, PTC511,\n                                    PTC1023, PTC1522 };\n\n    NetClientState *nc = qemu_get_queue(s->nic);\n    if (s->phy_reg[PHY_CTRL] & MII_CR_LOOPBACK) {\n        qemu_receive_packet(nc, buf, size);\n    } else {\n        qemu_send_packet(nc, buf, size);\n    }\n    inc_tx_bcast_or_mcast_count(s, buf);\n    e1000x_increase_size_stats(s->mac_reg, PTCregs, size);\n}", "func_hash": 300536712775088152847906693971285564175, "file_name": "e1000.c", "file_hash": 47410790699069024700445146821057200888, "cwe": ["CWE-835"], "cve": "CVE-2021-3416", "cve_desc": "A potential stack overflow via infinite loop issue was found in various NIC emulators of QEMU in versions up to and including 5.2.0. The issue occurs in loopback mode of a NIC wherein reentrant DMA checks get bypassed. A guest user/process may use this flaw to consume CPU cycles or crash the QEMU process on the host resulting in DoS scenario.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-3416", "file_path": "hw/net/e1000.c"}
{"idx": 210896, "project": "spice", "commit_id": "a4a16ac42d2f19a17e36556546aa94d5cd83745f", "project_url": "https://gitlab.freedesktop.org/spice/spice", "commit_url": "https://gitlab.freedesktop.org/spice/spice/commit/a4a16ac42d2f19a17e36556546aa94d5cd83745f", "commit_message": "memslot: Fix off-by-one error in group/slot boundary check\n\nRedMemSlotInfo keeps an array of groups, and each group contains an\narray of slots. Unfortunately, these checks are off by 1, they check\nthat the index is greater or equal to the number of elements in the\narray, while these arrays are 0 based. The check should only check for\nstrictly greater than the number of elements.\n\nFor the group array, this is not a big issue, as these memslot groups\nare created by spice-server users (eg QEMU), and the group ids used to\nindex that array are also generated by the spice-server user, so it\nshould not be possible for the guest to set them to arbitrary values.\n\nThe slot id is more problematic, as it's calculated from a QXLPHYSICAL\naddress, and such addresses are usually set by the guest QXL driver, so\nthe guest can set these to arbitrary values, including malicious values,\nwhich are probably easy to build from the guest PCI configuration.\n\nThis patch fixes the arrays bound check, and adds a test case for this.\nThis fixes CVE-2019-3813.\n\nSigned-off-by: Christophe Fergeau <cfergeau@redhat.com>\nAcked-by: Frediano Ziglio <fziglio@redhat.com>", "target": 1, "func": "void *memslot_get_virt(RedMemSlotInfo *info, QXLPHYSICAL addr, uint32_t add_size,\n                       int group_id)\n{\n    int slot_id;\n    int generation;\n    unsigned long h_virt;\n\n    MemSlot *slot;\n\n    if (group_id > info->num_memslots_groups) {\n        spice_critical(\"group_id too big\");\n        return NULL;\n    }\n\n    slot_id = memslot_get_id(info, addr);\n    if (slot_id > info->num_memslots) {\n        print_memslots(info);\n        spice_critical(\"slot_id %d too big, addr=%\" PRIx64, slot_id, addr);\n        return NULL;\n    }\n\n    slot = &info->mem_slots[group_id][slot_id];\n\n    generation = memslot_get_generation(info, addr);\n    if (generation != slot->generation) {\n        print_memslots(info);\n        spice_critical(\"address generation is not valid, group_id %d, slot_id %d, \"\n                       \"gen %d, slot_gen %d\",\n                       group_id, slot_id,\n                       generation, slot->generation);\n        return NULL;\n    }\n\n    h_virt = __get_clean_virt(info, addr);\n    h_virt += slot->address_delta;\n\n    if (!memslot_validate_virt(info, h_virt, slot_id, add_size, group_id)) {\n        return NULL;\n    }\n\n    return (void*)(uintptr_t)h_virt;\n}", "func_hash": 339666083531536346198123409033012275535, "file_name": "memslot.c", "file_hash": 314430538622797217223560939109800616180, "cwe": ["CWE-193"], "cve": "CVE-2019-3813", "cve_desc": "Spice, versions 0.5.2 through 0.14.1, are vulnerable to an out-of-bounds read due to an off-by-one error in memslot_get_virt. This may lead to a denial of service, or, in the worst case, code-execution by unauthenticated attackers.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2019-3813", "file_path": "server/memslot.c"}
{"idx": 442587, "project": "spice", "commit_id": "a4a16ac42d2f19a17e36556546aa94d5cd83745f", "project_url": "https://gitlab.freedesktop.org/spice/spice", "commit_url": "https://gitlab.freedesktop.org/spice/spice/commit/a4a16ac42d2f19a17e36556546aa94d5cd83745f", "commit_message": "memslot: Fix off-by-one error in group/slot boundary check\n\nRedMemSlotInfo keeps an array of groups, and each group contains an\narray of slots. Unfortunately, these checks are off by 1, they check\nthat the index is greater or equal to the number of elements in the\narray, while these arrays are 0 based. The check should only check for\nstrictly greater than the number of elements.\n\nFor the group array, this is not a big issue, as these memslot groups\nare created by spice-server users (eg QEMU), and the group ids used to\nindex that array are also generated by the spice-server user, so it\nshould not be possible for the guest to set them to arbitrary values.\n\nThe slot id is more problematic, as it's calculated from a QXLPHYSICAL\naddress, and such addresses are usually set by the guest QXL driver, so\nthe guest can set these to arbitrary values, including malicious values,\nwhich are probably easy to build from the guest PCI configuration.\n\nThis patch fixes the arrays bound check, and adds a test case for this.\nThis fixes CVE-2019-3813.\n\nSigned-off-by: Christophe Fergeau <cfergeau@redhat.com>\nAcked-by: Frediano Ziglio <fziglio@redhat.com>", "target": 0, "func": "void *memslot_get_virt(RedMemSlotInfo *info, QXLPHYSICAL addr, uint32_t add_size,\n                       int group_id)\n{\n    int slot_id;\n    int generation;\n    unsigned long h_virt;\n\n    MemSlot *slot;\n\n    if (group_id >= info->num_memslots_groups) {\n        spice_critical(\"group_id too big\");\n        return NULL;\n    }\n\n    slot_id = memslot_get_id(info, addr);\n    if (slot_id >= info->num_memslots) {\n        print_memslots(info);\n        spice_critical(\"slot_id %d too big, addr=%\" PRIx64, slot_id, addr);\n        return NULL;\n    }\n\n    slot = &info->mem_slots[group_id][slot_id];\n\n    generation = memslot_get_generation(info, addr);\n    if (generation != slot->generation) {\n        print_memslots(info);\n        spice_critical(\"address generation is not valid, group_id %d, slot_id %d, \"\n                       \"gen %d, slot_gen %d\",\n                       group_id, slot_id,\n                       generation, slot->generation);\n        return NULL;\n    }\n\n    h_virt = __get_clean_virt(info, addr);\n    h_virt += slot->address_delta;\n\n    if (!memslot_validate_virt(info, h_virt, slot_id, add_size, group_id)) {\n        return NULL;\n    }\n\n    return (void*)(uintptr_t)h_virt;\n}", "func_hash": 316300758635752588909124078674988704544, "file_name": "memslot.c", "file_hash": 44209429737432775835092242401604898921, "cwe": ["CWE-193"], "cve": "CVE-2019-3813", "cve_desc": "Spice, versions 0.5.2 through 0.14.1, are vulnerable to an out-of-bounds read due to an off-by-one error in memslot_get_virt. This may lead to a denial of service, or, in the worst case, code-execution by unauthenticated attackers.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2019-3813", "file_path": "server/memslot.c"}
{"idx": 210904, "project": "curl", "commit_id": "70b1900dd13d16f2e83f571407a614541d5ac9ba", "project_url": "https://github.com/curl/curl", "commit_url": "https://github.com/curl/curl/commit/70b1900dd13d16f2e83f571407a614541d5ac9ba", "commit_message": "'mytx' in bug report #1723194 (http://curl.haxx.se/bug/view.cgi?id=1723194)\npointed out that the warnf() function in the curl tool didn't properly deal\nwith the cases when excessively long words were used in the string to chop\nup.", "target": 1, "func": "static void warnf(struct Configurable *config, const char *fmt, ...)\n{\n  if(!(config->conf & CONF_MUTE)) {\n    va_list ap;\n    int len;\n    char *ptr;\n    char print_buffer[256];\n\n    va_start(ap, fmt);\n    va_start(ap, fmt);\n    len = vsnprintf(print_buffer, sizeof(print_buffer), fmt, ap);\n    va_end(ap);\n\n    ptr = print_buffer;\n    while(len > 0) {\n      fputs(WARN_PREFIX, config->errors);\n\n      if(len > (int)WARN_TEXTWIDTH) {\n        int cut = WARN_TEXTWIDTH-1;\n\n        while(!ISSPACE(ptr[cut]) && cut) {\n          cut--;\n        }\n\n        fwrite(ptr, cut + 1, 1, config->errors);\n        fputs(\"\\n\", config->errors);\n        ptr += cut+1; /* skip the space too */\n        len -= cut;\n      }\n      else {\n        fputs(ptr, config->errors);\n        len = 0;\n      }\n    }\n  }\n}", "func_hash": 84425875494863871647567570837033062033, "file_name": "main.c", "file_hash": 117508051074384799366027341072623749818, "cwe": ["CWE-125"], "cve": "CVE-2018-16842", "cve_desc": "Curl versions 7.14.1 through 7.61.1 are vulnerable to a heap-based buffer over-read in the tool_msgs.c:voutf() function that may result in information exposure and denial of service.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2018-16842", "file_path": "src/main.c"}
{"idx": 442815, "project": "curl", "commit_id": "70b1900dd13d16f2e83f571407a614541d5ac9ba", "project_url": "https://github.com/curl/curl", "commit_url": "https://github.com/curl/curl/commit/70b1900dd13d16f2e83f571407a614541d5ac9ba", "commit_message": "'mytx' in bug report #1723194 (http://curl.haxx.se/bug/view.cgi?id=1723194)\npointed out that the warnf() function in the curl tool didn't properly deal\nwith the cases when excessively long words were used in the string to chop\nup.", "target": 0, "func": "static void warnf(struct Configurable *config, const char *fmt, ...)\n{\n  if(!(config->conf & CONF_MUTE)) {\n    va_list ap;\n    int len;\n    char *ptr;\n    char print_buffer[256];\n\n    va_start(ap, fmt);\n    va_start(ap, fmt);\n    len = vsnprintf(print_buffer, sizeof(print_buffer), fmt, ap);\n    va_end(ap);\n\n    ptr = print_buffer;\n    while(len > 0) {\n      fputs(WARN_PREFIX, config->errors);\n\n      if(len > (int)WARN_TEXTWIDTH) {\n        int cut = WARN_TEXTWIDTH-1;\n\n        while(!ISSPACE(ptr[cut]) && cut) {\n          cut--;\n        }\n        if(0 == cut)\n          /* not a single cutting position was found, just cut it at the\n             max text width then! */\n          cut = WARN_TEXTWIDTH-1;\n\n        fwrite(ptr, cut + 1, 1, config->errors);\n        fputs(\"\\n\", config->errors);\n        ptr += cut+1; /* skip the space too */\n        len -= cut;\n      }\n      else {\n        fputs(ptr, config->errors);\n        len = 0;\n      }\n    }\n  }\n}", "func_hash": 253014912777777803689145200879767407638, "file_name": "main.c", "file_hash": 161085884624432597777110570993729624797, "cwe": ["CWE-125"], "cve": "CVE-2018-16842", "cve_desc": "Curl versions 7.14.1 through 7.61.1 are vulnerable to a heap-based buffer over-read in the tool_msgs.c:voutf() function that may result in information exposure and denial of service.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2018-16842", "file_path": "src/main.c"}
