{"idx": 208411, "project": "vim", "commit_id": "27efc62f5d86afcb2ecb7565587fe8dea4b036fe", "project_url": "https://github.com/vim/vim", "commit_url": "https://github.com/vim/vim/commit/27efc62f5d86afcb2ecb7565587fe8dea4b036fe", "commit_message": "patch 9.0.0018: going over the end of the typahead\n\nProblem:    Going over the end of the typahead.\nSolution:   Put a NUL after the typeahead.", "target": 1, "func": "check_termcode(\n    int\t\tmax_offset,\n    char_u\t*buf,\n    int\t\tbufsize,\n    int\t\t*buflen)\n{\n    char_u\t*tp;\n    char_u\t*p;\n    int\t\tslen = 0;\t// init for GCC\n    int\t\tmodslen;\n    int\t\tlen;\n    int\t\tretval = 0;\n    int\t\toffset;\n    char_u\tkey_name[2];\n    int\t\tmodifiers;\n    char_u\t*modifiers_start = NULL;\n    int\t\tkey;\n    int\t\tnew_slen;   // Length of what will replace the termcode\n    char_u\tstring[MAX_KEY_CODE_LEN + 1];\n    int\t\ti, j;\n    int\t\tidx = 0;\n    int\t\tcpo_koffset;\n\n    cpo_koffset = (vim_strchr(p_cpo, CPO_KOFFSET) != NULL);\n\n    /*\n     * Speed up the checks for terminal codes by gathering all first bytes\n     * used in termleader[].  Often this is just a single <Esc>.\n     */\n    if (need_gather)\n\tgather_termleader();\n\n    /*\n     * Check at several positions in typebuf.tb_buf[], to catch something like\n     * \"x<Up>\" that can be mapped. Stop at max_offset, because characters\n     * after that cannot be used for mapping, and with @r commands\n     * typebuf.tb_buf[] can become very long.\n     * This is used often, KEEP IT FAST!\n     */\n    for (offset = 0; offset < max_offset; ++offset)\n    {\n\tif (buf == NULL)\n\t{\n\t    if (offset >= typebuf.tb_len)\n\t\tbreak;\n\t    tp = typebuf.tb_buf + typebuf.tb_off + offset;\n\t    len = typebuf.tb_len - offset;\t// length of the input\n\t}\n\telse\n\t{\n\t    if (offset >= *buflen)\n\t\tbreak;\n\t    tp = buf + offset;\n\t    len = *buflen - offset;\n\t}\n\n\t/*\n\t * Don't check characters after K_SPECIAL, those are already\n\t * translated terminal chars (avoid translating ~@^Hx).\n\t */\n\tif (*tp == K_SPECIAL)\n\t{\n\t    offset += 2;\t// there are always 2 extra characters\n\t    continue;\n\t}\n\n\t/*\n\t * Skip this position if the character does not appear as the first\n\t * character in term_strings. This speeds up a lot, since most\n\t * termcodes start with the same character (ESC or CSI).\n\t */\n\ti = *tp;\n\tfor (p = termleader; *p && *p != i; ++p)\n\t    ;\n\tif (*p == NUL)\n\t    continue;\n\n\t/*\n\t * Skip this position if p_ek is not set and tp[0] is an ESC and we\n\t * are in Insert mode.\n\t */\n\tif (*tp == ESC && !p_ek && (State & MODE_INSERT))\n\t    continue;\n\n\tkey_name[0] = NUL;\t// no key name found yet\n\tkey_name[1] = NUL;\t// no key name found yet\n\tmodifiers = 0;\t\t// no modifiers yet\n\n#ifdef FEAT_GUI\n\tif (gui.in_use)\n\t{\n\t    /*\n\t     * GUI special key codes are all of the form [CSI xx].\n\t     */\n\t    if (*tp == CSI)\t    // Special key from GUI\n\t    {\n\t\tif (len < 3)\n\t\t    return -1;\t    // Shouldn't happen\n\t\tslen = 3;\n\t\tkey_name[0] = tp[1];\n\t\tkey_name[1] = tp[2];\n\t    }\n\t}\n\telse\n#endif // FEAT_GUI\n\t{\n\t    int  mouse_index_found = -1;\n\n\t    for (idx = 0; idx < tc_len; ++idx)\n\t    {\n\t\t/*\n\t\t * Ignore the entry if we are not at the start of\n\t\t * typebuf.tb_buf[]\n\t\t * and there are not enough characters to make a match.\n\t\t * But only when the 'K' flag is in 'cpoptions'.\n\t\t */\n\t\tslen = termcodes[idx].len;\n\t\tmodifiers_start = NULL;\n\t\tif (cpo_koffset && offset && len < slen)\n\t\t    continue;\n\t\tif (STRNCMP(termcodes[idx].code, tp,\n\t\t\t\t     (size_t)(slen > len ? len : slen)) == 0)\n\t\t{\n\t\t    int\t    looks_like_mouse_start = FALSE;\n\n\t\t    if (len < slen)\t\t// got a partial sequence\n\t\t\treturn -1;\t\t// need to get more chars\n\n\t\t    /*\n\t\t     * When found a keypad key, check if there is another key\n\t\t     * that matches and use that one.  This makes <Home> to be\n\t\t     * found instead of <kHome> when they produce the same\n\t\t     * key code.\n\t\t     */\n\t\t    if (termcodes[idx].name[0] == 'K'\n\t\t\t\t       && VIM_ISDIGIT(termcodes[idx].name[1]))\n\t\t    {\n\t\t\tfor (j = idx + 1; j < tc_len; ++j)\n\t\t\t    if (termcodes[j].len == slen &&\n\t\t\t\t    STRNCMP(termcodes[idx].code,\n\t\t\t\t\t    termcodes[j].code, slen) == 0)\n\t\t\t    {\n\t\t\t\tidx = j;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t    }\n\n\t\t    if (slen == 2 && len > 2\n\t\t\t    && termcodes[idx].code[0] == ESC\n\t\t\t    && termcodes[idx].code[1] == '[')\n\t\t    {\n\t\t\t// The mouse termcode \"ESC [\" is also the prefix of\n\t\t\t// \"ESC [ I\" (focus gained) and other keys.  Check some\n\t\t\t// more bytes to find out.\n\t\t\tif (!isdigit(tp[2]))\n\t\t\t{\n\t\t\t    // ESC [ without number following: Only use it when\n\t\t\t    // there is no other match.\n\t\t\t    looks_like_mouse_start = TRUE;\n\t\t\t}\n\t\t\telse if (termcodes[idx].name[0] == KS_DEC_MOUSE)\n\t\t\t{\n\t\t\t    char_u  *nr = tp + 2;\n\t\t\t    int\t    count = 0;\n\n\t\t\t    // If a digit is following it could be a key with\n\t\t\t    // modifier, e.g., ESC [ 1;2P.  Can be confused\n\t\t\t    // with DEC_MOUSE, which requires four numbers\n\t\t\t    // following.  If not then it can't be a DEC_MOUSE\n\t\t\t    // code.\n\t\t\t    for (;;)\n\t\t\t    {\n\t\t\t\t++count;\n\t\t\t\t(void)getdigits(&nr);\n\t\t\t\tif (nr >= tp + len)\n\t\t\t\t    return -1;\t// partial sequence\n\t\t\t\tif (*nr != ';')\n\t\t\t\t    break;\n\t\t\t\t++nr;\n\t\t\t\tif (nr >= tp + len)\n\t\t\t\t    return -1;\t// partial sequence\n\t\t\t    }\n\t\t\t    if (count < 4)\n\t\t\t\tcontinue;\t// no match\n\t\t\t}\n\t\t    }\n\t\t    if (looks_like_mouse_start)\n\t\t    {\n\t\t\t// Only use it when there is no other match.\n\t\t\tif (mouse_index_found < 0)\n\t\t\t    mouse_index_found = idx;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tkey_name[0] = termcodes[idx].name[0];\n\t\t\tkey_name[1] = termcodes[idx].name[1];\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\n\t\t/*\n\t\t * Check for code with modifier, like xterm uses:\n\t\t * <Esc>[123;*X  (modslen == slen - 3)\n\t\t * <Esc>[@;*X    (matches <Esc>[X and <Esc>[1;9X )\n\t\t * Also <Esc>O*X and <M-O>*X (modslen == slen - 2).\n\t\t * When there is a modifier the * matches a number.\n\t\t * When there is no modifier the ;* or * is omitted.\n\t\t */\n\t\tif (termcodes[idx].modlen > 0 && mouse_index_found < 0)\n\t\t{\n\t\t    int at_code;\n\n\t\t    modslen = termcodes[idx].modlen;\n\t\t    if (cpo_koffset && offset && len < modslen)\n\t\t\tcontinue;\n\t\t    at_code = termcodes[idx].code[modslen] == '@';\n\t\t    if (STRNCMP(termcodes[idx].code, tp,\n\t\t\t\t(size_t)(modslen > len ? len : modslen)) == 0)\n\t\t    {\n\t\t\tint\t    n;\n\n\t\t\tif (len <= modslen)\t// got a partial sequence\n\t\t\t    return -1;\t\t// need to get more chars\n\n\t\t\tif (tp[modslen] == termcodes[idx].code[slen - 1])\n\t\t\t    // no modifiers\n\t\t\t    slen = modslen + 1;\n\t\t\telse if (tp[modslen] != ';' && modslen == slen - 3)\n\t\t\t    // no match for \"code;*X\" with \"code;\"\n\t\t\t    continue;\n\t\t\telse if (at_code && tp[modslen] != '1')\n\t\t\t    // no match for \"<Esc>[@\" with \"<Esc>[1\"\n\t\t\t    continue;\n\t\t\telse\n\t\t\t{\n\t\t\t    // Skip over the digits, the final char must\n\t\t\t    // follow. URXVT can use a negative value, thus\n\t\t\t    // also accept '-'.\n\t\t\t    for (j = slen - 2; j < len && (isdigit(tp[j])\n\t\t\t\t       || tp[j] == '-' || tp[j] == ';'); ++j)\n\t\t\t\t;\n\t\t\t    ++j;\n\t\t\t    if (len < j)\t// got a partial sequence\n\t\t\t\treturn -1;\t// need to get more chars\n\t\t\t    if (tp[j - 1] != termcodes[idx].code[slen - 1])\n\t\t\t\tcontinue;\t// no match\n\n\t\t\t    modifiers_start = tp + slen - 2;\n\n\t\t\t    // Match!  Convert modifier bits.\n\t\t\t    n = atoi((char *)modifiers_start);\n\t\t\t    modifiers |= decode_modifiers(n);\n\n\t\t\t    slen = j;\n\t\t\t}\n\t\t\tkey_name[0] = termcodes[idx].name[0];\n\t\t\tkey_name[1] = termcodes[idx].name[1];\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t    if (idx == tc_len && mouse_index_found >= 0)\n\t    {\n\t\tkey_name[0] = termcodes[mouse_index_found].name[0];\n\t\tkey_name[1] = termcodes[mouse_index_found].name[1];\n\t    }\n\t}\n\n#ifdef FEAT_TERMRESPONSE\n\tif (key_name[0] == NUL\n\t    // Mouse codes of DEC and pterm start with <ESC>[.  When\n\t    // detecting the start of these mouse codes they might as well be\n\t    // another key code or terminal response.\n# ifdef FEAT_MOUSE_DEC\n\t    || key_name[0] == KS_DEC_MOUSE\n# endif\n# ifdef FEAT_MOUSE_PTERM\n\t    || key_name[0] == KS_PTERM_MOUSE\n# endif\n\t   )\n\t{\n\t    char_u *argp = tp[0] == ESC ? tp + 2 : tp + 1;\n\n\t    /*\n\t     * Check for responses from the terminal starting with {lead}:\n\t     * \"<Esc>[\" or CSI followed by [0-9>?]\n\t     *\n\t     * - Xterm version string: {lead}>{x};{vers};{y}c\n\t     *   Also eat other possible responses to t_RV, rxvt returns\n\t     *   \"{lead}?1;2c\".\n\t     *\n\t     * - Cursor position report: {lead}{row};{col}R\n\t     *   The final byte must be 'R'. It is used for checking the\n\t     *   ambiguous-width character state.\n\t     *\n\t     * - window position reply: {lead}3;{x};{y}t\n\t     *\n\t     * - key with modifiers when modifyOtherKeys is enabled:\n\t     *\t    {lead}27;{modifier};{key}~\n\t     *\t    {lead}{key};{modifier}u\n\t     */\n\t    if (((tp[0] == ESC && len >= 3 && tp[1] == '[')\n\t\t\t    || (tp[0] == CSI && len >= 2))\n\t\t    && (VIM_ISDIGIT(*argp) || *argp == '>' || *argp == '?'))\n\t    {\n\t\tint resp = handle_csi(tp, len, argp, offset, buf,\n\t\t\t\t\t     bufsize, buflen, key_name, &slen);\n\t\tif (resp != 0)\n\t\t{\n# ifdef DEBUG_TERMRESPONSE\n\t\t    if (resp == -1)\n\t\t\tLOG_TR((\"Not enough characters for CSI sequence\"));\n# endif\n\t\t    return resp;\n\t\t}\n\t    }\n\n\t    // Check for fore/background color response from the terminal,\n\t    // starting} with <Esc>] or OSC\n\t    else if ((*T_RBG != NUL || *T_RFG != NUL)\n\t\t\t&& ((tp[0] == ESC && len >= 2 && tp[1] == ']')\n\t\t\t    || tp[0] == OSC))\n\t    {\n\t\tif (handle_osc(tp, argp, len, key_name, &slen) == FAIL)\n\t\t    return -1;\n\t    }\n\n\t    // Check for key code response from xterm,\n\t    // starting with <Esc>P or DCS\n\t    else if ((check_for_codes || rcs_status.tr_progress == STATUS_SENT)\n\t\t    && ((tp[0] == ESC && len >= 2 && tp[1] == 'P')\n\t\t\t|| tp[0] == DCS))\n\t    {\n\t\tif (handle_dcs(tp, argp, len, key_name, &slen) == FAIL)\n\t\t    return -1;\n\t    }\n\t}\n#endif\n\n\tif (key_name[0] == NUL)\n\t    continue;\t    // No match at this position, try next one\n\n\t// We only get here when we have a complete termcode match\n\n#ifdef FEAT_GUI\n\t/*\n\t * Only in the GUI: Fetch the pointer coordinates of the scroll event\n\t * so that we know which window to scroll later.\n\t */\n\tif (gui.in_use\n\t\t&& key_name[0] == (int)KS_EXTRA\n\t\t&& (key_name[1] == (int)KE_X1MOUSE\n\t\t    || key_name[1] == (int)KE_X2MOUSE\n\t\t    || key_name[1] == (int)KE_MOUSEMOVE_XY\n\t\t    || key_name[1] == (int)KE_MOUSELEFT\n\t\t    || key_name[1] == (int)KE_MOUSERIGHT\n\t\t    || key_name[1] == (int)KE_MOUSEDOWN\n\t\t    || key_name[1] == (int)KE_MOUSEUP))\n\t{\n\t    char_u\tbytes[6];\n\t    int\t\tnum_bytes = get_bytes_from_buf(tp + slen, bytes, 4);\n\n\t    if (num_bytes == -1)\t// not enough coordinates\n\t\treturn -1;\n\t    mouse_col = 128 * (bytes[0] - ' ' - 1) + bytes[1] - ' ' - 1;\n\t    mouse_row = 128 * (bytes[2] - ' ' - 1) + bytes[3] - ' ' - 1;\n\t    slen += num_bytes;\n\t    // equal to K_MOUSEMOVE\n\t    if (key_name[1] == (int)KE_MOUSEMOVE_XY)\n\t\tkey_name[1] = (int)KE_MOUSEMOVE;\n\t}\n\telse\n#endif\n\t/*\n\t * If it is a mouse click, get the coordinates.\n\t */\n\tif (key_name[0] == KS_MOUSE\n#ifdef FEAT_MOUSE_GPM\n\t\t|| key_name[0] == KS_GPM_MOUSE\n#endif\n#ifdef FEAT_MOUSE_JSB\n\t\t|| key_name[0] == KS_JSBTERM_MOUSE\n#endif\n#ifdef FEAT_MOUSE_NET\n\t\t|| key_name[0] == KS_NETTERM_MOUSE\n#endif\n#ifdef FEAT_MOUSE_DEC\n\t\t|| key_name[0] == KS_DEC_MOUSE\n#endif\n#ifdef FEAT_MOUSE_PTERM\n\t\t|| key_name[0] == KS_PTERM_MOUSE\n#endif\n#ifdef FEAT_MOUSE_URXVT\n\t\t|| key_name[0] == KS_URXVT_MOUSE\n#endif\n\t\t|| key_name[0] == KS_SGR_MOUSE\n\t\t|| key_name[0] == KS_SGR_MOUSE_RELEASE)\n\t{\n\t    if (check_termcode_mouse(tp, &slen, key_name, modifiers_start, idx,\n\t\t\t\t\t\t\t     &modifiers) == -1)\n\t\treturn -1;\n\t}\n\n#ifdef FEAT_GUI\n\t/*\n\t * If using the GUI, then we get menu and scrollbar events.\n\t *\n\t * A menu event is encoded as K_SPECIAL, KS_MENU, KE_FILLER followed by\n\t * four bytes which are to be taken as a pointer to the vimmenu_T\n\t * structure.\n\t *\n\t * A tab line event is encoded as K_SPECIAL KS_TABLINE nr, where \"nr\"\n\t * is one byte with the tab index.\n\t *\n\t * A scrollbar event is K_SPECIAL, KS_VER_SCROLLBAR, KE_FILLER followed\n\t * by one byte representing the scrollbar number, and then four bytes\n\t * representing a long_u which is the new value of the scrollbar.\n\t *\n\t * A horizontal scrollbar event is K_SPECIAL, KS_HOR_SCROLLBAR,\n\t * KE_FILLER followed by four bytes representing a long_u which is the\n\t * new value of the scrollbar.\n\t */\n# ifdef FEAT_MENU\n\telse if (key_name[0] == (int)KS_MENU)\n\t{\n\t    long_u\tval;\n\t    int\t\tnum_bytes = get_long_from_buf(tp + slen, &val);\n\n\t    if (num_bytes == -1)\n\t\treturn -1;\n\t    current_menu = (vimmenu_T *)val;\n\t    slen += num_bytes;\n\n\t    // The menu may have been deleted right after it was used, check\n\t    // for that.\n\t    if (check_menu_pointer(root_menu, current_menu) == FAIL)\n\t    {\n\t\tkey_name[0] = KS_EXTRA;\n\t\tkey_name[1] = (int)KE_IGNORE;\n\t    }\n\t}\n# endif\n# ifdef FEAT_GUI_TABLINE\n\telse if (key_name[0] == (int)KS_TABLINE)\n\t{\n\t    // Selecting tabline tab or using its menu.\n\t    char_u\tbytes[6];\n\t    int\t\tnum_bytes = get_bytes_from_buf(tp + slen, bytes, 1);\n\n\t    if (num_bytes == -1)\n\t\treturn -1;\n\t    current_tab = (int)bytes[0];\n\t    if (current_tab == 255)\t// -1 in a byte gives 255\n\t\tcurrent_tab = -1;\n\t    slen += num_bytes;\n\t}\n\telse if (key_name[0] == (int)KS_TABMENU)\n\t{\n\t    // Selecting tabline tab or using its menu.\n\t    char_u\tbytes[6];\n\t    int\t\tnum_bytes = get_bytes_from_buf(tp + slen, bytes, 2);\n\n\t    if (num_bytes == -1)\n\t\treturn -1;\n\t    current_tab = (int)bytes[0];\n\t    current_tabmenu = (int)bytes[1];\n\t    slen += num_bytes;\n\t}\n# endif\n# ifndef USE_ON_FLY_SCROLL\n\telse if (key_name[0] == (int)KS_VER_SCROLLBAR)\n\t{\n\t    long_u\tval;\n\t    char_u\tbytes[6];\n\t    int\t\tnum_bytes;\n\n\t    // Get the last scrollbar event in the queue of the same type\n\t    j = 0;\n\t    for (i = 0; tp[j] == CSI && tp[j + 1] == KS_VER_SCROLLBAR\n\t\t\t\t\t\t     && tp[j + 2] != NUL; ++i)\n\t    {\n\t\tj += 3;\n\t\tnum_bytes = get_bytes_from_buf(tp + j, bytes, 1);\n\t\tif (num_bytes == -1)\n\t\t    break;\n\t\tif (i == 0)\n\t\t    current_scrollbar = (int)bytes[0];\n\t\telse if (current_scrollbar != (int)bytes[0])\n\t\t    break;\n\t\tj += num_bytes;\n\t\tnum_bytes = get_long_from_buf(tp + j, &val);\n\t\tif (num_bytes == -1)\n\t\t    break;\n\t\tscrollbar_value = val;\n\t\tj += num_bytes;\n\t\tslen = j;\n\t    }\n\t    if (i == 0)\t\t// not enough characters to make one\n\t\treturn -1;\n\t}\n\telse if (key_name[0] == (int)KS_HOR_SCROLLBAR)\n\t{\n\t    long_u\tval;\n\t    int\t\tnum_bytes;\n\n\t    // Get the last horiz. scrollbar event in the queue\n\t    j = 0;\n\t    for (i = 0; tp[j] == CSI && tp[j + 1] == KS_HOR_SCROLLBAR\n\t\t\t\t\t\t     && tp[j + 2] != NUL; ++i)\n\t    {\n\t\tj += 3;\n\t\tnum_bytes = get_long_from_buf(tp + j, &val);\n\t\tif (num_bytes == -1)\n\t\t    break;\n\t\tscrollbar_value = val;\n\t\tj += num_bytes;\n\t\tslen = j;\n\t    }\n\t    if (i == 0)\t\t// not enough characters to make one\n\t\treturn -1;\n\t}\n# endif // !USE_ON_FLY_SCROLL\n#endif // FEAT_GUI\n\n#if (defined(UNIX) || defined(VMS))\n\t/*\n\t * Handle FocusIn/FocusOut event sequences reported by XTerm.\n\t * (CSI I/CSI O)\n\t */\n\tif (key_name[0] == KS_EXTRA\n# ifdef FEAT_GUI\n\t\t&& !gui.in_use\n# endif\n\t    )\n\t{\n\t    if (key_name[1] == KE_FOCUSGAINED)\n\t    {\n\t\tif (!focus_state)\n\t\t{\n\t\t    ui_focus_change(TRUE);\n\t\t    did_cursorhold = TRUE;\n\t\t    focus_state = TRUE;\n\t\t}\n\t\tkey_name[1] = (int)KE_IGNORE;\n\t    }\n\t    else if (key_name[1] == KE_FOCUSLOST)\n\t    {\n\t\tif (focus_state)\n\t\t{\n\t\t    ui_focus_change(FALSE);\n\t\t    did_cursorhold = TRUE;\n\t\t    focus_state = FALSE;\n\t\t}\n\t\tkey_name[1] = (int)KE_IGNORE;\n\t    }\n\t}\n#endif\n\n\t/*\n\t * Change <xHome> to <Home>, <xUp> to <Up>, etc.\n\t */\n\tkey = handle_x_keys(TERMCAP2KEY(key_name[0], key_name[1]));\n\n\t/*\n\t * Add any modifier codes to our string.\n\t */\n\tnew_slen = modifiers2keycode(modifiers, &key, string);\n\n\t// Finally, add the special key code to our string\n\tkey_name[0] = KEY2TERMCAP0(key);\n\tkey_name[1] = KEY2TERMCAP1(key);\n\tif (key_name[0] == KS_KEY)\n\t{\n\t    // from \":set <M-b>=xx\"\n\t    if (has_mbyte)\n\t\tnew_slen += (*mb_char2bytes)(key_name[1], string + new_slen);\n\t    else\n\t\tstring[new_slen++] = key_name[1];\n\t}\n\telse if (new_slen == 0 && key_name[0] == KS_EXTRA\n\t\t\t\t\t\t  && key_name[1] == KE_IGNORE)\n\t{\n\t    // Do not put K_IGNORE into the buffer, do return KEYLEN_REMOVED\n\t    // to indicate what happened.\n\t    retval = KEYLEN_REMOVED;\n\t}\n\telse\n\t{\n\t    string[new_slen++] = K_SPECIAL;\n\t    string[new_slen++] = key_name[0];\n\t    string[new_slen++] = key_name[1];\n\t}\n\tif (put_string_in_typebuf(offset, slen, string, new_slen,\n\t\t\t\t\t\t buf, bufsize, buflen) == FAIL)\n\t    return -1;\n\treturn retval == 0 ? (len + new_slen - slen + offset) : retval;\n    }\n\n#ifdef FEAT_TERMRESPONSE\n    LOG_TR((\"normal character\"));\n#endif\n\n    return 0;\t\t\t    // no match found\n}", "func_hash": 196889976171376146553776878857496634863, "file_name": "term.c", "file_hash": 255079853890988870585830908048537470004, "cwe": ["CWE-787"], "cve": "CVE-2022-2285", "cve_desc": "Integer Overflow or Wraparound in GitHub repository vim/vim prior to 9.0.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-2285", "file_path": "src/term.c"}
{"idx": 409515, "project": "vim", "commit_id": "27efc62f5d86afcb2ecb7565587fe8dea4b036fe", "project_url": "https://github.com/vim/vim", "commit_url": "https://github.com/vim/vim/commit/27efc62f5d86afcb2ecb7565587fe8dea4b036fe", "commit_message": "patch 9.0.0018: going over the end of the typahead\n\nProblem:    Going over the end of the typahead.\nSolution:   Put a NUL after the typeahead.", "target": 0, "func": "check_termcode(\n    int\t\tmax_offset,\n    char_u\t*buf,\n    int\t\tbufsize,\n    int\t\t*buflen)\n{\n    char_u\t*tp;\n    char_u\t*p;\n    int\t\tslen = 0;\t// init for GCC\n    int\t\tmodslen;\n    int\t\tlen;\n    int\t\tretval = 0;\n    int\t\toffset;\n    char_u\tkey_name[2];\n    int\t\tmodifiers;\n    char_u\t*modifiers_start = NULL;\n    int\t\tkey;\n    int\t\tnew_slen;   // Length of what will replace the termcode\n    char_u\tstring[MAX_KEY_CODE_LEN + 1];\n    int\t\ti, j;\n    int\t\tidx = 0;\n    int\t\tcpo_koffset;\n\n    cpo_koffset = (vim_strchr(p_cpo, CPO_KOFFSET) != NULL);\n\n    /*\n     * Speed up the checks for terminal codes by gathering all first bytes\n     * used in termleader[].  Often this is just a single <Esc>.\n     */\n    if (need_gather)\n\tgather_termleader();\n\n    /*\n     * Check at several positions in typebuf.tb_buf[], to catch something like\n     * \"x<Up>\" that can be mapped. Stop at max_offset, because characters\n     * after that cannot be used for mapping, and with @r commands\n     * typebuf.tb_buf[] can become very long.\n     * This is used often, KEEP IT FAST!\n     */\n    for (offset = 0; offset < max_offset; ++offset)\n    {\n\tif (buf == NULL)\n\t{\n\t    if (offset >= typebuf.tb_len)\n\t\tbreak;\n\t    tp = typebuf.tb_buf + typebuf.tb_off + offset;\n\t    len = typebuf.tb_len - offset;\t// length of the input\n\t}\n\telse\n\t{\n\t    if (offset >= *buflen)\n\t\tbreak;\n\t    tp = buf + offset;\n\t    len = *buflen - offset;\n\t}\n\n\t/*\n\t * Don't check characters after K_SPECIAL, those are already\n\t * translated terminal chars (avoid translating ~@^Hx).\n\t */\n\tif (*tp == K_SPECIAL)\n\t{\n\t    offset += 2;\t// there are always 2 extra characters\n\t    continue;\n\t}\n\n\t/*\n\t * Skip this position if the character does not appear as the first\n\t * character in term_strings. This speeds up a lot, since most\n\t * termcodes start with the same character (ESC or CSI).\n\t */\n\ti = *tp;\n\tfor (p = termleader; *p && *p != i; ++p)\n\t    ;\n\tif (*p == NUL)\n\t    continue;\n\n\t/*\n\t * Skip this position if p_ek is not set and tp[0] is an ESC and we\n\t * are in Insert mode.\n\t */\n\tif (*tp == ESC && !p_ek && (State & MODE_INSERT))\n\t    continue;\n\n\ttp[len] = NUL;\n\tkey_name[0] = NUL;\t// no key name found yet\n\tkey_name[1] = NUL;\t// no key name found yet\n\tmodifiers = 0;\t\t// no modifiers yet\n\n#ifdef FEAT_GUI\n\tif (gui.in_use)\n\t{\n\t    /*\n\t     * GUI special key codes are all of the form [CSI xx].\n\t     */\n\t    if (*tp == CSI)\t    // Special key from GUI\n\t    {\n\t\tif (len < 3)\n\t\t    return -1;\t    // Shouldn't happen\n\t\tslen = 3;\n\t\tkey_name[0] = tp[1];\n\t\tkey_name[1] = tp[2];\n\t    }\n\t}\n\telse\n#endif // FEAT_GUI\n\t{\n\t    int  mouse_index_found = -1;\n\n\t    for (idx = 0; idx < tc_len; ++idx)\n\t    {\n\t\t/*\n\t\t * Ignore the entry if we are not at the start of\n\t\t * typebuf.tb_buf[]\n\t\t * and there are not enough characters to make a match.\n\t\t * But only when the 'K' flag is in 'cpoptions'.\n\t\t */\n\t\tslen = termcodes[idx].len;\n\t\tmodifiers_start = NULL;\n\t\tif (cpo_koffset && offset && len < slen)\n\t\t    continue;\n\t\tif (STRNCMP(termcodes[idx].code, tp,\n\t\t\t\t     (size_t)(slen > len ? len : slen)) == 0)\n\t\t{\n\t\t    int\t    looks_like_mouse_start = FALSE;\n\n\t\t    if (len < slen)\t\t// got a partial sequence\n\t\t\treturn -1;\t\t// need to get more chars\n\n\t\t    /*\n\t\t     * When found a keypad key, check if there is another key\n\t\t     * that matches and use that one.  This makes <Home> to be\n\t\t     * found instead of <kHome> when they produce the same\n\t\t     * key code.\n\t\t     */\n\t\t    if (termcodes[idx].name[0] == 'K'\n\t\t\t\t       && VIM_ISDIGIT(termcodes[idx].name[1]))\n\t\t    {\n\t\t\tfor (j = idx + 1; j < tc_len; ++j)\n\t\t\t    if (termcodes[j].len == slen &&\n\t\t\t\t    STRNCMP(termcodes[idx].code,\n\t\t\t\t\t    termcodes[j].code, slen) == 0)\n\t\t\t    {\n\t\t\t\tidx = j;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t    }\n\n\t\t    if (slen == 2 && len > 2\n\t\t\t    && termcodes[idx].code[0] == ESC\n\t\t\t    && termcodes[idx].code[1] == '[')\n\t\t    {\n\t\t\t// The mouse termcode \"ESC [\" is also the prefix of\n\t\t\t// \"ESC [ I\" (focus gained) and other keys.  Check some\n\t\t\t// more bytes to find out.\n\t\t\tif (!isdigit(tp[2]))\n\t\t\t{\n\t\t\t    // ESC [ without number following: Only use it when\n\t\t\t    // there is no other match.\n\t\t\t    looks_like_mouse_start = TRUE;\n\t\t\t}\n\t\t\telse if (termcodes[idx].name[0] == KS_DEC_MOUSE)\n\t\t\t{\n\t\t\t    char_u  *nr = tp + 2;\n\t\t\t    int\t    count = 0;\n\n\t\t\t    // If a digit is following it could be a key with\n\t\t\t    // modifier, e.g., ESC [ 1;2P.  Can be confused\n\t\t\t    // with DEC_MOUSE, which requires four numbers\n\t\t\t    // following.  If not then it can't be a DEC_MOUSE\n\t\t\t    // code.\n\t\t\t    for (;;)\n\t\t\t    {\n\t\t\t\t++count;\n\t\t\t\t(void)getdigits(&nr);\n\t\t\t\tif (nr >= tp + len)\n\t\t\t\t    return -1;\t// partial sequence\n\t\t\t\tif (*nr != ';')\n\t\t\t\t    break;\n\t\t\t\t++nr;\n\t\t\t\tif (nr >= tp + len)\n\t\t\t\t    return -1;\t// partial sequence\n\t\t\t    }\n\t\t\t    if (count < 4)\n\t\t\t\tcontinue;\t// no match\n\t\t\t}\n\t\t    }\n\t\t    if (looks_like_mouse_start)\n\t\t    {\n\t\t\t// Only use it when there is no other match.\n\t\t\tif (mouse_index_found < 0)\n\t\t\t    mouse_index_found = idx;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tkey_name[0] = termcodes[idx].name[0];\n\t\t\tkey_name[1] = termcodes[idx].name[1];\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\n\t\t/*\n\t\t * Check for code with modifier, like xterm uses:\n\t\t * <Esc>[123;*X  (modslen == slen - 3)\n\t\t * <Esc>[@;*X    (matches <Esc>[X and <Esc>[1;9X )\n\t\t * Also <Esc>O*X and <M-O>*X (modslen == slen - 2).\n\t\t * When there is a modifier the * matches a number.\n\t\t * When there is no modifier the ;* or * is omitted.\n\t\t */\n\t\tif (termcodes[idx].modlen > 0 && mouse_index_found < 0)\n\t\t{\n\t\t    int at_code;\n\n\t\t    modslen = termcodes[idx].modlen;\n\t\t    if (cpo_koffset && offset && len < modslen)\n\t\t\tcontinue;\n\t\t    at_code = termcodes[idx].code[modslen] == '@';\n\t\t    if (STRNCMP(termcodes[idx].code, tp,\n\t\t\t\t(size_t)(modslen > len ? len : modslen)) == 0)\n\t\t    {\n\t\t\tint\t    n;\n\n\t\t\tif (len <= modslen)\t// got a partial sequence\n\t\t\t    return -1;\t\t// need to get more chars\n\n\t\t\tif (tp[modslen] == termcodes[idx].code[slen - 1])\n\t\t\t    // no modifiers\n\t\t\t    slen = modslen + 1;\n\t\t\telse if (tp[modslen] != ';' && modslen == slen - 3)\n\t\t\t    // no match for \"code;*X\" with \"code;\"\n\t\t\t    continue;\n\t\t\telse if (at_code && tp[modslen] != '1')\n\t\t\t    // no match for \"<Esc>[@\" with \"<Esc>[1\"\n\t\t\t    continue;\n\t\t\telse\n\t\t\t{\n\t\t\t    // Skip over the digits, the final char must\n\t\t\t    // follow. URXVT can use a negative value, thus\n\t\t\t    // also accept '-'.\n\t\t\t    for (j = slen - 2; j < len && (isdigit(tp[j])\n\t\t\t\t       || tp[j] == '-' || tp[j] == ';'); ++j)\n\t\t\t\t;\n\t\t\t    ++j;\n\t\t\t    if (len < j)\t// got a partial sequence\n\t\t\t\treturn -1;\t// need to get more chars\n\t\t\t    if (tp[j - 1] != termcodes[idx].code[slen - 1])\n\t\t\t\tcontinue;\t// no match\n\n\t\t\t    modifiers_start = tp + slen - 2;\n\n\t\t\t    // Match!  Convert modifier bits.\n\t\t\t    n = atoi((char *)modifiers_start);\n\t\t\t    modifiers |= decode_modifiers(n);\n\n\t\t\t    slen = j;\n\t\t\t}\n\t\t\tkey_name[0] = termcodes[idx].name[0];\n\t\t\tkey_name[1] = termcodes[idx].name[1];\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t    if (idx == tc_len && mouse_index_found >= 0)\n\t    {\n\t\tkey_name[0] = termcodes[mouse_index_found].name[0];\n\t\tkey_name[1] = termcodes[mouse_index_found].name[1];\n\t    }\n\t}\n\n#ifdef FEAT_TERMRESPONSE\n\tif (key_name[0] == NUL\n\t    // Mouse codes of DEC and pterm start with <ESC>[.  When\n\t    // detecting the start of these mouse codes they might as well be\n\t    // another key code or terminal response.\n# ifdef FEAT_MOUSE_DEC\n\t    || key_name[0] == KS_DEC_MOUSE\n# endif\n# ifdef FEAT_MOUSE_PTERM\n\t    || key_name[0] == KS_PTERM_MOUSE\n# endif\n\t   )\n\t{\n\t    char_u *argp = tp[0] == ESC ? tp + 2 : tp + 1;\n\n\t    /*\n\t     * Check for responses from the terminal starting with {lead}:\n\t     * \"<Esc>[\" or CSI followed by [0-9>?]\n\t     *\n\t     * - Xterm version string: {lead}>{x};{vers};{y}c\n\t     *   Also eat other possible responses to t_RV, rxvt returns\n\t     *   \"{lead}?1;2c\".\n\t     *\n\t     * - Cursor position report: {lead}{row};{col}R\n\t     *   The final byte must be 'R'. It is used for checking the\n\t     *   ambiguous-width character state.\n\t     *\n\t     * - window position reply: {lead}3;{x};{y}t\n\t     *\n\t     * - key with modifiers when modifyOtherKeys is enabled:\n\t     *\t    {lead}27;{modifier};{key}~\n\t     *\t    {lead}{key};{modifier}u\n\t     */\n\t    if (((tp[0] == ESC && len >= 3 && tp[1] == '[')\n\t\t\t    || (tp[0] == CSI && len >= 2))\n\t\t    && (VIM_ISDIGIT(*argp) || *argp == '>' || *argp == '?'))\n\t    {\n\t\tint resp = handle_csi(tp, len, argp, offset, buf,\n\t\t\t\t\t     bufsize, buflen, key_name, &slen);\n\t\tif (resp != 0)\n\t\t{\n# ifdef DEBUG_TERMRESPONSE\n\t\t    if (resp == -1)\n\t\t\tLOG_TR((\"Not enough characters for CSI sequence\"));\n# endif\n\t\t    return resp;\n\t\t}\n\t    }\n\n\t    // Check for fore/background color response from the terminal,\n\t    // starting} with <Esc>] or OSC\n\t    else if ((*T_RBG != NUL || *T_RFG != NUL)\n\t\t\t&& ((tp[0] == ESC && len >= 2 && tp[1] == ']')\n\t\t\t    || tp[0] == OSC))\n\t    {\n\t\tif (handle_osc(tp, argp, len, key_name, &slen) == FAIL)\n\t\t    return -1;\n\t    }\n\n\t    // Check for key code response from xterm,\n\t    // starting with <Esc>P or DCS\n\t    else if ((check_for_codes || rcs_status.tr_progress == STATUS_SENT)\n\t\t    && ((tp[0] == ESC && len >= 2 && tp[1] == 'P')\n\t\t\t|| tp[0] == DCS))\n\t    {\n\t\tif (handle_dcs(tp, argp, len, key_name, &slen) == FAIL)\n\t\t    return -1;\n\t    }\n\t}\n#endif\n\n\tif (key_name[0] == NUL)\n\t    continue;\t    // No match at this position, try next one\n\n\t// We only get here when we have a complete termcode match\n\n#ifdef FEAT_GUI\n\t/*\n\t * Only in the GUI: Fetch the pointer coordinates of the scroll event\n\t * so that we know which window to scroll later.\n\t */\n\tif (gui.in_use\n\t\t&& key_name[0] == (int)KS_EXTRA\n\t\t&& (key_name[1] == (int)KE_X1MOUSE\n\t\t    || key_name[1] == (int)KE_X2MOUSE\n\t\t    || key_name[1] == (int)KE_MOUSEMOVE_XY\n\t\t    || key_name[1] == (int)KE_MOUSELEFT\n\t\t    || key_name[1] == (int)KE_MOUSERIGHT\n\t\t    || key_name[1] == (int)KE_MOUSEDOWN\n\t\t    || key_name[1] == (int)KE_MOUSEUP))\n\t{\n\t    char_u\tbytes[6];\n\t    int\t\tnum_bytes = get_bytes_from_buf(tp + slen, bytes, 4);\n\n\t    if (num_bytes == -1)\t// not enough coordinates\n\t\treturn -1;\n\t    mouse_col = 128 * (bytes[0] - ' ' - 1) + bytes[1] - ' ' - 1;\n\t    mouse_row = 128 * (bytes[2] - ' ' - 1) + bytes[3] - ' ' - 1;\n\t    slen += num_bytes;\n\t    // equal to K_MOUSEMOVE\n\t    if (key_name[1] == (int)KE_MOUSEMOVE_XY)\n\t\tkey_name[1] = (int)KE_MOUSEMOVE;\n\t}\n\telse\n#endif\n\t/*\n\t * If it is a mouse click, get the coordinates.\n\t */\n\tif (key_name[0] == KS_MOUSE\n#ifdef FEAT_MOUSE_GPM\n\t\t|| key_name[0] == KS_GPM_MOUSE\n#endif\n#ifdef FEAT_MOUSE_JSB\n\t\t|| key_name[0] == KS_JSBTERM_MOUSE\n#endif\n#ifdef FEAT_MOUSE_NET\n\t\t|| key_name[0] == KS_NETTERM_MOUSE\n#endif\n#ifdef FEAT_MOUSE_DEC\n\t\t|| key_name[0] == KS_DEC_MOUSE\n#endif\n#ifdef FEAT_MOUSE_PTERM\n\t\t|| key_name[0] == KS_PTERM_MOUSE\n#endif\n#ifdef FEAT_MOUSE_URXVT\n\t\t|| key_name[0] == KS_URXVT_MOUSE\n#endif\n\t\t|| key_name[0] == KS_SGR_MOUSE\n\t\t|| key_name[0] == KS_SGR_MOUSE_RELEASE)\n\t{\n\t    if (check_termcode_mouse(tp, &slen, key_name, modifiers_start, idx,\n\t\t\t\t\t\t\t     &modifiers) == -1)\n\t\treturn -1;\n\t}\n\n#ifdef FEAT_GUI\n\t/*\n\t * If using the GUI, then we get menu and scrollbar events.\n\t *\n\t * A menu event is encoded as K_SPECIAL, KS_MENU, KE_FILLER followed by\n\t * four bytes which are to be taken as a pointer to the vimmenu_T\n\t * structure.\n\t *\n\t * A tab line event is encoded as K_SPECIAL KS_TABLINE nr, where \"nr\"\n\t * is one byte with the tab index.\n\t *\n\t * A scrollbar event is K_SPECIAL, KS_VER_SCROLLBAR, KE_FILLER followed\n\t * by one byte representing the scrollbar number, and then four bytes\n\t * representing a long_u which is the new value of the scrollbar.\n\t *\n\t * A horizontal scrollbar event is K_SPECIAL, KS_HOR_SCROLLBAR,\n\t * KE_FILLER followed by four bytes representing a long_u which is the\n\t * new value of the scrollbar.\n\t */\n# ifdef FEAT_MENU\n\telse if (key_name[0] == (int)KS_MENU)\n\t{\n\t    long_u\tval;\n\t    int\t\tnum_bytes = get_long_from_buf(tp + slen, &val);\n\n\t    if (num_bytes == -1)\n\t\treturn -1;\n\t    current_menu = (vimmenu_T *)val;\n\t    slen += num_bytes;\n\n\t    // The menu may have been deleted right after it was used, check\n\t    // for that.\n\t    if (check_menu_pointer(root_menu, current_menu) == FAIL)\n\t    {\n\t\tkey_name[0] = KS_EXTRA;\n\t\tkey_name[1] = (int)KE_IGNORE;\n\t    }\n\t}\n# endif\n# ifdef FEAT_GUI_TABLINE\n\telse if (key_name[0] == (int)KS_TABLINE)\n\t{\n\t    // Selecting tabline tab or using its menu.\n\t    char_u\tbytes[6];\n\t    int\t\tnum_bytes = get_bytes_from_buf(tp + slen, bytes, 1);\n\n\t    if (num_bytes == -1)\n\t\treturn -1;\n\t    current_tab = (int)bytes[0];\n\t    if (current_tab == 255)\t// -1 in a byte gives 255\n\t\tcurrent_tab = -1;\n\t    slen += num_bytes;\n\t}\n\telse if (key_name[0] == (int)KS_TABMENU)\n\t{\n\t    // Selecting tabline tab or using its menu.\n\t    char_u\tbytes[6];\n\t    int\t\tnum_bytes = get_bytes_from_buf(tp + slen, bytes, 2);\n\n\t    if (num_bytes == -1)\n\t\treturn -1;\n\t    current_tab = (int)bytes[0];\n\t    current_tabmenu = (int)bytes[1];\n\t    slen += num_bytes;\n\t}\n# endif\n# ifndef USE_ON_FLY_SCROLL\n\telse if (key_name[0] == (int)KS_VER_SCROLLBAR)\n\t{\n\t    long_u\tval;\n\t    char_u\tbytes[6];\n\t    int\t\tnum_bytes;\n\n\t    // Get the last scrollbar event in the queue of the same type\n\t    j = 0;\n\t    for (i = 0; tp[j] == CSI && tp[j + 1] == KS_VER_SCROLLBAR\n\t\t\t\t\t\t     && tp[j + 2] != NUL; ++i)\n\t    {\n\t\tj += 3;\n\t\tnum_bytes = get_bytes_from_buf(tp + j, bytes, 1);\n\t\tif (num_bytes == -1)\n\t\t    break;\n\t\tif (i == 0)\n\t\t    current_scrollbar = (int)bytes[0];\n\t\telse if (current_scrollbar != (int)bytes[0])\n\t\t    break;\n\t\tj += num_bytes;\n\t\tnum_bytes = get_long_from_buf(tp + j, &val);\n\t\tif (num_bytes == -1)\n\t\t    break;\n\t\tscrollbar_value = val;\n\t\tj += num_bytes;\n\t\tslen = j;\n\t    }\n\t    if (i == 0)\t\t// not enough characters to make one\n\t\treturn -1;\n\t}\n\telse if (key_name[0] == (int)KS_HOR_SCROLLBAR)\n\t{\n\t    long_u\tval;\n\t    int\t\tnum_bytes;\n\n\t    // Get the last horiz. scrollbar event in the queue\n\t    j = 0;\n\t    for (i = 0; tp[j] == CSI && tp[j + 1] == KS_HOR_SCROLLBAR\n\t\t\t\t\t\t     && tp[j + 2] != NUL; ++i)\n\t    {\n\t\tj += 3;\n\t\tnum_bytes = get_long_from_buf(tp + j, &val);\n\t\tif (num_bytes == -1)\n\t\t    break;\n\t\tscrollbar_value = val;\n\t\tj += num_bytes;\n\t\tslen = j;\n\t    }\n\t    if (i == 0)\t\t// not enough characters to make one\n\t\treturn -1;\n\t}\n# endif // !USE_ON_FLY_SCROLL\n#endif // FEAT_GUI\n\n#if (defined(UNIX) || defined(VMS))\n\t/*\n\t * Handle FocusIn/FocusOut event sequences reported by XTerm.\n\t * (CSI I/CSI O)\n\t */\n\tif (key_name[0] == KS_EXTRA\n# ifdef FEAT_GUI\n\t\t&& !gui.in_use\n# endif\n\t    )\n\t{\n\t    if (key_name[1] == KE_FOCUSGAINED)\n\t    {\n\t\tif (!focus_state)\n\t\t{\n\t\t    ui_focus_change(TRUE);\n\t\t    did_cursorhold = TRUE;\n\t\t    focus_state = TRUE;\n\t\t}\n\t\tkey_name[1] = (int)KE_IGNORE;\n\t    }\n\t    else if (key_name[1] == KE_FOCUSLOST)\n\t    {\n\t\tif (focus_state)\n\t\t{\n\t\t    ui_focus_change(FALSE);\n\t\t    did_cursorhold = TRUE;\n\t\t    focus_state = FALSE;\n\t\t}\n\t\tkey_name[1] = (int)KE_IGNORE;\n\t    }\n\t}\n#endif\n\n\t/*\n\t * Change <xHome> to <Home>, <xUp> to <Up>, etc.\n\t */\n\tkey = handle_x_keys(TERMCAP2KEY(key_name[0], key_name[1]));\n\n\t/*\n\t * Add any modifier codes to our string.\n\t */\n\tnew_slen = modifiers2keycode(modifiers, &key, string);\n\n\t// Finally, add the special key code to our string\n\tkey_name[0] = KEY2TERMCAP0(key);\n\tkey_name[1] = KEY2TERMCAP1(key);\n\tif (key_name[0] == KS_KEY)\n\t{\n\t    // from \":set <M-b>=xx\"\n\t    if (has_mbyte)\n\t\tnew_slen += (*mb_char2bytes)(key_name[1], string + new_slen);\n\t    else\n\t\tstring[new_slen++] = key_name[1];\n\t}\n\telse if (new_slen == 0 && key_name[0] == KS_EXTRA\n\t\t\t\t\t\t  && key_name[1] == KE_IGNORE)\n\t{\n\t    // Do not put K_IGNORE into the buffer, do return KEYLEN_REMOVED\n\t    // to indicate what happened.\n\t    retval = KEYLEN_REMOVED;\n\t}\n\telse\n\t{\n\t    string[new_slen++] = K_SPECIAL;\n\t    string[new_slen++] = key_name[0];\n\t    string[new_slen++] = key_name[1];\n\t}\n\tif (put_string_in_typebuf(offset, slen, string, new_slen,\n\t\t\t\t\t\t buf, bufsize, buflen) == FAIL)\n\t    return -1;\n\treturn retval == 0 ? (len + new_slen - slen + offset) : retval;\n    }\n\n#ifdef FEAT_TERMRESPONSE\n    LOG_TR((\"normal character\"));\n#endif\n\n    return 0;\t\t\t    // no match found\n}", "func_hash": 105354748681163651663383549655228844664, "file_name": "term.c", "file_hash": 113564079834188954277061754674630069521, "cwe": ["CWE-787"], "cve": "CVE-2022-2285", "cve_desc": "Integer Overflow or Wraparound in GitHub repository vim/vim prior to 9.0.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-2285", "file_path": "src/term.c"}
{"idx": 208505, "project": "tor", "commit_id": "57e35ad3d91724882c345ac709666a551a977f0f", "project_url": "https://github.com/torproject/tor", "commit_url": "https://gitweb.torproject.org/tor.git/commitdiff/57e35ad3d91724882c345ac709666a551a977f0f", "commit_message": "Avoid possible segfault when handling networkstatus vote with bad flavor\n\nFix for 6530; fix on 0.2.2.6-alpha.", "target": 1, "func": "networkstatus_parse_vote_from_string(const char *s, const char **eos_out,\n                                     networkstatus_type_t ns_type)\n{\n  smartlist_t *tokens = smartlist_create();\n  smartlist_t *rs_tokens = NULL, *footer_tokens = NULL;\n  networkstatus_voter_info_t *voter = NULL;\n  networkstatus_t *ns = NULL;\n  digests_t ns_digests;\n  const char *cert, *end_of_header, *end_of_footer, *s_dup = s;\n  directory_token_t *tok;\n  int ok;\n  struct in_addr in;\n  int i, inorder, n_signatures = 0;\n  memarea_t *area = NULL, *rs_area = NULL;\n  consensus_flavor_t flav = FLAV_NS;\n\n  tor_assert(s);\n\n  if (eos_out)\n    *eos_out = NULL;\n\n  if (router_get_networkstatus_v3_hashes(s, &ns_digests)) {\n    log_warn(LD_DIR, \"Unable to compute digest of network-status\");\n    goto err;\n  }\n\n  area = memarea_new();\n  end_of_header = find_start_of_next_routerstatus(s);\n  if (tokenize_string(area, s, end_of_header, tokens,\n                      (ns_type == NS_TYPE_CONSENSUS) ?\n                      networkstatus_consensus_token_table :\n                      networkstatus_token_table, 0)) {\n    log_warn(LD_DIR, \"Error tokenizing network-status vote header\");\n    goto err;\n  }\n\n  ns = tor_malloc_zero(sizeof(networkstatus_t));\n  memcpy(&ns->digests, &ns_digests, sizeof(ns_digests));\n\n  tok = find_by_keyword(tokens, K_NETWORK_STATUS_VERSION);\n  tor_assert(tok);\n  if (tok->n_args > 1) {\n    int flavor = networkstatus_parse_flavor_name(tok->args[1]);\n    if (flavor < 0) {\n      log_warn(LD_DIR, \"Can't parse document with unknown flavor %s\",\n               escaped(tok->args[2]));\n      goto err;\n    }\n    ns->flavor = flav = flavor;\n  }\n  if (flav != FLAV_NS && ns_type != NS_TYPE_CONSENSUS) {\n    log_warn(LD_DIR, \"Flavor found on non-consensus networkstatus.\");\n    goto err;\n  }\n\n  if (ns_type != NS_TYPE_CONSENSUS) {\n    const char *end_of_cert = NULL;\n    if (!(cert = strstr(s, \"\\ndir-key-certificate-version\")))\n      goto err;\n    ++cert;\n    ns->cert = authority_cert_parse_from_string(cert, &end_of_cert);\n    if (!ns->cert || !end_of_cert || end_of_cert > end_of_header)\n      goto err;\n  }\n\n  tok = find_by_keyword(tokens, K_VOTE_STATUS);\n  tor_assert(tok->n_args);\n  if (!strcmp(tok->args[0], \"vote\")) {\n    ns->type = NS_TYPE_VOTE;\n  } else if (!strcmp(tok->args[0], \"consensus\")) {\n    ns->type = NS_TYPE_CONSENSUS;\n  } else if (!strcmp(tok->args[0], \"opinion\")) {\n    ns->type = NS_TYPE_OPINION;\n  } else {\n    log_warn(LD_DIR, \"Unrecognized vote status %s in network-status\",\n             escaped(tok->args[0]));\n    goto err;\n  }\n  if (ns_type != ns->type) {\n    log_warn(LD_DIR, \"Got the wrong kind of v3 networkstatus.\");\n    goto err;\n  }\n\n  if (ns->type == NS_TYPE_VOTE || ns->type == NS_TYPE_OPINION) {\n    tok = find_by_keyword(tokens, K_PUBLISHED);\n    if (parse_iso_time(tok->args[0], &ns->published))\n      goto err;\n\n    ns->supported_methods = smartlist_create();\n    tok = find_opt_by_keyword(tokens, K_CONSENSUS_METHODS);\n    if (tok) {\n      for (i=0; i < tok->n_args; ++i)\n        smartlist_add(ns->supported_methods, tor_strdup(tok->args[i]));\n    } else {\n      smartlist_add(ns->supported_methods, tor_strdup(\"1\"));\n    }\n  } else {\n    tok = find_opt_by_keyword(tokens, K_CONSENSUS_METHOD);\n    if (tok) {\n      ns->consensus_method = (int)tor_parse_long(tok->args[0], 10, 1, INT_MAX,\n                                                 &ok, NULL);\n      if (!ok)\n        goto err;\n    } else {\n      ns->consensus_method = 1;\n    }\n  }\n\n  tok = find_by_keyword(tokens, K_VALID_AFTER);\n  if (parse_iso_time(tok->args[0], &ns->valid_after))\n    goto err;\n\n  tok = find_by_keyword(tokens, K_FRESH_UNTIL);\n  if (parse_iso_time(tok->args[0], &ns->fresh_until))\n    goto err;\n\n  tok = find_by_keyword(tokens, K_VALID_UNTIL);\n  if (parse_iso_time(tok->args[0], &ns->valid_until))\n    goto err;\n\n  tok = find_by_keyword(tokens, K_VOTING_DELAY);\n  tor_assert(tok->n_args >= 2);\n  ns->vote_seconds =\n    (int) tor_parse_long(tok->args[0], 10, 0, INT_MAX, &ok, NULL);\n  if (!ok)\n    goto err;\n  ns->dist_seconds =\n    (int) tor_parse_long(tok->args[1], 10, 0, INT_MAX, &ok, NULL);\n  if (!ok)\n    goto err;\n  if (ns->valid_after + MIN_VOTE_INTERVAL > ns->fresh_until) {\n    log_warn(LD_DIR, \"Vote/consensus freshness interval is too short\");\n    goto err;\n  }\n  if (ns->valid_after + MIN_VOTE_INTERVAL*2 > ns->valid_until) {\n    log_warn(LD_DIR, \"Vote/consensus liveness interval is too short\");\n    goto err;\n  }\n  if (ns->vote_seconds < MIN_VOTE_SECONDS) {\n    log_warn(LD_DIR, \"Vote seconds is too short\");\n    goto err;\n  }\n  if (ns->dist_seconds < MIN_DIST_SECONDS) {\n    log_warn(LD_DIR, \"Dist seconds is too short\");\n    goto err;\n  }\n\n  if ((tok = find_opt_by_keyword(tokens, K_CLIENT_VERSIONS))) {\n    ns->client_versions = tor_strdup(tok->args[0]);\n  }\n  if ((tok = find_opt_by_keyword(tokens, K_SERVER_VERSIONS))) {\n    ns->server_versions = tor_strdup(tok->args[0]);\n  }\n\n  tok = find_by_keyword(tokens, K_KNOWN_FLAGS);\n  ns->known_flags = smartlist_create();\n  inorder = 1;\n  for (i = 0; i < tok->n_args; ++i) {\n    smartlist_add(ns->known_flags, tor_strdup(tok->args[i]));\n    if (i>0 && strcmp(tok->args[i-1], tok->args[i])>= 0) {\n      log_warn(LD_DIR, \"%s >= %s\", tok->args[i-1], tok->args[i]);\n      inorder = 0;\n    }\n  }\n  if (!inorder) {\n    log_warn(LD_DIR, \"known-flags not in order\");\n    goto err;\n  }\n\n  tok = find_opt_by_keyword(tokens, K_PARAMS);\n  if (tok) {\n    inorder = 1;\n    ns->net_params = smartlist_create();\n    for (i = 0; i < tok->n_args; ++i) {\n      int ok=0;\n      char *eq = strchr(tok->args[i], '=');\n      if (!eq) {\n        log_warn(LD_DIR, \"Bad element '%s' in params\", escaped(tok->args[i]));\n        goto err;\n      }\n      tor_parse_long(eq+1, 10, INT32_MIN, INT32_MAX, &ok, NULL);\n      if (!ok) {\n        log_warn(LD_DIR, \"Bad element '%s' in params\", escaped(tok->args[i]));\n        goto err;\n      }\n      if (i > 0 && strcmp(tok->args[i-1], tok->args[i]) >= 0) {\n        log_warn(LD_DIR, \"%s >= %s\", tok->args[i-1], tok->args[i]);\n        inorder = 0;\n      }\n      smartlist_add(ns->net_params, tor_strdup(tok->args[i]));\n    }\n    if (!inorder) {\n      log_warn(LD_DIR, \"params not in order\");\n      goto err;\n    }\n  }\n\n  ns->voters = smartlist_create();\n\n  SMARTLIST_FOREACH_BEGIN(tokens, directory_token_t *, _tok) {\n    tok = _tok;\n    if (tok->tp == K_DIR_SOURCE) {\n      tor_assert(tok->n_args >= 6);\n\n      if (voter)\n        smartlist_add(ns->voters, voter);\n      voter = tor_malloc_zero(sizeof(networkstatus_voter_info_t));\n      voter->sigs = smartlist_create();\n      if (ns->type != NS_TYPE_CONSENSUS)\n        memcpy(voter->vote_digest, ns_digests.d[DIGEST_SHA1], DIGEST_LEN);\n\n      voter->nickname = tor_strdup(tok->args[0]);\n      if (strlen(tok->args[1]) != HEX_DIGEST_LEN ||\n          base16_decode(voter->identity_digest, sizeof(voter->identity_digest),\n                        tok->args[1], HEX_DIGEST_LEN) < 0) {\n        log_warn(LD_DIR, \"Error decoding identity digest %s in \"\n                 \"network-status vote.\", escaped(tok->args[1]));\n        goto err;\n      }\n      if (ns->type != NS_TYPE_CONSENSUS &&\n          tor_memneq(ns->cert->cache_info.identity_digest,\n                 voter->identity_digest, DIGEST_LEN)) {\n        log_warn(LD_DIR,\"Mismatch between identities in certificate and vote\");\n        goto err;\n      }\n      voter->address = tor_strdup(tok->args[2]);\n      if (!tor_inet_aton(tok->args[3], &in)) {\n        log_warn(LD_DIR, \"Error decoding IP address %s in network-status.\",\n                 escaped(tok->args[3]));\n        goto err;\n      }\n      voter->addr = ntohl(in.s_addr);\n      voter->dir_port = (uint16_t)\n        tor_parse_long(tok->args[4], 10, 0, 65535, &ok, NULL);\n      if (!ok)\n        goto err;\n      voter->or_port = (uint16_t)\n        tor_parse_long(tok->args[5], 10, 0, 65535, &ok, NULL);\n      if (!ok)\n        goto err;\n    } else if (tok->tp == K_CONTACT) {\n      if (!voter || voter->contact) {\n        log_warn(LD_DIR, \"contact element is out of place.\");\n        goto err;\n      }\n      voter->contact = tor_strdup(tok->args[0]);\n    } else if (tok->tp == K_VOTE_DIGEST) {\n      tor_assert(ns->type == NS_TYPE_CONSENSUS);\n      tor_assert(tok->n_args >= 1);\n      if (!voter || ! tor_digest_is_zero(voter->vote_digest)) {\n        log_warn(LD_DIR, \"vote-digest element is out of place.\");\n        goto err;\n      }\n      if (strlen(tok->args[0]) != HEX_DIGEST_LEN ||\n        base16_decode(voter->vote_digest, sizeof(voter->vote_digest),\n                      tok->args[0], HEX_DIGEST_LEN) < 0) {\n        log_warn(LD_DIR, \"Error decoding vote digest %s in \"\n                 \"network-status consensus.\", escaped(tok->args[0]));\n        goto err;\n      }\n    }\n  } SMARTLIST_FOREACH_END(_tok);\n  if (voter) {\n    smartlist_add(ns->voters, voter);\n    voter = NULL;\n  }\n  if (smartlist_len(ns->voters) == 0) {\n    log_warn(LD_DIR, \"Missing dir-source elements in a vote networkstatus.\");\n    goto err;\n  } else if (ns->type != NS_TYPE_CONSENSUS && smartlist_len(ns->voters) != 1) {\n    log_warn(LD_DIR, \"Too many dir-source elements in a vote networkstatus.\");\n    goto err;\n  }\n\n  if (ns->type != NS_TYPE_CONSENSUS &&\n      (tok = find_opt_by_keyword(tokens, K_LEGACY_DIR_KEY))) {\n    int bad = 1;\n    if (strlen(tok->args[0]) == HEX_DIGEST_LEN) {\n      networkstatus_voter_info_t *voter = smartlist_get(ns->voters, 0);\n      if (base16_decode(voter->legacy_id_digest, DIGEST_LEN,\n                        tok->args[0], HEX_DIGEST_LEN)<0)\n        bad = 1;\n      else\n        bad = 0;\n    }\n    if (bad) {\n      log_warn(LD_DIR, \"Invalid legacy key digest %s on vote.\",\n               escaped(tok->args[0]));\n    }\n  }\n\n  /* Parse routerstatus lines. */\n  rs_tokens = smartlist_create();\n  rs_area = memarea_new();\n  s = end_of_header;\n  ns->routerstatus_list = smartlist_create();\n\n  while (!strcmpstart(s, \"r \")) {\n    if (ns->type != NS_TYPE_CONSENSUS) {\n      vote_routerstatus_t *rs = tor_malloc_zero(sizeof(vote_routerstatus_t));\n      if (routerstatus_parse_entry_from_string(rs_area, &s, rs_tokens, ns,\n                                               rs, 0, 0))\n        smartlist_add(ns->routerstatus_list, rs);\n      else {\n        tor_free(rs->version);\n        tor_free(rs);\n      }\n    } else {\n      routerstatus_t *rs;\n      if ((rs = routerstatus_parse_entry_from_string(rs_area, &s, rs_tokens,\n                                                     NULL, NULL,\n                                                     ns->consensus_method,\n                                                     flav)))\n        smartlist_add(ns->routerstatus_list, rs);\n    }\n  }\n  for (i = 1; i < smartlist_len(ns->routerstatus_list); ++i) {\n    routerstatus_t *rs1, *rs2;\n    if (ns->type != NS_TYPE_CONSENSUS) {\n      vote_routerstatus_t *a = smartlist_get(ns->routerstatus_list, i-1);\n      vote_routerstatus_t *b = smartlist_get(ns->routerstatus_list, i);\n      rs1 = &a->status; rs2 = &b->status;\n    } else {\n      rs1 = smartlist_get(ns->routerstatus_list, i-1);\n      rs2 = smartlist_get(ns->routerstatus_list, i);\n    }\n    if (fast_memcmp(rs1->identity_digest, rs2->identity_digest, DIGEST_LEN)\n        >= 0) {\n      log_warn(LD_DIR, \"Vote networkstatus entries not sorted by identity \"\n               \"digest\");\n      goto err;\n    }\n  }\n\n  /* Parse footer; check signature. */\n  footer_tokens = smartlist_create();\n  if ((end_of_footer = strstr(s, \"\\nnetwork-status-version \")))\n    ++end_of_footer;\n  else\n    end_of_footer = s + strlen(s);\n  if (tokenize_string(area,s, end_of_footer, footer_tokens,\n                      networkstatus_vote_footer_token_table, 0)) {\n    log_warn(LD_DIR, \"Error tokenizing network-status vote footer.\");\n    goto err;\n  }\n\n  {\n    int found_sig = 0;\n    SMARTLIST_FOREACH_BEGIN(footer_tokens, directory_token_t *, _tok) {\n      tok = _tok;\n      if (tok->tp == K_DIRECTORY_SIGNATURE)\n        found_sig = 1;\n      else if (found_sig) {\n        log_warn(LD_DIR, \"Extraneous token after first directory-signature\");\n        goto err;\n      }\n    } SMARTLIST_FOREACH_END(_tok);\n  }\n\n  if ((tok = find_opt_by_keyword(footer_tokens, K_DIRECTORY_FOOTER))) {\n    if (tok != smartlist_get(footer_tokens, 0)) {\n      log_warn(LD_DIR, \"Misplaced directory-footer token\");\n      goto err;\n    }\n  }\n\n  tok = find_opt_by_keyword(footer_tokens, K_BW_WEIGHTS);\n  if (tok) {\n    ns->weight_params = smartlist_create();\n    for (i = 0; i < tok->n_args; ++i) {\n      int ok=0;\n      char *eq = strchr(tok->args[i], '=');\n      if (!eq) {\n        log_warn(LD_DIR, \"Bad element '%s' in weight params\",\n                 escaped(tok->args[i]));\n        goto err;\n      }\n      tor_parse_long(eq+1, 10, INT32_MIN, INT32_MAX, &ok, NULL);\n      if (!ok) {\n        log_warn(LD_DIR, \"Bad element '%s' in params\", escaped(tok->args[i]));\n        goto err;\n      }\n      smartlist_add(ns->weight_params, tor_strdup(tok->args[i]));\n    }\n  }\n\n  SMARTLIST_FOREACH_BEGIN(footer_tokens, directory_token_t *, _tok) {\n    char declared_identity[DIGEST_LEN];\n    networkstatus_voter_info_t *v;\n    document_signature_t *sig;\n    const char *id_hexdigest = NULL;\n    const char *sk_hexdigest = NULL;\n    digest_algorithm_t alg = DIGEST_SHA1;\n    tok = _tok;\n    if (tok->tp != K_DIRECTORY_SIGNATURE)\n      continue;\n    tor_assert(tok->n_args >= 2);\n    if (tok->n_args == 2) {\n      id_hexdigest = tok->args[0];\n      sk_hexdigest = tok->args[1];\n    } else {\n      const char *algname = tok->args[0];\n      int a;\n      id_hexdigest = tok->args[1];\n      sk_hexdigest = tok->args[2];\n      a = crypto_digest_algorithm_parse_name(algname);\n      if (a<0) {\n        log_warn(LD_DIR, \"Unknown digest algorithm %s; skipping\",\n                 escaped(algname));\n        continue;\n      }\n      alg = a;\n    }\n\n    if (!tok->object_type ||\n        strcmp(tok->object_type, \"SIGNATURE\") ||\n        tok->object_size < 128 || tok->object_size > 512) {\n      log_warn(LD_DIR, \"Bad object type or length on directory-signature\");\n      goto err;\n    }\n\n    if (strlen(id_hexdigest) != HEX_DIGEST_LEN ||\n        base16_decode(declared_identity, sizeof(declared_identity),\n                      id_hexdigest, HEX_DIGEST_LEN) < 0) {\n      log_warn(LD_DIR, \"Error decoding declared identity %s in \"\n               \"network-status vote.\", escaped(id_hexdigest));\n      goto err;\n    }\n    if (!(v = networkstatus_get_voter_by_id(ns, declared_identity))) {\n      log_warn(LD_DIR, \"ID on signature on network-status vote does not match \"\n               \"any declared directory source.\");\n      goto err;\n    }\n    sig = tor_malloc_zero(sizeof(document_signature_t));\n    memcpy(sig->identity_digest, v->identity_digest, DIGEST_LEN);\n    sig->alg = alg;\n    if (strlen(sk_hexdigest) != HEX_DIGEST_LEN ||\n        base16_decode(sig->signing_key_digest, sizeof(sig->signing_key_digest),\n                      sk_hexdigest, HEX_DIGEST_LEN) < 0) {\n      log_warn(LD_DIR, \"Error decoding declared signing key digest %s in \"\n               \"network-status vote.\", escaped(sk_hexdigest));\n      tor_free(sig);\n      goto err;\n    }\n\n    if (ns->type != NS_TYPE_CONSENSUS) {\n      if (tor_memneq(declared_identity, ns->cert->cache_info.identity_digest,\n                 DIGEST_LEN)) {\n        log_warn(LD_DIR, \"Digest mismatch between declared and actual on \"\n                 \"network-status vote.\");\n        tor_free(sig);\n        goto err;\n      }\n    }\n\n    if (voter_get_sig_by_algorithm(v, sig->alg)) {\n      /* We already parsed a vote with this algorithm from this voter. Use the\n         first one. */\n      log_fn(LOG_PROTOCOL_WARN, LD_DIR, \"We received a networkstatus \"\n             \"that contains two votes from the same voter with the same \"\n             \"algorithm. Ignoring the second vote.\");\n      tor_free(sig);\n      continue;\n    }\n\n    if (ns->type != NS_TYPE_CONSENSUS) {\n      if (check_signature_token(ns_digests.d[DIGEST_SHA1], DIGEST_LEN,\n                                tok, ns->cert->signing_key, 0,\n                                \"network-status vote\")) {\n        tor_free(sig);\n        goto err;\n      }\n      sig->good_signature = 1;\n    } else {\n      if (tok->object_size >= INT_MAX || tok->object_size >= SIZE_T_CEILING) {\n        tor_free(sig);\n        goto err;\n      }\n      sig->signature = tor_memdup(tok->object_body, tok->object_size);\n      sig->signature_len = (int) tok->object_size;\n    }\n    smartlist_add(v->sigs, sig);\n\n    ++n_signatures;\n  } SMARTLIST_FOREACH_END(_tok);\n\n  if (! n_signatures) {\n    log_warn(LD_DIR, \"No signatures on networkstatus vote.\");\n    goto err;\n  } else if (ns->type == NS_TYPE_VOTE && n_signatures != 1) {\n    log_warn(LD_DIR, \"Received more than one signature on a \"\n             \"network-status vote.\");\n    goto err;\n  }\n\n  if (eos_out)\n    *eos_out = end_of_footer;\n\n  goto done;\n err:\n  dump_desc(s_dup, \"v3 networkstatus\");\n  networkstatus_vote_free(ns);\n  ns = NULL;\n done:\n  if (tokens) {\n    SMARTLIST_FOREACH(tokens, directory_token_t *, t, token_clear(t));\n    smartlist_free(tokens);\n  }\n  if (voter) {\n    if (voter->sigs) {\n      SMARTLIST_FOREACH(voter->sigs, document_signature_t *, sig,\n                        document_signature_free(sig));\n      smartlist_free(voter->sigs);\n    }\n    tor_free(voter->nickname);\n    tor_free(voter->address);\n    tor_free(voter->contact);\n    tor_free(voter);\n  }\n  if (rs_tokens) {\n    SMARTLIST_FOREACH(rs_tokens, directory_token_t *, t, token_clear(t));\n    smartlist_free(rs_tokens);\n  }\n  if (footer_tokens) {\n    SMARTLIST_FOREACH(footer_tokens, directory_token_t *, t, token_clear(t));\n    smartlist_free(footer_tokens);\n  }\n  if (area) {\n    DUMP_AREA(area, \"v3 networkstatus\");\n    memarea_drop_all(area);\n  }\n  if (rs_area)\n    memarea_drop_all(rs_area);\n\n  return ns;\n}", "func_hash": 297795787979009632344281497591388902899, "file_name": "routerparse.c", "file_hash": 22420103474128049345359193080521452725, "cwe": ["CWE-399"], "cve": "CVE-2012-3517", "cve_desc": "Use-after-free vulnerability in dns.c in Tor before 0.2.2.38 might allow remote attackers to cause a denial of service (daemon crash) via vectors related to failed DNS requests.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-3517", "file_path": "src/or/routerparse.c"}
{"idx": 411896, "project": "tor", "commit_id": "57e35ad3d91724882c345ac709666a551a977f0f", "project_url": "https://github.com/torproject/tor", "commit_url": "https://gitweb.torproject.org/tor.git/commitdiff/57e35ad3d91724882c345ac709666a551a977f0f", "commit_message": "Avoid possible segfault when handling networkstatus vote with bad flavor\n\nFix for 6530; fix on 0.2.2.6-alpha.", "target": 0, "func": "networkstatus_parse_vote_from_string(const char *s, const char **eos_out,\n                                     networkstatus_type_t ns_type)\n{\n  smartlist_t *tokens = smartlist_create();\n  smartlist_t *rs_tokens = NULL, *footer_tokens = NULL;\n  networkstatus_voter_info_t *voter = NULL;\n  networkstatus_t *ns = NULL;\n  digests_t ns_digests;\n  const char *cert, *end_of_header, *end_of_footer, *s_dup = s;\n  directory_token_t *tok;\n  int ok;\n  struct in_addr in;\n  int i, inorder, n_signatures = 0;\n  memarea_t *area = NULL, *rs_area = NULL;\n  consensus_flavor_t flav = FLAV_NS;\n\n  tor_assert(s);\n\n  if (eos_out)\n    *eos_out = NULL;\n\n  if (router_get_networkstatus_v3_hashes(s, &ns_digests)) {\n    log_warn(LD_DIR, \"Unable to compute digest of network-status\");\n    goto err;\n  }\n\n  area = memarea_new();\n  end_of_header = find_start_of_next_routerstatus(s);\n  if (tokenize_string(area, s, end_of_header, tokens,\n                      (ns_type == NS_TYPE_CONSENSUS) ?\n                      networkstatus_consensus_token_table :\n                      networkstatus_token_table, 0)) {\n    log_warn(LD_DIR, \"Error tokenizing network-status vote header\");\n    goto err;\n  }\n\n  ns = tor_malloc_zero(sizeof(networkstatus_t));\n  memcpy(&ns->digests, &ns_digests, sizeof(ns_digests));\n\n  tok = find_by_keyword(tokens, K_NETWORK_STATUS_VERSION);\n  tor_assert(tok);\n  if (tok->n_args > 1) {\n    int flavor = networkstatus_parse_flavor_name(tok->args[1]);\n    if (flavor < 0) {\n      log_warn(LD_DIR, \"Can't parse document with unknown flavor %s\",\n               escaped(tok->args[1]));\n      goto err;\n    }\n    ns->flavor = flav = flavor;\n  }\n  if (flav != FLAV_NS && ns_type != NS_TYPE_CONSENSUS) {\n    log_warn(LD_DIR, \"Flavor found on non-consensus networkstatus.\");\n    goto err;\n  }\n\n  if (ns_type != NS_TYPE_CONSENSUS) {\n    const char *end_of_cert = NULL;\n    if (!(cert = strstr(s, \"\\ndir-key-certificate-version\")))\n      goto err;\n    ++cert;\n    ns->cert = authority_cert_parse_from_string(cert, &end_of_cert);\n    if (!ns->cert || !end_of_cert || end_of_cert > end_of_header)\n      goto err;\n  }\n\n  tok = find_by_keyword(tokens, K_VOTE_STATUS);\n  tor_assert(tok->n_args);\n  if (!strcmp(tok->args[0], \"vote\")) {\n    ns->type = NS_TYPE_VOTE;\n  } else if (!strcmp(tok->args[0], \"consensus\")) {\n    ns->type = NS_TYPE_CONSENSUS;\n  } else if (!strcmp(tok->args[0], \"opinion\")) {\n    ns->type = NS_TYPE_OPINION;\n  } else {\n    log_warn(LD_DIR, \"Unrecognized vote status %s in network-status\",\n             escaped(tok->args[0]));\n    goto err;\n  }\n  if (ns_type != ns->type) {\n    log_warn(LD_DIR, \"Got the wrong kind of v3 networkstatus.\");\n    goto err;\n  }\n\n  if (ns->type == NS_TYPE_VOTE || ns->type == NS_TYPE_OPINION) {\n    tok = find_by_keyword(tokens, K_PUBLISHED);\n    if (parse_iso_time(tok->args[0], &ns->published))\n      goto err;\n\n    ns->supported_methods = smartlist_create();\n    tok = find_opt_by_keyword(tokens, K_CONSENSUS_METHODS);\n    if (tok) {\n      for (i=0; i < tok->n_args; ++i)\n        smartlist_add(ns->supported_methods, tor_strdup(tok->args[i]));\n    } else {\n      smartlist_add(ns->supported_methods, tor_strdup(\"1\"));\n    }\n  } else {\n    tok = find_opt_by_keyword(tokens, K_CONSENSUS_METHOD);\n    if (tok) {\n      ns->consensus_method = (int)tor_parse_long(tok->args[0], 10, 1, INT_MAX,\n                                                 &ok, NULL);\n      if (!ok)\n        goto err;\n    } else {\n      ns->consensus_method = 1;\n    }\n  }\n\n  tok = find_by_keyword(tokens, K_VALID_AFTER);\n  if (parse_iso_time(tok->args[0], &ns->valid_after))\n    goto err;\n\n  tok = find_by_keyword(tokens, K_FRESH_UNTIL);\n  if (parse_iso_time(tok->args[0], &ns->fresh_until))\n    goto err;\n\n  tok = find_by_keyword(tokens, K_VALID_UNTIL);\n  if (parse_iso_time(tok->args[0], &ns->valid_until))\n    goto err;\n\n  tok = find_by_keyword(tokens, K_VOTING_DELAY);\n  tor_assert(tok->n_args >= 2);\n  ns->vote_seconds =\n    (int) tor_parse_long(tok->args[0], 10, 0, INT_MAX, &ok, NULL);\n  if (!ok)\n    goto err;\n  ns->dist_seconds =\n    (int) tor_parse_long(tok->args[1], 10, 0, INT_MAX, &ok, NULL);\n  if (!ok)\n    goto err;\n  if (ns->valid_after + MIN_VOTE_INTERVAL > ns->fresh_until) {\n    log_warn(LD_DIR, \"Vote/consensus freshness interval is too short\");\n    goto err;\n  }\n  if (ns->valid_after + MIN_VOTE_INTERVAL*2 > ns->valid_until) {\n    log_warn(LD_DIR, \"Vote/consensus liveness interval is too short\");\n    goto err;\n  }\n  if (ns->vote_seconds < MIN_VOTE_SECONDS) {\n    log_warn(LD_DIR, \"Vote seconds is too short\");\n    goto err;\n  }\n  if (ns->dist_seconds < MIN_DIST_SECONDS) {\n    log_warn(LD_DIR, \"Dist seconds is too short\");\n    goto err;\n  }\n\n  if ((tok = find_opt_by_keyword(tokens, K_CLIENT_VERSIONS))) {\n    ns->client_versions = tor_strdup(tok->args[0]);\n  }\n  if ((tok = find_opt_by_keyword(tokens, K_SERVER_VERSIONS))) {\n    ns->server_versions = tor_strdup(tok->args[0]);\n  }\n\n  tok = find_by_keyword(tokens, K_KNOWN_FLAGS);\n  ns->known_flags = smartlist_create();\n  inorder = 1;\n  for (i = 0; i < tok->n_args; ++i) {\n    smartlist_add(ns->known_flags, tor_strdup(tok->args[i]));\n    if (i>0 && strcmp(tok->args[i-1], tok->args[i])>= 0) {\n      log_warn(LD_DIR, \"%s >= %s\", tok->args[i-1], tok->args[i]);\n      inorder = 0;\n    }\n  }\n  if (!inorder) {\n    log_warn(LD_DIR, \"known-flags not in order\");\n    goto err;\n  }\n\n  tok = find_opt_by_keyword(tokens, K_PARAMS);\n  if (tok) {\n    inorder = 1;\n    ns->net_params = smartlist_create();\n    for (i = 0; i < tok->n_args; ++i) {\n      int ok=0;\n      char *eq = strchr(tok->args[i], '=');\n      if (!eq) {\n        log_warn(LD_DIR, \"Bad element '%s' in params\", escaped(tok->args[i]));\n        goto err;\n      }\n      tor_parse_long(eq+1, 10, INT32_MIN, INT32_MAX, &ok, NULL);\n      if (!ok) {\n        log_warn(LD_DIR, \"Bad element '%s' in params\", escaped(tok->args[i]));\n        goto err;\n      }\n      if (i > 0 && strcmp(tok->args[i-1], tok->args[i]) >= 0) {\n        log_warn(LD_DIR, \"%s >= %s\", tok->args[i-1], tok->args[i]);\n        inorder = 0;\n      }\n      smartlist_add(ns->net_params, tor_strdup(tok->args[i]));\n    }\n    if (!inorder) {\n      log_warn(LD_DIR, \"params not in order\");\n      goto err;\n    }\n  }\n\n  ns->voters = smartlist_create();\n\n  SMARTLIST_FOREACH_BEGIN(tokens, directory_token_t *, _tok) {\n    tok = _tok;\n    if (tok->tp == K_DIR_SOURCE) {\n      tor_assert(tok->n_args >= 6);\n\n      if (voter)\n        smartlist_add(ns->voters, voter);\n      voter = tor_malloc_zero(sizeof(networkstatus_voter_info_t));\n      voter->sigs = smartlist_create();\n      if (ns->type != NS_TYPE_CONSENSUS)\n        memcpy(voter->vote_digest, ns_digests.d[DIGEST_SHA1], DIGEST_LEN);\n\n      voter->nickname = tor_strdup(tok->args[0]);\n      if (strlen(tok->args[1]) != HEX_DIGEST_LEN ||\n          base16_decode(voter->identity_digest, sizeof(voter->identity_digest),\n                        tok->args[1], HEX_DIGEST_LEN) < 0) {\n        log_warn(LD_DIR, \"Error decoding identity digest %s in \"\n                 \"network-status vote.\", escaped(tok->args[1]));\n        goto err;\n      }\n      if (ns->type != NS_TYPE_CONSENSUS &&\n          tor_memneq(ns->cert->cache_info.identity_digest,\n                 voter->identity_digest, DIGEST_LEN)) {\n        log_warn(LD_DIR,\"Mismatch between identities in certificate and vote\");\n        goto err;\n      }\n      voter->address = tor_strdup(tok->args[2]);\n      if (!tor_inet_aton(tok->args[3], &in)) {\n        log_warn(LD_DIR, \"Error decoding IP address %s in network-status.\",\n                 escaped(tok->args[3]));\n        goto err;\n      }\n      voter->addr = ntohl(in.s_addr);\n      voter->dir_port = (uint16_t)\n        tor_parse_long(tok->args[4], 10, 0, 65535, &ok, NULL);\n      if (!ok)\n        goto err;\n      voter->or_port = (uint16_t)\n        tor_parse_long(tok->args[5], 10, 0, 65535, &ok, NULL);\n      if (!ok)\n        goto err;\n    } else if (tok->tp == K_CONTACT) {\n      if (!voter || voter->contact) {\n        log_warn(LD_DIR, \"contact element is out of place.\");\n        goto err;\n      }\n      voter->contact = tor_strdup(tok->args[0]);\n    } else if (tok->tp == K_VOTE_DIGEST) {\n      tor_assert(ns->type == NS_TYPE_CONSENSUS);\n      tor_assert(tok->n_args >= 1);\n      if (!voter || ! tor_digest_is_zero(voter->vote_digest)) {\n        log_warn(LD_DIR, \"vote-digest element is out of place.\");\n        goto err;\n      }\n      if (strlen(tok->args[0]) != HEX_DIGEST_LEN ||\n        base16_decode(voter->vote_digest, sizeof(voter->vote_digest),\n                      tok->args[0], HEX_DIGEST_LEN) < 0) {\n        log_warn(LD_DIR, \"Error decoding vote digest %s in \"\n                 \"network-status consensus.\", escaped(tok->args[0]));\n        goto err;\n      }\n    }\n  } SMARTLIST_FOREACH_END(_tok);\n  if (voter) {\n    smartlist_add(ns->voters, voter);\n    voter = NULL;\n  }\n  if (smartlist_len(ns->voters) == 0) {\n    log_warn(LD_DIR, \"Missing dir-source elements in a vote networkstatus.\");\n    goto err;\n  } else if (ns->type != NS_TYPE_CONSENSUS && smartlist_len(ns->voters) != 1) {\n    log_warn(LD_DIR, \"Too many dir-source elements in a vote networkstatus.\");\n    goto err;\n  }\n\n  if (ns->type != NS_TYPE_CONSENSUS &&\n      (tok = find_opt_by_keyword(tokens, K_LEGACY_DIR_KEY))) {\n    int bad = 1;\n    if (strlen(tok->args[0]) == HEX_DIGEST_LEN) {\n      networkstatus_voter_info_t *voter = smartlist_get(ns->voters, 0);\n      if (base16_decode(voter->legacy_id_digest, DIGEST_LEN,\n                        tok->args[0], HEX_DIGEST_LEN)<0)\n        bad = 1;\n      else\n        bad = 0;\n    }\n    if (bad) {\n      log_warn(LD_DIR, \"Invalid legacy key digest %s on vote.\",\n               escaped(tok->args[0]));\n    }\n  }\n\n  /* Parse routerstatus lines. */\n  rs_tokens = smartlist_create();\n  rs_area = memarea_new();\n  s = end_of_header;\n  ns->routerstatus_list = smartlist_create();\n\n  while (!strcmpstart(s, \"r \")) {\n    if (ns->type != NS_TYPE_CONSENSUS) {\n      vote_routerstatus_t *rs = tor_malloc_zero(sizeof(vote_routerstatus_t));\n      if (routerstatus_parse_entry_from_string(rs_area, &s, rs_tokens, ns,\n                                               rs, 0, 0))\n        smartlist_add(ns->routerstatus_list, rs);\n      else {\n        tor_free(rs->version);\n        tor_free(rs);\n      }\n    } else {\n      routerstatus_t *rs;\n      if ((rs = routerstatus_parse_entry_from_string(rs_area, &s, rs_tokens,\n                                                     NULL, NULL,\n                                                     ns->consensus_method,\n                                                     flav)))\n        smartlist_add(ns->routerstatus_list, rs);\n    }\n  }\n  for (i = 1; i < smartlist_len(ns->routerstatus_list); ++i) {\n    routerstatus_t *rs1, *rs2;\n    if (ns->type != NS_TYPE_CONSENSUS) {\n      vote_routerstatus_t *a = smartlist_get(ns->routerstatus_list, i-1);\n      vote_routerstatus_t *b = smartlist_get(ns->routerstatus_list, i);\n      rs1 = &a->status; rs2 = &b->status;\n    } else {\n      rs1 = smartlist_get(ns->routerstatus_list, i-1);\n      rs2 = smartlist_get(ns->routerstatus_list, i);\n    }\n    if (fast_memcmp(rs1->identity_digest, rs2->identity_digest, DIGEST_LEN)\n        >= 0) {\n      log_warn(LD_DIR, \"Vote networkstatus entries not sorted by identity \"\n               \"digest\");\n      goto err;\n    }\n  }\n\n  /* Parse footer; check signature. */\n  footer_tokens = smartlist_create();\n  if ((end_of_footer = strstr(s, \"\\nnetwork-status-version \")))\n    ++end_of_footer;\n  else\n    end_of_footer = s + strlen(s);\n  if (tokenize_string(area,s, end_of_footer, footer_tokens,\n                      networkstatus_vote_footer_token_table, 0)) {\n    log_warn(LD_DIR, \"Error tokenizing network-status vote footer.\");\n    goto err;\n  }\n\n  {\n    int found_sig = 0;\n    SMARTLIST_FOREACH_BEGIN(footer_tokens, directory_token_t *, _tok) {\n      tok = _tok;\n      if (tok->tp == K_DIRECTORY_SIGNATURE)\n        found_sig = 1;\n      else if (found_sig) {\n        log_warn(LD_DIR, \"Extraneous token after first directory-signature\");\n        goto err;\n      }\n    } SMARTLIST_FOREACH_END(_tok);\n  }\n\n  if ((tok = find_opt_by_keyword(footer_tokens, K_DIRECTORY_FOOTER))) {\n    if (tok != smartlist_get(footer_tokens, 0)) {\n      log_warn(LD_DIR, \"Misplaced directory-footer token\");\n      goto err;\n    }\n  }\n\n  tok = find_opt_by_keyword(footer_tokens, K_BW_WEIGHTS);\n  if (tok) {\n    ns->weight_params = smartlist_create();\n    for (i = 0; i < tok->n_args; ++i) {\n      int ok=0;\n      char *eq = strchr(tok->args[i], '=');\n      if (!eq) {\n        log_warn(LD_DIR, \"Bad element '%s' in weight params\",\n                 escaped(tok->args[i]));\n        goto err;\n      }\n      tor_parse_long(eq+1, 10, INT32_MIN, INT32_MAX, &ok, NULL);\n      if (!ok) {\n        log_warn(LD_DIR, \"Bad element '%s' in params\", escaped(tok->args[i]));\n        goto err;\n      }\n      smartlist_add(ns->weight_params, tor_strdup(tok->args[i]));\n    }\n  }\n\n  SMARTLIST_FOREACH_BEGIN(footer_tokens, directory_token_t *, _tok) {\n    char declared_identity[DIGEST_LEN];\n    networkstatus_voter_info_t *v;\n    document_signature_t *sig;\n    const char *id_hexdigest = NULL;\n    const char *sk_hexdigest = NULL;\n    digest_algorithm_t alg = DIGEST_SHA1;\n    tok = _tok;\n    if (tok->tp != K_DIRECTORY_SIGNATURE)\n      continue;\n    tor_assert(tok->n_args >= 2);\n    if (tok->n_args == 2) {\n      id_hexdigest = tok->args[0];\n      sk_hexdigest = tok->args[1];\n    } else {\n      const char *algname = tok->args[0];\n      int a;\n      id_hexdigest = tok->args[1];\n      sk_hexdigest = tok->args[2];\n      a = crypto_digest_algorithm_parse_name(algname);\n      if (a<0) {\n        log_warn(LD_DIR, \"Unknown digest algorithm %s; skipping\",\n                 escaped(algname));\n        continue;\n      }\n      alg = a;\n    }\n\n    if (!tok->object_type ||\n        strcmp(tok->object_type, \"SIGNATURE\") ||\n        tok->object_size < 128 || tok->object_size > 512) {\n      log_warn(LD_DIR, \"Bad object type or length on directory-signature\");\n      goto err;\n    }\n\n    if (strlen(id_hexdigest) != HEX_DIGEST_LEN ||\n        base16_decode(declared_identity, sizeof(declared_identity),\n                      id_hexdigest, HEX_DIGEST_LEN) < 0) {\n      log_warn(LD_DIR, \"Error decoding declared identity %s in \"\n               \"network-status vote.\", escaped(id_hexdigest));\n      goto err;\n    }\n    if (!(v = networkstatus_get_voter_by_id(ns, declared_identity))) {\n      log_warn(LD_DIR, \"ID on signature on network-status vote does not match \"\n               \"any declared directory source.\");\n      goto err;\n    }\n    sig = tor_malloc_zero(sizeof(document_signature_t));\n    memcpy(sig->identity_digest, v->identity_digest, DIGEST_LEN);\n    sig->alg = alg;\n    if (strlen(sk_hexdigest) != HEX_DIGEST_LEN ||\n        base16_decode(sig->signing_key_digest, sizeof(sig->signing_key_digest),\n                      sk_hexdigest, HEX_DIGEST_LEN) < 0) {\n      log_warn(LD_DIR, \"Error decoding declared signing key digest %s in \"\n               \"network-status vote.\", escaped(sk_hexdigest));\n      tor_free(sig);\n      goto err;\n    }\n\n    if (ns->type != NS_TYPE_CONSENSUS) {\n      if (tor_memneq(declared_identity, ns->cert->cache_info.identity_digest,\n                 DIGEST_LEN)) {\n        log_warn(LD_DIR, \"Digest mismatch between declared and actual on \"\n                 \"network-status vote.\");\n        tor_free(sig);\n        goto err;\n      }\n    }\n\n    if (voter_get_sig_by_algorithm(v, sig->alg)) {\n      /* We already parsed a vote with this algorithm from this voter. Use the\n         first one. */\n      log_fn(LOG_PROTOCOL_WARN, LD_DIR, \"We received a networkstatus \"\n             \"that contains two votes from the same voter with the same \"\n             \"algorithm. Ignoring the second vote.\");\n      tor_free(sig);\n      continue;\n    }\n\n    if (ns->type != NS_TYPE_CONSENSUS) {\n      if (check_signature_token(ns_digests.d[DIGEST_SHA1], DIGEST_LEN,\n                                tok, ns->cert->signing_key, 0,\n                                \"network-status vote\")) {\n        tor_free(sig);\n        goto err;\n      }\n      sig->good_signature = 1;\n    } else {\n      if (tok->object_size >= INT_MAX || tok->object_size >= SIZE_T_CEILING) {\n        tor_free(sig);\n        goto err;\n      }\n      sig->signature = tor_memdup(tok->object_body, tok->object_size);\n      sig->signature_len = (int) tok->object_size;\n    }\n    smartlist_add(v->sigs, sig);\n\n    ++n_signatures;\n  } SMARTLIST_FOREACH_END(_tok);\n\n  if (! n_signatures) {\n    log_warn(LD_DIR, \"No signatures on networkstatus vote.\");\n    goto err;\n  } else if (ns->type == NS_TYPE_VOTE && n_signatures != 1) {\n    log_warn(LD_DIR, \"Received more than one signature on a \"\n             \"network-status vote.\");\n    goto err;\n  }\n\n  if (eos_out)\n    *eos_out = end_of_footer;\n\n  goto done;\n err:\n  dump_desc(s_dup, \"v3 networkstatus\");\n  networkstatus_vote_free(ns);\n  ns = NULL;\n done:\n  if (tokens) {\n    SMARTLIST_FOREACH(tokens, directory_token_t *, t, token_clear(t));\n    smartlist_free(tokens);\n  }\n  if (voter) {\n    if (voter->sigs) {\n      SMARTLIST_FOREACH(voter->sigs, document_signature_t *, sig,\n                        document_signature_free(sig));\n      smartlist_free(voter->sigs);\n    }\n    tor_free(voter->nickname);\n    tor_free(voter->address);\n    tor_free(voter->contact);\n    tor_free(voter);\n  }\n  if (rs_tokens) {\n    SMARTLIST_FOREACH(rs_tokens, directory_token_t *, t, token_clear(t));\n    smartlist_free(rs_tokens);\n  }\n  if (footer_tokens) {\n    SMARTLIST_FOREACH(footer_tokens, directory_token_t *, t, token_clear(t));\n    smartlist_free(footer_tokens);\n  }\n  if (area) {\n    DUMP_AREA(area, \"v3 networkstatus\");\n    memarea_drop_all(area);\n  }\n  if (rs_area)\n    memarea_drop_all(rs_area);\n\n  return ns;\n}", "func_hash": 32476189085047846654485357461000169303, "file_name": "routerparse.c", "file_hash": 74078993205863755729749320619386018823, "cwe": ["CWE-399"], "cve": "CVE-2012-3517", "cve_desc": "Use-after-free vulnerability in dns.c in Tor before 0.2.2.38 might allow remote attackers to cause a denial of service (daemon crash) via vectors related to failed DNS requests.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-3517", "file_path": "src/or/routerparse.c"}
