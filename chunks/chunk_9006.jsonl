{"idx": 204495, "project": "linux", "commit_id": "47abea041f897d64dbd5777f0cf7745148f85d75", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/47abea041f897d64dbd5777f0cf7745148f85d75", "commit_message": "io_uring: fix off-by-one in sync cancelation file check\n\nThe passed in index should be validated against the number of registered\nfiles we have, it needs to be smaller than the index value to avoid going\none beyond the end.\n\nFixes: 78a861b94959 (\"io_uring: add sync cancelation API through io_uring_register()\")\nReported-by: Luo Likang <luolikang@nsfocus.com>\nSigned-off-by: Jens Axboe <axboe@kernel.dk>", "target": 1, "func": "static int __io_sync_cancel(struct io_uring_task *tctx,\n\t\t\t    struct io_cancel_data *cd, int fd)\n{\n\tstruct io_ring_ctx *ctx = cd->ctx;\n\n\t/* fixed must be grabbed every time since we drop the uring_lock */\n\tif ((cd->flags & IORING_ASYNC_CANCEL_FD) &&\n\t    (cd->flags & IORING_ASYNC_CANCEL_FD_FIXED)) {\n\t\tunsigned long file_ptr;\n\n\t\tif (unlikely(fd > ctx->nr_user_files))\n\t\t\treturn -EBADF;\n\t\tfd = array_index_nospec(fd, ctx->nr_user_files);\n\t\tfile_ptr = io_fixed_file_slot(&ctx->file_table, fd)->file_ptr;\n\t\tcd->file = (struct file *) (file_ptr & FFS_MASK);\n\t\tif (!cd->file)\n\t\t\treturn -EBADF;\n\t}\n\n\treturn __io_async_cancel(cd, tctx, 0);\n}", "func_hash": 178631003172617197260225259743936148137, "file_name": "cancel.c", "file_hash": 251597362135051290688561510710144448867, "cwe": ["CWE-193"], "cve": "CVE-2022-3103", "cve_desc": "off-by-one in io_uring module.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-3103", "file_path": "io_uring/cancel.c"}
{"idx": 360829, "project": "linux", "commit_id": "47abea041f897d64dbd5777f0cf7745148f85d75", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/47abea041f897d64dbd5777f0cf7745148f85d75", "commit_message": "io_uring: fix off-by-one in sync cancelation file check\n\nThe passed in index should be validated against the number of registered\nfiles we have, it needs to be smaller than the index value to avoid going\none beyond the end.\n\nFixes: 78a861b94959 (\"io_uring: add sync cancelation API through io_uring_register()\")\nReported-by: Luo Likang <luolikang@nsfocus.com>\nSigned-off-by: Jens Axboe <axboe@kernel.dk>", "target": 0, "func": "static int __io_sync_cancel(struct io_uring_task *tctx,\n\t\t\t    struct io_cancel_data *cd, int fd)\n{\n\tstruct io_ring_ctx *ctx = cd->ctx;\n\n\t/* fixed must be grabbed every time since we drop the uring_lock */\n\tif ((cd->flags & IORING_ASYNC_CANCEL_FD) &&\n\t    (cd->flags & IORING_ASYNC_CANCEL_FD_FIXED)) {\n\t\tunsigned long file_ptr;\n\n\t\tif (unlikely(fd >= ctx->nr_user_files))\n\t\t\treturn -EBADF;\n\t\tfd = array_index_nospec(fd, ctx->nr_user_files);\n\t\tfile_ptr = io_fixed_file_slot(&ctx->file_table, fd)->file_ptr;\n\t\tcd->file = (struct file *) (file_ptr & FFS_MASK);\n\t\tif (!cd->file)\n\t\t\treturn -EBADF;\n\t}\n\n\treturn __io_async_cancel(cd, tctx, 0);\n}", "func_hash": 191453192245381781842321164119198990689, "file_name": "cancel.c", "file_hash": 191362883793091950391767824989989369401, "cwe": ["CWE-193"], "cve": "CVE-2022-3103", "cve_desc": "off-by-one in io_uring module.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-3103", "file_path": "io_uring/cancel.c"}
{"idx": 204534, "project": "admesh", "commit_id": "e84d8353f1347e1f26f0a95770d92ba14e6ede38", "project_url": "https://github.com/admesh/admesh", "commit_url": "https://github.com/admesh/admesh/commit/e84d8353f1347e1f26f0a95770d92ba14e6ede38", "commit_message": "Fix heap buffer overflow in stl_update_connects_remove_1\n\n\n- Add argument value check to the stl_update_connects_remove_1\n- Add neighbor value check in stl_remove_degenerate\n\nFixes https://github.com/admesh/admesh/issues/28\nMerges https://github.com/admesh/admesh/pull/55", "target": 1, "func": "stl_remove_degenerate(stl_file *stl, int facet) {\n  int edge1;\n  int edge2;\n  int edge3;\n  int neighbor1;\n  int neighbor2;\n  int neighbor3;\n  int vnot1;\n  int vnot2;\n  int vnot3;\n\n  if (stl->error) return;\n\n  if(   !memcmp(&stl->facet_start[facet].vertex[0],\n                &stl->facet_start[facet].vertex[1], sizeof(stl_vertex))\n        && !memcmp(&stl->facet_start[facet].vertex[1],\n                   &stl->facet_start[facet].vertex[2], sizeof(stl_vertex))) {\n    /* all 3 vertices are equal.  Just remove the facet.  I don't think*/\n    /* this is really possible, but just in case... */\n    printf(\"removing a facet in stl_remove_degenerate\\n\");\n\n    stl_remove_facet(stl, facet);\n    return;\n  }\n\n  if(!memcmp(&stl->facet_start[facet].vertex[0],\n             &stl->facet_start[facet].vertex[1], sizeof(stl_vertex))) {\n    edge1 = 1;\n    edge2 = 2;\n    edge3 = 0;\n  } else if(!memcmp(&stl->facet_start[facet].vertex[1],\n                    &stl->facet_start[facet].vertex[2], sizeof(stl_vertex))) {\n    edge1 = 0;\n    edge2 = 2;\n    edge3 = 1;\n  } else if(!memcmp(&stl->facet_start[facet].vertex[2],\n                    &stl->facet_start[facet].vertex[0], sizeof(stl_vertex))) {\n    edge1 = 0;\n    edge2 = 1;\n    edge3 = 2;\n  } else {\n    /* No degenerate. Function shouldn't have been called. */\n    return;\n  }\n  neighbor1 = stl->neighbors_start[facet].neighbor[edge1];\n  neighbor2 = stl->neighbors_start[facet].neighbor[edge2];\n\n  if(neighbor1 == -1) {\n    stl_update_connects_remove_1(stl, neighbor2);\n  }\n  if(neighbor2 == -1) {\n    stl_update_connects_remove_1(stl, neighbor1);\n  }\n\n\n  neighbor3 = stl->neighbors_start[facet].neighbor[edge3];\n  vnot1 = stl->neighbors_start[facet].which_vertex_not[edge1];\n  vnot2 = stl->neighbors_start[facet].which_vertex_not[edge2];\n  vnot3 = stl->neighbors_start[facet].which_vertex_not[edge3];\n\n  if(neighbor1 != -1){\n    stl->neighbors_start[neighbor1].neighbor[(vnot1 + 1) % 3] = neighbor2;\n    stl->neighbors_start[neighbor1].which_vertex_not[(vnot1 + 1) % 3] = vnot2;\n  }\n  if(neighbor2 != -1){\n    stl->neighbors_start[neighbor2].neighbor[(vnot2 + 1) % 3] = neighbor1;\n    stl->neighbors_start[neighbor2].which_vertex_not[(vnot2 + 1) % 3] = vnot1;\n  }\n\n  stl_remove_facet(stl, facet);\n\n  if(neighbor3 != -1) {\n    stl_update_connects_remove_1(stl, neighbor3);\n    stl->neighbors_start[neighbor3].neighbor[(vnot3 + 1) % 3] = -1;\n  }\n}", "func_hash": 62749783590026466291303120848549680020, "file_name": "connect.c", "file_hash": 88334157411234536587499947341326463538, "cwe": ["CWE-125"], "cve": "CVE-2018-25033", "cve_desc": "ADMesh through 0.98.4 has a heap-based buffer over-read in stl_update_connects_remove_1 (called from stl_remove_degenerate) in connect.c in libadmesh.a.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2018-25033", "file_path": "src/connect.c"}
{"idx": 361303, "project": "admesh", "commit_id": "e84d8353f1347e1f26f0a95770d92ba14e6ede38", "project_url": "https://github.com/admesh/admesh", "commit_url": "https://github.com/admesh/admesh/commit/e84d8353f1347e1f26f0a95770d92ba14e6ede38", "commit_message": "Fix heap buffer overflow in stl_update_connects_remove_1\n\n\n- Add argument value check to the stl_update_connects_remove_1\n- Add neighbor value check in stl_remove_degenerate\n\nFixes https://github.com/admesh/admesh/issues/28\nMerges https://github.com/admesh/admesh/pull/55", "target": 0, "func": "stl_remove_degenerate(stl_file *stl, int facet) {\n  int edge1;\n  int edge2;\n  int edge3;\n  int neighbor1;\n  int neighbor2;\n  int neighbor3;\n  int vnot1;\n  int vnot2;\n  int vnot3;\n\n  if (stl->error) return;\n\n  if(   !memcmp(&stl->facet_start[facet].vertex[0],\n                &stl->facet_start[facet].vertex[1], sizeof(stl_vertex))\n        && !memcmp(&stl->facet_start[facet].vertex[1],\n                   &stl->facet_start[facet].vertex[2], sizeof(stl_vertex))) {\n    /* all 3 vertices are equal.  Just remove the facet.  I don't think*/\n    /* this is really possible, but just in case... */\n    printf(\"removing a facet in stl_remove_degenerate\\n\");\n\n    stl_remove_facet(stl, facet);\n    return;\n  }\n\n  if(!memcmp(&stl->facet_start[facet].vertex[0],\n             &stl->facet_start[facet].vertex[1], sizeof(stl_vertex))) {\n    edge1 = 1;\n    edge2 = 2;\n    edge3 = 0;\n  } else if(!memcmp(&stl->facet_start[facet].vertex[1],\n                    &stl->facet_start[facet].vertex[2], sizeof(stl_vertex))) {\n    edge1 = 0;\n    edge2 = 2;\n    edge3 = 1;\n  } else if(!memcmp(&stl->facet_start[facet].vertex[2],\n                    &stl->facet_start[facet].vertex[0], sizeof(stl_vertex))) {\n    edge1 = 0;\n    edge2 = 1;\n    edge3 = 2;\n  } else {\n    /* No degenerate. Function shouldn't have been called. */\n    return;\n  }\n  neighbor1 = stl->neighbors_start[facet].neighbor[edge1];\n  neighbor2 = stl->neighbors_start[facet].neighbor[edge2];\n\n  if(neighbor1 == -1 && neighbor2 != -1) {\n    stl_update_connects_remove_1(stl, neighbor2);\n  }\n  else if (neighbor2 == -1 && neighbor1 != -1) {\n    stl_update_connects_remove_1(stl, neighbor1);\n  }\n\n  neighbor3 = stl->neighbors_start[facet].neighbor[edge3];\n  vnot1 = stl->neighbors_start[facet].which_vertex_not[edge1];\n  vnot2 = stl->neighbors_start[facet].which_vertex_not[edge2];\n  vnot3 = stl->neighbors_start[facet].which_vertex_not[edge3];\n\n  if(neighbor1 != -1){\n    stl->neighbors_start[neighbor1].neighbor[(vnot1 + 1) % 3] = neighbor2;\n    stl->neighbors_start[neighbor1].which_vertex_not[(vnot1 + 1) % 3] = vnot2;\n  }\n  if(neighbor2 != -1){\n    stl->neighbors_start[neighbor2].neighbor[(vnot2 + 1) % 3] = neighbor1;\n    stl->neighbors_start[neighbor2].which_vertex_not[(vnot2 + 1) % 3] = vnot1;\n  }\n\n  stl_remove_facet(stl, facet);\n\n  if(neighbor3 != -1) {\n    stl_update_connects_remove_1(stl, neighbor3);\n    stl->neighbors_start[neighbor3].neighbor[(vnot3 + 1) % 3] = -1;\n  }\n}", "func_hash": 25155049141523797391201320731237896996, "file_name": "connect.c", "file_hash": 216745481854892780790975730037335372174, "cwe": ["CWE-125"], "cve": "CVE-2018-25033", "cve_desc": "ADMesh through 0.98.4 has a heap-based buffer over-read in stl_update_connects_remove_1 (called from stl_remove_degenerate) in connect.c in libadmesh.a.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2018-25033", "file_path": "src/connect.c"}
