{"idx": 208107, "project": "linux", "commit_id": "f85daf0e725358be78dfd208dea5fd665d8cb901", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/f85daf0e725358be78dfd208dea5fd665d8cb901", "commit_message": "xfrm: xfrm_policy: fix a possible double xfrm_pols_put() in xfrm_bundle_lookup()\n\nxfrm_policy_lookup() will call xfrm_pol_hold_rcu() to get a refcount of\npols[0]. This refcount can be dropped in xfrm_expand_policies() when\nxfrm_expand_policies() return error. pols[0]'s refcount is balanced in\nhere. But xfrm_bundle_lookup() will also call xfrm_pols_put() with\nnum_pols == 1 to drop this refcount when xfrm_expand_policies() return\nerror.\n\nThis patch also fix an illegal address access. pols[0] will save a error\npoint when xfrm_policy_lookup fails. This lead to xfrm_pols_put to resolve\nan illegal address in xfrm_bundle_lookup's error path.\n\nFix these by setting num_pols = 0 in xfrm_expand_policies()'s error path.\n\nFixes: 80c802f3073e (\"xfrm: cache bundles instead of policies for outgoing flows\")\nSigned-off-by: Hangyu Hua <hbh25y@gmail.com>\nSigned-off-by: Steffen Klassert <steffen.klassert@secunet.com>", "target": 1, "func": "static int xfrm_expand_policies(const struct flowi *fl, u16 family,\n\t\t\t\tstruct xfrm_policy **pols,\n\t\t\t\tint *num_pols, int *num_xfrms)\n{\n\tint i;\n\n\tif (*num_pols == 0 || !pols[0]) {\n\t\t*num_pols = 0;\n\t\t*num_xfrms = 0;\n\t\treturn 0;\n\t}\n\tif (IS_ERR(pols[0]))\n\t\treturn PTR_ERR(pols[0]);\n\n\t*num_xfrms = pols[0]->xfrm_nr;\n\n#ifdef CONFIG_XFRM_SUB_POLICY\n\tif (pols[0]->action == XFRM_POLICY_ALLOW &&\n\t    pols[0]->type != XFRM_POLICY_TYPE_MAIN) {\n\t\tpols[1] = xfrm_policy_lookup_bytype(xp_net(pols[0]),\n\t\t\t\t\t\t    XFRM_POLICY_TYPE_MAIN,\n\t\t\t\t\t\t    fl, family,\n\t\t\t\t\t\t    XFRM_POLICY_OUT,\n\t\t\t\t\t\t    pols[0]->if_id);\n\t\tif (pols[1]) {\n\t\t\tif (IS_ERR(pols[1])) {\n\t\t\t\txfrm_pols_put(pols, *num_pols);\n\t\t\t\treturn PTR_ERR(pols[1]);\n\t\t\t}\n\t\t\t(*num_pols)++;\n\t\t\t(*num_xfrms) += pols[1]->xfrm_nr;\n\t\t}\n\t}\n#endif\n\tfor (i = 0; i < *num_pols; i++) {\n\t\tif (pols[i]->action != XFRM_POLICY_ALLOW) {\n\t\t\t*num_xfrms = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n\n}", "func_hash": 251684023315514826982518858194996142213, "file_name": "xfrm_policy.c", "file_hash": 240690312801703995044299112379503581676, "cwe": ["CWE-703"], "cve": "CVE-2022-36879", "cve_desc": "An issue was discovered in the Linux kernel through 5.18.14. xfrm_expand_policies in net/xfrm/xfrm_policy.c can cause a refcount to be dropped twice.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-36879", "file_path": "net/xfrm/xfrm_policy.c"}
{"idx": 405333, "project": "linux", "commit_id": "f85daf0e725358be78dfd208dea5fd665d8cb901", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/f85daf0e725358be78dfd208dea5fd665d8cb901", "commit_message": "xfrm: xfrm_policy: fix a possible double xfrm_pols_put() in xfrm_bundle_lookup()\n\nxfrm_policy_lookup() will call xfrm_pol_hold_rcu() to get a refcount of\npols[0]. This refcount can be dropped in xfrm_expand_policies() when\nxfrm_expand_policies() return error. pols[0]'s refcount is balanced in\nhere. But xfrm_bundle_lookup() will also call xfrm_pols_put() with\nnum_pols == 1 to drop this refcount when xfrm_expand_policies() return\nerror.\n\nThis patch also fix an illegal address access. pols[0] will save a error\npoint when xfrm_policy_lookup fails. This lead to xfrm_pols_put to resolve\nan illegal address in xfrm_bundle_lookup's error path.\n\nFix these by setting num_pols = 0 in xfrm_expand_policies()'s error path.\n\nFixes: 80c802f3073e (\"xfrm: cache bundles instead of policies for outgoing flows\")\nSigned-off-by: Hangyu Hua <hbh25y@gmail.com>\nSigned-off-by: Steffen Klassert <steffen.klassert@secunet.com>", "target": 0, "func": "static int xfrm_expand_policies(const struct flowi *fl, u16 family,\n\t\t\t\tstruct xfrm_policy **pols,\n\t\t\t\tint *num_pols, int *num_xfrms)\n{\n\tint i;\n\n\tif (*num_pols == 0 || !pols[0]) {\n\t\t*num_pols = 0;\n\t\t*num_xfrms = 0;\n\t\treturn 0;\n\t}\n\tif (IS_ERR(pols[0])) {\n\t\t*num_pols = 0;\n\t\treturn PTR_ERR(pols[0]);\n\t}\n\n\t*num_xfrms = pols[0]->xfrm_nr;\n\n#ifdef CONFIG_XFRM_SUB_POLICY\n\tif (pols[0]->action == XFRM_POLICY_ALLOW &&\n\t    pols[0]->type != XFRM_POLICY_TYPE_MAIN) {\n\t\tpols[1] = xfrm_policy_lookup_bytype(xp_net(pols[0]),\n\t\t\t\t\t\t    XFRM_POLICY_TYPE_MAIN,\n\t\t\t\t\t\t    fl, family,\n\t\t\t\t\t\t    XFRM_POLICY_OUT,\n\t\t\t\t\t\t    pols[0]->if_id);\n\t\tif (pols[1]) {\n\t\t\tif (IS_ERR(pols[1])) {\n\t\t\t\txfrm_pols_put(pols, *num_pols);\n\t\t\t\t*num_pols = 0;\n\t\t\t\treturn PTR_ERR(pols[1]);\n\t\t\t}\n\t\t\t(*num_pols)++;\n\t\t\t(*num_xfrms) += pols[1]->xfrm_nr;\n\t\t}\n\t}\n#endif\n\tfor (i = 0; i < *num_pols; i++) {\n\t\tif (pols[i]->action != XFRM_POLICY_ALLOW) {\n\t\t\t*num_xfrms = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n\n}", "func_hash": 29732626654088535700777069321150029090, "file_name": "xfrm_policy.c", "file_hash": 264724924246430289692801756816591917107, "cwe": ["CWE-703"], "cve": "CVE-2022-36879", "cve_desc": "An issue was discovered in the Linux kernel through 5.18.14. xfrm_expand_policies in net/xfrm/xfrm_policy.c can cause a refcount to be dropped twice.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-36879", "file_path": "net/xfrm/xfrm_policy.c"}
