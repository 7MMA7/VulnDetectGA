{"idx": 207803, "project": "linux", "commit_id": "f227e3ec3b5cad859ad15666874405e8c1bbc1d4", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/f227e3ec3b5cad859ad15666874405e8c1bbc1d4", "commit_message": "random32: update the net random state on interrupt and activity\n\nThis modifies the first 32 bits out of the 128 bits of a random CPU's\nnet_rand_state on interrupt or CPU activity to complicate remote\nobservations that could lead to guessing the network RNG's internal\nstate.\n\nNote that depending on some network devices' interrupt rate moderation\nor binding, this re-seeding might happen on every packet or even almost\nnever.\n\nIn addition, with NOHZ some CPUs might not even get timer interrupts,\nleaving their local state rarely updated, while they are running\nnetworked processes making use of the random state.  For this reason, we\nalso perform this update in update_process_times() in order to at least\nupdate the state when there is user or system activity, since it's the\nonly case we care about.\n\nReported-by: Amit Klein <aksecurity@gmail.com>\nSuggested-by: Linus Torvalds <torvalds@linux-foundation.org>\nCc: Eric Dumazet <edumazet@google.com>\nCc: \"Jason A. Donenfeld\" <Jason@zx2c4.com>\nCc: Andy Lutomirski <luto@kernel.org>\nCc: Kees Cook <keescook@chromium.org>\nCc: Thomas Gleixner <tglx@linutronix.de>\nCc: Peter Zijlstra <peterz@infradead.org>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Willy Tarreau <w@1wt.eu>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "target": 1, "func": "void add_interrupt_randomness(int irq, int irq_flags)\n{\n\tstruct entropy_store\t*r;\n\tstruct fast_pool\t*fast_pool = this_cpu_ptr(&irq_randomness);\n\tstruct pt_regs\t\t*regs = get_irq_regs();\n\tunsigned long\t\tnow = jiffies;\n\tcycles_t\t\tcycles = random_get_entropy();\n\t__u32\t\t\tc_high, j_high;\n\t__u64\t\t\tip;\n\tunsigned long\t\tseed;\n\tint\t\t\tcredit = 0;\n\n\tif (cycles == 0)\n\t\tcycles = get_reg(fast_pool, regs);\n\tc_high = (sizeof(cycles) > 4) ? cycles >> 32 : 0;\n\tj_high = (sizeof(now) > 4) ? now >> 32 : 0;\n\tfast_pool->pool[0] ^= cycles ^ j_high ^ irq;\n\tfast_pool->pool[1] ^= now ^ c_high;\n\tip = regs ? instruction_pointer(regs) : _RET_IP_;\n\tfast_pool->pool[2] ^= ip;\n\tfast_pool->pool[3] ^= (sizeof(ip) > 4) ? ip >> 32 :\n\t\tget_reg(fast_pool, regs);\n\n\tfast_mix(fast_pool);\n\tadd_interrupt_bench(cycles);\n\n\tif (unlikely(crng_init == 0)) {\n\t\tif ((fast_pool->count >= 64) &&\n\t\t    crng_fast_load((char *) fast_pool->pool,\n\t\t\t\t   sizeof(fast_pool->pool))) {\n\t\t\tfast_pool->count = 0;\n\t\t\tfast_pool->last = now;\n\t\t}\n\t\treturn;\n\t}\n\n\tif ((fast_pool->count < 64) &&\n\t    !time_after(now, fast_pool->last + HZ))\n\t\treturn;\n\n\tr = &input_pool;\n\tif (!spin_trylock(&r->lock))\n\t\treturn;\n\n\tfast_pool->last = now;\n\t__mix_pool_bytes(r, &fast_pool->pool, sizeof(fast_pool->pool));\n\n\t/*\n\t * If we have architectural seed generator, produce a seed and\n\t * add it to the pool.  For the sake of paranoia don't let the\n\t * architectural seed generator dominate the input from the\n\t * interrupt noise.\n\t */\n\tif (arch_get_random_seed_long(&seed)) {\n\t\t__mix_pool_bytes(r, &seed, sizeof(seed));\n\t\tcredit = 1;\n\t}\n\tspin_unlock(&r->lock);\n\n\tfast_pool->count = 0;\n\n\t/* award one bit for the contents of the fast pool */\n\tcredit_entropy_bits(r, credit + 1);\n}", "func_hash": 72986691588442626387015743278968252767, "file_name": "random.c", "file_hash": 239066926887312120799410704296303486044, "cwe": ["CWE-200"], "cve": "CVE-2020-16166", "cve_desc": "The Linux kernel through 5.7.11 allows remote attackers to make observations that help to obtain sensitive information about the internal state of the network RNG, aka CID-f227e3ec3b5c. This is related to drivers/char/random.c and kernel/time/timer.c.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2020-16166", "file_path": "drivers/char/random.c"}
{"idx": 401579, "project": "linux", "commit_id": "f227e3ec3b5cad859ad15666874405e8c1bbc1d4", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/f227e3ec3b5cad859ad15666874405e8c1bbc1d4", "commit_message": "random32: update the net random state on interrupt and activity\n\nThis modifies the first 32 bits out of the 128 bits of a random CPU's\nnet_rand_state on interrupt or CPU activity to complicate remote\nobservations that could lead to guessing the network RNG's internal\nstate.\n\nNote that depending on some network devices' interrupt rate moderation\nor binding, this re-seeding might happen on every packet or even almost\nnever.\n\nIn addition, with NOHZ some CPUs might not even get timer interrupts,\nleaving their local state rarely updated, while they are running\nnetworked processes making use of the random state.  For this reason, we\nalso perform this update in update_process_times() in order to at least\nupdate the state when there is user or system activity, since it's the\nonly case we care about.\n\nReported-by: Amit Klein <aksecurity@gmail.com>\nSuggested-by: Linus Torvalds <torvalds@linux-foundation.org>\nCc: Eric Dumazet <edumazet@google.com>\nCc: \"Jason A. Donenfeld\" <Jason@zx2c4.com>\nCc: Andy Lutomirski <luto@kernel.org>\nCc: Kees Cook <keescook@chromium.org>\nCc: Thomas Gleixner <tglx@linutronix.de>\nCc: Peter Zijlstra <peterz@infradead.org>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Willy Tarreau <w@1wt.eu>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "target": 0, "func": "void add_interrupt_randomness(int irq, int irq_flags)\n{\n\tstruct entropy_store\t*r;\n\tstruct fast_pool\t*fast_pool = this_cpu_ptr(&irq_randomness);\n\tstruct pt_regs\t\t*regs = get_irq_regs();\n\tunsigned long\t\tnow = jiffies;\n\tcycles_t\t\tcycles = random_get_entropy();\n\t__u32\t\t\tc_high, j_high;\n\t__u64\t\t\tip;\n\tunsigned long\t\tseed;\n\tint\t\t\tcredit = 0;\n\n\tif (cycles == 0)\n\t\tcycles = get_reg(fast_pool, regs);\n\tc_high = (sizeof(cycles) > 4) ? cycles >> 32 : 0;\n\tj_high = (sizeof(now) > 4) ? now >> 32 : 0;\n\tfast_pool->pool[0] ^= cycles ^ j_high ^ irq;\n\tfast_pool->pool[1] ^= now ^ c_high;\n\tip = regs ? instruction_pointer(regs) : _RET_IP_;\n\tfast_pool->pool[2] ^= ip;\n\tfast_pool->pool[3] ^= (sizeof(ip) > 4) ? ip >> 32 :\n\t\tget_reg(fast_pool, regs);\n\n\tfast_mix(fast_pool);\n\tadd_interrupt_bench(cycles);\n\tthis_cpu_add(net_rand_state.s1, fast_pool->pool[cycles & 3]);\n\n\tif (unlikely(crng_init == 0)) {\n\t\tif ((fast_pool->count >= 64) &&\n\t\t    crng_fast_load((char *) fast_pool->pool,\n\t\t\t\t   sizeof(fast_pool->pool))) {\n\t\t\tfast_pool->count = 0;\n\t\t\tfast_pool->last = now;\n\t\t}\n\t\treturn;\n\t}\n\n\tif ((fast_pool->count < 64) &&\n\t    !time_after(now, fast_pool->last + HZ))\n\t\treturn;\n\n\tr = &input_pool;\n\tif (!spin_trylock(&r->lock))\n\t\treturn;\n\n\tfast_pool->last = now;\n\t__mix_pool_bytes(r, &fast_pool->pool, sizeof(fast_pool->pool));\n\n\t/*\n\t * If we have architectural seed generator, produce a seed and\n\t * add it to the pool.  For the sake of paranoia don't let the\n\t * architectural seed generator dominate the input from the\n\t * interrupt noise.\n\t */\n\tif (arch_get_random_seed_long(&seed)) {\n\t\t__mix_pool_bytes(r, &seed, sizeof(seed));\n\t\tcredit = 1;\n\t}\n\tspin_unlock(&r->lock);\n\n\tfast_pool->count = 0;\n\n\t/* award one bit for the contents of the fast pool */\n\tcredit_entropy_bits(r, credit + 1);\n}", "func_hash": 84995966578306698565240139293878155372, "file_name": "random.c", "file_hash": 208560159054698027072406931437153087485, "cwe": ["CWE-200"], "cve": "CVE-2020-16166", "cve_desc": "The Linux kernel through 5.7.11 allows remote attackers to make observations that help to obtain sensitive information about the internal state of the network RNG, aka CID-f227e3ec3b5c. This is related to drivers/char/random.c and kernel/time/timer.c.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2020-16166", "file_path": "drivers/char/random.c"}
