{"idx": 206942, "project": "vim", "commit_id": "1e56bda9048a9625bce6e660938c834c5c15b07d", "project_url": "https://github.com/vim/vim", "commit_url": "https://github.com/vim/vim/commit/1e56bda9048a9625bce6e660938c834c5c15b07d", "commit_message": "patch 9.0.0104: going beyond allocated memory when evaluating string constant\n\nProblem:    Going beyond allocated memory when evaluating string constant.\nSolution:   Properly skip over <Key> form.", "target": 1, "func": "eval_string(char_u **arg, typval_T *rettv, int evaluate, int interpolate)\n{\n    char_u\t*p;\n    char_u\t*end;\n    int\t\textra = interpolate ? 1 : 0;\n    int\t\toff = interpolate ? 0 : 1;\n    int\t\tlen;\n\n    // Find the end of the string, skipping backslashed characters.\n    for (p = *arg + off; *p != NUL && *p != '\"'; MB_PTR_ADV(p))\n    {\n\tif (*p == '\\\\' && p[1] != NUL)\n\t{\n\t    ++p;\n\t    // A \"\\<x>\" form occupies at least 4 characters, and produces up\n\t    // to 9 characters (6 for the char and 3 for a modifier):\n\t    // reserve space for 5 extra.\n\t    if (*p == '<')\n\t\textra += 5;\n\t}\n\telse if (interpolate && (*p == '{' || *p == '}'))\n\t{\n\t    if (*p == '{' && p[1] != '{') // start of expression\n\t\tbreak;\n\t    ++p;\n\t    if (p[-1] == '}' && *p != '}') // single '}' is an error\n\t    {\n\t\tsemsg(_(e_stray_closing_curly_str), *arg);\n\t\treturn FAIL;\n\t    }\n\t    --extra;  // \"{{\" becomes \"{\", \"}}\" becomes \"}\"\n\t}\n    }\n\n    if (*p != '\"' && !(interpolate && *p == '{'))\n    {\n\tsemsg(_(e_missing_double_quote_str), *arg);\n\treturn FAIL;\n    }\n\n    // If only parsing, set *arg and return here\n    if (!evaluate)\n    {\n\t*arg = p + off;\n\treturn OK;\n    }\n\n    // Copy the string into allocated memory, handling backslashed\n    // characters.\n    rettv->v_type = VAR_STRING;\n    len = (int)(p - *arg + extra);\n    rettv->vval.v_string = alloc(len);\n    if (rettv->vval.v_string == NULL)\n\treturn FAIL;\n    end = rettv->vval.v_string;\n\n    for (p = *arg + off; *p != NUL && *p != '\"'; )\n    {\n\tif (*p == '\\\\')\n\t{\n\t    switch (*++p)\n\t    {\n\t\tcase 'b': *end++ = BS; ++p; break;\n\t\tcase 'e': *end++ = ESC; ++p; break;\n\t\tcase 'f': *end++ = FF; ++p; break;\n\t\tcase 'n': *end++ = NL; ++p; break;\n\t\tcase 'r': *end++ = CAR; ++p; break;\n\t\tcase 't': *end++ = TAB; ++p; break;\n\n\t\tcase 'X': // hex: \"\\x1\", \"\\x12\"\n\t\tcase 'x':\n\t\tcase 'u': // Unicode: \"\\u0023\"\n\t\tcase 'U':\n\t\t\t  if (vim_isxdigit(p[1]))\n\t\t\t  {\n\t\t\t      int\tn, nr;\n\t\t\t      int\tc = toupper(*p);\n\n\t\t\t      if (c == 'X')\n\t\t\t\t  n = 2;\n\t\t\t      else if (*p == 'u')\n\t\t\t\t  n = 4;\n\t\t\t      else\n\t\t\t\t  n = 8;\n\t\t\t      nr = 0;\n\t\t\t      while (--n >= 0 && vim_isxdigit(p[1]))\n\t\t\t      {\n\t\t\t\t  ++p;\n\t\t\t\t  nr = (nr << 4) + hex2nr(*p);\n\t\t\t      }\n\t\t\t      ++p;\n\t\t\t      // For \"\\u\" store the number according to\n\t\t\t      // 'encoding'.\n\t\t\t      if (c != 'X')\n\t\t\t\t  end += (*mb_char2bytes)(nr, end);\n\t\t\t      else\n\t\t\t\t  *end++ = nr;\n\t\t\t  }\n\t\t\t  break;\n\n\t\t\t  // octal: \"\\1\", \"\\12\", \"\\123\"\n\t\tcase '0':\n\t\tcase '1':\n\t\tcase '2':\n\t\tcase '3':\n\t\tcase '4':\n\t\tcase '5':\n\t\tcase '6':\n\t\tcase '7': *end = *p++ - '0';\n\t\t\t  if (*p >= '0' && *p <= '7')\n\t\t\t  {\n\t\t\t      *end = (*end << 3) + *p++ - '0';\n\t\t\t      if (*p >= '0' && *p <= '7')\n\t\t\t\t  *end = (*end << 3) + *p++ - '0';\n\t\t\t  }\n\t\t\t  ++end;\n\t\t\t  break;\n\n\t\t\t  // Special key, e.g.: \"\\<C-W>\"\n\t\tcase '<':\n\t\t\t  {\n\t\t\t      int flags = FSK_KEYCODE | FSK_IN_STRING;\n\n\t\t\t      if (p[1] != '*')\n\t\t\t\t  flags |= FSK_SIMPLIFY;\n\t\t\t      extra = trans_special(&p, end, flags, FALSE, NULL);\n\t\t\t      if (extra != 0)\n\t\t\t      {\n\t\t\t\t  end += extra;\n\t\t\t\t  if (end >= rettv->vval.v_string + len)\n\t\t\t\t      iemsg(\"eval_string() used more space than allocated\");\n\t\t\t\t  break;\n\t\t\t      }\n\t\t\t  }\n\t\t\t  // FALLTHROUGH\n\n\t\tdefault: MB_COPY_CHAR(p, end);\n\t\t\t  break;\n\t    }\n\t}\n\telse\n\t{\n\t    if (interpolate && (*p == '{' || *p == '}'))\n\t    {\n\t\tif (*p == '{' && p[1] != '{') // start of expression\n\t\t    break;\n\t\t++p;  // reduce \"{{\" to \"{\" and \"}}\" to \"}\"\n\t    }\n\t    MB_COPY_CHAR(p, end);\n\t}\n    }\n    *end = NUL;\n    if (*p == '\"' && !interpolate)\n\t++p;\n    *arg = p;\n\n    return OK;\n}", "func_hash": 338220226163490913152834959718974208239, "file_name": "typval.c", "file_hash": 328531951922388475683903891036611129511, "cwe": ["CWE-125"], "cve": "CVE-2022-2580", "cve_desc": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0102.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-2580", "file_path": "src/typval.c"}
{"idx": 389676, "project": "vim", "commit_id": "1e56bda9048a9625bce6e660938c834c5c15b07d", "project_url": "https://github.com/vim/vim", "commit_url": "https://github.com/vim/vim/commit/1e56bda9048a9625bce6e660938c834c5c15b07d", "commit_message": "patch 9.0.0104: going beyond allocated memory when evaluating string constant\n\nProblem:    Going beyond allocated memory when evaluating string constant.\nSolution:   Properly skip over <Key> form.", "target": 0, "func": "eval_string(char_u **arg, typval_T *rettv, int evaluate, int interpolate)\n{\n    char_u\t*p;\n    char_u\t*end;\n    int\t\textra = interpolate ? 1 : 0;\n    int\t\toff = interpolate ? 0 : 1;\n    int\t\tlen;\n\n    // Find the end of the string, skipping backslashed characters.\n    for (p = *arg + off; *p != NUL && *p != '\"'; MB_PTR_ADV(p))\n    {\n\tif (*p == '\\\\' && p[1] != NUL)\n\t{\n\t    ++p;\n\t    // A \"\\<x>\" form occupies at least 4 characters, and produces up\n\t    // to 9 characters (6 for the char and 3 for a modifier):\n\t    // reserve space for 5 extra.\n\t    if (*p == '<')\n\t    {\n\t\tint\t\tmodifiers = 0;\n\t\tint\t\tflags = FSK_KEYCODE | FSK_IN_STRING;\n\n\t\textra += 5;\n\n\t\t// Skip to the '>' to avoid using '{' inside for string\n\t\t// interpolation.\n\t\tif (p[1] != '*')\n\t\t    flags |= FSK_SIMPLIFY;\n\t\tif (find_special_key(&p, &modifiers, flags, NULL) != 0)\n\t\t    --p;  // leave \"p\" on the \">\"\n\t    }\n\t}\n\telse if (interpolate && (*p == '{' || *p == '}'))\n\t{\n\t    if (*p == '{' && p[1] != '{') // start of expression\n\t\tbreak;\n\t    ++p;\n\t    if (p[-1] == '}' && *p != '}') // single '}' is an error\n\t    {\n\t\tsemsg(_(e_stray_closing_curly_str), *arg);\n\t\treturn FAIL;\n\t    }\n\t    --extra;  // \"{{\" becomes \"{\", \"}}\" becomes \"}\"\n\t}\n    }\n\n    if (*p != '\"' && !(interpolate && *p == '{'))\n    {\n\tsemsg(_(e_missing_double_quote_str), *arg);\n\treturn FAIL;\n    }\n\n    // If only parsing, set *arg and return here\n    if (!evaluate)\n    {\n\t*arg = p + off;\n\treturn OK;\n    }\n\n    // Copy the string into allocated memory, handling backslashed\n    // characters.\n    rettv->v_type = VAR_STRING;\n    len = (int)(p - *arg + extra);\n    rettv->vval.v_string = alloc(len);\n    if (rettv->vval.v_string == NULL)\n\treturn FAIL;\n    end = rettv->vval.v_string;\n\n    for (p = *arg + off; *p != NUL && *p != '\"'; )\n    {\n\tif (*p == '\\\\')\n\t{\n\t    switch (*++p)\n\t    {\n\t\tcase 'b': *end++ = BS; ++p; break;\n\t\tcase 'e': *end++ = ESC; ++p; break;\n\t\tcase 'f': *end++ = FF; ++p; break;\n\t\tcase 'n': *end++ = NL; ++p; break;\n\t\tcase 'r': *end++ = CAR; ++p; break;\n\t\tcase 't': *end++ = TAB; ++p; break;\n\n\t\tcase 'X': // hex: \"\\x1\", \"\\x12\"\n\t\tcase 'x':\n\t\tcase 'u': // Unicode: \"\\u0023\"\n\t\tcase 'U':\n\t\t\t  if (vim_isxdigit(p[1]))\n\t\t\t  {\n\t\t\t      int\tn, nr;\n\t\t\t      int\tc = toupper(*p);\n\n\t\t\t      if (c == 'X')\n\t\t\t\t  n = 2;\n\t\t\t      else if (*p == 'u')\n\t\t\t\t  n = 4;\n\t\t\t      else\n\t\t\t\t  n = 8;\n\t\t\t      nr = 0;\n\t\t\t      while (--n >= 0 && vim_isxdigit(p[1]))\n\t\t\t      {\n\t\t\t\t  ++p;\n\t\t\t\t  nr = (nr << 4) + hex2nr(*p);\n\t\t\t      }\n\t\t\t      ++p;\n\t\t\t      // For \"\\u\" store the number according to\n\t\t\t      // 'encoding'.\n\t\t\t      if (c != 'X')\n\t\t\t\t  end += (*mb_char2bytes)(nr, end);\n\t\t\t      else\n\t\t\t\t  *end++ = nr;\n\t\t\t  }\n\t\t\t  break;\n\n\t\t\t  // octal: \"\\1\", \"\\12\", \"\\123\"\n\t\tcase '0':\n\t\tcase '1':\n\t\tcase '2':\n\t\tcase '3':\n\t\tcase '4':\n\t\tcase '5':\n\t\tcase '6':\n\t\tcase '7': *end = *p++ - '0';\n\t\t\t  if (*p >= '0' && *p <= '7')\n\t\t\t  {\n\t\t\t      *end = (*end << 3) + *p++ - '0';\n\t\t\t      if (*p >= '0' && *p <= '7')\n\t\t\t\t  *end = (*end << 3) + *p++ - '0';\n\t\t\t  }\n\t\t\t  ++end;\n\t\t\t  break;\n\n\t\t\t  // Special key, e.g.: \"\\<C-W>\"\n\t\tcase '<':\n\t\t\t  {\n\t\t\t      int flags = FSK_KEYCODE | FSK_IN_STRING;\n\n\t\t\t      if (p[1] != '*')\n\t\t\t\t  flags |= FSK_SIMPLIFY;\n\t\t\t      extra = trans_special(&p, end, flags, FALSE, NULL);\n\t\t\t      if (extra != 0)\n\t\t\t      {\n\t\t\t\t  end += extra;\n\t\t\t\t  if (end >= rettv->vval.v_string + len)\n\t\t\t\t      iemsg(\"eval_string() used more space than allocated\");\n\t\t\t\t  break;\n\t\t\t      }\n\t\t\t  }\n\t\t\t  // FALLTHROUGH\n\n\t\tdefault: MB_COPY_CHAR(p, end);\n\t\t\t  break;\n\t    }\n\t}\n\telse\n\t{\n\t    if (interpolate && (*p == '{' || *p == '}'))\n\t    {\n\t\tif (*p == '{' && p[1] != '{') // start of expression\n\t\t    break;\n\t\t++p;  // reduce \"{{\" to \"{\" and \"}}\" to \"}\"\n\t    }\n\t    MB_COPY_CHAR(p, end);\n\t}\n    }\n    *end = NUL;\n    if (*p == '\"' && !interpolate)\n\t++p;\n    *arg = p;\n\n    return OK;\n}", "func_hash": 300144927032379821054071112406007573706, "file_name": "typval.c", "file_hash": 264686639878036499427248365468285871356, "cwe": ["CWE-125"], "cve": "CVE-2022-2580", "cve_desc": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0102.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-2580", "file_path": "src/typval.c"}
{"idx": 206946, "project": "jasper", "commit_id": "d99636fad60629785efd1ef72da772a8ef68f54c", "project_url": "https://github.com/mdadams/jasper", "commit_url": "https://github.com/jasper-software/jasper/commit/d99636fad60629785efd1ef72da772a8ef68f54c", "commit_message": "fix memory leaks in function cmdopts_parse", "target": 1, "func": "cmdopts_t *cmdopts_parse(int argc, char **argv)\n{\n\tenum {\n\t\tCMDOPT_HELP = 0,\n\t\tCMDOPT_VERBOSE,\n\t\tCMDOPT_QUIET,\n\t\tCMDOPT_INFILE,\n\t\tCMDOPT_INFMT,\n\t\tCMDOPT_INOPT,\n\t\tCMDOPT_OUTFILE,\n\t\tCMDOPT_OUTFMT,\n\t\tCMDOPT_OUTOPT,\n\t\tCMDOPT_VERSION,\n\t\tCMDOPT_DEBUG,\n\t\tCMDOPT_CMPTNO,\n\t\tCMDOPT_SRGB,\n\t\tCMDOPT_MAXMEM,\n\t\tCMDOPT_LIST_ENABLED_CODECS,\n\t\tCMDOPT_LIST_ALL_CODECS,\n\t\tCMDOPT_ENABLE_FORMAT,\n\t\tCMDOPT_ENABLE_ALL_FORMATS,\n\t};\n\n\tstatic const jas_opt_t cmdoptions[] = {\n\t\t{CMDOPT_HELP, \"help\", 0},\n\t\t{CMDOPT_VERBOSE, \"verbose\", 0},\n\t\t{CMDOPT_QUIET, \"quiet\", 0},\n\t\t{CMDOPT_QUIET, \"q\", 0},\n\t\t{CMDOPT_INFILE, \"input\", JAS_OPT_HASARG},\n\t\t{CMDOPT_INFILE, \"f\", JAS_OPT_HASARG},\n\t\t{CMDOPT_INFMT, \"input-format\", JAS_OPT_HASARG},\n\t\t{CMDOPT_INFMT, \"t\", JAS_OPT_HASARG},\n\t\t{CMDOPT_INOPT, \"input-option\", JAS_OPT_HASARG},\n\t\t{CMDOPT_INOPT, \"o\", JAS_OPT_HASARG},\n\t\t{CMDOPT_OUTFILE, \"output\", JAS_OPT_HASARG},\n\t\t{CMDOPT_OUTFILE, \"F\", JAS_OPT_HASARG},\n\t\t{CMDOPT_OUTFMT, \"output-format\", JAS_OPT_HASARG},\n\t\t{CMDOPT_OUTFMT, \"T\", JAS_OPT_HASARG},\n\t\t{CMDOPT_OUTOPT, \"output-option\", JAS_OPT_HASARG},\n\t\t{CMDOPT_OUTOPT, \"O\", JAS_OPT_HASARG},\n\t\t{CMDOPT_VERSION, \"version\", 0},\n\t\t{CMDOPT_DEBUG, \"debug-level\", JAS_OPT_HASARG},\n\t\t{CMDOPT_CMPTNO, \"cmptno\", JAS_OPT_HASARG},\n\t\t{CMDOPT_SRGB, \"force-srgb\", 0},\n\t\t{CMDOPT_SRGB, \"S\", 0},\n\t\t{CMDOPT_MAXMEM, \"memory-limit\", JAS_OPT_HASARG},\n\t\t{CMDOPT_LIST_ENABLED_CODECS, \"list-enabled-formats\", 0},\n\t\t{CMDOPT_LIST_ALL_CODECS, \"list-all-formats\", 0},\n\t\t{CMDOPT_ENABLE_FORMAT, \"enable-format\", JAS_OPT_HASARG},\n\t\t{CMDOPT_ENABLE_ALL_FORMATS, \"enable-all-formats\", 0},\n\t\t{-1, 0, 0}\n\t};\n\n\tcmdopts_t *cmdopts;\n\tint c;\n\n\tif (!(cmdopts = malloc(sizeof(cmdopts_t)))) {\n\t\tfprintf(stderr, \"error: insufficient memory\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tcmdopts->infile = 0;\n\tcmdopts->infmt = -1;\n\tcmdopts->infmt_str = 0;\n\tcmdopts->inopts = 0;\n\tcmdopts->inoptsbuf[0] = '\\0';\n\tcmdopts->outfile = 0;\n\tcmdopts->outfmt = -1;\n\tcmdopts->outfmt_str = 0;\n\tcmdopts->outopts = 0;\n\tcmdopts->outoptsbuf[0] = '\\0';\n\tcmdopts->verbose = 0;\n\tcmdopts->version = 0;\n\tcmdopts->cmptno = -1;\n\tcmdopts->debug = 0;\n\tcmdopts->srgb = 0;\n\tcmdopts->list_codecs = 0;\n\tcmdopts->list_codecs_all = 0;\n\tcmdopts->help = 0;\n\tcmdopts->max_mem = get_default_max_mem_usage();\n\tcmdopts->enable_format = 0;\n\tcmdopts->enable_all_formats = 0;\n\n\twhile ((c = jas_getopt(argc, argv, cmdoptions)) != EOF) {\n\t\tswitch (c) {\n\t\tcase CMDOPT_HELP:\n\t\t\tcmdopts->help = 1;\n\t\t\tbreak;\n\t\tcase CMDOPT_VERBOSE:\n\t\t\tcmdopts->verbose = 1;\n\t\t\tbreak;\n\t\tcase CMDOPT_QUIET:\n\t\t\tcmdopts->verbose = -1;\n\t\t\tbreak;\n\t\tcase CMDOPT_VERSION:\n\t\t\tcmdopts->version = 1;\n\t\t\tbreak;\n\t\tcase CMDOPT_LIST_ENABLED_CODECS:\n\t\t\tcmdopts->list_codecs = 1;\n\t\t\tcmdopts->list_codecs_all = 0;\n\t\t\tbreak;\n\t\tcase CMDOPT_LIST_ALL_CODECS:\n\t\t\tcmdopts->list_codecs = 1;\n\t\t\tcmdopts->list_codecs_all = 1;\n\t\t\tbreak;\n\t\tcase CMDOPT_DEBUG:\n\t\t\tcmdopts->debug = atoi(jas_optarg);\n\t\t\tbreak;\n\t\tcase CMDOPT_INFILE:\n\t\t\tcmdopts->infile = jas_optarg;\n\t\t\tbreak;\n\t\tcase CMDOPT_INFMT:\n\t\t\tcmdopts->infmt_str= jas_optarg;\n\t\t\tbreak;\n\t\tcase CMDOPT_INOPT:\n\t\t\taddopt(cmdopts->inoptsbuf, OPTSMAX, jas_optarg);\n\t\t\tcmdopts->inopts = cmdopts->inoptsbuf;\n\t\t\tbreak;\n\t\tcase CMDOPT_OUTFILE:\n\t\t\tcmdopts->outfile = jas_optarg;\n\t\t\tbreak;\n\t\tcase CMDOPT_OUTFMT:\n\t\t\tcmdopts->outfmt_str = jas_optarg;\n\t\t\tbreak;\n\t\tcase CMDOPT_OUTOPT:\n\t\t\taddopt(cmdopts->outoptsbuf, OPTSMAX, jas_optarg);\n\t\t\tcmdopts->outopts = cmdopts->outoptsbuf;\n\t\t\tbreak;\n\t\tcase CMDOPT_CMPTNO:\n\t\t\tcmdopts->cmptno = atoi(jas_optarg);\n\t\t\tbreak;\n\t\tcase CMDOPT_SRGB:\n\t\t\tcmdopts->srgb = 1;\n\t\t\tbreak;\n\t\tcase CMDOPT_MAXMEM:\n\t\t\tcmdopts->max_mem = strtoull(jas_optarg, 0, 10);\n\t\t\tbreak;\n\t\tcase CMDOPT_ENABLE_FORMAT:\n\t\t\tcmdopts->enable_format = jas_optarg;\n\t\t\tbreak;\n\t\tcase CMDOPT_ENABLE_ALL_FORMATS:\n\t\t\tcmdopts->enable_all_formats = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbadusage();\n\t\t\tbreak;\n\t\t}\n\t}\n\n\twhile (jas_optind < argc) {\n\t\tfprintf(stderr,\n\t\t  \"warning: ignoring bogus command line argument %s\\n\",\n\t\t  argv[jas_optind]);\n\t\t++jas_optind;\n\t}\n\n\tif (cmdopts->version || cmdopts->list_codecs || cmdopts->help) {\n\t\tgoto done;\n\t}\n\n\tif (!cmdopts->outfmt_str && !cmdopts->outfile) {\n\t\tfprintf(stderr, \"error: cannot determine output format\\n\");\n\t\tbadusage();\n\t}\n\ndone:\n\treturn cmdopts;\n}", "func_hash": 93181291511681804073691200897709901657, "file_name": "jasper.c", "file_hash": 221565924886298462326836957771233686713, "cwe": ["CWE-703"], "cve": "CVE-2022-2963", "cve_desc": "A vulnerability found in jasper. This security vulnerability happens because of a memory leak bug in function cmdopts_parse that can cause a crash or segmentation fault.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-2963", "file_path": "src/app/jasper.c"}
{"idx": 389760, "project": "jasper", "commit_id": "d99636fad60629785efd1ef72da772a8ef68f54c", "project_url": "https://github.com/mdadams/jasper", "commit_url": "https://github.com/jasper-software/jasper/commit/d99636fad60629785efd1ef72da772a8ef68f54c", "commit_message": "fix memory leaks in function cmdopts_parse", "target": 0, "func": "cmdopts_t *cmdopts_parse(int argc, char **argv)\n{\n\tenum {\n\t\tCMDOPT_HELP = 0,\n\t\tCMDOPT_VERBOSE,\n\t\tCMDOPT_QUIET,\n\t\tCMDOPT_INFILE,\n\t\tCMDOPT_INFMT,\n\t\tCMDOPT_INOPT,\n\t\tCMDOPT_OUTFILE,\n\t\tCMDOPT_OUTFMT,\n\t\tCMDOPT_OUTOPT,\n\t\tCMDOPT_VERSION,\n\t\tCMDOPT_DEBUG,\n\t\tCMDOPT_CMPTNO,\n\t\tCMDOPT_SRGB,\n\t\tCMDOPT_MAXMEM,\n\t\tCMDOPT_LIST_ENABLED_CODECS,\n\t\tCMDOPT_LIST_ALL_CODECS,\n\t\tCMDOPT_ENABLE_FORMAT,\n\t\tCMDOPT_ENABLE_ALL_FORMATS,\n\t};\n\n\tstatic const jas_opt_t cmdoptions[] = {\n\t\t{CMDOPT_HELP, \"help\", 0},\n\t\t{CMDOPT_VERBOSE, \"verbose\", 0},\n\t\t{CMDOPT_QUIET, \"quiet\", 0},\n\t\t{CMDOPT_QUIET, \"q\", 0},\n\t\t{CMDOPT_INFILE, \"input\", JAS_OPT_HASARG},\n\t\t{CMDOPT_INFILE, \"f\", JAS_OPT_HASARG},\n\t\t{CMDOPT_INFMT, \"input-format\", JAS_OPT_HASARG},\n\t\t{CMDOPT_INFMT, \"t\", JAS_OPT_HASARG},\n\t\t{CMDOPT_INOPT, \"input-option\", JAS_OPT_HASARG},\n\t\t{CMDOPT_INOPT, \"o\", JAS_OPT_HASARG},\n\t\t{CMDOPT_OUTFILE, \"output\", JAS_OPT_HASARG},\n\t\t{CMDOPT_OUTFILE, \"F\", JAS_OPT_HASARG},\n\t\t{CMDOPT_OUTFMT, \"output-format\", JAS_OPT_HASARG},\n\t\t{CMDOPT_OUTFMT, \"T\", JAS_OPT_HASARG},\n\t\t{CMDOPT_OUTOPT, \"output-option\", JAS_OPT_HASARG},\n\t\t{CMDOPT_OUTOPT, \"O\", JAS_OPT_HASARG},\n\t\t{CMDOPT_VERSION, \"version\", 0},\n\t\t{CMDOPT_DEBUG, \"debug-level\", JAS_OPT_HASARG},\n\t\t{CMDOPT_CMPTNO, \"cmptno\", JAS_OPT_HASARG},\n\t\t{CMDOPT_SRGB, \"force-srgb\", 0},\n\t\t{CMDOPT_SRGB, \"S\", 0},\n\t\t{CMDOPT_MAXMEM, \"memory-limit\", JAS_OPT_HASARG},\n\t\t{CMDOPT_LIST_ENABLED_CODECS, \"list-enabled-formats\", 0},\n\t\t{CMDOPT_LIST_ALL_CODECS, \"list-all-formats\", 0},\n\t\t{CMDOPT_ENABLE_FORMAT, \"enable-format\", JAS_OPT_HASARG},\n\t\t{CMDOPT_ENABLE_ALL_FORMATS, \"enable-all-formats\", 0},\n\t\t{-1, 0, 0}\n\t};\n\n\tcmdopts_t *cmdopts;\n\tint c;\n\n\tif (!(cmdopts = malloc(sizeof(cmdopts_t)))) {\n\t\tfprintf(stderr, \"error: insufficient memory\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tcmdopts->infile = 0;\n\tcmdopts->infmt = -1;\n\tcmdopts->infmt_str = 0;\n\tcmdopts->inopts = 0;\n\tcmdopts->inoptsbuf[0] = '\\0';\n\tcmdopts->outfile = 0;\n\tcmdopts->outfmt = -1;\n\tcmdopts->outfmt_str = 0;\n\tcmdopts->outopts = 0;\n\tcmdopts->outoptsbuf[0] = '\\0';\n\tcmdopts->verbose = 0;\n\tcmdopts->version = 0;\n\tcmdopts->cmptno = -1;\n\tcmdopts->debug = 0;\n\tcmdopts->srgb = 0;\n\tcmdopts->list_codecs = 0;\n\tcmdopts->list_codecs_all = 0;\n\tcmdopts->help = 0;\n\tcmdopts->max_mem = get_default_max_mem_usage();\n\tcmdopts->enable_format = 0;\n\tcmdopts->enable_all_formats = 0;\n\n\twhile ((c = jas_getopt(argc, argv, cmdoptions)) != EOF) {\n\t\tswitch (c) {\n\t\tcase CMDOPT_HELP:\n\t\t\tcmdopts->help = 1;\n\t\t\tbreak;\n\t\tcase CMDOPT_VERBOSE:\n\t\t\tcmdopts->verbose = 1;\n\t\t\tbreak;\n\t\tcase CMDOPT_QUIET:\n\t\t\tcmdopts->verbose = -1;\n\t\t\tbreak;\n\t\tcase CMDOPT_VERSION:\n\t\t\tcmdopts->version = 1;\n\t\t\tbreak;\n\t\tcase CMDOPT_LIST_ENABLED_CODECS:\n\t\t\tcmdopts->list_codecs = 1;\n\t\t\tcmdopts->list_codecs_all = 0;\n\t\t\tbreak;\n\t\tcase CMDOPT_LIST_ALL_CODECS:\n\t\t\tcmdopts->list_codecs = 1;\n\t\t\tcmdopts->list_codecs_all = 1;\n\t\t\tbreak;\n\t\tcase CMDOPT_DEBUG:\n\t\t\tcmdopts->debug = atoi(jas_optarg);\n\t\t\tbreak;\n\t\tcase CMDOPT_INFILE:\n\t\t\tcmdopts->infile = jas_optarg;\n\t\t\tbreak;\n\t\tcase CMDOPT_INFMT:\n\t\t\tcmdopts->infmt_str= jas_optarg;\n\t\t\tbreak;\n\t\tcase CMDOPT_INOPT:\n\t\t\taddopt(cmdopts->inoptsbuf, OPTSMAX, jas_optarg);\n\t\t\tcmdopts->inopts = cmdopts->inoptsbuf;\n\t\t\tbreak;\n\t\tcase CMDOPT_OUTFILE:\n\t\t\tcmdopts->outfile = jas_optarg;\n\t\t\tbreak;\n\t\tcase CMDOPT_OUTFMT:\n\t\t\tcmdopts->outfmt_str = jas_optarg;\n\t\t\tbreak;\n\t\tcase CMDOPT_OUTOPT:\n\t\t\taddopt(cmdopts->outoptsbuf, OPTSMAX, jas_optarg);\n\t\t\tcmdopts->outopts = cmdopts->outoptsbuf;\n\t\t\tbreak;\n\t\tcase CMDOPT_CMPTNO:\n\t\t\tcmdopts->cmptno = atoi(jas_optarg);\n\t\t\tbreak;\n\t\tcase CMDOPT_SRGB:\n\t\t\tcmdopts->srgb = 1;\n\t\t\tbreak;\n\t\tcase CMDOPT_MAXMEM:\n\t\t\tcmdopts->max_mem = strtoull(jas_optarg, 0, 10);\n\t\t\tbreak;\n\t\tcase CMDOPT_ENABLE_FORMAT:\n\t\t\tcmdopts->enable_format = jas_optarg;\n\t\t\tbreak;\n\t\tcase CMDOPT_ENABLE_ALL_FORMATS:\n\t\t\tcmdopts->enable_all_formats = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcmdopts_destroy(cmdopts);\n\t\t\tbadusage();\n\t\t\tbreak;\n\t\t}\n\t}\n\n\twhile (jas_optind < argc) {\n\t\tfprintf(stderr,\n\t\t  \"warning: ignoring bogus command line argument %s\\n\",\n\t\t  argv[jas_optind]);\n\t\t++jas_optind;\n\t}\n\n\tif (cmdopts->version || cmdopts->list_codecs || cmdopts->help) {\n\t\tgoto done;\n\t}\n\n\tif (!cmdopts->outfmt_str && !cmdopts->outfile) {\n\t\tfprintf(stderr, \"error: cannot determine output format\\n\");\n\t\tcmdopts_destroy(cmdopts);\n\t\tbadusage();\n\t}\n\ndone:\n\treturn cmdopts;\n}", "func_hash": 102932853856682606703676466444383538610, "file_name": "jasper.c", "file_hash": 43318189901043805005058339060588403940, "cwe": ["CWE-703"], "cve": "CVE-2022-2963", "cve_desc": "A vulnerability found in jasper. This security vulnerability happens because of a memory leak bug in function cmdopts_parse that can cause a crash or segmentation fault.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-2963", "file_path": "src/app/jasper.c"}
