{"idx": 206417, "project": "vim", "commit_id": "0971c7a4e537ea120a6bb2195960be8d0815e97b", "project_url": "https://github.com/vim/vim", "commit_url": "https://github.com/vim/vim/commit/0971c7a4e537ea120a6bb2195960be8d0815e97b", "commit_message": "patch 8.2.5162: reading before the start of the line with BS in Replace mode\n\nProblem:    Reading before the start of the line with BS in Replace mode.\nSolution:   Check the cursor column is more than zero.", "target": 1, "func": "ins_bs(\n    int\t\tc,\n    int\t\tmode,\n    int\t\t*inserted_space_p)\n{\n    linenr_T\tlnum;\n    int\t\tcc;\n    int\t\ttemp = 0;\t    // init for GCC\n    colnr_T\tsave_col;\n    colnr_T\tmincol;\n    int\t\tdid_backspace = FALSE;\n    int\t\tin_indent;\n    int\t\toldState;\n    int\t\tcpc[MAX_MCO];\t    // composing characters\n    int\t\tcall_fix_indent = FALSE;\n\n    /*\n     * can't delete anything in an empty file\n     * can't backup past first character in buffer\n     * can't backup past starting point unless 'backspace' > 1\n     * can backup to a previous line if 'backspace' == 0\n     */\n    if (       BUFEMPTY()\n\t    || (\n#ifdef FEAT_RIGHTLEFT\n\t\t!revins_on &&\n#endif\n\t\t((curwin->w_cursor.lnum == 1 && curwin->w_cursor.col == 0)\n\t\t    || (!can_bs(BS_START)\n\t\t\t&& ((arrow_used\n#ifdef FEAT_JOB_CHANNEL\n\t\t\t\t&& !bt_prompt(curbuf)\n#endif\n\t\t\t) || (curwin->w_cursor.lnum == Insstart_orig.lnum\n\t\t\t\t&& curwin->w_cursor.col <= Insstart_orig.col)))\n\t\t    || (!can_bs(BS_INDENT) && !arrow_used && ai_col > 0\n\t\t\t\t\t && curwin->w_cursor.col <= ai_col)\n\t\t    || (!can_bs(BS_EOL) && curwin->w_cursor.col == 0))))\n    {\n\tvim_beep(BO_BS);\n\treturn FALSE;\n    }\n\n    if (stop_arrow() == FAIL)\n\treturn FALSE;\n    in_indent = inindent(0);\n    if (in_indent)\n\tcan_cindent = FALSE;\n    end_comment_pending = NUL;\t// After BS, don't auto-end comment\n#ifdef FEAT_RIGHTLEFT\n    if (revins_on)\t    // put cursor after last inserted char\n\tinc_cursor();\n#endif\n\n    // Virtualedit:\n    //\tBACKSPACE_CHAR eats a virtual space\n    //\tBACKSPACE_WORD eats all coladd\n    //\tBACKSPACE_LINE eats all coladd and keeps going\n    if (curwin->w_cursor.coladd > 0)\n    {\n\tif (mode == BACKSPACE_CHAR)\n\t{\n\t    --curwin->w_cursor.coladd;\n\t    return TRUE;\n\t}\n\tif (mode == BACKSPACE_WORD)\n\t{\n\t    curwin->w_cursor.coladd = 0;\n\t    return TRUE;\n\t}\n\tcurwin->w_cursor.coladd = 0;\n    }\n\n    /*\n     * Delete newline!\n     */\n    if (curwin->w_cursor.col == 0)\n    {\n\tlnum = Insstart.lnum;\n\tif (curwin->w_cursor.lnum == lnum\n#ifdef FEAT_RIGHTLEFT\n\t\t\t|| revins_on\n#endif\n\t\t\t\t    )\n\t{\n\t    if (u_save((linenr_T)(curwin->w_cursor.lnum - 2),\n\t\t\t       (linenr_T)(curwin->w_cursor.lnum + 1)) == FAIL)\n\t\treturn FALSE;\n\t    --Insstart.lnum;\n\t    Insstart.col = (colnr_T)STRLEN(ml_get(Insstart.lnum));\n\t}\n\t/*\n\t * In replace mode:\n\t * cc < 0: NL was inserted, delete it\n\t * cc >= 0: NL was replaced, put original characters back\n\t */\n\tcc = -1;\n\tif (State & REPLACE_FLAG)\n\t    cc = replace_pop();\t    // returns -1 if NL was inserted\n\t/*\n\t * In replace mode, in the line we started replacing, we only move the\n\t * cursor.\n\t */\n\tif ((State & REPLACE_FLAG) && curwin->w_cursor.lnum <= lnum)\n\t{\n\t    dec_cursor();\n\t}\n\telse\n\t{\n\t    if (!(State & VREPLACE_FLAG)\n\t\t\t\t   || curwin->w_cursor.lnum > orig_line_count)\n\t    {\n\t\ttemp = gchar_cursor();\t// remember current char\n\t\t--curwin->w_cursor.lnum;\n\n\t\t// When \"aw\" is in 'formatoptions' we must delete the space at\n\t\t// the end of the line, otherwise the line will be broken\n\t\t// again when auto-formatting.\n\t\tif (has_format_option(FO_AUTO)\n\t\t\t\t\t   && has_format_option(FO_WHITE_PAR))\n\t\t{\n\t\t    char_u  *ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum,\n\t\t\t\t\t\t\t\t\tTRUE);\n\t\t    int\t    len;\n\n\t\t    len = (int)STRLEN(ptr);\n\t\t    if (len > 0 && ptr[len - 1] == ' ')\n\t\t\tptr[len - 1] = NUL;\n\t\t}\n\n\t\t(void)do_join(2, FALSE, FALSE, FALSE, FALSE);\n\t\tif (temp == NUL && gchar_cursor() != NUL)\n\t\t    inc_cursor();\n\t    }\n\t    else\n\t\tdec_cursor();\n\n\t    /*\n\t     * In MODE_REPLACE mode we have to put back the text that was\n\t     * replaced by the NL. On the replace stack is first a\n\t     * NUL-terminated sequence of characters that were deleted and then\n\t     * the characters that NL replaced.\n\t     */\n\t    if (State & REPLACE_FLAG)\n\t    {\n\t\t/*\n\t\t * Do the next ins_char() in MODE_NORMAL state, to\n\t\t * prevent ins_char() from replacing characters and\n\t\t * avoiding showmatch().\n\t\t */\n\t\toldState = State;\n\t\tState = MODE_NORMAL;\n\t\t/*\n\t\t * restore characters (blanks) deleted after cursor\n\t\t */\n\t\twhile (cc > 0)\n\t\t{\n\t\t    save_col = curwin->w_cursor.col;\n\t\t    mb_replace_pop_ins(cc);\n\t\t    curwin->w_cursor.col = save_col;\n\t\t    cc = replace_pop();\n\t\t}\n\t\t// restore the characters that NL replaced\n\t\treplace_pop_ins();\n\t\tState = oldState;\n\t    }\n\t}\n\tdid_ai = FALSE;\n    }\n    else\n    {\n\t/*\n\t * Delete character(s) before the cursor.\n\t */\n#ifdef FEAT_RIGHTLEFT\n\tif (revins_on)\t\t// put cursor on last inserted char\n\t    dec_cursor();\n#endif\n\tmincol = 0;\n\t\t\t\t\t\t// keep indent\n\tif (mode == BACKSPACE_LINE\n\t\t&& (curbuf->b_p_ai || cindent_on())\n#ifdef FEAT_RIGHTLEFT\n\t\t&& !revins_on\n#endif\n\t\t\t    )\n\t{\n\t    save_col = curwin->w_cursor.col;\n\t    beginline(BL_WHITE);\n\t    if (curwin->w_cursor.col < save_col)\n\t    {\n\t\tmincol = curwin->w_cursor.col;\n\t\t// should now fix the indent to match with the previous line\n\t\tcall_fix_indent = TRUE;\n\t    }\n\t    curwin->w_cursor.col = save_col;\n\t}\n\n\t/*\n\t * Handle deleting one 'shiftwidth' or 'softtabstop'.\n\t */\n\tif (\t   mode == BACKSPACE_CHAR\n\t\t&& ((p_sta && in_indent)\n\t\t    || ((get_sts_value() != 0\n#ifdef FEAT_VARTABS\n\t\t\t|| tabstop_count(curbuf->b_p_vsts_array)\n#endif\n\t\t\t)\n\t\t\t&& curwin->w_cursor.col > 0\n\t\t\t&& (*(ml_get_cursor() - 1) == TAB\n\t\t\t    || (*(ml_get_cursor() - 1) == ' '\n\t\t\t\t&& (!*inserted_space_p\n\t\t\t\t    || arrow_used))))))\n\t{\n\t    int\t\tts;\n\t    colnr_T\tvcol;\n\t    colnr_T\twant_vcol;\n\t    colnr_T\tstart_vcol;\n\n\t    *inserted_space_p = FALSE;\n\t    // Compute the virtual column where we want to be.  Since\n\t    // 'showbreak' may get in the way, need to get the last column of\n\t    // the previous character.\n\t    getvcol(curwin, &curwin->w_cursor, &vcol, NULL, NULL);\n\t    start_vcol = vcol;\n\t    dec_cursor();\n\t    getvcol(curwin, &curwin->w_cursor, NULL, NULL, &want_vcol);\n\t    inc_cursor();\n#ifdef FEAT_VARTABS\n\t    if (p_sta && in_indent)\n\t    {\n\t\tts = (int)get_sw_value(curbuf);\n\t\twant_vcol = (want_vcol / ts) * ts;\n\t    }\n\t    else\n\t\twant_vcol = tabstop_start(want_vcol, get_sts_value(),\n\t\t\t\t\t\t       curbuf->b_p_vsts_array);\n#else\n\t    if (p_sta && in_indent)\n\t\tts = (int)get_sw_value(curbuf);\n\t    else\n\t\tts = (int)get_sts_value();\n\t    want_vcol = (want_vcol / ts) * ts;\n#endif\n\n\t    // delete characters until we are at or before want_vcol\n\t    while (vcol > want_vcol\n\t\t    && (cc = *(ml_get_cursor() - 1), VIM_ISWHITE(cc)))\n\t\tins_bs_one(&vcol);\n\n\t    // insert extra spaces until we are at want_vcol\n\t    while (vcol < want_vcol)\n\t    {\n\t\t// Remember the first char we inserted\n\t\tif (curwin->w_cursor.lnum == Insstart_orig.lnum\n\t\t\t\t   && curwin->w_cursor.col < Insstart_orig.col)\n\t\t    Insstart_orig.col = curwin->w_cursor.col;\n\n\t\tif (State & VREPLACE_FLAG)\n\t\t    ins_char(' ');\n\t\telse\n\t\t{\n\t\t    ins_str((char_u *)\" \");\n\t\t    if ((State & REPLACE_FLAG))\n\t\t\treplace_push(NUL);\n\t\t}\n\t\tgetvcol(curwin, &curwin->w_cursor, &vcol, NULL, NULL);\n\t    }\n\n\t    // If we are now back where we started delete one character.  Can\n\t    // happen when using 'sts' and 'linebreak'.\n\t    if (vcol >= start_vcol)\n\t\tins_bs_one(&vcol);\n\t}\n\n\t/*\n\t * Delete up to starting point, start of line or previous word.\n\t */\n\telse\n\t{\n\t    int cclass = 0, prev_cclass = 0;\n\n\t    if (has_mbyte)\n\t\tcclass = mb_get_class(ml_get_cursor());\n\t    do\n\t    {\n#ifdef FEAT_RIGHTLEFT\n\t\tif (!revins_on) // put cursor on char to be deleted\n#endif\n\t\t    dec_cursor();\n\n\t\tcc = gchar_cursor();\n\t\t// look multi-byte character class\n\t\tif (has_mbyte)\n\t\t{\n\t\t    prev_cclass = cclass;\n\t\t    cclass = mb_get_class(ml_get_cursor());\n\t\t}\n\n\t\t// start of word?\n\t\tif (mode == BACKSPACE_WORD && !vim_isspace(cc))\n\t\t{\n\t\t    mode = BACKSPACE_WORD_NOT_SPACE;\n\t\t    temp = vim_iswordc(cc);\n\t\t}\n\t\t// end of word?\n\t\telse if (mode == BACKSPACE_WORD_NOT_SPACE\n\t\t\t&& ((vim_isspace(cc) || vim_iswordc(cc) != temp)\n\t\t\t|| prev_cclass != cclass))\n\t\t{\n#ifdef FEAT_RIGHTLEFT\n\t\t    if (!revins_on)\n#endif\n\t\t\tinc_cursor();\n#ifdef FEAT_RIGHTLEFT\n\t\t    else if (State & REPLACE_FLAG)\n\t\t\tdec_cursor();\n#endif\n\t\t    break;\n\t\t}\n\t\tif (State & REPLACE_FLAG)\n\t\t    replace_do_bs(-1);\n\t\telse\n\t\t{\n\t\t    if (enc_utf8 && p_deco)\n\t\t\t(void)utfc_ptr2char(ml_get_cursor(), cpc);\n\t\t    (void)del_char(FALSE);\n\t\t    /*\n\t\t     * If there are combining characters and 'delcombine' is set\n\t\t     * move the cursor back.  Don't back up before the base\n\t\t     * character.\n\t\t     */\n\t\t    if (enc_utf8 && p_deco && cpc[0] != NUL)\n\t\t\tinc_cursor();\n#ifdef FEAT_RIGHTLEFT\n\t\t    if (revins_chars)\n\t\t    {\n\t\t\trevins_chars--;\n\t\t\trevins_legal++;\n\t\t    }\n\t\t    if (revins_on && gchar_cursor() == NUL)\n\t\t\tbreak;\n#endif\n\t\t}\n\t\t// Just a single backspace?:\n\t\tif (mode == BACKSPACE_CHAR)\n\t\t    break;\n\t    } while (\n#ifdef FEAT_RIGHTLEFT\n\t\t    revins_on ||\n#endif\n\t\t    (curwin->w_cursor.col > mincol\n\t\t    &&  (can_bs(BS_NOSTOP)\n\t\t\t|| (curwin->w_cursor.lnum != Insstart_orig.lnum\n\t\t\t|| curwin->w_cursor.col != Insstart_orig.col)\n\t\t    )));\n\t}\n\tdid_backspace = TRUE;\n    }\n    did_si = FALSE;\n    can_si = FALSE;\n    can_si_back = FALSE;\n    if (curwin->w_cursor.col <= 1)\n\tdid_ai = FALSE;\n\n    if (call_fix_indent)\n\tfix_indent();\n\n    /*\n     * It's a little strange to put backspaces into the redo\n     * buffer, but it makes auto-indent a lot easier to deal\n     * with.\n     */\n    AppendCharToRedobuff(c);\n\n    // If deleted before the insertion point, adjust it\n    if (curwin->w_cursor.lnum == Insstart_orig.lnum\n\t\t\t\t  && curwin->w_cursor.col < Insstart_orig.col)\n\tInsstart_orig.col = curwin->w_cursor.col;\n\n    // vi behaviour: the cursor moves backward but the character that\n    //\t\t     was there remains visible\n    // Vim behaviour: the cursor moves backward and the character that\n    //\t\t      was there is erased from the screen.\n    // We can emulate the vi behaviour by pretending there is a dollar\n    // displayed even when there isn't.\n    //  --pkv Sun Jan 19 01:56:40 EST 2003\n    if (vim_strchr(p_cpo, CPO_BACKSPACE) != NULL && dollar_vcol == -1)\n\tdollar_vcol = curwin->w_virtcol;\n\n#ifdef FEAT_FOLDING\n    // When deleting a char the cursor line must never be in a closed fold.\n    // E.g., when 'foldmethod' is indent and deleting the first non-white\n    // char before a Tab.\n    if (did_backspace)\n\tfoldOpenCursor();\n#endif\n\n    return did_backspace;\n}", "func_hash": 172194519756788339453675041357999010208, "file_name": "edit.c", "file_hash": 334216402611901751671385717284214475763, "cwe": ["CWE-787"], "cve": "CVE-2022-2207", "cve_desc": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-2207", "file_path": "src/edit.c"}
{"idx": 380955, "project": "vim", "commit_id": "0971c7a4e537ea120a6bb2195960be8d0815e97b", "project_url": "https://github.com/vim/vim", "commit_url": "https://github.com/vim/vim/commit/0971c7a4e537ea120a6bb2195960be8d0815e97b", "commit_message": "patch 8.2.5162: reading before the start of the line with BS in Replace mode\n\nProblem:    Reading before the start of the line with BS in Replace mode.\nSolution:   Check the cursor column is more than zero.", "target": 0, "func": "ins_bs(\n    int\t\tc,\n    int\t\tmode,\n    int\t\t*inserted_space_p)\n{\n    linenr_T\tlnum;\n    int\t\tcc;\n    int\t\ttemp = 0;\t    // init for GCC\n    colnr_T\tsave_col;\n    colnr_T\tmincol;\n    int\t\tdid_backspace = FALSE;\n    int\t\tin_indent;\n    int\t\toldState;\n    int\t\tcpc[MAX_MCO];\t    // composing characters\n    int\t\tcall_fix_indent = FALSE;\n\n    /*\n     * can't delete anything in an empty file\n     * can't backup past first character in buffer\n     * can't backup past starting point unless 'backspace' > 1\n     * can backup to a previous line if 'backspace' == 0\n     */\n    if (       BUFEMPTY()\n\t    || (\n#ifdef FEAT_RIGHTLEFT\n\t\t!revins_on &&\n#endif\n\t\t((curwin->w_cursor.lnum == 1 && curwin->w_cursor.col == 0)\n\t\t    || (!can_bs(BS_START)\n\t\t\t&& ((arrow_used\n#ifdef FEAT_JOB_CHANNEL\n\t\t\t\t&& !bt_prompt(curbuf)\n#endif\n\t\t\t) || (curwin->w_cursor.lnum == Insstart_orig.lnum\n\t\t\t\t&& curwin->w_cursor.col <= Insstart_orig.col)))\n\t\t    || (!can_bs(BS_INDENT) && !arrow_used && ai_col > 0\n\t\t\t\t\t && curwin->w_cursor.col <= ai_col)\n\t\t    || (!can_bs(BS_EOL) && curwin->w_cursor.col == 0))))\n    {\n\tvim_beep(BO_BS);\n\treturn FALSE;\n    }\n\n    if (stop_arrow() == FAIL)\n\treturn FALSE;\n    in_indent = inindent(0);\n    if (in_indent)\n\tcan_cindent = FALSE;\n    end_comment_pending = NUL;\t// After BS, don't auto-end comment\n#ifdef FEAT_RIGHTLEFT\n    if (revins_on)\t    // put cursor after last inserted char\n\tinc_cursor();\n#endif\n\n    // Virtualedit:\n    //\tBACKSPACE_CHAR eats a virtual space\n    //\tBACKSPACE_WORD eats all coladd\n    //\tBACKSPACE_LINE eats all coladd and keeps going\n    if (curwin->w_cursor.coladd > 0)\n    {\n\tif (mode == BACKSPACE_CHAR)\n\t{\n\t    --curwin->w_cursor.coladd;\n\t    return TRUE;\n\t}\n\tif (mode == BACKSPACE_WORD)\n\t{\n\t    curwin->w_cursor.coladd = 0;\n\t    return TRUE;\n\t}\n\tcurwin->w_cursor.coladd = 0;\n    }\n\n    /*\n     * Delete newline!\n     */\n    if (curwin->w_cursor.col == 0)\n    {\n\tlnum = Insstart.lnum;\n\tif (curwin->w_cursor.lnum == lnum\n#ifdef FEAT_RIGHTLEFT\n\t\t\t|| revins_on\n#endif\n\t\t\t\t    )\n\t{\n\t    if (u_save((linenr_T)(curwin->w_cursor.lnum - 2),\n\t\t\t       (linenr_T)(curwin->w_cursor.lnum + 1)) == FAIL)\n\t\treturn FALSE;\n\t    --Insstart.lnum;\n\t    Insstart.col = (colnr_T)STRLEN(ml_get(Insstart.lnum));\n\t}\n\t/*\n\t * In replace mode:\n\t * cc < 0: NL was inserted, delete it\n\t * cc >= 0: NL was replaced, put original characters back\n\t */\n\tcc = -1;\n\tif (State & REPLACE_FLAG)\n\t    cc = replace_pop();\t    // returns -1 if NL was inserted\n\t/*\n\t * In replace mode, in the line we started replacing, we only move the\n\t * cursor.\n\t */\n\tif ((State & REPLACE_FLAG) && curwin->w_cursor.lnum <= lnum)\n\t{\n\t    dec_cursor();\n\t}\n\telse\n\t{\n\t    if (!(State & VREPLACE_FLAG)\n\t\t\t\t   || curwin->w_cursor.lnum > orig_line_count)\n\t    {\n\t\ttemp = gchar_cursor();\t// remember current char\n\t\t--curwin->w_cursor.lnum;\n\n\t\t// When \"aw\" is in 'formatoptions' we must delete the space at\n\t\t// the end of the line, otherwise the line will be broken\n\t\t// again when auto-formatting.\n\t\tif (has_format_option(FO_AUTO)\n\t\t\t\t\t   && has_format_option(FO_WHITE_PAR))\n\t\t{\n\t\t    char_u  *ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum,\n\t\t\t\t\t\t\t\t\tTRUE);\n\t\t    int\t    len;\n\n\t\t    len = (int)STRLEN(ptr);\n\t\t    if (len > 0 && ptr[len - 1] == ' ')\n\t\t\tptr[len - 1] = NUL;\n\t\t}\n\n\t\t(void)do_join(2, FALSE, FALSE, FALSE, FALSE);\n\t\tif (temp == NUL && gchar_cursor() != NUL)\n\t\t    inc_cursor();\n\t    }\n\t    else\n\t\tdec_cursor();\n\n\t    /*\n\t     * In MODE_REPLACE mode we have to put back the text that was\n\t     * replaced by the NL. On the replace stack is first a\n\t     * NUL-terminated sequence of characters that were deleted and then\n\t     * the characters that NL replaced.\n\t     */\n\t    if (State & REPLACE_FLAG)\n\t    {\n\t\t/*\n\t\t * Do the next ins_char() in MODE_NORMAL state, to\n\t\t * prevent ins_char() from replacing characters and\n\t\t * avoiding showmatch().\n\t\t */\n\t\toldState = State;\n\t\tState = MODE_NORMAL;\n\t\t/*\n\t\t * restore characters (blanks) deleted after cursor\n\t\t */\n\t\twhile (cc > 0)\n\t\t{\n\t\t    save_col = curwin->w_cursor.col;\n\t\t    mb_replace_pop_ins(cc);\n\t\t    curwin->w_cursor.col = save_col;\n\t\t    cc = replace_pop();\n\t\t}\n\t\t// restore the characters that NL replaced\n\t\treplace_pop_ins();\n\t\tState = oldState;\n\t    }\n\t}\n\tdid_ai = FALSE;\n    }\n    else\n    {\n\t/*\n\t * Delete character(s) before the cursor.\n\t */\n#ifdef FEAT_RIGHTLEFT\n\tif (revins_on)\t\t// put cursor on last inserted char\n\t    dec_cursor();\n#endif\n\tmincol = 0;\n\t\t\t\t\t\t// keep indent\n\tif (mode == BACKSPACE_LINE\n\t\t&& (curbuf->b_p_ai || cindent_on())\n#ifdef FEAT_RIGHTLEFT\n\t\t&& !revins_on\n#endif\n\t\t\t    )\n\t{\n\t    save_col = curwin->w_cursor.col;\n\t    beginline(BL_WHITE);\n\t    if (curwin->w_cursor.col < save_col)\n\t    {\n\t\tmincol = curwin->w_cursor.col;\n\t\t// should now fix the indent to match with the previous line\n\t\tcall_fix_indent = TRUE;\n\t    }\n\t    curwin->w_cursor.col = save_col;\n\t}\n\n\t/*\n\t * Handle deleting one 'shiftwidth' or 'softtabstop'.\n\t */\n\tif (\t   mode == BACKSPACE_CHAR\n\t\t&& ((p_sta && in_indent)\n\t\t    || ((get_sts_value() != 0\n#ifdef FEAT_VARTABS\n\t\t\t|| tabstop_count(curbuf->b_p_vsts_array)\n#endif\n\t\t\t)\n\t\t\t&& curwin->w_cursor.col > 0\n\t\t\t&& (*(ml_get_cursor() - 1) == TAB\n\t\t\t    || (*(ml_get_cursor() - 1) == ' '\n\t\t\t\t&& (!*inserted_space_p\n\t\t\t\t    || arrow_used))))))\n\t{\n\t    int\t\tts;\n\t    colnr_T\tvcol;\n\t    colnr_T\twant_vcol;\n\t    colnr_T\tstart_vcol;\n\n\t    *inserted_space_p = FALSE;\n\t    // Compute the virtual column where we want to be.  Since\n\t    // 'showbreak' may get in the way, need to get the last column of\n\t    // the previous character.\n\t    getvcol(curwin, &curwin->w_cursor, &vcol, NULL, NULL);\n\t    start_vcol = vcol;\n\t    dec_cursor();\n\t    getvcol(curwin, &curwin->w_cursor, NULL, NULL, &want_vcol);\n\t    inc_cursor();\n#ifdef FEAT_VARTABS\n\t    if (p_sta && in_indent)\n\t    {\n\t\tts = (int)get_sw_value(curbuf);\n\t\twant_vcol = (want_vcol / ts) * ts;\n\t    }\n\t    else\n\t\twant_vcol = tabstop_start(want_vcol, get_sts_value(),\n\t\t\t\t\t\t       curbuf->b_p_vsts_array);\n#else\n\t    if (p_sta && in_indent)\n\t\tts = (int)get_sw_value(curbuf);\n\t    else\n\t\tts = (int)get_sts_value();\n\t    want_vcol = (want_vcol / ts) * ts;\n#endif\n\n\t    // delete characters until we are at or before want_vcol\n\t    while (vcol > want_vcol && curwin->w_cursor.col > 0\n\t\t    && (cc = *(ml_get_cursor() - 1), VIM_ISWHITE(cc)))\n\t\tins_bs_one(&vcol);\n\n\t    // insert extra spaces until we are at want_vcol\n\t    while (vcol < want_vcol)\n\t    {\n\t\t// Remember the first char we inserted\n\t\tif (curwin->w_cursor.lnum == Insstart_orig.lnum\n\t\t\t\t   && curwin->w_cursor.col < Insstart_orig.col)\n\t\t    Insstart_orig.col = curwin->w_cursor.col;\n\n\t\tif (State & VREPLACE_FLAG)\n\t\t    ins_char(' ');\n\t\telse\n\t\t{\n\t\t    ins_str((char_u *)\" \");\n\t\t    if ((State & REPLACE_FLAG))\n\t\t\treplace_push(NUL);\n\t\t}\n\t\tgetvcol(curwin, &curwin->w_cursor, &vcol, NULL, NULL);\n\t    }\n\n\t    // If we are now back where we started delete one character.  Can\n\t    // happen when using 'sts' and 'linebreak'.\n\t    if (vcol >= start_vcol)\n\t\tins_bs_one(&vcol);\n\t}\n\n\t/*\n\t * Delete up to starting point, start of line or previous word.\n\t */\n\telse\n\t{\n\t    int cclass = 0, prev_cclass = 0;\n\n\t    if (has_mbyte)\n\t\tcclass = mb_get_class(ml_get_cursor());\n\t    do\n\t    {\n#ifdef FEAT_RIGHTLEFT\n\t\tif (!revins_on) // put cursor on char to be deleted\n#endif\n\t\t    dec_cursor();\n\n\t\tcc = gchar_cursor();\n\t\t// look multi-byte character class\n\t\tif (has_mbyte)\n\t\t{\n\t\t    prev_cclass = cclass;\n\t\t    cclass = mb_get_class(ml_get_cursor());\n\t\t}\n\n\t\t// start of word?\n\t\tif (mode == BACKSPACE_WORD && !vim_isspace(cc))\n\t\t{\n\t\t    mode = BACKSPACE_WORD_NOT_SPACE;\n\t\t    temp = vim_iswordc(cc);\n\t\t}\n\t\t// end of word?\n\t\telse if (mode == BACKSPACE_WORD_NOT_SPACE\n\t\t\t&& ((vim_isspace(cc) || vim_iswordc(cc) != temp)\n\t\t\t|| prev_cclass != cclass))\n\t\t{\n#ifdef FEAT_RIGHTLEFT\n\t\t    if (!revins_on)\n#endif\n\t\t\tinc_cursor();\n#ifdef FEAT_RIGHTLEFT\n\t\t    else if (State & REPLACE_FLAG)\n\t\t\tdec_cursor();\n#endif\n\t\t    break;\n\t\t}\n\t\tif (State & REPLACE_FLAG)\n\t\t    replace_do_bs(-1);\n\t\telse\n\t\t{\n\t\t    if (enc_utf8 && p_deco)\n\t\t\t(void)utfc_ptr2char(ml_get_cursor(), cpc);\n\t\t    (void)del_char(FALSE);\n\t\t    /*\n\t\t     * If there are combining characters and 'delcombine' is set\n\t\t     * move the cursor back.  Don't back up before the base\n\t\t     * character.\n\t\t     */\n\t\t    if (enc_utf8 && p_deco && cpc[0] != NUL)\n\t\t\tinc_cursor();\n#ifdef FEAT_RIGHTLEFT\n\t\t    if (revins_chars)\n\t\t    {\n\t\t\trevins_chars--;\n\t\t\trevins_legal++;\n\t\t    }\n\t\t    if (revins_on && gchar_cursor() == NUL)\n\t\t\tbreak;\n#endif\n\t\t}\n\t\t// Just a single backspace?:\n\t\tif (mode == BACKSPACE_CHAR)\n\t\t    break;\n\t    } while (\n#ifdef FEAT_RIGHTLEFT\n\t\t    revins_on ||\n#endif\n\t\t    (curwin->w_cursor.col > mincol\n\t\t    &&  (can_bs(BS_NOSTOP)\n\t\t\t|| (curwin->w_cursor.lnum != Insstart_orig.lnum\n\t\t\t|| curwin->w_cursor.col != Insstart_orig.col)\n\t\t    )));\n\t}\n\tdid_backspace = TRUE;\n    }\n    did_si = FALSE;\n    can_si = FALSE;\n    can_si_back = FALSE;\n    if (curwin->w_cursor.col <= 1)\n\tdid_ai = FALSE;\n\n    if (call_fix_indent)\n\tfix_indent();\n\n    /*\n     * It's a little strange to put backspaces into the redo\n     * buffer, but it makes auto-indent a lot easier to deal\n     * with.\n     */\n    AppendCharToRedobuff(c);\n\n    // If deleted before the insertion point, adjust it\n    if (curwin->w_cursor.lnum == Insstart_orig.lnum\n\t\t\t\t  && curwin->w_cursor.col < Insstart_orig.col)\n\tInsstart_orig.col = curwin->w_cursor.col;\n\n    // vi behaviour: the cursor moves backward but the character that\n    //\t\t     was there remains visible\n    // Vim behaviour: the cursor moves backward and the character that\n    //\t\t      was there is erased from the screen.\n    // We can emulate the vi behaviour by pretending there is a dollar\n    // displayed even when there isn't.\n    //  --pkv Sun Jan 19 01:56:40 EST 2003\n    if (vim_strchr(p_cpo, CPO_BACKSPACE) != NULL && dollar_vcol == -1)\n\tdollar_vcol = curwin->w_virtcol;\n\n#ifdef FEAT_FOLDING\n    // When deleting a char the cursor line must never be in a closed fold.\n    // E.g., when 'foldmethod' is indent and deleting the first non-white\n    // char before a Tab.\n    if (did_backspace)\n\tfoldOpenCursor();\n#endif\n\n    return did_backspace;\n}", "func_hash": 64259932111379563055532506605085485351, "file_name": "edit.c", "file_hash": 91657375912486719968624749742093008286, "cwe": ["CWE-787"], "cve": "CVE-2022-2207", "cve_desc": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-2207", "file_path": "src/edit.c"}
