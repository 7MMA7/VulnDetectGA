{"idx": 214358, "project": "clamav-devel", "commit_id": "224fee54dd6cd8933d7007331ec2bfca0398d4b4", "project_url": "https://github.com/vrtadmin/clamav-devel", "commit_url": "http://git.clamav.net/gitweb?p=clamav-devel.git;a=commit;h=224fee54dd6cd8933d7007331ec2bfca0398d4b4", "commit_message": "libclamav/mspack.c: fix Quantum decompressor (bb#1771)", "target": 1, "func": "int qtm_decompress(struct qtm_stream *qtm, off_t out_bytes) {\n  unsigned int frame_start, frame_end, window_posn, match_offset, range;\n  unsigned char *window, *i_ptr, *i_end, *runsrc, *rundest;\n  int i, j, selector, extra, sym, match_length, ret;\n  unsigned short H, L, C, symf;\n\n  register unsigned int bit_buffer;\n  register unsigned char bits_left;\n  unsigned char bits_needed, bit_run;\n\n  /* easy answers */\n  if (!qtm || (out_bytes < 0)) return CL_ENULLARG;\n  if (qtm->error) return qtm->error;\n\n  /* flush out any stored-up bytes before we begin */\n  i = qtm->o_end - qtm->o_ptr;\n  if ((off_t) i > out_bytes) i = (int) out_bytes;\n  if (i) {\n    if (qtm->wflag && (ret = mspack_write(qtm->ofd, qtm->o_ptr, i, qtm->file)) != CL_SUCCESS) {\n      return qtm->error = ret;\n    }\n    qtm->o_ptr  += i;\n    out_bytes   -= i;\n  }\n  if (out_bytes == 0) return CL_SUCCESS;\n\n  /* restore local state */\n  QTM_RESTORE_BITS;\n  window = qtm->window;\n  window_posn = qtm->window_posn;\n  frame_start = qtm->frame_start;\n  H = qtm->H;\n  L = qtm->L;\n  C = qtm->C;\n\n  /* while we do not have enough decoded bytes in reserve: */\n  while ((qtm->o_end - qtm->o_ptr) < out_bytes) {\n\n    /* read header if necessary. Initialises H, L and C */\n    if (!qtm->header_read) {\n      H = 0xFFFF; L = 0; QTM_READ_BITS(C, 16);\n      qtm->header_read = 1;\n    }\n\n    /* decode more, at most up to to frame boundary */\n    frame_end = window_posn + (out_bytes - (qtm->o_end - qtm->o_ptr));\n    if ((frame_start + QTM_FRAME_SIZE) < frame_end) {\n      frame_end = frame_start + QTM_FRAME_SIZE;\n    }\n\n    while (window_posn < frame_end) {\n      QTM_GET_SYMBOL(qtm->model7, selector);\n      if (selector < 4) {\n\tstruct qtm_model *mdl = (selector == 0) ? &qtm->model0 :\n\t                        ((selector == 1) ? &qtm->model1 :\n\t\t\t\t((selector == 2) ? &qtm->model2 :\n                                                   &qtm->model3));\n\tQTM_GET_SYMBOL((*mdl), sym);\n\twindow[window_posn++] = sym;\n      }\n      else {\n\tswitch (selector) {\n\tcase 4: /* selector 4 = fixed length match (3 bytes) */\n\t  QTM_GET_SYMBOL(qtm->model4, sym);\n\t  QTM_READ_BITS(extra, qtm->extra_bits[sym]);\n\t  match_offset = qtm->position_base[sym] + extra + 1;\n\t  match_length = 3;\n\t  break;\n\n\tcase 5: /* selector 5 = fixed length match (4 bytes) */\n\t  QTM_GET_SYMBOL(qtm->model5, sym);\n\t  QTM_READ_BITS(extra, qtm->extra_bits[sym]);\n\t  match_offset = qtm->position_base[sym] + extra + 1;\n\t  match_length = 4;\n\t  break;\n\n\tcase 6: /* selector 6 = variable length match */\n\t  QTM_GET_SYMBOL(qtm->model6len, sym);\n\t  QTM_READ_BITS(extra, qtm->length_extra[sym]);\n\t  match_length = qtm->length_base[sym] + extra + 5;\n\n\t  QTM_GET_SYMBOL(qtm->model6, sym);\n\t  QTM_READ_BITS(extra, qtm->extra_bits[sym]);\n\t  match_offset = qtm->position_base[sym] + extra + 1;\n\t  break;\n\n\tdefault:\n\t  /* should be impossible, model7 can only return 0-6 */\n\t  return qtm->error = CL_EFORMAT;\n\t}\n\n\trundest = &window[window_posn];\n\ti = match_length;\n\t/* does match offset wrap the window? */\n\tif (match_offset > window_posn) {\n\t  /* j = length from match offset to end of window */\n\t  j = match_offset - window_posn;\n\t  if (j > (int) qtm->window_size) {\n\t    cli_dbgmsg(\"qtm_decompress: match offset beyond window boundaries\\n\");\n\t    return qtm->error = CL_EFORMAT;\n\t  }\n\t  runsrc = &window[qtm->window_size - j];\n\t  if (j < i) {\n\t    /* if match goes over the window edge, do two copy runs */\n\t    i -= j; while (j-- > 0) *rundest++ = *runsrc++;\n\t    runsrc = window;\n\t  }\n\t  while (i-- > 0) *rundest++ = *runsrc++;\n\t}\n\telse {\n\t  runsrc = rundest - match_offset;\n\t  if(i > (int) (qtm->window_size - window_posn))\n\t    i = qtm->window_size - window_posn;\n\t  while (i-- > 0) *rundest++ = *runsrc++;\n\t}\n\twindow_posn += match_length;\n      }\n    } /* while (window_posn < frame_end) */\n\n    qtm->o_end = &window[window_posn];\n\n    /* another frame completed? */\n    if ((window_posn - frame_start) >= QTM_FRAME_SIZE) {\n      if ((window_posn - frame_start) != QTM_FRAME_SIZE) {\n\tcli_dbgmsg(\"qtm_decompress: overshot frame alignment\\n\");\n\treturn qtm->error = CL_EFORMAT;\n      }\n\n      /* re-align input */\n      if (bits_left & 7) QTM_REMOVE_BITS(bits_left & 7);\n      do { QTM_READ_BITS(i, 8); } while (i != 0xFF);\n      qtm->header_read = 0;\n\n      /* window wrap? */\n      if (window_posn == qtm->window_size) {\n\t/* flush all currently stored data */\n\ti = (qtm->o_end - qtm->o_ptr);\n\tif (qtm->wflag && (ret = mspack_write(qtm->ofd, qtm->o_ptr, i, qtm->file)) != CL_SUCCESS) {\n\t  return qtm->error = ret;\n\t}\n\tout_bytes -= i;\n\tqtm->o_ptr = &window[0];\n\tqtm->o_end = &window[0];\n\twindow_posn = 0;\n      }\n\n      frame_start = window_posn;\n    }\n\n  } /* while (more bytes needed) */\n\n  if (out_bytes) {\n    i = (int) out_bytes;\n    if (qtm->wflag && (ret = mspack_write(qtm->ofd, qtm->o_ptr, i, qtm->file)) != CL_SUCCESS) {\n      return qtm->error = ret;\n    }\n    qtm->o_ptr += i;\n  }\n\n  /* store local state */\n  QTM_STORE_BITS;\n  qtm->window_posn = window_posn;\n  qtm->frame_start = frame_start;\n  qtm->H = H;\n  qtm->L = L;\n  qtm->C = C;\n\n  return CL_SUCCESS;\n}", "func_hash": 291050376752284006088755347145639053650, "file_name": "mspack.c", "file_hash": 137114659534783781079186144852150621076, "cwe": ["CWE-20"], "cve": "CVE-2010-1311", "cve_desc": "The qtm_decompress function in libclamav/mspack.c in ClamAV before 0.96 allows remote attackers to cause a denial of service (memory corruption and application crash) via a crafted CAB archive that uses the Quantum (aka .Q) compression format.  NOTE: some of these details are obtained from third party information.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2010-1311", "file_path": "libclamav/mspack.c"}
{"idx": 477946, "project": "clamav-devel", "commit_id": "224fee54dd6cd8933d7007331ec2bfca0398d4b4", "project_url": "https://github.com/vrtadmin/clamav-devel", "commit_url": "http://git.clamav.net/gitweb?p=clamav-devel.git;a=commit;h=224fee54dd6cd8933d7007331ec2bfca0398d4b4", "commit_message": "libclamav/mspack.c: fix Quantum decompressor (bb#1771)", "target": 0, "func": "int qtm_decompress(struct qtm_stream *qtm, off_t out_bytes) {\n  unsigned int frame_start, frame_end, window_posn, match_offset, range;\n  unsigned char *window, *i_ptr, *i_end, *runsrc, *rundest;\n  int i, j, selector, extra, sym, match_length, ret;\n  unsigned short H, L, C, symf;\n\n  register unsigned int bit_buffer;\n  register unsigned char bits_left;\n  unsigned char bits_needed, bit_run;\n\n  /* easy answers */\n  if (!qtm || (out_bytes < 0)) return CL_ENULLARG;\n  if (qtm->error) return qtm->error;\n\n  /* flush out any stored-up bytes before we begin */\n  i = qtm->o_end - qtm->o_ptr;\n  if ((off_t) i > out_bytes) i = (int) out_bytes;\n  if (i) {\n    if (qtm->wflag && (ret = mspack_write(qtm->ofd, qtm->o_ptr, i, qtm->file)) != CL_SUCCESS) {\n      return qtm->error = ret;\n    }\n    qtm->o_ptr  += i;\n    out_bytes   -= i;\n  }\n  if (out_bytes == 0) return CL_SUCCESS;\n\n  /* restore local state */\n  QTM_RESTORE_BITS;\n  window = qtm->window;\n  window_posn = qtm->window_posn;\n  frame_start = qtm->frame_start;\n  H = qtm->H;\n  L = qtm->L;\n  C = qtm->C;\n\n  /* while we do not have enough decoded bytes in reserve: */\n  while ((qtm->o_end - qtm->o_ptr) < out_bytes) {\n\n    /* read header if necessary. Initialises H, L and C */\n    if (!qtm->header_read) {\n      H = 0xFFFF; L = 0; QTM_READ_BITS(C, 16);\n      qtm->header_read = 1;\n    }\n\n    /* decode more, at most up to to frame boundary */\n    frame_end = window_posn + (out_bytes - (qtm->o_end - qtm->o_ptr));\n    if ((frame_start + QTM_FRAME_SIZE) < frame_end) {\n      frame_end = frame_start + QTM_FRAME_SIZE;\n    }\n\n    while (window_posn < frame_end) {\n      QTM_GET_SYMBOL(qtm->model7, selector);\n      if (selector < 4) {\n\tstruct qtm_model *mdl = (selector == 0) ? &qtm->model0 :\n\t                        ((selector == 1) ? &qtm->model1 :\n\t\t\t\t((selector == 2) ? &qtm->model2 :\n                                                   &qtm->model3));\n\tQTM_GET_SYMBOL((*mdl), sym);\n\twindow[window_posn++] = sym;\n      }\n      else {\n\tswitch (selector) {\n\tcase 4: /* selector 4 = fixed length match (3 bytes) */\n\t  QTM_GET_SYMBOL(qtm->model4, sym);\n\t  QTM_READ_BITS(extra, qtm->extra_bits[sym]);\n\t  match_offset = qtm->position_base[sym] + extra + 1;\n\t  match_length = 3;\n\t  break;\n\n\tcase 5: /* selector 5 = fixed length match (4 bytes) */\n\t  QTM_GET_SYMBOL(qtm->model5, sym);\n\t  QTM_READ_BITS(extra, qtm->extra_bits[sym]);\n\t  match_offset = qtm->position_base[sym] + extra + 1;\n\t  match_length = 4;\n\t  break;\n\n\tcase 6: /* selector 6 = variable length match */\n\t  QTM_GET_SYMBOL(qtm->model6len, sym);\n\t  QTM_READ_BITS(extra, qtm->length_extra[sym]);\n\t  match_length = qtm->length_base[sym] + extra + 5;\n\n\t  QTM_GET_SYMBOL(qtm->model6, sym);\n\t  QTM_READ_BITS(extra, qtm->extra_bits[sym]);\n\t  match_offset = qtm->position_base[sym] + extra + 1;\n\t  break;\n\n\tdefault:\n\t  /* should be impossible, model7 can only return 0-6 */\n\t  return qtm->error = CL_EFORMAT;\n\t}\n\n\tif (window_posn + match_length > qtm->window_size) {\n\t  cli_dbgmsg(\"qtm_decompress: match ran over window wrap\\n\");\n\t  return qtm->error = CL_EFORMAT;\n\t}\n\n\trundest = &window[window_posn];\n\ti = match_length;\n\t/* does match offset wrap the window? */\n\tif (match_offset > window_posn) {\n\t  /* j = length from match offset to end of window */\n\t  j = match_offset - window_posn;\n\t  if (j > (int) qtm->window_size) {\n\t    cli_dbgmsg(\"qtm_decompress: match offset beyond window boundaries\\n\");\n\t    return qtm->error = CL_EFORMAT;\n\t  }\n\t  runsrc = &window[qtm->window_size - j];\n\t  if (j < i) {\n\t    /* if match goes over the window edge, do two copy runs */\n\t    i -= j; while (j-- > 0) *rundest++ = *runsrc++;\n\t    runsrc = window;\n\t  }\n\t  while (i-- > 0) *rundest++ = *runsrc++;\n\t}\n\telse {\n\t  runsrc = rundest - match_offset;\n\t  if(i > (int) (qtm->window_size - window_posn))\n\t    i = qtm->window_size - window_posn;\n\t  while (i-- > 0) *rundest++ = *runsrc++;\n\t}\n\twindow_posn += match_length;\n      }\n    } /* while (window_posn < frame_end) */\n\n    qtm->o_end = &window[window_posn];\n\n    /* another frame completed? */\n    if ((window_posn - frame_start) >= QTM_FRAME_SIZE) {\n      if ((window_posn - frame_start) != QTM_FRAME_SIZE) {\n\tcli_dbgmsg(\"qtm_decompress: overshot frame alignment\\n\");\n\treturn qtm->error = CL_EFORMAT;\n      }\n\n      /* re-align input */\n      if (bits_left & 7) QTM_REMOVE_BITS(bits_left & 7);\n      do { QTM_READ_BITS(i, 8); } while (i != 0xFF);\n      qtm->header_read = 0;\n\n      /* window wrap? */\n      if (window_posn == qtm->window_size) {\n\t/* flush all currently stored data */\n\ti = (qtm->o_end - qtm->o_ptr);\n\tif (qtm->wflag && (ret = mspack_write(qtm->ofd, qtm->o_ptr, i, qtm->file)) != CL_SUCCESS) {\n\t  return qtm->error = ret;\n\t}\n\tout_bytes -= i;\n\tqtm->o_ptr = &window[0];\n\tqtm->o_end = &window[0];\n\twindow_posn = 0;\n      }\n\n      frame_start = window_posn;\n    }\n\n  } /* while (more bytes needed) */\n\n  if (out_bytes) {\n    i = (int) out_bytes;\n    if (qtm->wflag && (ret = mspack_write(qtm->ofd, qtm->o_ptr, i, qtm->file)) != CL_SUCCESS) {\n      return qtm->error = ret;\n    }\n    qtm->o_ptr += i;\n  }\n\n  /* store local state */\n  QTM_STORE_BITS;\n  qtm->window_posn = window_posn;\n  qtm->frame_start = frame_start;\n  qtm->H = H;\n  qtm->L = L;\n  qtm->C = C;\n\n  return CL_SUCCESS;\n}", "func_hash": 309561544522405112370599990059884786931, "file_name": "mspack.c", "file_hash": 294647704290965311324683497678599566631, "cwe": ["CWE-20"], "cve": "CVE-2010-1311", "cve_desc": "The qtm_decompress function in libclamav/mspack.c in ClamAV before 0.96 allows remote attackers to cause a denial of service (memory corruption and application crash) via a crafted CAB archive that uses the Quantum (aka .Q) compression format.  NOTE: some of these details are obtained from third party information.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2010-1311", "file_path": "libclamav/mspack.c"}
