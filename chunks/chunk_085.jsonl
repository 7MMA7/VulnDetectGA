{"idx": 196893, "project": "envoy", "commit_id": "e9f936d85dc1edc34fabd0a1725ec180f2316353", "project_url": "https://github.com/istio/envoy", "commit_url": "https://github.com/envoyproxy/envoy/commit/e9f936d85dc1edc34fabd0a1725ec180f2316353", "commit_message": "CVE-2022-21654\n\ntls allows re-use when some cert validation settings have changed\n\nSigned-off-by: Yan Avlasov <yavlasov@google.com>", "target": 1, "func": "void DefaultCertValidator::updateDigestForSessionId(bssl::ScopedEVP_MD_CTX& md,\n                                                    uint8_t hash_buffer[EVP_MAX_MD_SIZE],\n                                                    unsigned hash_length) {\n  int rc;\n\n  // Hash all the settings that affect whether the server will allow/accept\n  // the client connection. This ensures that the client is always validated against\n  // the correct settings, even if session resumption across different listeners\n  // is enabled.\n  if (ca_cert_ != nullptr) {\n    rc = X509_digest(ca_cert_.get(), EVP_sha256(), hash_buffer, &hash_length);\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n    RELEASE_ASSERT(hash_length == SHA256_DIGEST_LENGTH,\n                   fmt::format(\"invalid SHA256 hash length {}\", hash_length));\n\n    rc = EVP_DigestUpdate(md.get(), hash_buffer, hash_length);\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n  }\n\n  for (const auto& hash : verify_certificate_hash_list_) {\n    rc = EVP_DigestUpdate(md.get(), hash.data(),\n                          hash.size() *\n                              sizeof(std::remove_reference<decltype(hash)>::type::value_type));\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n  }\n\n  for (const auto& hash : verify_certificate_spki_list_) {\n    rc = EVP_DigestUpdate(md.get(), hash.data(),\n                          hash.size() *\n                              sizeof(std::remove_reference<decltype(hash)>::type::value_type));\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n  }\n}", "func_hash": 140411723524972581248505271605198365196, "file_name": "default_validator.cc", "file_hash": 12469299547216327731154844869138538271, "cwe": ["CWE-362"], "cve": "CVE-2022-21654", "cve_desc": "Envoy is an open source edge and service proxy, designed for cloud-native applications. Envoy's tls allows re-use when some cert validation settings have changed from their default configuration. The only workaround for this issue is to ensure that default tls settings are used. Users are advised to upgrade.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-21654", "file_path": "source/extensions/transport_sockets/tls/cert_validator/default_validator.cc"}
{"idx": 247550, "project": "envoy", "commit_id": "e9f936d85dc1edc34fabd0a1725ec180f2316353", "project_url": "https://github.com/istio/envoy", "commit_url": "https://github.com/envoyproxy/envoy/commit/e9f936d85dc1edc34fabd0a1725ec180f2316353", "commit_message": "CVE-2022-21654\n\ntls allows re-use when some cert validation settings have changed\n\nSigned-off-by: Yan Avlasov <yavlasov@google.com>", "target": 0, "func": "void DefaultCertValidator::updateDigestForSessionId(bssl::ScopedEVP_MD_CTX& md,\n                                                    uint8_t hash_buffer[EVP_MAX_MD_SIZE],\n                                                    unsigned hash_length) {\n  int rc;\n\n  // Hash all the settings that affect whether the server will allow/accept\n  // the client connection. This ensures that the client is always validated against\n  // the correct settings, even if session resumption across different listeners\n  // is enabled.\n  if (ca_cert_ != nullptr) {\n    rc = X509_digest(ca_cert_.get(), EVP_sha256(), hash_buffer, &hash_length);\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n    RELEASE_ASSERT(hash_length == SHA256_DIGEST_LENGTH,\n                   fmt::format(\"invalid SHA256 hash length {}\", hash_length));\n\n    rc = EVP_DigestUpdate(md.get(), hash_buffer, hash_length);\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n  }\n\n  for (const auto& hash : verify_certificate_hash_list_) {\n    rc = EVP_DigestUpdate(md.get(), hash.data(),\n                          hash.size() *\n                              sizeof(std::remove_reference<decltype(hash)>::type::value_type));\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n  }\n\n  for (const auto& hash : verify_certificate_spki_list_) {\n    rc = EVP_DigestUpdate(md.get(), hash.data(),\n                          hash.size() *\n                              sizeof(std::remove_reference<decltype(hash)>::type::value_type));\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n  }\n\n  rc = EVP_DigestUpdate(md.get(), &verify_trusted_ca_, sizeof(verify_trusted_ca_));\n  RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n\n  if (config_ != nullptr) {\n    for (const auto& matcher : config_->subjectAltNameMatchers()) {\n      size_t hash = MessageUtil::hash(matcher);\n      rc = EVP_DigestUpdate(md.get(), &hash, sizeof(hash));\n      RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n    }\n\n    const std::string& crl = config_->certificateRevocationList();\n    if (!crl.empty()) {\n      rc = EVP_DigestUpdate(md.get(), crl.data(), crl.length());\n      RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n    }\n\n    bool allow_expired = config_->allowExpiredCertificate();\n    rc = EVP_DigestUpdate(md.get(), &allow_expired, sizeof(allow_expired));\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n\n    auto trust_chain_verification = config_->trustChainVerification();\n    rc = EVP_DigestUpdate(md.get(), &trust_chain_verification, sizeof(trust_chain_verification));\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n\n    auto only_leaf_crl = config_->onlyVerifyLeafCertificateCrl();\n    rc = EVP_DigestUpdate(md.get(), &only_leaf_crl, sizeof(only_leaf_crl));\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n  }\n}", "func_hash": 325686322374262257116614301181972043862, "file_name": "default_validator.cc", "file_hash": 261316308158712382898480668520478060002, "cwe": ["CWE-362"], "cve": "CVE-2022-21654", "cve_desc": "Envoy is an open source edge and service proxy, designed for cloud-native applications. Envoy's tls allows re-use when some cert validation settings have changed from their default configuration. The only workaround for this issue is to ensure that default tls settings are used. Users are advised to upgrade.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-21654", "file_path": "source/extensions/transport_sockets/tls/cert_validator/default_validator.cc"}
