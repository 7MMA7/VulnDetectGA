{"idx": 213037, "project": "php-src", "commit_id": "2bcbc95f033c31b00595ed39f79c3a99b4ed0501", "project_url": "https://github.com/php/php-src", "commit_url": "http://git.php.net/?p=php-src.git;a=commit;h=2bcbc95f033c31b00595ed39f79c3a99b4ed0501", "commit_message": "Fix bug #79037 (global buffer-overflow in `mbfl_filt_conv_big5_wchar`)", "target": 1, "func": "mbfl_filt_conv_big5_wchar(int c, mbfl_convert_filter *filter)\n{\n\tint k;\n\tint c1, w, c2;\n\n\tswitch (filter->status) {\n\tcase 0:\n\t\tif (filter->from->no_encoding == mbfl_no_encoding_cp950) {\n\t\t\tc1 = 0x80;\n\t\t} else {\n\t\t\tc1 = 0xa0;\n\t\t}\n\n\t\tif (c >= 0 && c <= 0x80) {\t/* latin */\n\t\t\tCK((*filter->output_function)(c, filter->data));\n\t\t} else if (c == 0xff) {\n\t\t\tCK((*filter->output_function)(0xf8f8, filter->data));\n\t\t} else if (c > c1 && c < 0xff) {\t/* dbcs lead byte */\n\t\t\tfilter->status = 1;\n\t\t\tfilter->cache = c;\n\t\t} else {\n\t\t\tw = c & MBFL_WCSGROUP_MASK;\n\t\t\tw |= MBFL_WCSGROUP_THROUGH;\n\t\t\tCK((*filter->output_function)(w, filter->data));\n\t\t}\n\t\tbreak;\n\n\tcase 1:\t\t/* dbcs second byte */\n\t\tfilter->status = 0;\n\t\tc1 = filter->cache;\n\t\tif ((c > 0x39 && c < 0x7f) | (c > 0xa0 && c < 0xff)) {\n\t\t\tif (c < 0x7f){\n\t\t\t\tw = (c1 - 0xa1)*157 + (c - 0x40);\n\t\t\t} else {\n\t\t\t\tw = (c1 - 0xa1)*157 + (c - 0xa1) + 0x3f;\n\t\t\t}\n\t\t\tif (w >= 0 && w < big5_ucs_table_size) {\n\t\t\t\tw = big5_ucs_table[w];\n\t\t\t} else {\n\t\t\t\tw = 0;\n\t\t\t}\n\n\t\t\tif (filter->from->no_encoding == mbfl_no_encoding_cp950) {\n\t\t\t\t/* PUA for CP950 */\n\t\t\t\tif (w <= 0 &&\n\t\t\t\t\t(((c1 >= 0xfa && c1 <= 0xfe) || (c1 >= 0x8e && c1 <= 0xa0) ||\n\t\t\t\t\t  (c1 >= 0x81 && c1 <= 0x8d) ||(c1 >= 0xc7 && c1 <= 0xc8))\n\t\t\t\t\t && ((c > 0x39 && c < 0x7f) || (c > 0xa0 && c < 0xff))) ||\n\t\t\t\t\t((c1 == 0xc6) && (c > 0xa0 && c < 0xff))) {\n\t\t\t\t\tc2 = c1 << 8 | c;\n\t\t\t\t\tfor (k = 0; k < sizeof(cp950_pua_tbl)/(sizeof(unsigned short)*4); k++) {\n\t\t\t\t\t\tif (c2 >= cp950_pua_tbl[k][2] && c2 <= cp950_pua_tbl[k][3]) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif ((cp950_pua_tbl[k][2] & 0xff) == 0x40) {\n\t\t\t\t\t\tw = 157*(c1 - (cp950_pua_tbl[k][2]>>8)) + c - (c >= 0xa1 ? 0x62 : 0x40)\n\t\t\t\t\t\t\t+ cp950_pua_tbl[k][0];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tw = c2 - cp950_pua_tbl[k][2] + cp950_pua_tbl[k][0];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (w <= 0) {\n\t\t\t\tw = (c1 << 8) | c;\n\t\t\t\tw &= MBFL_WCSPLANE_MASK;\n\t\t\t\tw |= MBFL_WCSPLANE_BIG5;\n\t\t\t}\n\t\t\tCK((*filter->output_function)(w, filter->data));\n\t\t} else if ((c >= 0 && c < 0x21) || c == 0x7f) {\t\t/* CTLs */\n\t\t\tCK((*filter->output_function)(c, filter->data));\n\t\t} else {\n\t\t\tw = (c1 << 8) | c;\n\t\t\tw &= MBFL_WCSGROUP_MASK;\n\t\t\tw |= MBFL_WCSGROUP_THROUGH;\n\t\t\tCK((*filter->output_function)(w, filter->data));\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tfilter->status = 0;\n\t\tbreak;\n\t}\n\n\treturn c;\n}", "func_hash": 8283586201644887300915898295948875795, "file_name": "mbfilter_big5.c", "file_hash": 67113767760618335945735132719612525083, "cwe": ["CWE-125"], "cve": "CVE-2020-7060", "cve_desc": "When using certain mbstring functions to convert multibyte encodings, in PHP versions 7.2.x below 7.2.27, 7.3.x below 7.3.14 and 7.4.x below 7.4.2 it is possible to supply data that will cause function mbfl_filt_conv_big5_wchar to read past the allocated buffer. This may lead to information disclosure or crash.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2020-7060", "file_path": "ext/mbstring/libmbfl/filters/mbfilter_big5.c"}
{"idx": 464942, "project": "php-src", "commit_id": "2bcbc95f033c31b00595ed39f79c3a99b4ed0501", "project_url": "https://github.com/php/php-src", "commit_url": "http://git.php.net/?p=php-src.git;a=commit;h=2bcbc95f033c31b00595ed39f79c3a99b4ed0501", "commit_message": "Fix bug #79037 (global buffer-overflow in `mbfl_filt_conv_big5_wchar`)", "target": 0, "func": "mbfl_filt_conv_big5_wchar(int c, mbfl_convert_filter *filter)\n{\n\tint k;\n\tint c1, w, c2;\n\n\tswitch (filter->status) {\n\tcase 0:\n\t\tif (filter->from->no_encoding == mbfl_no_encoding_cp950) {\n\t\t\tc1 = 0x80;\n\t\t} else {\n\t\t\tc1 = 0xa0;\n\t\t}\n\n\t\tif (c >= 0 && c <= 0x80) {\t/* latin */\n\t\t\tCK((*filter->output_function)(c, filter->data));\n\t\t} else if (c == 0xff) {\n\t\t\tCK((*filter->output_function)(0xf8f8, filter->data));\n\t\t} else if (c > c1 && c < 0xff) {\t/* dbcs lead byte */\n\t\t\tfilter->status = 1;\n\t\t\tfilter->cache = c;\n\t\t} else {\n\t\t\tw = c & MBFL_WCSGROUP_MASK;\n\t\t\tw |= MBFL_WCSGROUP_THROUGH;\n\t\t\tCK((*filter->output_function)(w, filter->data));\n\t\t}\n\t\tbreak;\n\n\tcase 1:\t\t/* dbcs second byte */\n\t\tfilter->status = 0;\n\t\tc1 = filter->cache;\n\t\tif ((c > 0x39 && c < 0x7f) | (c > 0xa0 && c < 0xff)) {\n\t\t\tif (c < 0x7f){\n\t\t\t\tw = (c1 - 0xa1)*157 + (c - 0x40);\n\t\t\t} else {\n\t\t\t\tw = (c1 - 0xa1)*157 + (c - 0xa1) + 0x3f;\n\t\t\t}\n\t\t\tif (w >= 0 && w < big5_ucs_table_size) {\n\t\t\t\tw = big5_ucs_table[w];\n\t\t\t} else {\n\t\t\t\tw = 0;\n\t\t\t}\n\n\t\t\tif (filter->from->no_encoding == mbfl_no_encoding_cp950) {\n\t\t\t\t/* PUA for CP950 */\n\t\t\t\tif (w <= 0 && is_in_cp950_pua(c1, c)) {\n\t\t\t\t\tc2 = c1 << 8 | c;\n\t\t\t\t\tfor (k = 0; k < sizeof(cp950_pua_tbl)/(sizeof(unsigned short)*4); k++) {\n\t\t\t\t\t\tif (c2 >= cp950_pua_tbl[k][2] && c2 <= cp950_pua_tbl[k][3]) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif ((cp950_pua_tbl[k][2] & 0xff) == 0x40) {\n\t\t\t\t\t\tw = 157*(c1 - (cp950_pua_tbl[k][2]>>8)) + c - (c >= 0xa1 ? 0x62 : 0x40)\n\t\t\t\t\t\t\t+ cp950_pua_tbl[k][0];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tw = c2 - cp950_pua_tbl[k][2] + cp950_pua_tbl[k][0];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (w <= 0) {\n\t\t\t\tw = (c1 << 8) | c;\n\t\t\t\tw &= MBFL_WCSPLANE_MASK;\n\t\t\t\tw |= MBFL_WCSPLANE_BIG5;\n\t\t\t}\n\t\t\tCK((*filter->output_function)(w, filter->data));\n\t\t} else if ((c >= 0 && c < 0x21) || c == 0x7f) {\t\t/* CTLs */\n\t\t\tCK((*filter->output_function)(c, filter->data));\n\t\t} else {\n\t\t\tw = (c1 << 8) | c;\n\t\t\tw &= MBFL_WCSGROUP_MASK;\n\t\t\tw |= MBFL_WCSGROUP_THROUGH;\n\t\t\tCK((*filter->output_function)(w, filter->data));\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tfilter->status = 0;\n\t\tbreak;\n\t}\n\n\treturn c;\n}", "func_hash": 324298547167958214830404594575086371894, "file_name": "mbfilter_big5.c", "file_hash": 135358838595920427772392870415942108469, "cwe": ["CWE-125"], "cve": "CVE-2020-7060", "cve_desc": "When using certain mbstring functions to convert multibyte encodings, in PHP versions 7.2.x below 7.2.27, 7.3.x below 7.3.14 and 7.4.x below 7.4.2 it is possible to supply data that will cause function mbfl_filt_conv_big5_wchar to read past the allocated buffer. This may lead to information disclosure or crash.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2020-7060", "file_path": "ext/mbstring/libmbfl/filters/mbfilter_big5.c"}
{"idx": 213075, "project": "linux", "commit_id": "d270453a0d9ec10bb8a802a142fb1b3601a83098", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/d270453a0d9ec10bb8a802a142fb1b3601a83098", "commit_message": "nfc: nfcmrvl: main: reorder destructive operations in nfcmrvl_nci_unregister_dev to avoid bugs\n\nThere are destructive operations such as nfcmrvl_fw_dnld_abort and\ngpio_free in nfcmrvl_nci_unregister_dev. The resources such as firmware,\ngpio and so on could be destructed while the upper layer functions such as\nnfcmrvl_fw_dnld_start and nfcmrvl_nci_recv_frame is executing, which leads\nto double-free, use-after-free and null-ptr-deref bugs.\n\nThere are three situations that could lead to double-free bugs.\n\nThe first situation is shown below:\n\n   (Thread 1)                 |      (Thread 2)\nnfcmrvl_fw_dnld_start         |\n ...                          |  nfcmrvl_nci_unregister_dev\n release_firmware()           |   nfcmrvl_fw_dnld_abort\n  kfree(fw) //(1)             |    fw_dnld_over\n                              |     release_firmware\n  ...                         |      kfree(fw) //(2)\n                              |     ...\n\nThe second situation is shown below:\n\n   (Thread 1)                 |      (Thread 2)\nnfcmrvl_fw_dnld_start         |\n ...                          |\n mod_timer                    |\n (wait a time)                |\n fw_dnld_timeout              |  nfcmrvl_nci_unregister_dev\n   fw_dnld_over               |   nfcmrvl_fw_dnld_abort\n    release_firmware          |    fw_dnld_over\n     kfree(fw) //(1)          |     release_firmware\n     ...                      |      kfree(fw) //(2)\n\nThe third situation is shown below:\n\n       (Thread 1)               |       (Thread 2)\nnfcmrvl_nci_recv_frame          |\n if(..->fw_download_in_progress)|\n  nfcmrvl_fw_dnld_recv_frame    |\n   queue_work                   |\n                                |\nfw_dnld_rx_work                 | nfcmrvl_nci_unregister_dev\n fw_dnld_over                   |  nfcmrvl_fw_dnld_abort\n  release_firmware              |   fw_dnld_over\n   kfree(fw) //(1)              |    release_firmware\n                                |     kfree(fw) //(2)\n\nThe firmware struct is deallocated in position (1) and deallocated\nin position (2) again.\n\nThe crash trace triggered by POC is like below:\n\nBUG: KASAN: double-free or invalid-free in fw_dnld_over\nCall Trace:\n  kfree\n  fw_dnld_over\n  nfcmrvl_nci_unregister_dev\n  nci_uart_tty_close\n  tty_ldisc_kill\n  tty_ldisc_hangup\n  __tty_hangup.part.0\n  tty_release\n  ...\n\nWhat's more, there are also use-after-free and null-ptr-deref bugs\nin nfcmrvl_fw_dnld_start. If we deallocate firmware struct, gpio or\nset null to the members of priv->fw_dnld in nfcmrvl_nci_unregister_dev,\nthen, we dereference firmware, gpio or the members of priv->fw_dnld in\nnfcmrvl_fw_dnld_start, the UAF or NPD bugs will happen.\n\nThis patch reorders destructive operations after nci_unregister_device\nin order to synchronize between cleanup routine and firmware download\nroutine.\n\nThe nci_unregister_device is well synchronized. If the device is\ndetaching, the firmware download routine will goto error. If firmware\ndownload routine is executing, nci_unregister_device will wait until\nfirmware download routine is finished.\n\nFixes: 3194c6870158 (\"NFC: nfcmrvl: add firmware download support\")\nSigned-off-by: Duoming Zhou <duoming@zju.edu.cn>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "target": 1, "func": "void nfcmrvl_nci_unregister_dev(struct nfcmrvl_private *priv)\n{\n\tstruct nci_dev *ndev = priv->ndev;\n\n\tif (priv->ndev->nfc_dev->fw_download_in_progress)\n\t\tnfcmrvl_fw_dnld_abort(priv);\n\n\tnfcmrvl_fw_dnld_deinit(priv);\n\n\tif (gpio_is_valid(priv->config.reset_n_io))\n\t\tgpio_free(priv->config.reset_n_io);\n\n\tnci_unregister_device(ndev);\n\tnci_free_device(ndev);\n\tkfree(priv);\n}", "func_hash": 80022393435189393698798858771068403226, "file_name": "main.c", "file_hash": 269589724165464795755961413543377431257, "cwe": ["CWE-416"], "cve": "CVE-2022-1734", "cve_desc": "A flaw in Linux Kernel found in nfcmrvl_nci_unregister_dev() in drivers/nfc/nfcmrvl/main.c can lead to use after free both read or write when non synchronized between cleanup routine and firmware download routine.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-1734", "file_path": "init/main.c"}
{"idx": 465854, "project": "linux", "commit_id": "d270453a0d9ec10bb8a802a142fb1b3601a83098", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/d270453a0d9ec10bb8a802a142fb1b3601a83098", "commit_message": "nfc: nfcmrvl: main: reorder destructive operations in nfcmrvl_nci_unregister_dev to avoid bugs\n\nThere are destructive operations such as nfcmrvl_fw_dnld_abort and\ngpio_free in nfcmrvl_nci_unregister_dev. The resources such as firmware,\ngpio and so on could be destructed while the upper layer functions such as\nnfcmrvl_fw_dnld_start and nfcmrvl_nci_recv_frame is executing, which leads\nto double-free, use-after-free and null-ptr-deref bugs.\n\nThere are three situations that could lead to double-free bugs.\n\nThe first situation is shown below:\n\n   (Thread 1)                 |      (Thread 2)\nnfcmrvl_fw_dnld_start         |\n ...                          |  nfcmrvl_nci_unregister_dev\n release_firmware()           |   nfcmrvl_fw_dnld_abort\n  kfree(fw) //(1)             |    fw_dnld_over\n                              |     release_firmware\n  ...                         |      kfree(fw) //(2)\n                              |     ...\n\nThe second situation is shown below:\n\n   (Thread 1)                 |      (Thread 2)\nnfcmrvl_fw_dnld_start         |\n ...                          |\n mod_timer                    |\n (wait a time)                |\n fw_dnld_timeout              |  nfcmrvl_nci_unregister_dev\n   fw_dnld_over               |   nfcmrvl_fw_dnld_abort\n    release_firmware          |    fw_dnld_over\n     kfree(fw) //(1)          |     release_firmware\n     ...                      |      kfree(fw) //(2)\n\nThe third situation is shown below:\n\n       (Thread 1)               |       (Thread 2)\nnfcmrvl_nci_recv_frame          |\n if(..->fw_download_in_progress)|\n  nfcmrvl_fw_dnld_recv_frame    |\n   queue_work                   |\n                                |\nfw_dnld_rx_work                 | nfcmrvl_nci_unregister_dev\n fw_dnld_over                   |  nfcmrvl_fw_dnld_abort\n  release_firmware              |   fw_dnld_over\n   kfree(fw) //(1)              |    release_firmware\n                                |     kfree(fw) //(2)\n\nThe firmware struct is deallocated in position (1) and deallocated\nin position (2) again.\n\nThe crash trace triggered by POC is like below:\n\nBUG: KASAN: double-free or invalid-free in fw_dnld_over\nCall Trace:\n  kfree\n  fw_dnld_over\n  nfcmrvl_nci_unregister_dev\n  nci_uart_tty_close\n  tty_ldisc_kill\n  tty_ldisc_hangup\n  __tty_hangup.part.0\n  tty_release\n  ...\n\nWhat's more, there are also use-after-free and null-ptr-deref bugs\nin nfcmrvl_fw_dnld_start. If we deallocate firmware struct, gpio or\nset null to the members of priv->fw_dnld in nfcmrvl_nci_unregister_dev,\nthen, we dereference firmware, gpio or the members of priv->fw_dnld in\nnfcmrvl_fw_dnld_start, the UAF or NPD bugs will happen.\n\nThis patch reorders destructive operations after nci_unregister_device\nin order to synchronize between cleanup routine and firmware download\nroutine.\n\nThe nci_unregister_device is well synchronized. If the device is\ndetaching, the firmware download routine will goto error. If firmware\ndownload routine is executing, nci_unregister_device will wait until\nfirmware download routine is finished.\n\nFixes: 3194c6870158 (\"NFC: nfcmrvl: add firmware download support\")\nSigned-off-by: Duoming Zhou <duoming@zju.edu.cn>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "target": 0, "func": "void nfcmrvl_nci_unregister_dev(struct nfcmrvl_private *priv)\n{\n\tstruct nci_dev *ndev = priv->ndev;\n\n\tnci_unregister_device(ndev);\n\tif (priv->ndev->nfc_dev->fw_download_in_progress)\n\t\tnfcmrvl_fw_dnld_abort(priv);\n\n\tnfcmrvl_fw_dnld_deinit(priv);\n\n\tif (gpio_is_valid(priv->config.reset_n_io))\n\t\tgpio_free(priv->config.reset_n_io);\n\n\tnci_free_device(ndev);\n\tkfree(priv);\n}", "func_hash": 316889922482617255369760811895973398042, "file_name": "main.c", "file_hash": 72783035661229533043408251312926412443, "cwe": ["CWE-416"], "cve": "CVE-2022-1734", "cve_desc": "A flaw in Linux Kernel found in nfcmrvl_nci_unregister_dev() in drivers/nfc/nfcmrvl/main.c can lead to use after free both read or write when non synchronized between cleanup routine and firmware download routine.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-1734", "file_path": "init/main.c"}
