{"idx": 199767, "project": "hexchat", "commit_id": "4e061a43b3453a9856d34250c3913175c45afe9d", "project_url": "https://github.com/hexchat/hexchat", "commit_url": "https://github.com/hexchat/hexchat/commit/4e061a43b3453a9856d34250c3913175c45afe9d", "commit_message": "Clean up handling CAP LS", "target": 1, "func": "inbound_cap_ls (server *serv, char *nick, char *extensions_str,\n\t\t\t\t\t const message_tags_data *tags_data)\n{\n\tchar buffer[256];\t/* buffer for requesting capabilities and emitting the signal */\n\tguint32 want_cap; /* format the CAP REQ string based on previous capabilities being requested or not */\n\tguint32 want_sasl; /* CAP END shouldn't be sent when SASL is requested, it needs further responses */\n\tchar **extensions;\n\tint i;\n\n\tEMIT_SIGNAL_TIMESTAMP (XP_TE_CAPLIST, serv->server_session, nick,\n\t\t\t\t\t\t\t\t  extensions_str, NULL, NULL, 0, tags_data->timestamp);\n\twant_cap = 0;\n\twant_sasl = 0;\n\n\textensions = g_strsplit (extensions_str, \" \", 0);\n\n\tstrcpy (buffer, \"CAP REQ :\");\n\n\tfor (i=0; extensions[i]; i++)\n\t{\n\t\tconst char *extension = extensions[i];\n\n\t\tif (!strcmp (extension, \"identify-msg\"))\n\t\t{\n\t\t\tstrcat (buffer, \"identify-msg \");\n\t\t\twant_cap = 1;\n\t\t}\n\t\tif (!strcmp (extension, \"multi-prefix\"))\n\t\t{\n\t\t\tstrcat (buffer, \"multi-prefix \");\n\t\t\twant_cap = 1;\n\t\t}\n\t\tif (!strcmp (extension, \"away-notify\"))\n\t\t{\n\t\t\tstrcat (buffer, \"away-notify \");\n\t\t\twant_cap = 1;\n\t\t}\n\t\tif (!strcmp (extension, \"account-notify\"))\n\t\t{\n\t\t\tstrcat (buffer, \"account-notify \");\n\t\t\twant_cap = 1;\n\t\t}\n\t\tif (!strcmp (extension, \"extended-join\"))\n\t\t{\n\t\t\tstrcat (buffer, \"extended-join \");\n\t\t\twant_cap = 1;\n\t\t}\n\t\tif (!strcmp (extension, \"userhost-in-names\"))\n\t\t{\n\t\t\tstrcat (buffer, \"userhost-in-names \");\n\t\t\twant_cap = 1;\n\t\t}\n\n\t\t/* bouncers can prefix a name space to the extension so we should use.\n\t\t * znc <= 1.0 uses \"znc.in/server-time\" and newer use \"znc.in/server-time-iso\".\n\t\t */\n\t\tif (!strcmp (extension, \"znc.in/server-time-iso\"))\n\t\t{\n\t\t\tstrcat (buffer, \"znc.in/server-time-iso \");\n\t\t\twant_cap = 1;\n\t\t}\n\t\tif (!strcmp (extension, \"znc.in/server-time\"))\n\t\t{\n\t\t\tstrcat (buffer, \"znc.in/server-time \");\n\t\t\twant_cap = 1;\n\t\t}\n\t\tif (prefs.hex_irc_cap_server_time\n\t\t\t && !strcmp (extension, \"server-time\"))\n\t\t{\n\t\t\tstrcat (buffer, \"server-time \");\n\t\t\twant_cap = 1;\n\t\t}\n\t\t\n\t\t/* if the SASL password is set AND auth mode is set to SASL, request SASL auth */\n\t\tif (!strcmp (extension, \"sasl\")\n\t\t\t&& ((serv->loginmethod == LOGIN_SASL && strlen (serv->password) != 0)\n\t\t\t|| (serv->loginmethod == LOGIN_SASLEXTERNAL && serv->have_cert)))\n\t\t{\n\t\t\tstrcat (buffer, \"sasl \");\n\t\t\twant_cap = 1;\n\t\t\twant_sasl = 1;\n\t\t}\n\t}\n\n\tg_strfreev (extensions);\n\n\tif (want_cap)\n\t{\n\t\t/* buffer + 9 = emit buffer without \"CAP REQ :\" */\n\t\tEMIT_SIGNAL_TIMESTAMP (XP_TE_CAPREQ, serv->server_session,\n\t\t\t\t\t\t\t\t\t  buffer + 9, NULL, NULL, NULL, 0,\n\t\t\t\t\t\t\t\t\t  tags_data->timestamp);\n\t\ttcp_sendf (serv, \"%s\\r\\n\", g_strchomp (buffer));\n\t}\n\tif (!want_sasl)\n\t{\n\t\t/* if we use SASL, CAP END is dealt via raw numerics */\n\t\tserv->sent_capend = TRUE;\n\t\ttcp_send_len (serv, \"CAP END\\r\\n\", 9);\n\t}\n}", "func_hash": 289376674180826741553106169575003472652, "file_name": "inbound.c", "file_hash": 202497518967624726910452754426675896941, "cwe": ["CWE-22"], "cve": "CVE-2016-2087", "cve_desc": "Directory traversal vulnerability in the client in HexChat 2.11.0 allows remote IRC servers to read or modify arbitrary files via a .. (dot dot) in the server name.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-2087", "file_path": "src/common/inbound.c"}
{"idx": 292205, "project": "hexchat", "commit_id": "4e061a43b3453a9856d34250c3913175c45afe9d", "project_url": "https://github.com/hexchat/hexchat", "commit_url": "https://github.com/hexchat/hexchat/commit/4e061a43b3453a9856d34250c3913175c45afe9d", "commit_message": "Clean up handling CAP LS", "target": 0, "func": "inbound_cap_ls (server *serv, char *nick, char *extensions_str,\n\t\t\t\t\t const message_tags_data *tags_data)\n{\n\tchar buffer[256];\t/* buffer for requesting capabilities and emitting the signal */\n\tgboolean want_cap = FALSE; /* format the CAP REQ string based on previous capabilities being requested or not */\n\tgboolean want_sasl = FALSE; /* CAP END shouldn't be sent when SASL is requested, it needs further responses */\n\tchar **extensions;\n\tint i;\n\n\tEMIT_SIGNAL_TIMESTAMP (XP_TE_CAPLIST, serv->server_session, nick,\n\t\t\t\t\t\t\t\t  extensions_str, NULL, NULL, 0, tags_data->timestamp);\n\n\textensions = g_strsplit (extensions_str, \" \", 0);\n\n\tstrcpy (buffer, \"CAP REQ :\");\n\n\tfor (i=0; extensions[i]; i++)\n\t{\n\t\tconst char *extension = extensions[i];\n\t\tgsize x;\n\n\t\t/* if the SASL password is set AND auth mode is set to SASL, request SASL auth */\n\t\tif (!g_strcmp0 (extension, \"sasl\") &&\n\t\t\t((serv->loginmethod == LOGIN_SASL && strlen (serv->password) != 0)\n\t\t\t\t|| (serv->loginmethod == LOGIN_SASLEXTERNAL && serv->have_cert)))\n\t\t{\n\t\t\twant_cap = TRUE;\n\t\t\twant_sasl = TRUE;\n\t\t\tg_strlcat (buffer, \"sasl \", sizeof(buffer));\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (x = 0; x < G_N_ELEMENTS(supported_caps); ++x)\n\t\t{\n\t\t\tif (!g_strcmp0 (extension, supported_caps[x]))\n\t\t\t{\n\t\t\t\tg_strlcat (buffer, extension, sizeof(buffer));\n\t\t\t\tg_strlcat (buffer, \" \", sizeof(buffer));\n\t\t\t\twant_cap = TRUE;\n\t\t\t}\n\t\t}\n\t}\n\n\tg_strfreev (extensions);\n\n\tif (want_cap)\n\t{\n\t\t/* buffer + 9 = emit buffer without \"CAP REQ :\" */\n\t\tEMIT_SIGNAL_TIMESTAMP (XP_TE_CAPREQ, serv->server_session,\n\t\t\t\t\t\t\t\t\t  buffer + 9, NULL, NULL, NULL, 0,\n\t\t\t\t\t\t\t\t\t  tags_data->timestamp);\n\t\ttcp_sendf (serv, \"%s\\r\\n\", g_strchomp (buffer));\n\t}\n\tif (!want_sasl)\n\t{\n\t\t/* if we use SASL, CAP END is dealt via raw numerics */\n\t\tserv->sent_capend = TRUE;\n\t\ttcp_send_len (serv, \"CAP END\\r\\n\", 9);\n\t}\n}", "func_hash": 298030143557811243277605801674004119778, "file_name": "inbound.c", "file_hash": 316287172279434102312310467592869221678, "cwe": ["CWE-22"], "cve": "CVE-2016-2087", "cve_desc": "Directory traversal vulnerability in the client in HexChat 2.11.0 allows remote IRC servers to read or modify arbitrary files via a .. (dot dot) in the server name.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-2087", "file_path": "src/common/inbound.c"}
