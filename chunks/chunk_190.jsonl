{"idx": 204425, "project": "frr", "commit_id": "6d58272b4cf96f0daa846210dd2104877900f921", "project_url": "https://github.com/FRRouting/frr", "commit_url": "https://github.com/FRRouting/frr/commit/6d58272b4cf96f0daa846210dd2104877900f921", "commit_message": "[bgpd] cleanup, compact and consolidate capability parsing code\n\n2007-07-26 Paul Jakma <paul.jakma@sun.com>\n\n\t* (general) Clean up and compact capability parsing slightly.\n\t  Consolidate validation of length and logging of generic TLV, and\n\t  memcpy of capability data, thus removing such from cap specifc\n\t  code (not always present or correct).\n\t* bgp_open.h: Add structures for the generic capability TLV header\n\t  and for the data formats of the various specific capabilities we\n\t  support.  Hence remove the badly named, or else misdefined, struct\n\t  capability.\n\t* bgp_open.c: (bgp_capability_vty_out) Use struct capability_mp_data.\n\t  Do the length checks *before* memcpy()'ing based on that length\n\t  (stored capability - should have been validated anyway on input,\n\t  but..).\n\t  (bgp_afi_safi_valid_indices) new function to validate (afi,safi)\n\t  which is about to be used as index into arrays, consolidates\n\t  several instances of same, at least one of which appeared to be\n\t  incomplete..\n\t  (bgp_capability_mp) Much condensed.\n\t  (bgp_capability_orf_entry) New, process one ORF entry\n\t  (bgp_capability_orf) Condensed. Fixed to process all ORF entries.\n\t  (bgp_capability_restart) Condensed, and fixed to use a\n\t  cap-specific type, rather than abusing capability_mp.\n\t  (struct message capcode_str) added to aid generic logging.\n\t  (size_t cap_minsizes[]) added to aid generic validation of\n\t  capability length field.\n\t  (bgp_capability_parse) Generic logging and validation of TLV\n\t  consolidated here. Code compacted as much as possible.\n\t* bgp_packet.c: (bgp_open_receive) Capability parsers now use\n\t  streams, so no more need here to manually fudge the input stream\n\t  getp.\n\t  (bgp_capability_msg_parse) use struct capability_mp_data. Validate\n\t  lengths /before/ memcpy. Use bgp_afi_safi_valid_indices.\n\t  (bgp_capability_receive) Exported for use by test harness.\n\t* bgp_vty.c: (bgp_show_summary) fix conversion warning\n\t  (bgp_show_peer) ditto\n\t* bgp_debug.h: Fix storage 'extern' after type 'const'.\n        * lib/log.c: (mes_lookup) warning about code not being in\n          same-number array slot should be debug, not warning. E.g. BGP\n          has several discontigious number spaces, allocating from\n          different parts of a space is not uncommon (e.g. IANA\n          assigned versus vendor-assigned code points in some number\n          space).", "target": 1, "func": "bgp_capability_msg_parse (struct peer *peer, u_char *pnt, bgp_size_t length)\n{\n  u_char *end;\n  struct capability cap;\n  u_char action;\n  struct bgp *bgp;\n  afi_t afi;\n  safi_t safi;\n\n  bgp = peer->bgp;\n  end = pnt + length;\n\n  while (pnt < end)\n    {\n      /* We need at least action, capability code and capability length. */\n      if (pnt + 3 > end)\n        {\n          zlog_info (\"%s Capability length error\", peer->host);\n          bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n          return -1;\n        }\n\n      action = *pnt;\n\n      /* Fetch structure to the byte stream. */\n      memcpy (&cap, pnt + 1, sizeof (struct capability));\n\n      /* Action value check.  */\n      if (action != CAPABILITY_ACTION_SET\n\t  && action != CAPABILITY_ACTION_UNSET)\n        {\n          zlog_info (\"%s Capability Action Value error %d\",\n\t\t     peer->host, action);\n          bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n          return -1;\n        }\n\n      if (BGP_DEBUG (normal, NORMAL))\n\tzlog_debug (\"%s CAPABILITY has action: %d, code: %u, length %u\",\n\t\t   peer->host, action, cap.code, cap.length);\n\n      /* Capability length check. */\n      if (pnt + (cap.length + 3) > end)\n        {\n          zlog_info (\"%s Capability length error\", peer->host);\n          bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n          return -1;\n        }\n\n      /* We know MP Capability Code. */\n      if (cap.code == CAPABILITY_CODE_MP)\n        {\n\t  afi = ntohs (cap.mpc.afi);\n\t  safi = cap.mpc.safi;\n\n          /* Ignore capability when override-capability is set. */\n          if (CHECK_FLAG (peer->flags, PEER_FLAG_OVERRIDE_CAPABILITY))\n\t    continue;\n\n\t  /* Address family check.  */\n\t  if ((afi == AFI_IP \n\t       || afi == AFI_IP6)\n\t      && (safi == SAFI_UNICAST \n\t\t  || safi == SAFI_MULTICAST \n\t\t  || safi == BGP_SAFI_VPNV4))\n\t    {\n\t      if (BGP_DEBUG (normal, NORMAL))\n\t\tzlog_debug (\"%s CAPABILITY has %s MP_EXT CAP for afi/safi: %u/%u\",\n\t\t\t   peer->host,\n\t\t\t   action == CAPABILITY_ACTION_SET \n\t\t\t   ? \"Advertising\" : \"Removing\",\n\t\t\t   ntohs(cap.mpc.afi) , cap.mpc.safi);\n\t\t  \n\t      /* Adjust safi code. */\n\t      if (safi == BGP_SAFI_VPNV4)\n\t\tsafi = SAFI_MPLS_VPN;\n\t      \n\t      if (action == CAPABILITY_ACTION_SET)\n\t\t{\n\t\t  peer->afc_recv[afi][safi] = 1;\n\t\t  if (peer->afc[afi][safi])\n\t\t    {\n\t\t      peer->afc_nego[afi][safi] = 1;\n\t\t      bgp_announce_route (peer, afi, safi);\n\t\t    }\n\t\t}\n\t      else\n\t\t{\n\t\t  peer->afc_recv[afi][safi] = 0;\n\t\t  peer->afc_nego[afi][safi] = 0;\n\n\t\t  if (peer_active_nego (peer))\n\t\t    bgp_clear_route (peer, afi, safi);\n\t\t  else\n\t\t    BGP_EVENT_ADD (peer, BGP_Stop);\n\t\t} \n\t    }\n        }\n      else\n        {\n          zlog_warn (\"%s unrecognized capability code: %d - ignored\",\n                     peer->host, cap.code);\n        }\n      pnt += cap.length + 3;\n    }\n  return 0;\n}", "func_hash": 158680384884701932457641345037828096002, "file_name": "bgp_packet.c", "file_hash": 16679227999356180294013513559974077753, "cwe": ["CWE-125"], "cve": "CVE-2022-37032", "cve_desc": "An out-of-bounds read in the BGP daemon of FRRouting FRR before 8.4 may lead to a segmentation fault and denial of service. This occurs in bgp_capability_msg_parse in bgpd/bgp_packet.c.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-37032", "file_path": "bgpd/bgp_packet.c"}
{"idx": 359365, "project": "frr", "commit_id": "6d58272b4cf96f0daa846210dd2104877900f921", "project_url": "https://github.com/FRRouting/frr", "commit_url": "https://github.com/FRRouting/frr/commit/6d58272b4cf96f0daa846210dd2104877900f921", "commit_message": "[bgpd] cleanup, compact and consolidate capability parsing code\n\n2007-07-26 Paul Jakma <paul.jakma@sun.com>\n\n\t* (general) Clean up and compact capability parsing slightly.\n\t  Consolidate validation of length and logging of generic TLV, and\n\t  memcpy of capability data, thus removing such from cap specifc\n\t  code (not always present or correct).\n\t* bgp_open.h: Add structures for the generic capability TLV header\n\t  and for the data formats of the various specific capabilities we\n\t  support.  Hence remove the badly named, or else misdefined, struct\n\t  capability.\n\t* bgp_open.c: (bgp_capability_vty_out) Use struct capability_mp_data.\n\t  Do the length checks *before* memcpy()'ing based on that length\n\t  (stored capability - should have been validated anyway on input,\n\t  but..).\n\t  (bgp_afi_safi_valid_indices) new function to validate (afi,safi)\n\t  which is about to be used as index into arrays, consolidates\n\t  several instances of same, at least one of which appeared to be\n\t  incomplete..\n\t  (bgp_capability_mp) Much condensed.\n\t  (bgp_capability_orf_entry) New, process one ORF entry\n\t  (bgp_capability_orf) Condensed. Fixed to process all ORF entries.\n\t  (bgp_capability_restart) Condensed, and fixed to use a\n\t  cap-specific type, rather than abusing capability_mp.\n\t  (struct message capcode_str) added to aid generic logging.\n\t  (size_t cap_minsizes[]) added to aid generic validation of\n\t  capability length field.\n\t  (bgp_capability_parse) Generic logging and validation of TLV\n\t  consolidated here. Code compacted as much as possible.\n\t* bgp_packet.c: (bgp_open_receive) Capability parsers now use\n\t  streams, so no more need here to manually fudge the input stream\n\t  getp.\n\t  (bgp_capability_msg_parse) use struct capability_mp_data. Validate\n\t  lengths /before/ memcpy. Use bgp_afi_safi_valid_indices.\n\t  (bgp_capability_receive) Exported for use by test harness.\n\t* bgp_vty.c: (bgp_show_summary) fix conversion warning\n\t  (bgp_show_peer) ditto\n\t* bgp_debug.h: Fix storage 'extern' after type 'const'.\n        * lib/log.c: (mes_lookup) warning about code not being in\n          same-number array slot should be debug, not warning. E.g. BGP\n          has several discontigious number spaces, allocating from\n          different parts of a space is not uncommon (e.g. IANA\n          assigned versus vendor-assigned code points in some number\n          space).", "target": 0, "func": "bgp_capability_msg_parse (struct peer *peer, u_char *pnt, bgp_size_t length)\n{\n  u_char *end;\n  struct capability_mp_data mpc;\n  struct capability_header *hdr;\n  u_char action;\n  struct bgp *bgp;\n  afi_t afi;\n  safi_t safi;\n\n  bgp = peer->bgp;\n  end = pnt + length;\n\n  while (pnt < end)\n    {      \n      /* We need at least action, capability code and capability length. */\n      if (pnt + 3 > end)\n        {\n          zlog_info (\"%s Capability length error\", peer->host);\n          bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n          return -1;\n        }\n      action = *pnt;\n      hdr = (struct capability_header *)(pnt + 1);\n      \n      /* Action value check.  */\n      if (action != CAPABILITY_ACTION_SET\n\t  && action != CAPABILITY_ACTION_UNSET)\n        {\n          zlog_info (\"%s Capability Action Value error %d\",\n\t\t     peer->host, action);\n          bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n          return -1;\n        }\n\n      if (BGP_DEBUG (normal, NORMAL))\n\tzlog_debug (\"%s CAPABILITY has action: %d, code: %u, length %u\",\n\t\t   peer->host, action, hdr->code, hdr->length);\n\n      /* Capability length check. */\n      if ((pnt + hdr->length + 3) > end)\n        {\n          zlog_info (\"%s Capability length error\", peer->host);\n          bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n          return -1;\n        }\n\n      /* Fetch structure to the byte stream. */\n      memcpy (&mpc, pnt + 3, sizeof (struct capability_mp_data));\n\n      /* We know MP Capability Code. */\n      if (hdr->code == CAPABILITY_CODE_MP)\n        {\n\t  afi = ntohs (mpc.afi);\n\t  safi = mpc.safi;\n\n          /* Ignore capability when override-capability is set. */\n          if (CHECK_FLAG (peer->flags, PEER_FLAG_OVERRIDE_CAPABILITY))\n\t    continue;\n          \n          if (!bgp_afi_safi_valid_indices (afi, &safi))\n            {\n              if (BGP_DEBUG (normal, NORMAL))\n                zlog_debug (\"%s Dynamic Capability MP_EXT afi/safi invalid\",\n                            peer->host, afi, safi);\n              continue;\n            }\n          \n\t  /* Address family check.  */\n          if (BGP_DEBUG (normal, NORMAL))\n            zlog_debug (\"%s CAPABILITY has %s MP_EXT CAP for afi/safi: %u/%u\",\n                       peer->host,\n                       action == CAPABILITY_ACTION_SET \n                       ? \"Advertising\" : \"Removing\",\n                       ntohs(mpc.afi) , mpc.safi);\n              \n          if (action == CAPABILITY_ACTION_SET)\n            {\n              peer->afc_recv[afi][safi] = 1;\n              if (peer->afc[afi][safi])\n                {\n                  peer->afc_nego[afi][safi] = 1;\n                  bgp_announce_route (peer, afi, safi);\n                }\n            }\n          else\n            {\n              peer->afc_recv[afi][safi] = 0;\n              peer->afc_nego[afi][safi] = 0;\n\n              if (peer_active_nego (peer))\n                bgp_clear_route (peer, afi, safi);\n              else\n                BGP_EVENT_ADD (peer, BGP_Stop);\n            }\n        }\n      else\n        {\n          zlog_warn (\"%s unrecognized capability code: %d - ignored\",\n                     peer->host, hdr->code);\n        }\n      pnt += hdr->length + 3;\n    }\n  return 0;\n}", "func_hash": 222322579110596507029051344758915923400, "file_name": "bgp_packet.c", "file_hash": 203634856057323248974002745421549823051, "cwe": ["CWE-125"], "cve": "CVE-2022-37032", "cve_desc": "An out-of-bounds read in the BGP daemon of FRRouting FRR before 8.4 may lead to a segmentation fault and denial of service. This occurs in bgp_capability_msg_parse in bgpd/bgp_packet.c.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-37032", "file_path": "bgpd/bgp_packet.c"}
