{"idx": 204425, "project": "frr", "commit_id": "6d58272b4cf96f0daa846210dd2104877900f921", "project_url": "https://github.com/FRRouting/frr", "commit_url": "https://github.com/FRRouting/frr/commit/6d58272b4cf96f0daa846210dd2104877900f921", "commit_message": "[bgpd] cleanup, compact and consolidate capability parsing code\n\n2007-07-26 Paul Jakma <paul.jakma@sun.com>\n\n\t* (general) Clean up and compact capability parsing slightly.\n\t  Consolidate validation of length and logging of generic TLV, and\n\t  memcpy of capability data, thus removing such from cap specifc\n\t  code (not always present or correct).\n\t* bgp_open.h: Add structures for the generic capability TLV header\n\t  and for the data formats of the various specific capabilities we\n\t  support.  Hence remove the badly named, or else misdefined, struct\n\t  capability.\n\t* bgp_open.c: (bgp_capability_vty_out) Use struct capability_mp_data.\n\t  Do the length checks *before* memcpy()'ing based on that length\n\t  (stored capability - should have been validated anyway on input,\n\t  but..).\n\t  (bgp_afi_safi_valid_indices) new function to validate (afi,safi)\n\t  which is about to be used as index into arrays, consolidates\n\t  several instances of same, at least one of which appeared to be\n\t  incomplete..\n\t  (bgp_capability_mp) Much condensed.\n\t  (bgp_capability_orf_entry) New, process one ORF entry\n\t  (bgp_capability_orf) Condensed. Fixed to process all ORF entries.\n\t  (bgp_capability_restart) Condensed, and fixed to use a\n\t  cap-specific type, rather than abusing capability_mp.\n\t  (struct message capcode_str) added to aid generic logging.\n\t  (size_t cap_minsizes[]) added to aid generic validation of\n\t  capability length field.\n\t  (bgp_capability_parse) Generic logging and validation of TLV\n\t  consolidated here. Code compacted as much as possible.\n\t* bgp_packet.c: (bgp_open_receive) Capability parsers now use\n\t  streams, so no more need here to manually fudge the input stream\n\t  getp.\n\t  (bgp_capability_msg_parse) use struct capability_mp_data. Validate\n\t  lengths /before/ memcpy. Use bgp_afi_safi_valid_indices.\n\t  (bgp_capability_receive) Exported for use by test harness.\n\t* bgp_vty.c: (bgp_show_summary) fix conversion warning\n\t  (bgp_show_peer) ditto\n\t* bgp_debug.h: Fix storage 'extern' after type 'const'.\n        * lib/log.c: (mes_lookup) warning about code not being in\n          same-number array slot should be debug, not warning. E.g. BGP\n          has several discontigious number spaces, allocating from\n          different parts of a space is not uncommon (e.g. IANA\n          assigned versus vendor-assigned code points in some number\n          space).", "target": 1, "func": "bgp_capability_msg_parse (struct peer *peer, u_char *pnt, bgp_size_t length)\n{\n  u_char *end;\n  struct capability cap;\n  u_char action;\n  struct bgp *bgp;\n  afi_t afi;\n  safi_t safi;\n\n  bgp = peer->bgp;\n  end = pnt + length;\n\n  while (pnt < end)\n    {\n      /* We need at least action, capability code and capability length. */\n      if (pnt + 3 > end)\n        {\n          zlog_info (\"%s Capability length error\", peer->host);\n          bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n          return -1;\n        }\n\n      action = *pnt;\n\n      /* Fetch structure to the byte stream. */\n      memcpy (&cap, pnt + 1, sizeof (struct capability));\n\n      /* Action value check.  */\n      if (action != CAPABILITY_ACTION_SET\n\t  && action != CAPABILITY_ACTION_UNSET)\n        {\n          zlog_info (\"%s Capability Action Value error %d\",\n\t\t     peer->host, action);\n          bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n          return -1;\n        }\n\n      if (BGP_DEBUG (normal, NORMAL))\n\tzlog_debug (\"%s CAPABILITY has action: %d, code: %u, length %u\",\n\t\t   peer->host, action, cap.code, cap.length);\n\n      /* Capability length check. */\n      if (pnt + (cap.length + 3) > end)\n        {\n          zlog_info (\"%s Capability length error\", peer->host);\n          bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n          return -1;\n        }\n\n      /* We know MP Capability Code. */\n      if (cap.code == CAPABILITY_CODE_MP)\n        {\n\t  afi = ntohs (cap.mpc.afi);\n\t  safi = cap.mpc.safi;\n\n          /* Ignore capability when override-capability is set. */\n          if (CHECK_FLAG (peer->flags, PEER_FLAG_OVERRIDE_CAPABILITY))\n\t    continue;\n\n\t  /* Address family check.  */\n\t  if ((afi == AFI_IP \n\t       || afi == AFI_IP6)\n\t      && (safi == SAFI_UNICAST \n\t\t  || safi == SAFI_MULTICAST \n\t\t  || safi == BGP_SAFI_VPNV4))\n\t    {\n\t      if (BGP_DEBUG (normal, NORMAL))\n\t\tzlog_debug (\"%s CAPABILITY has %s MP_EXT CAP for afi/safi: %u/%u\",\n\t\t\t   peer->host,\n\t\t\t   action == CAPABILITY_ACTION_SET \n\t\t\t   ? \"Advertising\" : \"Removing\",\n\t\t\t   ntohs(cap.mpc.afi) , cap.mpc.safi);\n\t\t  \n\t      /* Adjust safi code. */\n\t      if (safi == BGP_SAFI_VPNV4)\n\t\tsafi = SAFI_MPLS_VPN;\n\t      \n\t      if (action == CAPABILITY_ACTION_SET)\n\t\t{\n\t\t  peer->afc_recv[afi][safi] = 1;\n\t\t  if (peer->afc[afi][safi])\n\t\t    {\n\t\t      peer->afc_nego[afi][safi] = 1;\n\t\t      bgp_announce_route (peer, afi, safi);\n\t\t    }\n\t\t}\n\t      else\n\t\t{\n\t\t  peer->afc_recv[afi][safi] = 0;\n\t\t  peer->afc_nego[afi][safi] = 0;\n\n\t\t  if (peer_active_nego (peer))\n\t\t    bgp_clear_route (peer, afi, safi);\n\t\t  else\n\t\t    BGP_EVENT_ADD (peer, BGP_Stop);\n\t\t} \n\t    }\n        }\n      else\n        {\n          zlog_warn (\"%s unrecognized capability code: %d - ignored\",\n                     peer->host, cap.code);\n        }\n      pnt += cap.length + 3;\n    }\n  return 0;\n}", "func_hash": 158680384884701932457641345037828096002, "file_name": "bgp_packet.c", "file_hash": 16679227999356180294013513559974077753, "cwe": ["CWE-125"], "cve": "CVE-2022-37032", "cve_desc": "An out-of-bounds read in the BGP daemon of FRRouting FRR before 8.4 may lead to a segmentation fault and denial of service. This occurs in bgp_capability_msg_parse in bgpd/bgp_packet.c.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-37032", "file_path": "bgpd/bgp_packet.c"}
{"idx": 359365, "project": "frr", "commit_id": "6d58272b4cf96f0daa846210dd2104877900f921", "project_url": "https://github.com/FRRouting/frr", "commit_url": "https://github.com/FRRouting/frr/commit/6d58272b4cf96f0daa846210dd2104877900f921", "commit_message": "[bgpd] cleanup, compact and consolidate capability parsing code\n\n2007-07-26 Paul Jakma <paul.jakma@sun.com>\n\n\t* (general) Clean up and compact capability parsing slightly.\n\t  Consolidate validation of length and logging of generic TLV, and\n\t  memcpy of capability data, thus removing such from cap specifc\n\t  code (not always present or correct).\n\t* bgp_open.h: Add structures for the generic capability TLV header\n\t  and for the data formats of the various specific capabilities we\n\t  support.  Hence remove the badly named, or else misdefined, struct\n\t  capability.\n\t* bgp_open.c: (bgp_capability_vty_out) Use struct capability_mp_data.\n\t  Do the length checks *before* memcpy()'ing based on that length\n\t  (stored capability - should have been validated anyway on input,\n\t  but..).\n\t  (bgp_afi_safi_valid_indices) new function to validate (afi,safi)\n\t  which is about to be used as index into arrays, consolidates\n\t  several instances of same, at least one of which appeared to be\n\t  incomplete..\n\t  (bgp_capability_mp) Much condensed.\n\t  (bgp_capability_orf_entry) New, process one ORF entry\n\t  (bgp_capability_orf) Condensed. Fixed to process all ORF entries.\n\t  (bgp_capability_restart) Condensed, and fixed to use a\n\t  cap-specific type, rather than abusing capability_mp.\n\t  (struct message capcode_str) added to aid generic logging.\n\t  (size_t cap_minsizes[]) added to aid generic validation of\n\t  capability length field.\n\t  (bgp_capability_parse) Generic logging and validation of TLV\n\t  consolidated here. Code compacted as much as possible.\n\t* bgp_packet.c: (bgp_open_receive) Capability parsers now use\n\t  streams, so no more need here to manually fudge the input stream\n\t  getp.\n\t  (bgp_capability_msg_parse) use struct capability_mp_data. Validate\n\t  lengths /before/ memcpy. Use bgp_afi_safi_valid_indices.\n\t  (bgp_capability_receive) Exported for use by test harness.\n\t* bgp_vty.c: (bgp_show_summary) fix conversion warning\n\t  (bgp_show_peer) ditto\n\t* bgp_debug.h: Fix storage 'extern' after type 'const'.\n        * lib/log.c: (mes_lookup) warning about code not being in\n          same-number array slot should be debug, not warning. E.g. BGP\n          has several discontigious number spaces, allocating from\n          different parts of a space is not uncommon (e.g. IANA\n          assigned versus vendor-assigned code points in some number\n          space).", "target": 0, "func": "bgp_capability_msg_parse (struct peer *peer, u_char *pnt, bgp_size_t length)\n{\n  u_char *end;\n  struct capability_mp_data mpc;\n  struct capability_header *hdr;\n  u_char action;\n  struct bgp *bgp;\n  afi_t afi;\n  safi_t safi;\n\n  bgp = peer->bgp;\n  end = pnt + length;\n\n  while (pnt < end)\n    {      \n      /* We need at least action, capability code and capability length. */\n      if (pnt + 3 > end)\n        {\n          zlog_info (\"%s Capability length error\", peer->host);\n          bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n          return -1;\n        }\n      action = *pnt;\n      hdr = (struct capability_header *)(pnt + 1);\n      \n      /* Action value check.  */\n      if (action != CAPABILITY_ACTION_SET\n\t  && action != CAPABILITY_ACTION_UNSET)\n        {\n          zlog_info (\"%s Capability Action Value error %d\",\n\t\t     peer->host, action);\n          bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n          return -1;\n        }\n\n      if (BGP_DEBUG (normal, NORMAL))\n\tzlog_debug (\"%s CAPABILITY has action: %d, code: %u, length %u\",\n\t\t   peer->host, action, hdr->code, hdr->length);\n\n      /* Capability length check. */\n      if ((pnt + hdr->length + 3) > end)\n        {\n          zlog_info (\"%s Capability length error\", peer->host);\n          bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n          return -1;\n        }\n\n      /* Fetch structure to the byte stream. */\n      memcpy (&mpc, pnt + 3, sizeof (struct capability_mp_data));\n\n      /* We know MP Capability Code. */\n      if (hdr->code == CAPABILITY_CODE_MP)\n        {\n\t  afi = ntohs (mpc.afi);\n\t  safi = mpc.safi;\n\n          /* Ignore capability when override-capability is set. */\n          if (CHECK_FLAG (peer->flags, PEER_FLAG_OVERRIDE_CAPABILITY))\n\t    continue;\n          \n          if (!bgp_afi_safi_valid_indices (afi, &safi))\n            {\n              if (BGP_DEBUG (normal, NORMAL))\n                zlog_debug (\"%s Dynamic Capability MP_EXT afi/safi invalid\",\n                            peer->host, afi, safi);\n              continue;\n            }\n          \n\t  /* Address family check.  */\n          if (BGP_DEBUG (normal, NORMAL))\n            zlog_debug (\"%s CAPABILITY has %s MP_EXT CAP for afi/safi: %u/%u\",\n                       peer->host,\n                       action == CAPABILITY_ACTION_SET \n                       ? \"Advertising\" : \"Removing\",\n                       ntohs(mpc.afi) , mpc.safi);\n              \n          if (action == CAPABILITY_ACTION_SET)\n            {\n              peer->afc_recv[afi][safi] = 1;\n              if (peer->afc[afi][safi])\n                {\n                  peer->afc_nego[afi][safi] = 1;\n                  bgp_announce_route (peer, afi, safi);\n                }\n            }\n          else\n            {\n              peer->afc_recv[afi][safi] = 0;\n              peer->afc_nego[afi][safi] = 0;\n\n              if (peer_active_nego (peer))\n                bgp_clear_route (peer, afi, safi);\n              else\n                BGP_EVENT_ADD (peer, BGP_Stop);\n            }\n        }\n      else\n        {\n          zlog_warn (\"%s unrecognized capability code: %d - ignored\",\n                     peer->host, hdr->code);\n        }\n      pnt += hdr->length + 3;\n    }\n  return 0;\n}", "func_hash": 222322579110596507029051344758915923400, "file_name": "bgp_packet.c", "file_hash": 203634856057323248974002745421549823051, "cwe": ["CWE-125"], "cve": "CVE-2022-37032", "cve_desc": "An out-of-bounds read in the BGP daemon of FRRouting FRR before 8.4 may lead to a segmentation fault and denial of service. This occurs in bgp_capability_msg_parse in bgpd/bgp_packet.c.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-37032", "file_path": "bgpd/bgp_packet.c"}
{"idx": 204438, "project": "ImageMagick", "commit_id": "716496e6df0add89e9679d6da9c0afca814cfe49", "project_url": "https://github.com/ImageMagick/ImageMagick", "commit_url": "https://github.com/ImageMagick/ImageMagick/commit/716496e6df0add89e9679d6da9c0afca814cfe49", "commit_message": "do not attempt to write a null image list (thanks to Vinay Rohila)", "target": 1, "func": "WandPrivate void CLINoImageOperator(MagickCLI *cli_wand,\n  const char *option,const char *arg1n,const char *arg2n)\n{\n  const char    /* percent escaped versions of the args */\n    *arg1,\n    *arg2;\n\n#define _image_info     (cli_wand->wand.image_info)\n#define _images         (cli_wand->wand.images)\n#define _exception      (cli_wand->wand.exception)\n#define _process_flags  (cli_wand->process_flags)\n#define _option_type    ((CommandOptionFlags) cli_wand->command->flags)\n#define IfNormalOp      (*option=='-')\n#define IfPlusOp        (*option!='-')\n\n  assert(cli_wand != (MagickCLI *) NULL);\n  assert(cli_wand->signature == MagickWandSignature);\n  assert(cli_wand->wand.signature == MagickWandSignature);\n\n  if (cli_wand->wand.debug != MagickFalse)\n    (void) CLILogEvent(cli_wand,CommandEvent,GetMagickModule(),\n      \"- NoImage Operator: %s \\\"%s\\\" \\\"%s\\\"\", option,\n      arg1n != (char *) NULL ? arg1n : \"\",\n      arg2n != (char *) NULL ? arg2n : \"\");\n\n  arg1 = arg1n;\n  arg2 = arg2n;\n\n  /* Interpret Percent Escapes in Arguments - using first image */\n  if ( (((_process_flags & ProcessInterpretProperities) != 0 )\n        || ((_option_type & AlwaysInterpretArgsFlag) != 0)\n       )  && ((_option_type & NeverInterpretArgsFlag) == 0) ) {\n    /* Interpret Percent escapes in argument 1 */\n    if (arg1n != (char *) NULL) {\n      arg1=InterpretImageProperties(_image_info,_images,arg1n,_exception);\n      if (arg1 == (char *) NULL) {\n        CLIWandException(OptionWarning,\"InterpretPropertyFailure\",option);\n        arg1=arg1n;  /* use the given argument as is */\n      }\n    }\n    if (arg2n != (char *) NULL) {\n      arg2=InterpretImageProperties(_image_info,_images,arg2n,_exception);\n      if (arg2 == (char *) NULL) {\n        CLIWandException(OptionWarning,\"InterpretPropertyFailure\",option);\n        arg2=arg2n;  /* use the given argument as is */\n      }\n    }\n  }\n#undef _process_flags\n#undef _option_type\n\n  do {  /* break to exit code */\n    /*\n      No-op options  (ignore these)\n    */\n    if (LocaleCompare(\"noop\",option+1) == 0)   /* zero argument */\n      break;\n    if (LocaleCompare(\"sans\",option+1) == 0)   /* one argument */\n      break;\n    if (LocaleCompare(\"sans0\",option+1) == 0)  /* zero argument */\n      break;\n    if (LocaleCompare(\"sans1\",option+1) == 0)  /* one argument */\n      break;\n    if (LocaleCompare(\"sans2\",option+1) == 0)  /* two arguments */\n      break;\n    /*\n      Image Reading\n    */\n    if ( ( LocaleCompare(\"read\",option+1) == 0 ) ||\n      ( LocaleCompare(\"--\",option) == 0 ) ) {\n      /* Do Glob filename Expansion for 'arg1' then read all images.\n      *\n      * Expansion handles '@', '~', '*', and '?' meta-characters while ignoring\n      * (but attaching to the filenames in the generated argument list) any\n      * [...] read modifiers that may be present.\n      *\n      * For example: It will expand '*.gif[20x20]' into a list such as\n      * 'abc.gif[20x20]',  'foobar.gif[20x20]',  'xyzzy.gif[20x20]'\n      *\n      * NOTE: In IMv6 this was done globally across all images. This\n      * meant you could include IM options in '@filename' lists, but you\n      * could not include comments.   Doing it only for image read makes\n      * it far more secure.\n      *\n      * Note: arguments do not have percent escapes expanded for security\n      * reasons.\n      */\n      int      argc;\n      char     **argv;\n      ssize_t  i;\n\n      argc = 1;\n      argv = (char **) &arg1;\n\n      /* Expand 'glob' expressions in the given filename.\n        Expansion handles any 'coder:' prefix, or read modifiers attached\n        to the filename, including them in the resulting expanded list.\n      */\n      if (ExpandFilenames(&argc,&argv) == MagickFalse)\n        CLIWandExceptArgBreak(ResourceLimitError,\"MemoryAllocationFailed\",\n            option,GetExceptionMessage(errno));\n\n      /* loop over expanded filename list, and read then all in */\n      for (i=0; i < (ssize_t) argc; i++) {\n        Image *\n          new_images;\n        if (_image_info->ping != MagickFalse)\n          new_images=PingImages(_image_info,argv[i],_exception);\n        else\n          new_images=ReadImages(_image_info,argv[i],_exception);\n        AppendImageToList(&_images, new_images);\n        argv[i]=DestroyString(argv[i]);\n      }\n      argv=(char **) RelinquishMagickMemory(argv);\n      break;\n    }\n    /*\n      Image Writing\n      Note: Writing a empty image list is valid in specific cases\n    */\n    if (LocaleCompare(\"write\",option+1) == 0) {\n      /* Note: arguments do not have percent escapes expanded */\n      char\n        key[MagickPathExtent];\n\n      Image\n        *write_images;\n\n      ImageInfo\n        *write_info;\n\n      /* Need images, unless a \"null:\" output coder is used */\n      if ( _images == (Image *) NULL ) {\n        if ( LocaleCompare(arg1,\"null:\") == 0 )\n          break;\n        CLIWandExceptArgBreak(OptionError,\"NoImagesForWrite\",option,arg1);\n      }\n\n      (void) FormatLocaleString(key,MagickPathExtent,\"cache:%s\",arg1);\n      (void) DeleteImageRegistry(key);\n      write_images=CloneImageList(_images,_exception);\n      write_info=CloneImageInfo(_image_info);\n      (void) WriteImages(write_info,write_images,arg1,_exception);\n      write_info=DestroyImageInfo(write_info);\n      write_images=DestroyImageList(write_images);\n      break;\n    }\n    /*\n      Parenthesis and Brace operations\n    */\n    if (LocaleCompare(\"(\",option) == 0) {\n      /* stack 'push' images */\n      Stack\n        *node;\n\n      size_t\n        size;\n\n      size=0;\n      node=cli_wand->image_list_stack;\n      for ( ; node != (Stack *) NULL; node=node->next)\n        size++;\n      if ( size >= MAX_STACK_DEPTH )\n        CLIWandExceptionBreak(OptionError,\"ParenthesisNestedTooDeeply\",option);\n      node=(Stack *) AcquireMagickMemory(sizeof(*node));\n      if (node == (Stack *) NULL)\n        CLIWandExceptionBreak(ResourceLimitFatalError,\n            \"MemoryAllocationFailed\",option);\n      node->data = (void *)cli_wand->wand.images;\n      node->next = cli_wand->image_list_stack;\n      cli_wand->image_list_stack = node;\n      cli_wand->wand.images = NewImageList();\n\n      /* handle respect-parenthesis */\n      if (IsStringTrue(GetImageOption(cli_wand->wand.image_info,\n                    \"respect-parenthesis\")) != MagickFalse)\n        option=\"{\"; /* fall-thru so as to push image settings too */\n      else\n        break;\n      /* fall thru to operation */\n    }\n    if (LocaleCompare(\"{\",option) == 0) {\n      /* stack 'push' of image_info settings */\n      Stack\n        *node;\n\n      size_t\n        size;\n\n      size=0;\n      node=cli_wand->image_info_stack;\n      for ( ; node != (Stack *) NULL; node=node->next)\n        size++;\n      if ( size >= MAX_STACK_DEPTH )\n        CLIWandExceptionBreak(OptionError,\"CurlyBracesNestedTooDeeply\",option);\n      node=(Stack *) AcquireMagickMemory(sizeof(*node));\n      if (node == (Stack *) NULL)\n        CLIWandExceptionBreak(ResourceLimitFatalError,\n            \"MemoryAllocationFailed\",option);\n\n      node->data = (void *)cli_wand->wand.image_info;\n      node->next = cli_wand->image_info_stack;\n\n      cli_wand->image_info_stack = node;\n      cli_wand->wand.image_info = CloneImageInfo(cli_wand->wand.image_info);\n      if (cli_wand->wand.image_info == (ImageInfo *) NULL) {\n        CLIWandException(ResourceLimitFatalError,\"MemoryAllocationFailed\",\n            option);\n        cli_wand->wand.image_info = (ImageInfo *)node->data;\n        node = (Stack *)RelinquishMagickMemory(node);\n        break;\n      }\n\n      break;\n    }\n    if (LocaleCompare(\")\",option) == 0) {\n      /* pop images from stack */\n      Stack\n        *node;\n\n      node = (Stack *)cli_wand->image_list_stack;\n      if ( node == (Stack *) NULL)\n        CLIWandExceptionBreak(OptionError,\"UnbalancedParenthesis\",option);\n      cli_wand->image_list_stack = node->next;\n\n      AppendImageToList((Image **)&node->data,cli_wand->wand.images);\n      cli_wand->wand.images= (Image *)node->data;\n      node = (Stack *)RelinquishMagickMemory(node);\n\n      /* handle respect-parenthesis - of the previous 'pushed' settings */\n      node = cli_wand->image_info_stack;\n      if ( node != (Stack *) NULL)\n        {\n          if (IsStringTrue(GetImageOption(\n                cli_wand->wand.image_info,\"respect-parenthesis\")) != MagickFalse)\n            option=\"}\"; /* fall-thru so as to pop image settings too */\n          else\n            break;\n        }\n      else\n        break;\n      /* fall thru to next if */\n    }\n    if (LocaleCompare(\"}\",option) == 0) {\n      /* pop image_info settings from stack */\n      Stack\n        *node;\n\n      node = (Stack *)cli_wand->image_info_stack;\n      if ( node == (Stack *) NULL)\n        CLIWandExceptionBreak(OptionError,\"UnbalancedCurlyBraces\",option);\n      cli_wand->image_info_stack = node->next;\n\n      (void) DestroyImageInfo(cli_wand->wand.image_info);\n      cli_wand->wand.image_info = (ImageInfo *)node->data;\n      node = (Stack *)RelinquishMagickMemory(node);\n\n      GetDrawInfo(cli_wand->wand.image_info, cli_wand->draw_info);\n      cli_wand->quantize_info=DestroyQuantizeInfo(cli_wand->quantize_info);\n      cli_wand->quantize_info=AcquireQuantizeInfo(cli_wand->wand.image_info);\n\n      break;\n    }\n      if (LocaleCompare(\"print\",option+1) == 0)\n        {\n          (void) FormatLocaleFile(stdout,\"%s\",arg1);\n          break;\n        }\n    if (LocaleCompare(\"set\",option+1) == 0)\n      {\n        /* Settings are applied to each image in memory in turn (if any).\n           While a option: only need to be applied once globally.\n\n           NOTE: rguments have not been automatically percent expaneded\n        */\n\n        /* escape the 'key' once only, using first image. */\n        arg1=InterpretImageProperties(_image_info,_images,arg1n,_exception);\n        if (arg1 == (char *) NULL)\n          CLIWandExceptionBreak(OptionWarning,\"InterpretPropertyFailure\",\n                option);\n\n        if (LocaleNCompare(arg1,\"registry:\",9) == 0)\n          {\n            if (IfPlusOp)\n              {\n                (void) DeleteImageRegistry(arg1+9);\n                arg1=DestroyString((char *)arg1);\n                break;\n              }\n            arg2=InterpretImageProperties(_image_info,_images,arg2n,_exception);\n            if (arg2 == (char *) NULL) {\n              arg1=DestroyString((char *)arg1);\n              CLIWandExceptionBreak(OptionWarning,\"InterpretPropertyFailure\",\n                    option);\n            }\n            (void) SetImageRegistry(StringRegistryType,arg1+9,arg2,_exception);\n            arg1=DestroyString((char *)arg1);\n            arg2=DestroyString((char *)arg2);\n            break;\n          }\n        if (LocaleNCompare(arg1,\"option:\",7) == 0)\n          {\n            /* delete equivelent artifact from all images (if any) */\n            if (_images != (Image *) NULL)\n              {\n                MagickResetIterator(&cli_wand->wand);\n                while (MagickNextImage(&cli_wand->wand) != MagickFalse)\n                  (void) DeleteImageArtifact(_images,arg1+7);\n                MagickResetIterator(&cli_wand->wand);\n              }\n            /* now set/delete the global option as needed */\n            /* FUTURE: make escapes in a global 'option:' delayed */\n            arg2=(char *) NULL;\n            if (IfNormalOp)\n              {\n                arg2=InterpretImageProperties(_image_info,_images,arg2n,_exception);\n                if (arg2 == (char *) NULL)\n                  CLIWandExceptionBreak(OptionWarning,\n                       \"InterpretPropertyFailure\",option);\n              }\n            (void) SetImageOption(_image_info,arg1+7,arg2);\n            arg1=DestroyString((char *)arg1);\n            arg2=DestroyString((char *)arg2);\n            break;\n          }\n        /* Set Artifacts/Properties/Attributes all images (required) */\n        if ( _images == (Image *) NULL )\n          CLIWandExceptArgBreak(OptionWarning,\"NoImageForProperty\",option,arg1);\n\n        MagickResetIterator(&cli_wand->wand);\n        while (MagickNextImage(&cli_wand->wand) != MagickFalse)\n          {\n            arg2=(char *) NULL;\n            if (IfNormalOp)\n              {\n                arg2=InterpretImageProperties(_image_info,_images,arg2n,_exception);\n                if (arg2 == (char *) NULL)\n                  CLIWandExceptionBreak(OptionWarning,\n                       \"InterpretPropertyFailure\",option);\n              }\n            if (LocaleNCompare(arg1,\"artifact:\",9) == 0)\n              (void) SetImageArtifact(_images,arg1+9,arg2);\n            else if (LocaleNCompare(arg1,\"property:\",9) == 0)\n              (void) SetImageProperty(_images,arg1+9,arg2,_exception);\n            else\n              (void) SetImageProperty(_images,arg1,arg2,_exception);\n            arg2=DestroyString((char *)arg2);\n          }\n        MagickResetIterator(&cli_wand->wand);\n        arg1=DestroyString((char *)arg1);\n        break;\n     }\n    if (LocaleCompare(\"clone\",option+1) == 0) {\n        Image\n          *new_images;\n\n        if (*option == '+')\n          arg1=AcquireString(\"-1\");\n        if (IsSceneGeometry(arg1,MagickFalse) == MagickFalse)\n          CLIWandExceptionBreak(OptionError,\"InvalidArgument\",option);\n        if ( cli_wand->image_list_stack == (Stack *) NULL)\n          CLIWandExceptionBreak(OptionError,\"UnableToCloneImage\",option);\n        new_images = (Image *)cli_wand->image_list_stack->data;\n        if (new_images == (Image *) NULL)\n          CLIWandExceptionBreak(OptionError,\"UnableToCloneImage\",option);\n        new_images=CloneImages(new_images,arg1,_exception);\n        if (new_images == (Image *) NULL)\n          CLIWandExceptionBreak(OptionError,\"NoSuchImage\",option);\n        AppendImageToList(&_images,new_images);\n        break;\n      }\n    /*\n       Informational Operations.\n\n       Note that these do not require either a cli-wand or images!\n       Though currently a cli-wand much be provided regardless.\n    */\n    if (LocaleCompare(\"version\",option+1) == 0)\n      {\n        ListMagickVersion(stdout);\n        break;\n      }\n    if (LocaleCompare(\"list\",option+1) == 0) {\n      /*\n         FUTURE: This 'switch' should really be part of MagickCore\n      */\n      ssize_t\n        list;\n\n      list=ParseCommandOption(MagickListOptions,MagickFalse,arg1);\n      if ( list < 0 ) {\n        CLIWandExceptionArg(OptionError,\"UnrecognizedListType\",option,arg1);\n        break;\n      }\n      switch (list)\n      {\n        case MagickCoderOptions:\n        {\n          (void) ListCoderInfo((FILE *) NULL,_exception);\n          break;\n        }\n        case MagickColorOptions:\n        {\n          (void) ListColorInfo((FILE *) NULL,_exception);\n          break;\n        }\n        case MagickConfigureOptions:\n        {\n          (void) ListConfigureInfo((FILE *) NULL,_exception);\n          break;\n        }\n        case MagickDelegateOptions:\n        {\n          (void) ListDelegateInfo((FILE *) NULL,_exception);\n          break;\n        }\n        case MagickFontOptions:\n        {\n          (void) ListTypeInfo((FILE *) NULL,_exception);\n          break;\n        }\n        case MagickFormatOptions:\n          (void) ListMagickInfo((FILE *) NULL,_exception);\n          break;\n        case MagickLocaleOptions:\n          (void) ListLocaleInfo((FILE *) NULL,_exception);\n          break;\n        case MagickLogOptions:\n          (void) ListLogInfo((FILE *) NULL,_exception);\n          break;\n        case MagickMagicOptions:\n          (void) ListMagicInfo((FILE *) NULL,_exception);\n          break;\n        case MagickMimeOptions:\n          (void) ListMimeInfo((FILE *) NULL,_exception);\n          break;\n        case MagickModuleOptions:\n          (void) ListModuleInfo((FILE *) NULL,_exception);\n          break;\n        case MagickPolicyOptions:\n          (void) ListPolicyInfo((FILE *) NULL,_exception);\n          break;\n        case MagickResourceOptions:\n          (void) ListMagickResourceInfo((FILE *) NULL,_exception);\n          break;\n        case MagickThresholdOptions:\n          (void) ListThresholdMaps((FILE *) NULL,_exception);\n          break;\n        default:\n          (void) ListCommandOptions((FILE *) NULL,(CommandOption) list,\n            _exception);\n          break;\n      }\n      break;\n    }\n\n    CLIWandException(OptionError,\"UnrecognizedOption\",option);\n\nDisableMSCWarning(4127)\n  } while (0);  /* break to exit code. */\nRestoreMSCWarning\n\n  /* clean up percent escape interpreted strings */\n  if (arg1 != arg1n )\n    arg1=DestroyString((char *)arg1);\n  if (arg2 != arg2n )\n    arg2=DestroyString((char *)arg2);\n\n#undef _image_info\n#undef _images\n#undef _exception\n#undef IfNormalOp\n#undef IfPlusOp\n}", "func_hash": 310441418553941793285963012286957612842, "file_name": "operation.c", "file_hash": 209735039697633444699043395330012675070, "cwe": ["CWE-617"], "cve": "CVE-2022-2719", "cve_desc": "In ImageMagick, a crafted file could trigger an assertion failure when a call to WriteImages was made in MagickWand/operation.c, due to a NULL image list. This could potentially cause a denial of service. This was fixed in upstream ImageMagick version 7.1.0-30.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-2719", "file_path": "MagickWand/operation.c"}
{"idx": 359843, "project": "ImageMagick", "commit_id": "716496e6df0add89e9679d6da9c0afca814cfe49", "project_url": "https://github.com/ImageMagick/ImageMagick", "commit_url": "https://github.com/ImageMagick/ImageMagick/commit/716496e6df0add89e9679d6da9c0afca814cfe49", "commit_message": "do not attempt to write a null image list (thanks to Vinay Rohila)", "target": 0, "func": "WandPrivate void CLINoImageOperator(MagickCLI *cli_wand,\n  const char *option,const char *arg1n,const char *arg2n)\n{\n  const char    /* percent escaped versions of the args */\n    *arg1,\n    *arg2;\n\n#define _image_info     (cli_wand->wand.image_info)\n#define _images         (cli_wand->wand.images)\n#define _exception      (cli_wand->wand.exception)\n#define _process_flags  (cli_wand->process_flags)\n#define _option_type    ((CommandOptionFlags) cli_wand->command->flags)\n#define IfNormalOp      (*option=='-')\n#define IfPlusOp        (*option!='-')\n\n  assert(cli_wand != (MagickCLI *) NULL);\n  assert(cli_wand->signature == MagickWandSignature);\n  assert(cli_wand->wand.signature == MagickWandSignature);\n\n  if (cli_wand->wand.debug != MagickFalse)\n    (void) CLILogEvent(cli_wand,CommandEvent,GetMagickModule(),\n      \"- NoImage Operator: %s \\\"%s\\\" \\\"%s\\\"\", option,\n      arg1n != (char *) NULL ? arg1n : \"\",\n      arg2n != (char *) NULL ? arg2n : \"\");\n\n  arg1 = arg1n;\n  arg2 = arg2n;\n\n  /* Interpret Percent Escapes in Arguments - using first image */\n  if ( (((_process_flags & ProcessInterpretProperities) != 0 )\n        || ((_option_type & AlwaysInterpretArgsFlag) != 0)\n       )  && ((_option_type & NeverInterpretArgsFlag) == 0) ) {\n    /* Interpret Percent escapes in argument 1 */\n    if (arg1n != (char *) NULL) {\n      arg1=InterpretImageProperties(_image_info,_images,arg1n,_exception);\n      if (arg1 == (char *) NULL) {\n        CLIWandException(OptionWarning,\"InterpretPropertyFailure\",option);\n        arg1=arg1n;  /* use the given argument as is */\n      }\n    }\n    if (arg2n != (char *) NULL) {\n      arg2=InterpretImageProperties(_image_info,_images,arg2n,_exception);\n      if (arg2 == (char *) NULL) {\n        CLIWandException(OptionWarning,\"InterpretPropertyFailure\",option);\n        arg2=arg2n;  /* use the given argument as is */\n      }\n    }\n  }\n#undef _process_flags\n#undef _option_type\n\n  do {  /* break to exit code */\n    /*\n      No-op options  (ignore these)\n    */\n    if (LocaleCompare(\"noop\",option+1) == 0)   /* zero argument */\n      break;\n    if (LocaleCompare(\"sans\",option+1) == 0)   /* one argument */\n      break;\n    if (LocaleCompare(\"sans0\",option+1) == 0)  /* zero argument */\n      break;\n    if (LocaleCompare(\"sans1\",option+1) == 0)  /* one argument */\n      break;\n    if (LocaleCompare(\"sans2\",option+1) == 0)  /* two arguments */\n      break;\n    /*\n      Image Reading\n    */\n    if ( ( LocaleCompare(\"read\",option+1) == 0 ) ||\n      ( LocaleCompare(\"--\",option) == 0 ) ) {\n      /* Do Glob filename Expansion for 'arg1' then read all images.\n      *\n      * Expansion handles '@', '~', '*', and '?' meta-characters while ignoring\n      * (but attaching to the filenames in the generated argument list) any\n      * [...] read modifiers that may be present.\n      *\n      * For example: It will expand '*.gif[20x20]' into a list such as\n      * 'abc.gif[20x20]',  'foobar.gif[20x20]',  'xyzzy.gif[20x20]'\n      *\n      * NOTE: In IMv6 this was done globally across all images. This\n      * meant you could include IM options in '@filename' lists, but you\n      * could not include comments.   Doing it only for image read makes\n      * it far more secure.\n      *\n      * Note: arguments do not have percent escapes expanded for security\n      * reasons.\n      */\n      int      argc;\n      char     **argv;\n      ssize_t  i;\n\n      argc = 1;\n      argv = (char **) &arg1;\n\n      /* Expand 'glob' expressions in the given filename.\n        Expansion handles any 'coder:' prefix, or read modifiers attached\n        to the filename, including them in the resulting expanded list.\n      */\n      if (ExpandFilenames(&argc,&argv) == MagickFalse)\n        CLIWandExceptArgBreak(ResourceLimitError,\"MemoryAllocationFailed\",\n            option,GetExceptionMessage(errno));\n\n      /* loop over expanded filename list, and read then all in */\n      for (i=0; i < (ssize_t) argc; i++) {\n        Image *\n          new_images;\n        if (_image_info->ping != MagickFalse)\n          new_images=PingImages(_image_info,argv[i],_exception);\n        else\n          new_images=ReadImages(_image_info,argv[i],_exception);\n        AppendImageToList(&_images, new_images);\n        argv[i]=DestroyString(argv[i]);\n      }\n      argv=(char **) RelinquishMagickMemory(argv);\n      break;\n    }\n    /*\n      Image Writing\n      Note: Writing a empty image list is valid in specific cases\n    */\n    if (LocaleCompare(\"write\",option+1) == 0) {\n      /* Note: arguments do not have percent escapes expanded */\n      char\n        key[MagickPathExtent];\n\n      Image\n        *write_images;\n\n      ImageInfo\n        *write_info;\n\n      /* Need images, unless a \"null:\" output coder is used */\n      if ( _images == (Image *) NULL ) {\n        if ( LocaleCompare(arg1,\"null:\") == 0 )\n          break;\n        CLIWandExceptArgBreak(OptionError,\"NoImagesForWrite\",option,arg1);\n      }\n\n      (void) FormatLocaleString(key,MagickPathExtent,\"cache:%s\",arg1);\n      (void) DeleteImageRegistry(key);\n      write_images=CloneImageList(_images,_exception);\n      write_info=CloneImageInfo(_image_info);\n      if (write_images != (Image *) NULL)\n        (void) WriteImages(write_info,write_images,arg1,_exception);\n      write_info=DestroyImageInfo(write_info);\n      write_images=DestroyImageList(write_images);\n      break;\n    }\n    /*\n      Parenthesis and Brace operations\n    */\n    if (LocaleCompare(\"(\",option) == 0) {\n      /* stack 'push' images */\n      Stack\n        *node;\n\n      size_t\n        size;\n\n      size=0;\n      node=cli_wand->image_list_stack;\n      for ( ; node != (Stack *) NULL; node=node->next)\n        size++;\n      if ( size >= MAX_STACK_DEPTH )\n        CLIWandExceptionBreak(OptionError,\"ParenthesisNestedTooDeeply\",option);\n      node=(Stack *) AcquireMagickMemory(sizeof(*node));\n      if (node == (Stack *) NULL)\n        CLIWandExceptionBreak(ResourceLimitFatalError,\n            \"MemoryAllocationFailed\",option);\n      node->data = (void *)cli_wand->wand.images;\n      node->next = cli_wand->image_list_stack;\n      cli_wand->image_list_stack = node;\n      cli_wand->wand.images = NewImageList();\n\n      /* handle respect-parenthesis */\n      if (IsStringTrue(GetImageOption(cli_wand->wand.image_info,\n                    \"respect-parenthesis\")) != MagickFalse)\n        option=\"{\"; /* fall-thru so as to push image settings too */\n      else\n        break;\n      /* fall thru to operation */\n    }\n    if (LocaleCompare(\"{\",option) == 0) {\n      /* stack 'push' of image_info settings */\n      Stack\n        *node;\n\n      size_t\n        size;\n\n      size=0;\n      node=cli_wand->image_info_stack;\n      for ( ; node != (Stack *) NULL; node=node->next)\n        size++;\n      if ( size >= MAX_STACK_DEPTH )\n        CLIWandExceptionBreak(OptionError,\"CurlyBracesNestedTooDeeply\",option);\n      node=(Stack *) AcquireMagickMemory(sizeof(*node));\n      if (node == (Stack *) NULL)\n        CLIWandExceptionBreak(ResourceLimitFatalError,\n            \"MemoryAllocationFailed\",option);\n\n      node->data = (void *)cli_wand->wand.image_info;\n      node->next = cli_wand->image_info_stack;\n\n      cli_wand->image_info_stack = node;\n      cli_wand->wand.image_info = CloneImageInfo(cli_wand->wand.image_info);\n      if (cli_wand->wand.image_info == (ImageInfo *) NULL) {\n        CLIWandException(ResourceLimitFatalError,\"MemoryAllocationFailed\",\n            option);\n        cli_wand->wand.image_info = (ImageInfo *)node->data;\n        node = (Stack *)RelinquishMagickMemory(node);\n        break;\n      }\n\n      break;\n    }\n    if (LocaleCompare(\")\",option) == 0) {\n      /* pop images from stack */\n      Stack\n        *node;\n\n      node = (Stack *)cli_wand->image_list_stack;\n      if ( node == (Stack *) NULL)\n        CLIWandExceptionBreak(OptionError,\"UnbalancedParenthesis\",option);\n      cli_wand->image_list_stack = node->next;\n\n      AppendImageToList((Image **)&node->data,cli_wand->wand.images);\n      cli_wand->wand.images= (Image *)node->data;\n      node = (Stack *)RelinquishMagickMemory(node);\n\n      /* handle respect-parenthesis - of the previous 'pushed' settings */\n      node = cli_wand->image_info_stack;\n      if ( node != (Stack *) NULL)\n        {\n          if (IsStringTrue(GetImageOption(\n                cli_wand->wand.image_info,\"respect-parenthesis\")) != MagickFalse)\n            option=\"}\"; /* fall-thru so as to pop image settings too */\n          else\n            break;\n        }\n      else\n        break;\n      /* fall thru to next if */\n    }\n    if (LocaleCompare(\"}\",option) == 0) {\n      /* pop image_info settings from stack */\n      Stack\n        *node;\n\n      node = (Stack *)cli_wand->image_info_stack;\n      if ( node == (Stack *) NULL)\n        CLIWandExceptionBreak(OptionError,\"UnbalancedCurlyBraces\",option);\n      cli_wand->image_info_stack = node->next;\n\n      (void) DestroyImageInfo(cli_wand->wand.image_info);\n      cli_wand->wand.image_info = (ImageInfo *)node->data;\n      node = (Stack *)RelinquishMagickMemory(node);\n\n      GetDrawInfo(cli_wand->wand.image_info, cli_wand->draw_info);\n      cli_wand->quantize_info=DestroyQuantizeInfo(cli_wand->quantize_info);\n      cli_wand->quantize_info=AcquireQuantizeInfo(cli_wand->wand.image_info);\n\n      break;\n    }\n      if (LocaleCompare(\"print\",option+1) == 0)\n        {\n          (void) FormatLocaleFile(stdout,\"%s\",arg1);\n          break;\n        }\n    if (LocaleCompare(\"set\",option+1) == 0)\n      {\n        /* Settings are applied to each image in memory in turn (if any).\n           While a option: only need to be applied once globally.\n\n           NOTE: rguments have not been automatically percent expaneded\n        */\n\n        /* escape the 'key' once only, using first image. */\n        arg1=InterpretImageProperties(_image_info,_images,arg1n,_exception);\n        if (arg1 == (char *) NULL)\n          CLIWandExceptionBreak(OptionWarning,\"InterpretPropertyFailure\",\n                option);\n\n        if (LocaleNCompare(arg1,\"registry:\",9) == 0)\n          {\n            if (IfPlusOp)\n              {\n                (void) DeleteImageRegistry(arg1+9);\n                arg1=DestroyString((char *)arg1);\n                break;\n              }\n            arg2=InterpretImageProperties(_image_info,_images,arg2n,_exception);\n            if (arg2 == (char *) NULL) {\n              arg1=DestroyString((char *)arg1);\n              CLIWandExceptionBreak(OptionWarning,\"InterpretPropertyFailure\",\n                    option);\n            }\n            (void) SetImageRegistry(StringRegistryType,arg1+9,arg2,_exception);\n            arg1=DestroyString((char *)arg1);\n            arg2=DestroyString((char *)arg2);\n            break;\n          }\n        if (LocaleNCompare(arg1,\"option:\",7) == 0)\n          {\n            /* delete equivelent artifact from all images (if any) */\n            if (_images != (Image *) NULL)\n              {\n                MagickResetIterator(&cli_wand->wand);\n                while (MagickNextImage(&cli_wand->wand) != MagickFalse)\n                  (void) DeleteImageArtifact(_images,arg1+7);\n                MagickResetIterator(&cli_wand->wand);\n              }\n            /* now set/delete the global option as needed */\n            /* FUTURE: make escapes in a global 'option:' delayed */\n            arg2=(char *) NULL;\n            if (IfNormalOp)\n              {\n                arg2=InterpretImageProperties(_image_info,_images,arg2n,_exception);\n                if (arg2 == (char *) NULL)\n                  CLIWandExceptionBreak(OptionWarning,\n                       \"InterpretPropertyFailure\",option);\n              }\n            (void) SetImageOption(_image_info,arg1+7,arg2);\n            arg1=DestroyString((char *)arg1);\n            arg2=DestroyString((char *)arg2);\n            break;\n          }\n        /* Set Artifacts/Properties/Attributes all images (required) */\n        if ( _images == (Image *) NULL )\n          CLIWandExceptArgBreak(OptionWarning,\"NoImageForProperty\",option,arg1);\n\n        MagickResetIterator(&cli_wand->wand);\n        while (MagickNextImage(&cli_wand->wand) != MagickFalse)\n          {\n            arg2=(char *) NULL;\n            if (IfNormalOp)\n              {\n                arg2=InterpretImageProperties(_image_info,_images,arg2n,_exception);\n                if (arg2 == (char *) NULL)\n                  CLIWandExceptionBreak(OptionWarning,\n                       \"InterpretPropertyFailure\",option);\n              }\n            if (LocaleNCompare(arg1,\"artifact:\",9) == 0)\n              (void) SetImageArtifact(_images,arg1+9,arg2);\n            else if (LocaleNCompare(arg1,\"property:\",9) == 0)\n              (void) SetImageProperty(_images,arg1+9,arg2,_exception);\n            else\n              (void) SetImageProperty(_images,arg1,arg2,_exception);\n            arg2=DestroyString((char *)arg2);\n          }\n        MagickResetIterator(&cli_wand->wand);\n        arg1=DestroyString((char *)arg1);\n        break;\n     }\n    if (LocaleCompare(\"clone\",option+1) == 0) {\n        Image\n          *new_images;\n\n        if (*option == '+')\n          arg1=AcquireString(\"-1\");\n        if (IsSceneGeometry(arg1,MagickFalse) == MagickFalse)\n          CLIWandExceptionBreak(OptionError,\"InvalidArgument\",option);\n        if ( cli_wand->image_list_stack == (Stack *) NULL)\n          CLIWandExceptionBreak(OptionError,\"UnableToCloneImage\",option);\n        new_images = (Image *)cli_wand->image_list_stack->data;\n        if (new_images == (Image *) NULL)\n          CLIWandExceptionBreak(OptionError,\"UnableToCloneImage\",option);\n        new_images=CloneImages(new_images,arg1,_exception);\n        if (new_images == (Image *) NULL)\n          CLIWandExceptionBreak(OptionError,\"NoSuchImage\",option);\n        AppendImageToList(&_images,new_images);\n        break;\n      }\n    /*\n       Informational Operations.\n\n       Note that these do not require either a cli-wand or images!\n       Though currently a cli-wand much be provided regardless.\n    */\n    if (LocaleCompare(\"version\",option+1) == 0)\n      {\n        ListMagickVersion(stdout);\n        break;\n      }\n    if (LocaleCompare(\"list\",option+1) == 0) {\n      /*\n         FUTURE: This 'switch' should really be part of MagickCore\n      */\n      ssize_t\n        list;\n\n      list=ParseCommandOption(MagickListOptions,MagickFalse,arg1);\n      if ( list < 0 ) {\n        CLIWandExceptionArg(OptionError,\"UnrecognizedListType\",option,arg1);\n        break;\n      }\n      switch (list)\n      {\n        case MagickCoderOptions:\n        {\n          (void) ListCoderInfo((FILE *) NULL,_exception);\n          break;\n        }\n        case MagickColorOptions:\n        {\n          (void) ListColorInfo((FILE *) NULL,_exception);\n          break;\n        }\n        case MagickConfigureOptions:\n        {\n          (void) ListConfigureInfo((FILE *) NULL,_exception);\n          break;\n        }\n        case MagickDelegateOptions:\n        {\n          (void) ListDelegateInfo((FILE *) NULL,_exception);\n          break;\n        }\n        case MagickFontOptions:\n        {\n          (void) ListTypeInfo((FILE *) NULL,_exception);\n          break;\n        }\n        case MagickFormatOptions:\n          (void) ListMagickInfo((FILE *) NULL,_exception);\n          break;\n        case MagickLocaleOptions:\n          (void) ListLocaleInfo((FILE *) NULL,_exception);\n          break;\n        case MagickLogOptions:\n          (void) ListLogInfo((FILE *) NULL,_exception);\n          break;\n        case MagickMagicOptions:\n          (void) ListMagicInfo((FILE *) NULL,_exception);\n          break;\n        case MagickMimeOptions:\n          (void) ListMimeInfo((FILE *) NULL,_exception);\n          break;\n        case MagickModuleOptions:\n          (void) ListModuleInfo((FILE *) NULL,_exception);\n          break;\n        case MagickPolicyOptions:\n          (void) ListPolicyInfo((FILE *) NULL,_exception);\n          break;\n        case MagickResourceOptions:\n          (void) ListMagickResourceInfo((FILE *) NULL,_exception);\n          break;\n        case MagickThresholdOptions:\n          (void) ListThresholdMaps((FILE *) NULL,_exception);\n          break;\n        default:\n          (void) ListCommandOptions((FILE *) NULL,(CommandOption) list,\n            _exception);\n          break;\n      }\n      break;\n    }\n\n    CLIWandException(OptionError,\"UnrecognizedOption\",option);\n\nDisableMSCWarning(4127)\n  } while (0);  /* break to exit code. */\nRestoreMSCWarning\n\n  /* clean up percent escape interpreted strings */\n  if (arg1 != arg1n )\n    arg1=DestroyString((char *)arg1);\n  if (arg2 != arg2n )\n    arg2=DestroyString((char *)arg2);\n\n#undef _image_info\n#undef _images\n#undef _exception\n#undef IfNormalOp\n#undef IfPlusOp\n}", "func_hash": 579576062025196307167021581529787649, "file_name": "operation.c", "file_hash": 114606754670284270817581814822080534295, "cwe": ["CWE-617"], "cve": "CVE-2022-2719", "cve_desc": "In ImageMagick, a crafted file could trigger an assertion failure when a call to WriteImages was made in MagickWand/operation.c, due to a NULL image list. This could potentially cause a denial of service. This was fixed in upstream ImageMagick version 7.1.0-30.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-2719", "file_path": "MagickWand/operation.c"}
