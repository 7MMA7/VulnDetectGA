{"idx": 206625, "project": "raptor", "commit_id": "590681e546cd9aa18d57dc2ea1858cb734a3863f", "project_url": "https://github.com/dajobe/raptor", "commit_url": "https://github.com/dajobe/raptor/commit/590681e546cd9aa18d57dc2ea1858cb734a3863f", "commit_message": "Calcualte max nspace declarations correctly for XML writer\n\n(raptor_xml_writer_start_element_common): Calculate max including for\neach attribute a potential name and value.\n\nFixes Issues #0000617 http://bugs.librdf.org/mantis/view.php?id=617\nand #0000618 http://bugs.librdf.org/mantis/view.php?id=618", "target": 1, "func": "raptor_xml_writer_start_element_common(raptor_xml_writer* xml_writer,\n                                       raptor_xml_element* element,\n                                       int auto_empty)\n{\n  raptor_iostream* iostr = xml_writer->iostr;\n  raptor_namespace_stack *nstack = xml_writer->nstack;\n  int depth = xml_writer->depth;\n  int auto_indent = XML_WRITER_AUTO_INDENT(xml_writer);\n  struct nsd *nspace_declarations = NULL;\n  size_t nspace_declarations_count = 0;  \n  unsigned int i;\n\n  /* max is 1 per element and 1 for each attribute + size of declared */\n  if(nstack) {\n    int nspace_max_count = element->attribute_count+1;\n    if(element->declared_nspaces)\n      nspace_max_count += raptor_sequence_size(element->declared_nspaces);\n    if(element->xml_language)\n      nspace_max_count++;\n\n    nspace_declarations = RAPTOR_CALLOC(struct nsd*, nspace_max_count,\n                                        sizeof(struct nsd));\n    if(!nspace_declarations)\n      return 1;\n  }\n\n  if(element->name->nspace) {\n    if(nstack && !raptor_namespaces_namespace_in_scope(nstack, element->name->nspace)) {\n      nspace_declarations[0].declaration=\n        raptor_namespace_format_as_xml(element->name->nspace,\n                                       &nspace_declarations[0].length);\n      if(!nspace_declarations[0].declaration)\n        goto error;\n      nspace_declarations[0].nspace = element->name->nspace;\n      nspace_declarations_count++;\n    }\n  }\n\n  if(nstack && element->attributes) {\n    for(i = 0; i < element->attribute_count; i++) {\n      /* qname */\n      if(element->attributes[i]->nspace) {\n        /* Check if we need a namespace declaration attribute */\n        if(nstack && \n           !raptor_namespaces_namespace_in_scope(nstack, element->attributes[i]->nspace) && element->attributes[i]->nspace != element->name->nspace) {\n          /* not in scope and not same as element (so already going to be declared)*/\n          unsigned int j;\n          int declare_me = 1;\n          \n          /* check it wasn't an earlier declaration too */\n          for(j = 0; j < nspace_declarations_count; j++)\n            if(nspace_declarations[j].nspace == element->attributes[j]->nspace) {\n              declare_me = 0;\n              break;\n            }\n            \n          if(declare_me) {\n            nspace_declarations[nspace_declarations_count].declaration=\n              raptor_namespace_format_as_xml(element->attributes[i]->nspace,\n                                             &nspace_declarations[nspace_declarations_count].length);\n            if(!nspace_declarations[nspace_declarations_count].declaration)\n              goto error;\n            nspace_declarations[nspace_declarations_count].nspace = element->attributes[i]->nspace;\n            nspace_declarations_count++;\n          }\n        }\n      }\n\n      /* Add the attribute + value */\n      nspace_declarations[nspace_declarations_count].declaration=\n        raptor_qname_format_as_xml(element->attributes[i],\n                                   &nspace_declarations[nspace_declarations_count].length);\n      if(!nspace_declarations[nspace_declarations_count].declaration)\n        goto error;\n      nspace_declarations[nspace_declarations_count].nspace = NULL;\n      nspace_declarations_count++;\n\n    }\n  }\n\n  if(nstack && element->declared_nspaces &&\n     raptor_sequence_size(element->declared_nspaces) > 0) {\n    for(i = 0; i< (unsigned int)raptor_sequence_size(element->declared_nspaces); i++) {\n      raptor_namespace* nspace = (raptor_namespace*)raptor_sequence_get_at(element->declared_nspaces, i);\n      unsigned int j;\n      int declare_me = 1;\n      \n      /* check it wasn't an earlier declaration too */\n      for(j = 0; j < nspace_declarations_count; j++)\n        if(nspace_declarations[j].nspace == nspace) {\n          declare_me = 0;\n          break;\n        }\n      \n      if(declare_me) {\n        nspace_declarations[nspace_declarations_count].declaration=\n          raptor_namespace_format_as_xml(nspace,\n                                         &nspace_declarations[nspace_declarations_count].length);\n        if(!nspace_declarations[nspace_declarations_count].declaration)\n          goto error;\n        nspace_declarations[nspace_declarations_count].nspace = nspace;\n        nspace_declarations_count++;\n      }\n\n    }\n  }\n\n  if(nstack && element->xml_language) {\n    size_t lang_len = strlen(RAPTOR_GOOD_CAST(char*, element->xml_language));\n#define XML_LANG_PREFIX_LEN 10\n    size_t buf_length = XML_LANG_PREFIX_LEN + lang_len + 1;\n    unsigned char* buffer = RAPTOR_MALLOC(unsigned char*, buf_length + 1);\n    const char quote = '\\\"';\n    unsigned char* p;\n\n    memcpy(buffer, \"xml:lang=\\\"\", XML_LANG_PREFIX_LEN);\n    p = buffer + XML_LANG_PREFIX_LEN;\n    p += raptor_xml_escape_string(xml_writer->world,\n                                  element->xml_language, lang_len,\n                                  p, buf_length, quote);\n    *p++ = quote;\n    *p = '\\0';\n\n    nspace_declarations[nspace_declarations_count].declaration = buffer;\n    nspace_declarations[nspace_declarations_count].length = buf_length;\n    nspace_declarations[nspace_declarations_count].nspace = NULL;\n    nspace_declarations_count++;\n  }\n  \n\n  raptor_iostream_write_byte('<', iostr);\n\n  if(element->name->nspace && element->name->nspace->prefix_length > 0) {\n    raptor_iostream_counted_string_write((const char*)element->name->nspace->prefix, \n                                         element->name->nspace->prefix_length,\n                                         iostr);\n    raptor_iostream_write_byte(':', iostr);\n  }\n  raptor_iostream_counted_string_write((const char*)element->name->local_name,\n                                       element->name->local_name_length,\n                                       iostr);\n\n  /* declare namespaces and attributes */\n  if(nspace_declarations_count) {\n    int need_indent = 0;\n    \n    /* sort them into the canonical order */\n    qsort((void*)nspace_declarations, \n          nspace_declarations_count, sizeof(struct nsd),\n          raptor_xml_writer_nsd_compare);\n\n    /* declare namespaces first */\n    for(i = 0; i < nspace_declarations_count; i++) {\n      if(!nspace_declarations[i].nspace)\n        continue;\n\n      if(auto_indent && need_indent) {\n        /* indent attributes */\n        raptor_xml_writer_newline(xml_writer);\n        xml_writer->depth++;\n        raptor_xml_writer_indent(xml_writer);\n        xml_writer->depth--;\n      }\n      raptor_iostream_write_byte(' ', iostr);\n      raptor_iostream_counted_string_write((const char*)nspace_declarations[i].declaration,\n                                           nspace_declarations[i].length,\n                                           iostr);\n      RAPTOR_FREE(char*, nspace_declarations[i].declaration);\n      nspace_declarations[i].declaration = NULL;\n      need_indent = 1;\n      \n      if(raptor_namespace_stack_start_namespace(nstack,\n                                                (raptor_namespace*)nspace_declarations[i].nspace,\n                                                depth))\n        goto error;\n    }\n\n    /* declare attributes */\n    for(i = 0; i < nspace_declarations_count; i++) {\n      if(nspace_declarations[i].nspace)\n        continue;\n\n      if(auto_indent && need_indent) {\n        /* indent attributes */\n        raptor_xml_writer_newline(xml_writer);\n        xml_writer->depth++;\n        raptor_xml_writer_indent(xml_writer);\n        xml_writer->depth--;\n      }\n      raptor_iostream_write_byte(' ', iostr);\n      raptor_iostream_counted_string_write((const char*)nspace_declarations[i].declaration,\n                                           nspace_declarations[i].length,\n                                           iostr);\n      need_indent = 1;\n\n      RAPTOR_FREE(char*, nspace_declarations[i].declaration);\n      nspace_declarations[i].declaration = NULL;\n    }\n  }\n\n  if(!auto_empty)\n    raptor_iostream_write_byte('>', iostr);\n\n  if(nstack)\n    RAPTOR_FREE(stringarray, nspace_declarations);\n\n  return 0;\n\n  /* Clean up nspace_declarations on error */\n  error:\n\n  for(i = 0; i < nspace_declarations_count; i++) {\n    if(nspace_declarations[i].declaration)\n      RAPTOR_FREE(char*, nspace_declarations[i].declaration);\n  }\n\n  RAPTOR_FREE(stringarray, nspace_declarations);\n\n  return 1;\n}", "func_hash": 183974089624650942434351568312452779610, "file_name": "raptor_xml_writer.c", "file_hash": 303005196227120175198140448209688194758, "cwe": ["CWE-787"], "cve": "CVE-2017-18926", "cve_desc": "raptor_xml_writer_start_element_common in raptor_xml_writer.c in Raptor RDF Syntax Library 2.0.15 miscalculates the maximum nspace declarations for the XML writer, leading to heap-based buffer overflows (sometimes seen in raptor_qname_format_as_xml).", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-18926", "file_path": "src/raptor_xml_writer.c"}
{"idx": 384124, "project": "raptor", "commit_id": "590681e546cd9aa18d57dc2ea1858cb734a3863f", "project_url": "https://github.com/dajobe/raptor", "commit_url": "https://github.com/dajobe/raptor/commit/590681e546cd9aa18d57dc2ea1858cb734a3863f", "commit_message": "Calcualte max nspace declarations correctly for XML writer\n\n(raptor_xml_writer_start_element_common): Calculate max including for\neach attribute a potential name and value.\n\nFixes Issues #0000617 http://bugs.librdf.org/mantis/view.php?id=617\nand #0000618 http://bugs.librdf.org/mantis/view.php?id=618", "target": 0, "func": "raptor_xml_writer_start_element_common(raptor_xml_writer* xml_writer,\n                                       raptor_xml_element* element,\n                                       int auto_empty)\n{\n  raptor_iostream* iostr = xml_writer->iostr;\n  raptor_namespace_stack *nstack = xml_writer->nstack;\n  int depth = xml_writer->depth;\n  int auto_indent = XML_WRITER_AUTO_INDENT(xml_writer);\n  struct nsd *nspace_declarations = NULL;\n  size_t nspace_declarations_count = 0;  \n  unsigned int i;\n\n  if(nstack) {\n    int nspace_max_count = element->attribute_count * 2; /* attr and value */\n    if(element->name->nspace)\n      nspace_max_count++;\n    if(element->declared_nspaces)\n      nspace_max_count += raptor_sequence_size(element->declared_nspaces);\n    if(element->xml_language)\n      nspace_max_count++;\n\n    nspace_declarations = RAPTOR_CALLOC(struct nsd*, nspace_max_count,\n                                        sizeof(struct nsd));\n    if(!nspace_declarations)\n      return 1;\n  }\n\n  if(element->name->nspace) {\n    if(nstack && !raptor_namespaces_namespace_in_scope(nstack, element->name->nspace)) {\n      nspace_declarations[0].declaration=\n        raptor_namespace_format_as_xml(element->name->nspace,\n                                       &nspace_declarations[0].length);\n      if(!nspace_declarations[0].declaration)\n        goto error;\n      nspace_declarations[0].nspace = element->name->nspace;\n      nspace_declarations_count++;\n    }\n  }\n\n  if(nstack && element->attributes) {\n    for(i = 0; i < element->attribute_count; i++) {\n      /* qname */\n      if(element->attributes[i]->nspace) {\n        /* Check if we need a namespace declaration attribute */\n        if(nstack && \n           !raptor_namespaces_namespace_in_scope(nstack, element->attributes[i]->nspace) && element->attributes[i]->nspace != element->name->nspace) {\n          /* not in scope and not same as element (so already going to be declared)*/\n          unsigned int j;\n          int declare_me = 1;\n          \n          /* check it wasn't an earlier declaration too */\n          for(j = 0; j < nspace_declarations_count; j++)\n            if(nspace_declarations[j].nspace == element->attributes[j]->nspace) {\n              declare_me = 0;\n              break;\n            }\n            \n          if(declare_me) {\n            nspace_declarations[nspace_declarations_count].declaration=\n              raptor_namespace_format_as_xml(element->attributes[i]->nspace,\n                                             &nspace_declarations[nspace_declarations_count].length);\n            if(!nspace_declarations[nspace_declarations_count].declaration)\n              goto error;\n            nspace_declarations[nspace_declarations_count].nspace = element->attributes[i]->nspace;\n            nspace_declarations_count++;\n          }\n        }\n      }\n\n      /* Add the attribute's value */\n      nspace_declarations[nspace_declarations_count].declaration=\n        raptor_qname_format_as_xml(element->attributes[i],\n                                   &nspace_declarations[nspace_declarations_count].length);\n      if(!nspace_declarations[nspace_declarations_count].declaration)\n        goto error;\n      nspace_declarations[nspace_declarations_count].nspace = NULL;\n      nspace_declarations_count++;\n\n    }\n  }\n\n  if(nstack && element->declared_nspaces &&\n     raptor_sequence_size(element->declared_nspaces) > 0) {\n    for(i = 0; i< (unsigned int)raptor_sequence_size(element->declared_nspaces); i++) {\n      raptor_namespace* nspace = (raptor_namespace*)raptor_sequence_get_at(element->declared_nspaces, i);\n      unsigned int j;\n      int declare_me = 1;\n      \n      /* check it wasn't an earlier declaration too */\n      for(j = 0; j < nspace_declarations_count; j++)\n        if(nspace_declarations[j].nspace == nspace) {\n          declare_me = 0;\n          break;\n        }\n      \n      if(declare_me) {\n        nspace_declarations[nspace_declarations_count].declaration=\n          raptor_namespace_format_as_xml(nspace,\n                                         &nspace_declarations[nspace_declarations_count].length);\n        if(!nspace_declarations[nspace_declarations_count].declaration)\n          goto error;\n        nspace_declarations[nspace_declarations_count].nspace = nspace;\n        nspace_declarations_count++;\n      }\n\n    }\n  }\n\n  if(nstack && element->xml_language) {\n    size_t lang_len = strlen(RAPTOR_GOOD_CAST(char*, element->xml_language));\n#define XML_LANG_PREFIX_LEN 10\n    size_t buf_length = XML_LANG_PREFIX_LEN + lang_len + 1;\n    unsigned char* buffer = RAPTOR_MALLOC(unsigned char*, buf_length + 1);\n    const char quote = '\\\"';\n    unsigned char* p;\n\n    memcpy(buffer, \"xml:lang=\\\"\", XML_LANG_PREFIX_LEN);\n    p = buffer + XML_LANG_PREFIX_LEN;\n    p += raptor_xml_escape_string(xml_writer->world,\n                                  element->xml_language, lang_len,\n                                  p, buf_length, quote);\n    *p++ = quote;\n    *p = '\\0';\n\n    nspace_declarations[nspace_declarations_count].declaration = buffer;\n    nspace_declarations[nspace_declarations_count].length = buf_length;\n    nspace_declarations[nspace_declarations_count].nspace = NULL;\n    nspace_declarations_count++;\n  }\n  \n\n  raptor_iostream_write_byte('<', iostr);\n\n  if(element->name->nspace && element->name->nspace->prefix_length > 0) {\n    raptor_iostream_counted_string_write((const char*)element->name->nspace->prefix, \n                                         element->name->nspace->prefix_length,\n                                         iostr);\n    raptor_iostream_write_byte(':', iostr);\n  }\n  raptor_iostream_counted_string_write((const char*)element->name->local_name,\n                                       element->name->local_name_length,\n                                       iostr);\n\n  /* declare namespaces and attributes */\n  if(nspace_declarations_count) {\n    int need_indent = 0;\n    \n    /* sort them into the canonical order */\n    qsort((void*)nspace_declarations, \n          nspace_declarations_count, sizeof(struct nsd),\n          raptor_xml_writer_nsd_compare);\n\n    /* declare namespaces first */\n    for(i = 0; i < nspace_declarations_count; i++) {\n      if(!nspace_declarations[i].nspace)\n        continue;\n\n      if(auto_indent && need_indent) {\n        /* indent attributes */\n        raptor_xml_writer_newline(xml_writer);\n        xml_writer->depth++;\n        raptor_xml_writer_indent(xml_writer);\n        xml_writer->depth--;\n      }\n      raptor_iostream_write_byte(' ', iostr);\n      raptor_iostream_counted_string_write((const char*)nspace_declarations[i].declaration,\n                                           nspace_declarations[i].length,\n                                           iostr);\n      RAPTOR_FREE(char*, nspace_declarations[i].declaration);\n      nspace_declarations[i].declaration = NULL;\n      need_indent = 1;\n      \n      if(raptor_namespace_stack_start_namespace(nstack,\n                                                (raptor_namespace*)nspace_declarations[i].nspace,\n                                                depth))\n        goto error;\n    }\n\n    /* declare attributes */\n    for(i = 0; i < nspace_declarations_count; i++) {\n      if(nspace_declarations[i].nspace)\n        continue;\n\n      if(auto_indent && need_indent) {\n        /* indent attributes */\n        raptor_xml_writer_newline(xml_writer);\n        xml_writer->depth++;\n        raptor_xml_writer_indent(xml_writer);\n        xml_writer->depth--;\n      }\n      raptor_iostream_write_byte(' ', iostr);\n      raptor_iostream_counted_string_write((const char*)nspace_declarations[i].declaration,\n                                           nspace_declarations[i].length,\n                                           iostr);\n      need_indent = 1;\n\n      RAPTOR_FREE(char*, nspace_declarations[i].declaration);\n      nspace_declarations[i].declaration = NULL;\n    }\n  }\n\n  if(!auto_empty)\n    raptor_iostream_write_byte('>', iostr);\n\n  if(nstack)\n    RAPTOR_FREE(stringarray, nspace_declarations);\n\n  return 0;\n\n  /* Clean up nspace_declarations on error */\n  error:\n\n  for(i = 0; i < nspace_declarations_count; i++) {\n    if(nspace_declarations[i].declaration)\n      RAPTOR_FREE(char*, nspace_declarations[i].declaration);\n  }\n\n  RAPTOR_FREE(stringarray, nspace_declarations);\n\n  return 1;\n}", "func_hash": 82963305933956175677502497774267767451, "file_name": "raptor_xml_writer.c", "file_hash": 139112831165877018854969912519011883099, "cwe": ["CWE-787"], "cve": "CVE-2017-18926", "cve_desc": "raptor_xml_writer_start_element_common in raptor_xml_writer.c in Raptor RDF Syntax Library 2.0.15 miscalculates the maximum nspace declarations for the XML writer, leading to heap-based buffer overflows (sometimes seen in raptor_qname_format_as_xml).", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-18926", "file_path": "src/raptor_xml_writer.c"}
