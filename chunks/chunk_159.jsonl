{"idx": 214003, "project": "libvncserver", "commit_id": "7b1ef0ffc4815cab9a96c7278394152bdc89dc4d", "project_url": "https://github.com/LibVNC/libvncserver", "commit_url": "https://github.com/LibVNC/libvncserver/commit/7b1ef0ffc4815cab9a96c7278394152bdc89dc4d", "commit_message": "LibVNCClient: really fix #250", "target": 1, "func": "HandleCoRREBPP (rfbClient* client, int rx, int ry, int rw, int rh)\n{\n    rfbRREHeader hdr;\n    int i;\n    CARDBPP pix;\n    uint8_t *ptr;\n    int x, y, w, h;\n\n    if (!ReadFromRFBServer(client, (char *)&hdr, sz_rfbRREHeader))\n\treturn FALSE;\n\n    hdr.nSubrects = rfbClientSwap32IfLE(hdr.nSubrects);\n\n    if (!ReadFromRFBServer(client, (char *)&pix, sizeof(pix)))\n\treturn FALSE;\n\n    client->GotFillRect(client, rx, ry, rw, rh, pix);\n\n    if (hdr.nSubrects * (4 + (BPP / 8)) > RFB_BUFFER_SIZE || !ReadFromRFBServer(client, client->buffer, hdr.nSubrects * (4 + (BPP / 8))))\n\treturn FALSE;\n\n    ptr = (uint8_t *)client->buffer;\n\n    for (i = 0; i < hdr.nSubrects; i++) {\n\tpix = *(CARDBPP *)ptr;\n\tptr += BPP/8;\n\tx = *ptr++;\n\ty = *ptr++;\n\tw = *ptr++;\n\th = *ptr++;\n\n\tclient->GotFillRect(client, rx+x, ry+y, w, h, pix);\n    }\n\n    return TRUE;\n}", "func_hash": 237803274447948071871623859823888407579, "file_name": "corre.c", "file_hash": 261775603875912977761086457849276889433, "cwe": ["CWE-787"], "cve": "CVE-2018-20020", "cve_desc": "LibVNC before commit 7b1ef0ffc4815cab9a96c7278394152bdc89dc4d contains heap out-of-bound write vulnerability inside structure in VNC client code that can result remote code execution", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2018-20020", "file_path": "libvncclient/corre.c"}
{"idx": 474462, "project": "libvncserver", "commit_id": "7b1ef0ffc4815cab9a96c7278394152bdc89dc4d", "project_url": "https://github.com/LibVNC/libvncserver", "commit_url": "https://github.com/LibVNC/libvncserver/commit/7b1ef0ffc4815cab9a96c7278394152bdc89dc4d", "commit_message": "LibVNCClient: really fix #250", "target": 0, "func": "HandleCoRREBPP (rfbClient* client, int rx, int ry, int rw, int rh)\n{\n    rfbRREHeader hdr;\n    int i;\n    CARDBPP pix;\n    uint8_t *ptr;\n    int x, y, w, h;\n\n    if (!ReadFromRFBServer(client, (char *)&hdr, sz_rfbRREHeader))\n\treturn FALSE;\n\n    hdr.nSubrects = rfbClientSwap32IfLE(hdr.nSubrects);\n\n    if (!ReadFromRFBServer(client, (char *)&pix, sizeof(pix)))\n\treturn FALSE;\n\n    client->GotFillRect(client, rx, ry, rw, rh, pix);\n\n    if (hdr.nSubrects > RFB_BUFFER_SIZE / (4 + (BPP / 8)) || !ReadFromRFBServer(client, client->buffer, hdr.nSubrects * (4 + (BPP / 8))))\n\treturn FALSE;\n\n    ptr = (uint8_t *)client->buffer;\n\n    for (i = 0; i < hdr.nSubrects; i++) {\n\tpix = *(CARDBPP *)ptr;\n\tptr += BPP/8;\n\tx = *ptr++;\n\ty = *ptr++;\n\tw = *ptr++;\n\th = *ptr++;\n\n\tclient->GotFillRect(client, rx+x, ry+y, w, h, pix);\n    }\n\n    return TRUE;\n}", "func_hash": 270120955611228778905999334086826608945, "file_name": "corre.c", "file_hash": 95538594092483864981062945399271614171, "cwe": ["CWE-787"], "cve": "CVE-2018-20020", "cve_desc": "LibVNC before commit 7b1ef0ffc4815cab9a96c7278394152bdc89dc4d contains heap out-of-bound write vulnerability inside structure in VNC client code that can result remote code execution", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2018-20020", "file_path": "libvncclient/corre.c"}
{"idx": 214124, "project": "chafa", "commit_id": "e6ce3746cdcf0836b9dae659a5aed15d73a080d8", "project_url": "https://github.com/hpjansson/chafa", "commit_url": "https://github.com/hpjansson/chafa/commit/e6ce3746cdcf0836b9dae659a5aed15d73a080d8", "commit_message": "libnsgif: fix oob in lzw_decode", "target": 1, "func": "lzw_result lzw_decode(struct lzw_ctx *ctx,\n\t\tconst uint8_t ** const stack_pos_out)\n{\n\tlzw_result res;\n\tuint32_t code_new;\n\tuint32_t code_out;\n\tuint8_t last_value;\n\tuint8_t *stack_pos = ctx->stack_base;\n\tuint32_t clear_code = ctx->clear_code;\n\tuint32_t current_entry = ctx->current_entry;\n\tstruct lzw_dictionary_entry * const table = ctx->table;\n\n\t/* Get a new code from the input */\n\tres = lzw__next_code(&ctx->input, ctx->current_code_size, &code_new);\n\tif (res != LZW_OK) {\n\t\treturn res;\n\t}\n\n\t/* Handle the new code */\n\tif (code_new == clear_code) {\n\t\t/* Got Clear code */\n\t\treturn lzw__clear_codes(ctx, stack_pos_out);\n\n\t} else if (code_new == ctx->eoi_code) {\n\t\t/* Got End of Information code */\n\t\treturn LZW_EOI_CODE;\n\n\t} else if (code_new > current_entry) {\n\t\t/* Code is invalid */\n\t\treturn LZW_BAD_CODE;\n\n\t} else if (code_new < current_entry) {\n\t\t/* Code is in table */\n\t\tcode_out = code_new;\n\t\tlast_value = table[code_new].first_value;\n\t} else {\n\t\t/* Code not in table */\n\t\t*stack_pos++ = ctx->previous_code_first;\n\t\tcode_out = ctx->previous_code;\n\t\tlast_value = ctx->previous_code_first;\n\t}\n\n\t/* Add to the dictionary, only if there's space */\n\tif (current_entry < (1 << LZW_CODE_MAX)) {\n\t\tstruct lzw_dictionary_entry *entry = table + current_entry;\n\t\tentry->last_value     = last_value;\n\t\tentry->first_value    = ctx->previous_code_first;\n\t\tentry->previous_entry = ctx->previous_code;\n\t\tctx->current_entry++;\n\t}\n\n\t/* Ensure code size is increased, if needed. */\n\tif (current_entry == ctx->current_code_size_max) {\n\t\tif (ctx->current_code_size < LZW_CODE_MAX) {\n\t\t\tctx->current_code_size++;\n\t\t\tctx->current_code_size_max =\n\t\t\t\t\t(1 << ctx->current_code_size) - 1;\n\t\t}\n\t}\n\n\t/* Store details of this code as \"previous code\" to the context. */\n\tctx->previous_code_first = table[code_new].first_value;\n\tctx->previous_code = code_new;\n\n\t/* Put rest of data for this code on output stack.\n\t * Note, in the case of \"code not in table\", the last entry of the\n\t * current code has already been placed on the stack above. */\n\twhile (code_out > clear_code) {\n\t\tstruct lzw_dictionary_entry *entry = table + code_out;\n\t\t*stack_pos++ = entry->last_value;\n\t\tcode_out = entry->previous_entry;\n\t}\n\t*stack_pos++ = table[code_out].last_value;\n\n\t*stack_pos_out = stack_pos;\n\treturn LZW_OK;\n}", "func_hash": 197312030105469318680562726195282198881, "file_name": "lzw.c", "file_hash": 206609516216923718063023254663769273017, "cwe": ["CWE-125"], "cve": "CVE-2022-2061", "cve_desc": "Heap-based Buffer Overflow in GitHub repository hpjansson/chafa prior to 1.12.0.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-2061", "file_path": "libnsgif/lzw.c"}
{"idx": 475987, "project": "chafa", "commit_id": "e6ce3746cdcf0836b9dae659a5aed15d73a080d8", "project_url": "https://github.com/hpjansson/chafa", "commit_url": "https://github.com/hpjansson/chafa/commit/e6ce3746cdcf0836b9dae659a5aed15d73a080d8", "commit_message": "libnsgif: fix oob in lzw_decode", "target": 0, "func": "lzw_result lzw_decode(struct lzw_ctx *ctx,\n\t\tconst uint8_t ** const stack_pos_out)\n{\n\tlzw_result res;\n\tuint32_t code_new;\n\tuint32_t code_out;\n\tuint8_t last_value;\n\tuint8_t *stack_pos = ctx->stack_base;\n\tuint32_t clear_code = ctx->clear_code;\n\tuint32_t current_entry = ctx->current_entry;\n\tstruct lzw_dictionary_entry * const table = ctx->table;\n\n\t/* Get a new code from the input */\n\tres = lzw__next_code(&ctx->input, ctx->current_code_size, &code_new);\n\tif (res != LZW_OK) {\n\t\treturn res;\n\t}\n\n\t/* Handle the new code */\n\tif (code_new == clear_code) {\n\t\t/* Got Clear code */\n\t\treturn lzw__clear_codes(ctx, stack_pos_out);\n\n\t} else if (code_new == ctx->eoi_code) {\n\t\t/* Got End of Information code */\n\t\treturn LZW_EOI_CODE;\n\n\t} else if (code_new > current_entry) {\n\t\t/* Code is invalid */\n\t\treturn LZW_BAD_CODE;\n\n\t} else if (code_new >= 1 << LZW_CODE_MAX) {\n\t\t/* Don't access out of bound */\n\t\treturn LZW_BAD_CODE;\n\n\t} else if (code_new < current_entry) {\n\t\t/* Code is in table */\n\t\tcode_out = code_new;\n\t\tlast_value = table[code_new].first_value;\n\t} else {\n\t\t/* Code not in table */\n\t\t*stack_pos++ = ctx->previous_code_first;\n\t\tcode_out = ctx->previous_code;\n\t\tlast_value = ctx->previous_code_first;\n\t}\n\n\t/* Add to the dictionary, only if there's space */\n\tif (current_entry < (1 << LZW_CODE_MAX)) {\n\t\tstruct lzw_dictionary_entry *entry = table + current_entry;\n\t\tentry->last_value     = last_value;\n\t\tentry->first_value    = ctx->previous_code_first;\n\t\tentry->previous_entry = ctx->previous_code;\n\t\tctx->current_entry++;\n\t}\n\n\t/* Ensure code size is increased, if needed. */\n\tif (current_entry == ctx->current_code_size_max) {\n\t\tif (ctx->current_code_size < LZW_CODE_MAX) {\n\t\t\tctx->current_code_size++;\n\t\t\tctx->current_code_size_max =\n\t\t\t\t\t(1 << ctx->current_code_size) - 1;\n\t\t}\n\t}\n\n\t/* Store details of this code as \"previous code\" to the context. */\n\tctx->previous_code_first = table[code_new].first_value;\n\tctx->previous_code = code_new;\n\n\t/* Put rest of data for this code on output stack.\n\t * Note, in the case of \"code not in table\", the last entry of the\n\t * current code has already been placed on the stack above. */\n\twhile (code_out > clear_code) {\n\t\tstruct lzw_dictionary_entry *entry = table + code_out;\n\t\t*stack_pos++ = entry->last_value;\n\t\tcode_out = entry->previous_entry;\n\t}\n\t*stack_pos++ = table[code_out].last_value;\n\n\t*stack_pos_out = stack_pos;\n\treturn LZW_OK;\n}", "func_hash": 232258018845507324994493987384082077230, "file_name": "lzw.c", "file_hash": 168965779407481929590316655829608211083, "cwe": ["CWE-125"], "cve": "CVE-2022-2061", "cve_desc": "Heap-based Buffer Overflow in GitHub repository hpjansson/chafa prior to 1.12.0.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-2061", "file_path": "libnsgif/lzw.c"}
