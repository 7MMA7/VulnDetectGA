{"idx": 206771, "project": "qcad", "commit_id": "1eeffc5daf5a06cf6213ffc19e95923cdebb2eb8", "project_url": "https://github.com/qcad/qcad", "commit_url": "https://github.com/qcad/qcad/commit/1eeffc5daf5a06cf6213ffc19e95923cdebb2eb8", "commit_message": "check vertexIndex which might be -1 for broken DXF", "target": 1, "func": "bool DL_Dxf::handleLWPolylineData(DL_CreationInterface* /*creationInterface*/) {\n    // Allocate LWPolyline vertices (group code 90):\n    if (groupCode==90) {\n        maxVertices = toInt(groupValue);\n        if (maxVertices>0) {\n            if (vertices!=NULL) {\n                delete[] vertices;\n            }\n            vertices = new double[4*maxVertices];\n            for (int i=0; i<maxVertices; ++i) {\n                vertices[i*4] = 0.0;\n                vertices[i*4+1] = 0.0;\n                vertices[i*4+2] = 0.0;\n                vertices[i*4+3] = 0.0;\n            }\n        }\n        vertexIndex=-1;\n        return true;\n    }\n\n    // Process LWPolylines vertices (group codes 10/20/30/42):\n    else if (groupCode==10 || groupCode==20 ||\n             groupCode==30 || groupCode==42) {\n\n        if (vertexIndex<maxVertices-1 && groupCode==10) {\n            vertexIndex++;\n        }\n\n        if (groupCode<=30) {\n            if (vertexIndex>=0 && vertexIndex<maxVertices) {\n                vertices[4*vertexIndex + (groupCode/10-1)] = toReal(groupValue);\n            }\n        } else if (groupCode==42 && vertexIndex<maxVertices) {\n            vertices[4*vertexIndex + 3] = toReal(groupValue);\n        }\n        return true;\n    }\n    return false;\n}", "func_hash": 109412697930486379897697175336143106380, "file_name": "dl_dxf.cpp", "file_hash": 313944639125792713455398286070640568043, "cwe": ["CWE-191"], "cve": "CVE-2021-21897", "cve_desc": "A code execution vulnerability exists in the DL_Dxf::handleLWPolylineData functionality of Ribbonsoft dxflib 3.17.0. A specially-crafted .dxf file can lead to a heap buffer overflow. An attacker can provide a malicious file to trigger this vulnerability.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-21897", "file_path": "src/3rdparty/dxflib/src/dl_dxf.cpp"}
{"idx": 386565, "project": "qcad", "commit_id": "1eeffc5daf5a06cf6213ffc19e95923cdebb2eb8", "project_url": "https://github.com/qcad/qcad", "commit_url": "https://github.com/qcad/qcad/commit/1eeffc5daf5a06cf6213ffc19e95923cdebb2eb8", "commit_message": "check vertexIndex which might be -1 for broken DXF", "target": 0, "func": "bool DL_Dxf::handleLWPolylineData(DL_CreationInterface* /*creationInterface*/) {\n    // Allocate LWPolyline vertices (group code 90):\n    if (groupCode==90) {\n        maxVertices = toInt(groupValue);\n        if (maxVertices>0) {\n            if (vertices!=NULL) {\n                delete[] vertices;\n            }\n            vertices = new double[4*maxVertices];\n            for (int i=0; i<maxVertices; ++i) {\n                vertices[i*4] = 0.0;\n                vertices[i*4+1] = 0.0;\n                vertices[i*4+2] = 0.0;\n                vertices[i*4+3] = 0.0;\n            }\n        }\n        vertexIndex=-1;\n        return true;\n    }\n\n    // Process LWPolylines vertices (group codes 10/20/30/42):\n    else if (groupCode==10 || groupCode==20 ||\n             groupCode==30 || groupCode==42) {\n\n        if (vertexIndex<maxVertices-1 && groupCode==10) {\n            vertexIndex++;\n        }\n\n        if (groupCode<=30) {\n            if (vertexIndex>=0 && vertexIndex<maxVertices && vertexIndex>=0) {\n                vertices[4*vertexIndex + (groupCode/10-1)] = toReal(groupValue);\n            }\n        } else if (groupCode==42 && vertexIndex<maxVertices && vertexIndex>=0) {\n            vertices[4*vertexIndex + 3] = toReal(groupValue);\n        }\n        return true;\n    }\n    return false;\n}", "func_hash": 66825183138389317029314964036422106221, "file_name": "dl_dxf.cpp", "file_hash": 181081005270076491555487324786328968837, "cwe": ["CWE-191"], "cve": "CVE-2021-21897", "cve_desc": "A code execution vulnerability exists in the DL_Dxf::handleLWPolylineData functionality of Ribbonsoft dxflib 3.17.0. A specially-crafted .dxf file can lead to a heap buffer overflow. An attacker can provide a malicious file to trigger this vulnerability.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-21897", "file_path": "src/3rdparty/dxflib/src/dl_dxf.cpp"}
{"idx": 206781, "project": "linux", "commit_id": "ea8569194b43f0f01f0a84c689388542c7254a1f", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=ea8569194b43f0f01f0a84c689388542c7254a1f", "commit_message": "udf: Restore i_lenAlloc when inode expansion fails\n\nWhen we fail to expand inode from inline format to a normal format, we\nrestore inode to contain the original inline formatting but we forgot to\nset i_lenAlloc back. The mismatch between i_lenAlloc and i_size was then\ncausing further problems such as warnings and lost data down the line.\n\nReported-by: butt3rflyh4ck <butterflyhuangxx@gmail.com>\nCC: stable@vger.kernel.org\nFixes: 7e49b6f2480c (\"udf: Convert UDF to new truncate calling sequence\")\nReviewed-by: Christoph Hellwig <hch@lst.de>\nSigned-off-by: Jan Kara <jack@suse.cz>", "target": 1, "func": "int udf_expand_file_adinicb(struct inode *inode)\n{\n\tstruct page *page;\n\tchar *kaddr;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tint err;\n\n\tWARN_ON_ONCE(!inode_is_locked(inode));\n\tif (!iinfo->i_lenAlloc) {\n\t\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_SHORT_AD))\n\t\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_SHORT;\n\t\telse\n\t\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_LONG;\n\t\t/* from now on we have normal address_space methods */\n\t\tinode->i_data.a_ops = &udf_aops;\n\t\tup_write(&iinfo->i_data_sem);\n\t\tmark_inode_dirty(inode);\n\t\treturn 0;\n\t}\n\t/*\n\t * Release i_data_sem so that we can lock a page - page lock ranks\n\t * above i_data_sem. i_mutex still protects us against file changes.\n\t */\n\tup_write(&iinfo->i_data_sem);\n\n\tpage = find_or_create_page(inode->i_mapping, 0, GFP_NOFS);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tif (!PageUptodate(page)) {\n\t\tkaddr = kmap_atomic(page);\n\t\tmemset(kaddr + iinfo->i_lenAlloc, 0x00,\n\t\t       PAGE_SIZE - iinfo->i_lenAlloc);\n\t\tmemcpy(kaddr, iinfo->i_data + iinfo->i_lenEAttr,\n\t\t\tiinfo->i_lenAlloc);\n\t\tflush_dcache_page(page);\n\t\tSetPageUptodate(page);\n\t\tkunmap_atomic(kaddr);\n\t}\n\tdown_write(&iinfo->i_data_sem);\n\tmemset(iinfo->i_data + iinfo->i_lenEAttr, 0x00,\n\t       iinfo->i_lenAlloc);\n\tiinfo->i_lenAlloc = 0;\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_SHORT_AD))\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_SHORT;\n\telse\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_LONG;\n\t/* from now on we have normal address_space methods */\n\tinode->i_data.a_ops = &udf_aops;\n\tset_page_dirty(page);\n\tunlock_page(page);\n\tup_write(&iinfo->i_data_sem);\n\terr = filemap_fdatawrite(inode->i_mapping);\n\tif (err) {\n\t\t/* Restore everything back so that we don't lose data... */\n\t\tlock_page(page);\n\t\tdown_write(&iinfo->i_data_sem);\n\t\tkaddr = kmap_atomic(page);\n\t\tmemcpy(iinfo->i_data + iinfo->i_lenEAttr, kaddr, inode->i_size);\n\t\tkunmap_atomic(kaddr);\n\t\tunlock_page(page);\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_IN_ICB;\n\t\tinode->i_data.a_ops = &udf_adinicb_aops;\n\t\tup_write(&iinfo->i_data_sem);\n\t}\n\tput_page(page);\n\tmark_inode_dirty(inode);\n\n\treturn err;\n}", "func_hash": 151977926301006306483685572008692883310, "file_name": "inode.c", "file_hash": 299509065903875732825474013259696803505, "cwe": ["CWE-476"], "cve": "CVE-2022-0617", "cve_desc": "A flaw null pointer dereference in the Linux kernel UDF file system functionality was found in the way user triggers udf_file_write_iter function for the malicious UDF image. A local user could use this flaw to crash the system. Actual from Linux kernel 4.2-rc1 till 5.17-rc2.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-0617", "file_path": "fs/inode.c"}
{"idx": 386750, "project": "linux", "commit_id": "ea8569194b43f0f01f0a84c689388542c7254a1f", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=ea8569194b43f0f01f0a84c689388542c7254a1f", "commit_message": "udf: Restore i_lenAlloc when inode expansion fails\n\nWhen we fail to expand inode from inline format to a normal format, we\nrestore inode to contain the original inline formatting but we forgot to\nset i_lenAlloc back. The mismatch between i_lenAlloc and i_size was then\ncausing further problems such as warnings and lost data down the line.\n\nReported-by: butt3rflyh4ck <butterflyhuangxx@gmail.com>\nCC: stable@vger.kernel.org\nFixes: 7e49b6f2480c (\"udf: Convert UDF to new truncate calling sequence\")\nReviewed-by: Christoph Hellwig <hch@lst.de>\nSigned-off-by: Jan Kara <jack@suse.cz>", "target": 0, "func": "int udf_expand_file_adinicb(struct inode *inode)\n{\n\tstruct page *page;\n\tchar *kaddr;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tint err;\n\n\tWARN_ON_ONCE(!inode_is_locked(inode));\n\tif (!iinfo->i_lenAlloc) {\n\t\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_SHORT_AD))\n\t\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_SHORT;\n\t\telse\n\t\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_LONG;\n\t\t/* from now on we have normal address_space methods */\n\t\tinode->i_data.a_ops = &udf_aops;\n\t\tup_write(&iinfo->i_data_sem);\n\t\tmark_inode_dirty(inode);\n\t\treturn 0;\n\t}\n\t/*\n\t * Release i_data_sem so that we can lock a page - page lock ranks\n\t * above i_data_sem. i_mutex still protects us against file changes.\n\t */\n\tup_write(&iinfo->i_data_sem);\n\n\tpage = find_or_create_page(inode->i_mapping, 0, GFP_NOFS);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tif (!PageUptodate(page)) {\n\t\tkaddr = kmap_atomic(page);\n\t\tmemset(kaddr + iinfo->i_lenAlloc, 0x00,\n\t\t       PAGE_SIZE - iinfo->i_lenAlloc);\n\t\tmemcpy(kaddr, iinfo->i_data + iinfo->i_lenEAttr,\n\t\t\tiinfo->i_lenAlloc);\n\t\tflush_dcache_page(page);\n\t\tSetPageUptodate(page);\n\t\tkunmap_atomic(kaddr);\n\t}\n\tdown_write(&iinfo->i_data_sem);\n\tmemset(iinfo->i_data + iinfo->i_lenEAttr, 0x00,\n\t       iinfo->i_lenAlloc);\n\tiinfo->i_lenAlloc = 0;\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_SHORT_AD))\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_SHORT;\n\telse\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_LONG;\n\t/* from now on we have normal address_space methods */\n\tinode->i_data.a_ops = &udf_aops;\n\tset_page_dirty(page);\n\tunlock_page(page);\n\tup_write(&iinfo->i_data_sem);\n\terr = filemap_fdatawrite(inode->i_mapping);\n\tif (err) {\n\t\t/* Restore everything back so that we don't lose data... */\n\t\tlock_page(page);\n\t\tdown_write(&iinfo->i_data_sem);\n\t\tkaddr = kmap_atomic(page);\n\t\tmemcpy(iinfo->i_data + iinfo->i_lenEAttr, kaddr, inode->i_size);\n\t\tkunmap_atomic(kaddr);\n\t\tunlock_page(page);\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_IN_ICB;\n\t\tinode->i_data.a_ops = &udf_adinicb_aops;\n\t\tiinfo->i_lenAlloc = inode->i_size;\n\t\tup_write(&iinfo->i_data_sem);\n\t}\n\tput_page(page);\n\tmark_inode_dirty(inode);\n\n\treturn err;\n}", "func_hash": 191954099261759057406602593964899861240, "file_name": "inode.c", "file_hash": 50770462585650222153062698584720679665, "cwe": ["CWE-476"], "cve": "CVE-2022-0617", "cve_desc": "A flaw null pointer dereference in the Linux kernel UDF file system functionality was found in the way user triggers udf_file_write_iter function for the malicious UDF image. A local user could use this flaw to crash the system. Actual from Linux kernel 4.2-rc1 till 5.17-rc2.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-0617", "file_path": "fs/inode.c"}
