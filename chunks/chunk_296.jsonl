{"idx": 211877, "project": "libexpat", "commit_id": "a2fe525e660badd64b6c557c2b1ec26ddc07f6e4", "project_url": "https://github.com/libexpat/libexpat", "commit_url": "https://github.com/libexpat/libexpat/commit/a2fe525e660badd64b6c557c2b1ec26ddc07f6e4", "commit_message": "lib: Protect against malicious namespace declarations (CVE-2022-25236)", "target": 1, "func": "addBinding(XML_Parser parser, PREFIX *prefix, const ATTRIBUTE_ID *attId,\n           const XML_Char *uri, BINDING **bindingsPtr) {\n  static const XML_Char xmlNamespace[]\n      = {ASCII_h,      ASCII_t,     ASCII_t,     ASCII_p,      ASCII_COLON,\n         ASCII_SLASH,  ASCII_SLASH, ASCII_w,     ASCII_w,      ASCII_w,\n         ASCII_PERIOD, ASCII_w,     ASCII_3,     ASCII_PERIOD, ASCII_o,\n         ASCII_r,      ASCII_g,     ASCII_SLASH, ASCII_X,      ASCII_M,\n         ASCII_L,      ASCII_SLASH, ASCII_1,     ASCII_9,      ASCII_9,\n         ASCII_8,      ASCII_SLASH, ASCII_n,     ASCII_a,      ASCII_m,\n         ASCII_e,      ASCII_s,     ASCII_p,     ASCII_a,      ASCII_c,\n         ASCII_e,      '\\0'};\n  static const int xmlLen = (int)sizeof(xmlNamespace) / sizeof(XML_Char) - 1;\n  static const XML_Char xmlnsNamespace[]\n      = {ASCII_h,     ASCII_t,      ASCII_t, ASCII_p, ASCII_COLON,  ASCII_SLASH,\n         ASCII_SLASH, ASCII_w,      ASCII_w, ASCII_w, ASCII_PERIOD, ASCII_w,\n         ASCII_3,     ASCII_PERIOD, ASCII_o, ASCII_r, ASCII_g,      ASCII_SLASH,\n         ASCII_2,     ASCII_0,      ASCII_0, ASCII_0, ASCII_SLASH,  ASCII_x,\n         ASCII_m,     ASCII_l,      ASCII_n, ASCII_s, ASCII_SLASH,  '\\0'};\n  static const int xmlnsLen\n      = (int)sizeof(xmlnsNamespace) / sizeof(XML_Char) - 1;\n\n  XML_Bool mustBeXML = XML_FALSE;\n  XML_Bool isXML = XML_TRUE;\n  XML_Bool isXMLNS = XML_TRUE;\n\n  BINDING *b;\n  int len;\n\n  /* empty URI is only valid for default namespace per XML NS 1.0 (not 1.1) */\n  if (*uri == XML_T('\\0') && prefix->name)\n    return XML_ERROR_UNDECLARING_PREFIX;\n\n  if (prefix->name && prefix->name[0] == XML_T(ASCII_x)\n      && prefix->name[1] == XML_T(ASCII_m)\n      && prefix->name[2] == XML_T(ASCII_l)) {\n    /* Not allowed to bind xmlns */\n    if (prefix->name[3] == XML_T(ASCII_n) && prefix->name[4] == XML_T(ASCII_s)\n        && prefix->name[5] == XML_T('\\0'))\n      return XML_ERROR_RESERVED_PREFIX_XMLNS;\n\n    if (prefix->name[3] == XML_T('\\0'))\n      mustBeXML = XML_TRUE;\n  }\n\n  for (len = 0; uri[len]; len++) {\n    if (isXML && (len > xmlLen || uri[len] != xmlNamespace[len]))\n      isXML = XML_FALSE;\n\n    if (! mustBeXML && isXMLNS\n        && (len > xmlnsLen || uri[len] != xmlnsNamespace[len]))\n      isXMLNS = XML_FALSE;\n  }\n  isXML = isXML && len == xmlLen;\n  isXMLNS = isXMLNS && len == xmlnsLen;\n\n  if (mustBeXML != isXML)\n    return mustBeXML ? XML_ERROR_RESERVED_PREFIX_XML\n                     : XML_ERROR_RESERVED_NAMESPACE_URI;\n\n  if (isXMLNS)\n    return XML_ERROR_RESERVED_NAMESPACE_URI;\n\n  if (parser->m_namespaceSeparator)\n    len++;\n  if (parser->m_freeBindingList) {\n    b = parser->m_freeBindingList;\n    if (len > b->uriAlloc) {\n      /* Detect and prevent integer overflow */\n      if (len > INT_MAX - EXPAND_SPARE) {\n        return XML_ERROR_NO_MEMORY;\n      }\n\n      /* Detect and prevent integer overflow.\n       * The preprocessor guard addresses the \"always false\" warning\n       * from -Wtype-limits on platforms where\n       * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */\n#if UINT_MAX >= SIZE_MAX\n      if ((unsigned)(len + EXPAND_SPARE) > (size_t)(-1) / sizeof(XML_Char)) {\n        return XML_ERROR_NO_MEMORY;\n      }\n#endif\n\n      XML_Char *temp = (XML_Char *)REALLOC(\n          parser, b->uri, sizeof(XML_Char) * (len + EXPAND_SPARE));\n      if (temp == NULL)\n        return XML_ERROR_NO_MEMORY;\n      b->uri = temp;\n      b->uriAlloc = len + EXPAND_SPARE;\n    }\n    parser->m_freeBindingList = b->nextTagBinding;\n  } else {\n    b = (BINDING *)MALLOC(parser, sizeof(BINDING));\n    if (! b)\n      return XML_ERROR_NO_MEMORY;\n\n    /* Detect and prevent integer overflow */\n    if (len > INT_MAX - EXPAND_SPARE) {\n      return XML_ERROR_NO_MEMORY;\n    }\n    /* Detect and prevent integer overflow.\n     * The preprocessor guard addresses the \"always false\" warning\n     * from -Wtype-limits on platforms where\n     * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */\n#if UINT_MAX >= SIZE_MAX\n    if ((unsigned)(len + EXPAND_SPARE) > (size_t)(-1) / sizeof(XML_Char)) {\n      return XML_ERROR_NO_MEMORY;\n    }\n#endif\n\n    b->uri\n        = (XML_Char *)MALLOC(parser, sizeof(XML_Char) * (len + EXPAND_SPARE));\n    if (! b->uri) {\n      FREE(parser, b);\n      return XML_ERROR_NO_MEMORY;\n    }\n    b->uriAlloc = len + EXPAND_SPARE;\n  }\n  b->uriLen = len;\n  memcpy(b->uri, uri, len * sizeof(XML_Char));\n  if (parser->m_namespaceSeparator)\n    b->uri[len - 1] = parser->m_namespaceSeparator;\n  b->prefix = prefix;\n  b->attId = attId;\n  b->prevPrefixBinding = prefix->binding;\n  /* NULL binding when default namespace undeclared */\n  if (*uri == XML_T('\\0') && prefix == &parser->m_dtd->defaultPrefix)\n    prefix->binding = NULL;\n  else\n    prefix->binding = b;\n  b->nextTagBinding = *bindingsPtr;\n  *bindingsPtr = b;\n  /* if attId == NULL then we are not starting a namespace scope */\n  if (attId && parser->m_startNamespaceDeclHandler)\n    parser->m_startNamespaceDeclHandler(parser->m_handlerArg, prefix->name,\n                                        prefix->binding ? uri : 0);\n  return XML_ERROR_NONE;\n}", "func_hash": 22295362737021887331084829836677682659, "file_name": "xmlparse.c", "file_hash": 64970761866861782031621044957132437337, "cwe": ["CWE-668"], "cve": "CVE-2022-25236", "cve_desc": "xmlparse.c in Expat (aka libexpat) before 2.4.5 allows attackers to insert namespace-separator characters into namespace URIs.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-25236", "file_path": "expat/lib/xmlparse.c"}
{"idx": 453109, "project": "libexpat", "commit_id": "a2fe525e660badd64b6c557c2b1ec26ddc07f6e4", "project_url": "https://github.com/libexpat/libexpat", "commit_url": "https://github.com/libexpat/libexpat/commit/a2fe525e660badd64b6c557c2b1ec26ddc07f6e4", "commit_message": "lib: Protect against malicious namespace declarations (CVE-2022-25236)", "target": 0, "func": "addBinding(XML_Parser parser, PREFIX *prefix, const ATTRIBUTE_ID *attId,\n           const XML_Char *uri, BINDING **bindingsPtr) {\n  static const XML_Char xmlNamespace[]\n      = {ASCII_h,      ASCII_t,     ASCII_t,     ASCII_p,      ASCII_COLON,\n         ASCII_SLASH,  ASCII_SLASH, ASCII_w,     ASCII_w,      ASCII_w,\n         ASCII_PERIOD, ASCII_w,     ASCII_3,     ASCII_PERIOD, ASCII_o,\n         ASCII_r,      ASCII_g,     ASCII_SLASH, ASCII_X,      ASCII_M,\n         ASCII_L,      ASCII_SLASH, ASCII_1,     ASCII_9,      ASCII_9,\n         ASCII_8,      ASCII_SLASH, ASCII_n,     ASCII_a,      ASCII_m,\n         ASCII_e,      ASCII_s,     ASCII_p,     ASCII_a,      ASCII_c,\n         ASCII_e,      '\\0'};\n  static const int xmlLen = (int)sizeof(xmlNamespace) / sizeof(XML_Char) - 1;\n  static const XML_Char xmlnsNamespace[]\n      = {ASCII_h,     ASCII_t,      ASCII_t, ASCII_p, ASCII_COLON,  ASCII_SLASH,\n         ASCII_SLASH, ASCII_w,      ASCII_w, ASCII_w, ASCII_PERIOD, ASCII_w,\n         ASCII_3,     ASCII_PERIOD, ASCII_o, ASCII_r, ASCII_g,      ASCII_SLASH,\n         ASCII_2,     ASCII_0,      ASCII_0, ASCII_0, ASCII_SLASH,  ASCII_x,\n         ASCII_m,     ASCII_l,      ASCII_n, ASCII_s, ASCII_SLASH,  '\\0'};\n  static const int xmlnsLen\n      = (int)sizeof(xmlnsNamespace) / sizeof(XML_Char) - 1;\n\n  XML_Bool mustBeXML = XML_FALSE;\n  XML_Bool isXML = XML_TRUE;\n  XML_Bool isXMLNS = XML_TRUE;\n\n  BINDING *b;\n  int len;\n\n  /* empty URI is only valid for default namespace per XML NS 1.0 (not 1.1) */\n  if (*uri == XML_T('\\0') && prefix->name)\n    return XML_ERROR_UNDECLARING_PREFIX;\n\n  if (prefix->name && prefix->name[0] == XML_T(ASCII_x)\n      && prefix->name[1] == XML_T(ASCII_m)\n      && prefix->name[2] == XML_T(ASCII_l)) {\n    /* Not allowed to bind xmlns */\n    if (prefix->name[3] == XML_T(ASCII_n) && prefix->name[4] == XML_T(ASCII_s)\n        && prefix->name[5] == XML_T('\\0'))\n      return XML_ERROR_RESERVED_PREFIX_XMLNS;\n\n    if (prefix->name[3] == XML_T('\\0'))\n      mustBeXML = XML_TRUE;\n  }\n\n  for (len = 0; uri[len]; len++) {\n    if (isXML && (len > xmlLen || uri[len] != xmlNamespace[len]))\n      isXML = XML_FALSE;\n\n    if (! mustBeXML && isXMLNS\n        && (len > xmlnsLen || uri[len] != xmlnsNamespace[len]))\n      isXMLNS = XML_FALSE;\n\n    // NOTE: While Expat does not validate namespace URIs against RFC 3986,\n    //       we have to at least make sure that the XML processor on top of\n    //       Expat (that is splitting tag names by namespace separator into\n    //       2- or 3-tuples (uri-local or uri-local-prefix)) cannot be confused\n    //       by an attacker putting additional namespace separator characters\n    //       into namespace declarations.  That would be ambiguous and not to\n    //       be expected.\n    if (parser->m_ns && (uri[len] == parser->m_namespaceSeparator)) {\n      return XML_ERROR_SYNTAX;\n    }\n  }\n  isXML = isXML && len == xmlLen;\n  isXMLNS = isXMLNS && len == xmlnsLen;\n\n  if (mustBeXML != isXML)\n    return mustBeXML ? XML_ERROR_RESERVED_PREFIX_XML\n                     : XML_ERROR_RESERVED_NAMESPACE_URI;\n\n  if (isXMLNS)\n    return XML_ERROR_RESERVED_NAMESPACE_URI;\n\n  if (parser->m_namespaceSeparator)\n    len++;\n  if (parser->m_freeBindingList) {\n    b = parser->m_freeBindingList;\n    if (len > b->uriAlloc) {\n      /* Detect and prevent integer overflow */\n      if (len > INT_MAX - EXPAND_SPARE) {\n        return XML_ERROR_NO_MEMORY;\n      }\n\n      /* Detect and prevent integer overflow.\n       * The preprocessor guard addresses the \"always false\" warning\n       * from -Wtype-limits on platforms where\n       * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */\n#if UINT_MAX >= SIZE_MAX\n      if ((unsigned)(len + EXPAND_SPARE) > (size_t)(-1) / sizeof(XML_Char)) {\n        return XML_ERROR_NO_MEMORY;\n      }\n#endif\n\n      XML_Char *temp = (XML_Char *)REALLOC(\n          parser, b->uri, sizeof(XML_Char) * (len + EXPAND_SPARE));\n      if (temp == NULL)\n        return XML_ERROR_NO_MEMORY;\n      b->uri = temp;\n      b->uriAlloc = len + EXPAND_SPARE;\n    }\n    parser->m_freeBindingList = b->nextTagBinding;\n  } else {\n    b = (BINDING *)MALLOC(parser, sizeof(BINDING));\n    if (! b)\n      return XML_ERROR_NO_MEMORY;\n\n    /* Detect and prevent integer overflow */\n    if (len > INT_MAX - EXPAND_SPARE) {\n      return XML_ERROR_NO_MEMORY;\n    }\n    /* Detect and prevent integer overflow.\n     * The preprocessor guard addresses the \"always false\" warning\n     * from -Wtype-limits on platforms where\n     * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */\n#if UINT_MAX >= SIZE_MAX\n    if ((unsigned)(len + EXPAND_SPARE) > (size_t)(-1) / sizeof(XML_Char)) {\n      return XML_ERROR_NO_MEMORY;\n    }\n#endif\n\n    b->uri\n        = (XML_Char *)MALLOC(parser, sizeof(XML_Char) * (len + EXPAND_SPARE));\n    if (! b->uri) {\n      FREE(parser, b);\n      return XML_ERROR_NO_MEMORY;\n    }\n    b->uriAlloc = len + EXPAND_SPARE;\n  }\n  b->uriLen = len;\n  memcpy(b->uri, uri, len * sizeof(XML_Char));\n  if (parser->m_namespaceSeparator)\n    b->uri[len - 1] = parser->m_namespaceSeparator;\n  b->prefix = prefix;\n  b->attId = attId;\n  b->prevPrefixBinding = prefix->binding;\n  /* NULL binding when default namespace undeclared */\n  if (*uri == XML_T('\\0') && prefix == &parser->m_dtd->defaultPrefix)\n    prefix->binding = NULL;\n  else\n    prefix->binding = b;\n  b->nextTagBinding = *bindingsPtr;\n  *bindingsPtr = b;\n  /* if attId == NULL then we are not starting a namespace scope */\n  if (attId && parser->m_startNamespaceDeclHandler)\n    parser->m_startNamespaceDeclHandler(parser->m_handlerArg, prefix->name,\n                                        prefix->binding ? uri : 0);\n  return XML_ERROR_NONE;\n}", "func_hash": 180909609780994811991308792390157424153, "file_name": "xmlparse.c", "file_hash": 39872007825496999526918942248087494728, "cwe": ["CWE-668"], "cve": "CVE-2022-25236", "cve_desc": "xmlparse.c in Expat (aka libexpat) before 2.4.5 allows attackers to insert namespace-separator characters into namespace URIs.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-25236", "file_path": "expat/lib/xmlparse.c"}
