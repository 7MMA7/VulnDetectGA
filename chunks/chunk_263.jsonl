{"idx": 210520, "project": "vim", "commit_id": "8eba2bd291b347e3008aa9e565652d51ad638cfa", "project_url": "https://github.com/vim/vim", "commit_url": "https://github.com/vim/vim/commit/8eba2bd291b347e3008aa9e565652d51ad638cfa", "commit_message": "patch 8.2.5151: reading beyond the end of the line with lisp indenting\n\nProblem:    Reading beyond the end of the line with lisp indenting.\nSolution:   Avoid going over the NUL at the end of the line.", "target": 1, "func": "get_lisp_indent(void)\n{\n    pos_T\t*pos, realpos, paren;\n    int\t\tamount;\n    char_u\t*that;\n    colnr_T\tcol;\n    colnr_T\tfirsttry;\n    int\t\tparencount, quotecount;\n    int\t\tvi_lisp;\n\n    // Set vi_lisp to use the vi-compatible method\n    vi_lisp = (vim_strchr(p_cpo, CPO_LISP) != NULL);\n\n    realpos = curwin->w_cursor;\n    curwin->w_cursor.col = 0;\n\n    if ((pos = findmatch(NULL, '(')) == NULL)\n\tpos = findmatch(NULL, '[');\n    else\n    {\n\tparen = *pos;\n\tpos = findmatch(NULL, '[');\n\tif (pos == NULL || LT_POSP(pos, &paren))\n\t    pos = &paren;\n    }\n    if (pos != NULL)\n    {\n\t// Extra trick: Take the indent of the first previous non-white\n\t// line that is at the same () level.\n\tamount = -1;\n\tparencount = 0;\n\n\twhile (--curwin->w_cursor.lnum >= pos->lnum)\n\t{\n\t    if (linewhite(curwin->w_cursor.lnum))\n\t\tcontinue;\n\t    for (that = ml_get_curline(); *that != NUL; ++that)\n\t    {\n\t\tif (*that == ';')\n\t\t{\n\t\t    while (*(that + 1) != NUL)\n\t\t\t++that;\n\t\t    continue;\n\t\t}\n\t\tif (*that == '\\\\')\n\t\t{\n\t\t    if (*(that + 1) != NUL)\n\t\t\t++that;\n\t\t    continue;\n\t\t}\n\t\tif (*that == '\"' && *(that + 1) != NUL)\n\t\t{\n\t\t    while (*++that && *that != '\"')\n\t\t    {\n\t\t\t// skipping escaped characters in the string\n\t\t\tif (*that == '\\\\')\n\t\t\t{\n\t\t\t    if (*++that == NUL)\n\t\t\t\tbreak;\n\t\t\t    if (that[1] == NUL)\n\t\t\t    {\n\t\t\t\t++that;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    if (*that == NUL)\n\t\t\tbreak;\n\t\t}\n\t\tif (*that == '(' || *that == '[')\n\t\t    ++parencount;\n\t\telse if (*that == ')' || *that == ']')\n\t\t    --parencount;\n\t    }\n\t    if (parencount == 0)\n\t    {\n\t\tamount = get_indent();\n\t\tbreak;\n\t    }\n\t}\n\n\tif (amount == -1)\n\t{\n\t    curwin->w_cursor.lnum = pos->lnum;\n\t    curwin->w_cursor.col = pos->col;\n\t    col = pos->col;\n\n\t    that = ml_get_curline();\n\n\t    if (vi_lisp && get_indent() == 0)\n\t\tamount = 2;\n\t    else\n\t    {\n\t\tchar_u *line = that;\n\n\t\tamount = 0;\n\t\twhile (*that && col)\n\t\t{\n\t\t    amount += lbr_chartabsize_adv(line, &that, (colnr_T)amount);\n\t\t    col--;\n\t\t}\n\n\t\t// Some keywords require \"body\" indenting rules (the\n\t\t// non-standard-lisp ones are Scheme special forms):\n\t\t//\n\t\t// (let ((a 1))    instead    (let ((a 1))\n\t\t//   (...))\t      of\t   (...))\n\n\t\tif (!vi_lisp && (*that == '(' || *that == '[')\n\t\t\t\t\t\t      && lisp_match(that + 1))\n\t\t    amount += 2;\n\t\telse\n\t\t{\n\t\t    that++;\n\t\t    amount++;\n\t\t    firsttry = amount;\n\n\t\t    while (VIM_ISWHITE(*that))\n\t\t    {\n\t\t\tamount += lbr_chartabsize(line, that, (colnr_T)amount);\n\t\t\t++that;\n\t\t    }\n\n\t\t    if (*that && *that != ';') // not a comment line\n\t\t    {\n\t\t\t// test *that != '(' to accommodate first let/do\n\t\t\t// argument if it is more than one line\n\t\t\tif (!vi_lisp && *that != '(' && *that != '[')\n\t\t\t    firsttry++;\n\n\t\t\tparencount = 0;\n\t\t\tquotecount = 0;\n\n\t\t\tif (vi_lisp\n\t\t\t\t|| (*that != '\"'\n\t\t\t\t    && *that != '\\''\n\t\t\t\t    && *that != '#'\n\t\t\t\t    && (*that < '0' || *that > '9')))\n\t\t\t{\n\t\t\t    while (*that\n\t\t\t\t    && (!VIM_ISWHITE(*that)\n\t\t\t\t\t|| quotecount\n\t\t\t\t\t|| parencount)\n\t\t\t\t    && (!((*that == '(' || *that == '[')\n\t\t\t\t\t    && !quotecount\n\t\t\t\t\t    && !parencount\n\t\t\t\t\t    && vi_lisp)))\n\t\t\t    {\n\t\t\t\tif (*that == '\"')\n\t\t\t\t    quotecount = !quotecount;\n\t\t\t\tif ((*that == '(' || *that == '[')\n\t\t\t\t\t\t\t       && !quotecount)\n\t\t\t\t    ++parencount;\n\t\t\t\tif ((*that == ')' || *that == ']')\n\t\t\t\t\t\t\t       && !quotecount)\n\t\t\t\t    --parencount;\n\t\t\t\tif (*that == '\\\\' && *(that+1) != NUL)\n\t\t\t\t    amount += lbr_chartabsize_adv(\n\t\t\t\t\t\tline, &that, (colnr_T)amount);\n\t\t\t\tamount += lbr_chartabsize_adv(\n\t\t\t\t\t\tline, &that, (colnr_T)amount);\n\t\t\t    }\n\t\t\t}\n\t\t\twhile (VIM_ISWHITE(*that))\n\t\t\t{\n\t\t\t    amount += lbr_chartabsize(\n\t\t\t\t\t\t line, that, (colnr_T)amount);\n\t\t\t    that++;\n\t\t\t}\n\t\t\tif (!*that || *that == ';')\n\t\t\t    amount = firsttry;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n    else\n\tamount = 0;\t// no matching '(' or '[' found, use zero indent\n\n    curwin->w_cursor = realpos;\n\n    return amount;\n}", "func_hash": 285577847836020601306828905018553438405, "file_name": "indent.c", "file_hash": 245226379140826048087051552287940041760, "cwe": ["CWE-125"], "cve": "CVE-2022-2183", "cve_desc": "Out-of-bounds Read in GitHub repository vim/vim prior to 8.2.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-2183", "file_path": "src/indent.c"}
{"idx": 436990, "project": "vim", "commit_id": "8eba2bd291b347e3008aa9e565652d51ad638cfa", "project_url": "https://github.com/vim/vim", "commit_url": "https://github.com/vim/vim/commit/8eba2bd291b347e3008aa9e565652d51ad638cfa", "commit_message": "patch 8.2.5151: reading beyond the end of the line with lisp indenting\n\nProblem:    Reading beyond the end of the line with lisp indenting.\nSolution:   Avoid going over the NUL at the end of the line.", "target": 0, "func": "get_lisp_indent(void)\n{\n    pos_T\t*pos, realpos, paren;\n    int\t\tamount;\n    char_u\t*that;\n    colnr_T\tcol;\n    colnr_T\tfirsttry;\n    int\t\tparencount, quotecount;\n    int\t\tvi_lisp;\n\n    // Set vi_lisp to use the vi-compatible method\n    vi_lisp = (vim_strchr(p_cpo, CPO_LISP) != NULL);\n\n    realpos = curwin->w_cursor;\n    curwin->w_cursor.col = 0;\n\n    if ((pos = findmatch(NULL, '(')) == NULL)\n\tpos = findmatch(NULL, '[');\n    else\n    {\n\tparen = *pos;\n\tpos = findmatch(NULL, '[');\n\tif (pos == NULL || LT_POSP(pos, &paren))\n\t    pos = &paren;\n    }\n    if (pos != NULL)\n    {\n\t// Extra trick: Take the indent of the first previous non-white\n\t// line that is at the same () level.\n\tamount = -1;\n\tparencount = 0;\n\n\twhile (--curwin->w_cursor.lnum >= pos->lnum)\n\t{\n\t    if (linewhite(curwin->w_cursor.lnum))\n\t\tcontinue;\n\t    for (that = ml_get_curline(); *that != NUL; ++that)\n\t    {\n\t\tif (*that == ';')\n\t\t{\n\t\t    while (*(that + 1) != NUL)\n\t\t\t++that;\n\t\t    continue;\n\t\t}\n\t\tif (*that == '\\\\')\n\t\t{\n\t\t    if (*(that + 1) != NUL)\n\t\t\t++that;\n\t\t    continue;\n\t\t}\n\t\tif (*that == '\"' && *(that + 1) != NUL)\n\t\t{\n\t\t    while (*++that && *that != '\"')\n\t\t    {\n\t\t\t// skipping escaped characters in the string\n\t\t\tif (*that == '\\\\')\n\t\t\t{\n\t\t\t    if (*++that == NUL)\n\t\t\t\tbreak;\n\t\t\t    if (that[1] == NUL)\n\t\t\t    {\n\t\t\t\t++that;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    if (*that == NUL)\n\t\t\tbreak;\n\t\t}\n\t\tif (*that == '(' || *that == '[')\n\t\t    ++parencount;\n\t\telse if (*that == ')' || *that == ']')\n\t\t    --parencount;\n\t    }\n\t    if (parencount == 0)\n\t    {\n\t\tamount = get_indent();\n\t\tbreak;\n\t    }\n\t}\n\n\tif (amount == -1)\n\t{\n\t    curwin->w_cursor.lnum = pos->lnum;\n\t    curwin->w_cursor.col = pos->col;\n\t    col = pos->col;\n\n\t    that = ml_get_curline();\n\n\t    if (vi_lisp && get_indent() == 0)\n\t\tamount = 2;\n\t    else\n\t    {\n\t\tchar_u *line = that;\n\n\t\tamount = 0;\n\t\twhile (*that && col)\n\t\t{\n\t\t    amount += lbr_chartabsize_adv(line, &that, (colnr_T)amount);\n\t\t    col--;\n\t\t}\n\n\t\t// Some keywords require \"body\" indenting rules (the\n\t\t// non-standard-lisp ones are Scheme special forms):\n\t\t//\n\t\t// (let ((a 1))    instead    (let ((a 1))\n\t\t//   (...))\t      of\t   (...))\n\n\t\tif (!vi_lisp && (*that == '(' || *that == '[')\n\t\t\t\t\t\t      && lisp_match(that + 1))\n\t\t    amount += 2;\n\t\telse\n\t\t{\n\t\t    if (*that != NUL)\n\t\t    {\n\t\t\tthat++;\n\t\t\tamount++;\n\t\t    }\n\t\t    firsttry = amount;\n\n\t\t    while (VIM_ISWHITE(*that))\n\t\t    {\n\t\t\tamount += lbr_chartabsize(line, that, (colnr_T)amount);\n\t\t\t++that;\n\t\t    }\n\n\t\t    if (*that && *that != ';') // not a comment line\n\t\t    {\n\t\t\t// test *that != '(' to accommodate first let/do\n\t\t\t// argument if it is more than one line\n\t\t\tif (!vi_lisp && *that != '(' && *that != '[')\n\t\t\t    firsttry++;\n\n\t\t\tparencount = 0;\n\t\t\tquotecount = 0;\n\n\t\t\tif (vi_lisp\n\t\t\t\t|| (*that != '\"'\n\t\t\t\t    && *that != '\\''\n\t\t\t\t    && *that != '#'\n\t\t\t\t    && (*that < '0' || *that > '9')))\n\t\t\t{\n\t\t\t    while (*that\n\t\t\t\t    && (!VIM_ISWHITE(*that)\n\t\t\t\t\t|| quotecount\n\t\t\t\t\t|| parencount)\n\t\t\t\t    && (!((*that == '(' || *that == '[')\n\t\t\t\t\t    && !quotecount\n\t\t\t\t\t    && !parencount\n\t\t\t\t\t    && vi_lisp)))\n\t\t\t    {\n\t\t\t\tif (*that == '\"')\n\t\t\t\t    quotecount = !quotecount;\n\t\t\t\tif ((*that == '(' || *that == '[')\n\t\t\t\t\t\t\t       && !quotecount)\n\t\t\t\t    ++parencount;\n\t\t\t\tif ((*that == ')' || *that == ']')\n\t\t\t\t\t\t\t       && !quotecount)\n\t\t\t\t    --parencount;\n\t\t\t\tif (*that == '\\\\' && *(that+1) != NUL)\n\t\t\t\t    amount += lbr_chartabsize_adv(\n\t\t\t\t\t\tline, &that, (colnr_T)amount);\n\t\t\t\tamount += lbr_chartabsize_adv(\n\t\t\t\t\t\tline, &that, (colnr_T)amount);\n\t\t\t    }\n\t\t\t}\n\t\t\twhile (VIM_ISWHITE(*that))\n\t\t\t{\n\t\t\t    amount += lbr_chartabsize(\n\t\t\t\t\t\t line, that, (colnr_T)amount);\n\t\t\t    that++;\n\t\t\t}\n\t\t\tif (!*that || *that == ';')\n\t\t\t    amount = firsttry;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n    else\n\tamount = 0;\t// no matching '(' or '[' found, use zero indent\n\n    curwin->w_cursor = realpos;\n\n    return amount;\n}", "func_hash": 309369228494831536830069160339652260754, "file_name": "indent.c", "file_hash": 124492176625563887995731103684583862461, "cwe": ["CWE-125"], "cve": "CVE-2022-2183", "cve_desc": "Out-of-bounds Read in GitHub repository vim/vim prior to 8.2.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-2183", "file_path": "src/indent.c"}
