{"idx": 212834, "project": "rsyslog", "commit_id": "0381a0de64a5a048c3d48b79055bd9848d0c7fc2", "project_url": "https://github.com/rsyslog/rsyslog", "commit_url": "https://github.com/rsyslog/rsyslog/commit/0381a0de64a5a048c3d48b79055bd9848d0c7fc2", "commit_message": "imptcp: fix Segmentation Fault when octet count is to high", "target": 1, "func": "processDataRcvd(ptcpsess_t *const __restrict__ pThis,\n\tchar **buff,\n\tconst int buffLen,\n\tstruct syslogTime *stTime,\n\tconst time_t ttGenTime,\n\tmulti_submit_t *pMultiSub,\n\tunsigned *const __restrict__ pnMsgs)\n{\n\tDEFiRet;\n\tchar c = **buff;\n\tint octatesToCopy, octatesToDiscard;\n\n\tif(pThis->inputState == eAtStrtFram) {\n\t\tif(pThis->bSuppOctetFram && isdigit((int) c)) {\n\t\t\tpThis->inputState = eInOctetCnt;\n\t\t\tpThis->iOctetsRemain = 0;\n\t\t\tpThis->eFraming = TCP_FRAMING_OCTET_COUNTING;\n\t\t} else if(pThis->bSPFramingFix && c == ' ') {\n\t\t\t/* Cisco very occasionally sends a SP after a LF, which\n\t\t\t * thrashes framing if not taken special care of. Here,\n\t\t\t * we permit space *in front of the next frame* and\n\t\t\t * ignore it.\n\t\t\t */\n\t\t\t FINALIZE;\n\t\t} else {\n\t\t\tpThis->inputState = eInMsg;\n\t\t\tpThis->eFraming = TCP_FRAMING_OCTET_STUFFING;\n\t\t}\n\t}\n\n\tif(pThis->inputState == eInOctetCnt) {\n\t\tif(isdigit(c)) {\n\t\t\tpThis->iOctetsRemain = pThis->iOctetsRemain * 10 + c - '0';\n\t\t} else { /* done with the octet count, so this must be the SP terminator */\n\t\t\tDBGPRINTF(\"TCP Message with octet-counter, size %d.\\n\", pThis->iOctetsRemain);\n\t\t\tif(c != ' ') {\n\t\t\t\terrmsg.LogError(0, NO_ERRCODE, \"Framing Error in received TCP message: \"\n\t\t\t\t\t    \"delimiter is not SP but has ASCII value %d.\", c);\n\t\t\t}\n\t\t\tif(pThis->iOctetsRemain < 1) {\n\t\t\t\t/* TODO: handle the case where the octet count is 0! */\n\t\t\t\tDBGPRINTF(\"Framing Error: invalid octet count\\n\");\n\t\t\t\terrmsg.LogError(0, NO_ERRCODE, \"Framing Error in received TCP message: \"\n\t\t\t\t\t    \"invalid octet count %d.\", pThis->iOctetsRemain);\n\t\t\t} else if(pThis->iOctetsRemain > iMaxLine) {\n\t\t\t\t/* while we can not do anything against it, we can at least log an indication\n\t\t\t\t * that something went wrong) -- rgerhards, 2008-03-14\n\t\t\t\t */\n\t\t\t\tDBGPRINTF(\"truncating message with %d octets - max msg size is %d\\n\",\n\t\t\t\t\t  pThis->iOctetsRemain, iMaxLine);\n\t\t\t\terrmsg.LogError(0, NO_ERRCODE, \"received oversize message: size is %d bytes, \"\n\t\t\t\t\t        \"max msg size is %d, truncating...\", pThis->iOctetsRemain, iMaxLine);\n\t\t\t}\n\t\t\tpThis->inputState = eInMsg;\n\t\t}\n\t} else {\n\t\tassert(pThis->inputState == eInMsg);\n\n\t\tif (pThis->eFraming == TCP_FRAMING_OCTET_STUFFING) {\n\t\t\tif(pThis->iMsg >= iMaxLine) {\n\t\t\t\t/* emergency, we now need to flush, no matter if we are at end of message or not... */\n\t\t\t\tint i = 1;\n\t\t\t\tchar currBuffChar;\n\t\t\t\twhile(i < buffLen && ((currBuffChar = (*buff)[i]) != '\\n'\n\t\t\t\t\t&& (pThis->pLstn->pSrv->iAddtlFrameDelim == TCPSRV_NO_ADDTL_DELIMITER\n\t\t\t\t\t\t|| currBuffChar != pThis->pLstn->pSrv->iAddtlFrameDelim))) {\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tLogError(0, NO_ERRCODE, \"error: message received is at least %d byte larger than max msg\"\n\t\t\t\t\t\" size; message will be split starting at: \\\"%.*s\\\"\\n\", i, (i < 32) ? i : 32, *buff);\n\t\t\t\tdoSubmitMsg(pThis, stTime, ttGenTime, pMultiSub);\n\t\t\t\t++(*pnMsgs);\n\t\t\t\t/* we might think if it is better to ignore the rest of the\n\t\t\t\t * message than to treat it as a new one. Maybe this is a good\n\t\t\t\t * candidate for a configuration parameter...\n\t\t\t\t * rgerhards, 2006-12-04\n\t\t\t\t */\n\t\t\t}\n\n\t\t\tif ((c == '\\n')\n\t\t\t\t   || ((pThis->pLstn->pSrv->iAddtlFrameDelim != TCPSRV_NO_ADDTL_DELIMITER)\n\t\t\t\t\t   && (c == pThis->pLstn->pSrv->iAddtlFrameDelim))\n\t\t\t\t   ) { /* record delimiter? */\n\t\t\t\tdoSubmitMsg(pThis, stTime, ttGenTime, pMultiSub);\n\t\t\t\t++(*pnMsgs);\n\t\t\t\tpThis->inputState = eAtStrtFram;\n\t\t\t} else {\n\t\t\t\t/* IMPORTANT: here we copy the actual frame content to the message - for BOTH framing modes!\n\t\t\t\t * If we have a message that is larger than the max msg size, we truncate it. This is the best\n\t\t\t\t * we can do in light of what the engine supports. -- rgerhards, 2008-03-14\n\t\t\t\t */\n\t\t\t\tif(pThis->iMsg < iMaxLine) {\n\t\t\t\t\t*(pThis->pMsg + pThis->iMsg++) = c;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tassert(pThis->eFraming == TCP_FRAMING_OCTET_COUNTING);\n\t\t\toctatesToCopy = pThis->iOctetsRemain;\n\t\t\toctatesToDiscard = 0;\n\t\t\tif (buffLen < octatesToCopy) {\n\t\t\t\toctatesToCopy = buffLen;\n\t\t\t}\n\t\t\tif (octatesToCopy + pThis->iMsg > iMaxLine) {\n\t\t\t\toctatesToDiscard = octatesToCopy - (iMaxLine - pThis->iMsg);\n\t\t\t\toctatesToCopy = iMaxLine - pThis->iMsg;\n\t\t\t}\n\n\t\t\tmemcpy(pThis->pMsg + pThis->iMsg, *buff, octatesToCopy);\n\t\t\tpThis->iMsg += octatesToCopy;\n\t\t\tpThis->iOctetsRemain -= (octatesToCopy + octatesToDiscard);\n\t\t\t*buff += (octatesToCopy + octatesToDiscard - 1);\n\t\t\tif (pThis->iOctetsRemain == 0) {\n\t\t\t\t/* we have end of frame! */\n\t\t\t\tdoSubmitMsg(pThis, stTime, ttGenTime, pMultiSub);\n\t\t\t\t++(*pnMsgs);\n\t\t\t\tpThis->inputState = eAtStrtFram;\n\t\t\t}\n\t\t}\n\n\t}\n\nfinalize_it:\n\tRETiRet;\n}", "func_hash": 175845780697344678841951403700990960175, "file_name": "imptcp.c", "file_hash": 66608949268386945207139768258979939814, "cwe": ["CWE-190"], "cve": "CVE-2018-16881", "cve_desc": "A denial of service vulnerability was found in rsyslog in the imptcp module. An attacker could send a specially crafted message to the imptcp socket, which would cause rsyslog to crash. Versions before 8.27.0 are vulnerable.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2018-16881", "file_path": "plugins/imptcp/imptcp.c"}
{"idx": 462409, "project": "rsyslog", "commit_id": "0381a0de64a5a048c3d48b79055bd9848d0c7fc2", "project_url": "https://github.com/rsyslog/rsyslog", "commit_url": "https://github.com/rsyslog/rsyslog/commit/0381a0de64a5a048c3d48b79055bd9848d0c7fc2", "commit_message": "imptcp: fix Segmentation Fault when octet count is to high", "target": 0, "func": "processDataRcvd(ptcpsess_t *const __restrict__ pThis,\n\tchar **buff,\n\tconst int buffLen,\n\tstruct syslogTime *stTime,\n\tconst time_t ttGenTime,\n\tmulti_submit_t *pMultiSub,\n\tunsigned *const __restrict__ pnMsgs)\n{\n\tDEFiRet;\n\tchar c = **buff;\n\tint octatesToCopy, octatesToDiscard;\n\n\tif(pThis->inputState == eAtStrtFram) {\n\t\tif(pThis->bSuppOctetFram && isdigit((int) c)) {\n\t\t\tpThis->inputState = eInOctetCnt;\n\t\t\tpThis->iOctetsRemain = 0;\n\t\t\tpThis->eFraming = TCP_FRAMING_OCTET_COUNTING;\n\t\t} else if(pThis->bSPFramingFix && c == ' ') {\n\t\t\t/* Cisco very occasionally sends a SP after a LF, which\n\t\t\t * thrashes framing if not taken special care of. Here,\n\t\t\t * we permit space *in front of the next frame* and\n\t\t\t * ignore it.\n\t\t\t */\n\t\t\t FINALIZE;\n\t\t} else {\n\t\t\tpThis->inputState = eInMsg;\n\t\t\tpThis->eFraming = TCP_FRAMING_OCTET_STUFFING;\n\t\t}\n\t}\n\n\tif(pThis->inputState == eInOctetCnt) {\n\t\tif(isdigit(c)) {\n\t\t\tif(pThis->iOctetsRemain <= 200000000) {\n\t\t\t\tpThis->iOctetsRemain = pThis->iOctetsRemain * 10 + c - '0';\n\t\t\t} else {\n\t\t\t\terrmsg.LogError(0, NO_ERRCODE, \"Framing Error in received TCP message: \"\n\t\t\t\t\t\t\"frame too large (at least %d%c), change to octet stuffing\",\n\t\t\t\t\t\tpThis->iOctetsRemain, c);\n\t\t\t\tpThis->eFraming = TCP_FRAMING_OCTET_STUFFING;\n\t\t\t\tpThis->inputState = eInMsg;\n\t\t\t}\n\t\t\t*(pThis->pMsg + pThis->iMsg++) = c;\n\t\t} else { /* done with the octet count, so this must be the SP terminator */\n\t\t\tDBGPRINTF(\"TCP Message with octet-counter, size %d.\\n\", pThis->iOctetsRemain);\n\t\t\tif(c != ' ') {\n\t\t\t\terrmsg.LogError(0, NO_ERRCODE, \"Framing Error in received TCP message: \"\n\t\t\t\t\t    \"delimiter is not SP but has ASCII value %d.\", c);\n\t\t\t}\n\t\t\tif(pThis->iOctetsRemain < 1) {\n\t\t\t\t/* TODO: handle the case where the octet count is 0! */\n\t\t\t\terrmsg.LogError(0, NO_ERRCODE, \"Framing Error in received TCP message: \"\n\t\t\t\t\t    \"invalid octet count %d.\", pThis->iOctetsRemain);\n\t\t\t\tpThis->eFraming = TCP_FRAMING_OCTET_STUFFING;\n\t\t\t} else if(pThis->iOctetsRemain > iMaxLine) {\n\t\t\t\t/* while we can not do anything against it, we can at least log an indication\n\t\t\t\t * that something went wrong) -- rgerhards, 2008-03-14\n\t\t\t\t */\n\t\t\t\tDBGPRINTF(\"truncating message with %d octets - max msg size is %d\\n\",\n\t\t\t\t\t  pThis->iOctetsRemain, iMaxLine);\n\t\t\t\terrmsg.LogError(0, NO_ERRCODE, \"received oversize message: size is %d bytes, \"\n\t\t\t\t\t        \"max msg size is %d, truncating...\", pThis->iOctetsRemain, iMaxLine);\n\t\t\t}\n\t\t\tpThis->inputState = eInMsg;\n\t\t\tpThis->iMsg = 0;\n\t\t}\n\t} else {\n\t\tassert(pThis->inputState == eInMsg);\n\n\t\tif (pThis->eFraming == TCP_FRAMING_OCTET_STUFFING) {\n\t\t\tif(pThis->iMsg >= iMaxLine) {\n\t\t\t\t/* emergency, we now need to flush, no matter if we are at end of message or not... */\n\t\t\t\tint i = 1;\n\t\t\t\tchar currBuffChar;\n\t\t\t\twhile(i < buffLen && ((currBuffChar = (*buff)[i]) != '\\n'\n\t\t\t\t\t&& (pThis->pLstn->pSrv->iAddtlFrameDelim == TCPSRV_NO_ADDTL_DELIMITER\n\t\t\t\t\t\t|| currBuffChar != pThis->pLstn->pSrv->iAddtlFrameDelim))) {\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tLogError(0, NO_ERRCODE, \"error: message received is at least %d byte larger than max msg\"\n\t\t\t\t\t\" size; message will be split starting at: \\\"%.*s\\\"\\n\", i, (i < 32) ? i : 32, *buff);\n\t\t\t\tdoSubmitMsg(pThis, stTime, ttGenTime, pMultiSub);\n\t\t\t\t++(*pnMsgs);\n\t\t\t\t/* we might think if it is better to ignore the rest of the\n\t\t\t\t * message than to treat it as a new one. Maybe this is a good\n\t\t\t\t * candidate for a configuration parameter...\n\t\t\t\t * rgerhards, 2006-12-04\n\t\t\t\t */\n\t\t\t}\n\n\t\t\tif ((c == '\\n')\n\t\t\t\t   || ((pThis->pLstn->pSrv->iAddtlFrameDelim != TCPSRV_NO_ADDTL_DELIMITER)\n\t\t\t\t\t   && (c == pThis->pLstn->pSrv->iAddtlFrameDelim))\n\t\t\t\t   ) { /* record delimiter? */\n\t\t\t\tdoSubmitMsg(pThis, stTime, ttGenTime, pMultiSub);\n\t\t\t\t++(*pnMsgs);\n\t\t\t\tpThis->inputState = eAtStrtFram;\n\t\t\t} else {\n\t\t\t\t/* IMPORTANT: here we copy the actual frame content to the message - for BOTH framing modes!\n\t\t\t\t * If we have a message that is larger than the max msg size, we truncate it. This is the best\n\t\t\t\t * we can do in light of what the engine supports. -- rgerhards, 2008-03-14\n\t\t\t\t */\n\t\t\t\tif(pThis->iMsg < iMaxLine) {\n\t\t\t\t\t*(pThis->pMsg + pThis->iMsg++) = c;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tassert(pThis->eFraming == TCP_FRAMING_OCTET_COUNTING);\n\t\t\toctatesToCopy = pThis->iOctetsRemain;\n\t\t\toctatesToDiscard = 0;\n\t\t\tif (buffLen < octatesToCopy) {\n\t\t\t\toctatesToCopy = buffLen;\n\t\t\t}\n\t\t\tif (octatesToCopy + pThis->iMsg > iMaxLine) {\n\t\t\t\toctatesToDiscard = octatesToCopy - (iMaxLine - pThis->iMsg);\n\t\t\t\toctatesToCopy = iMaxLine - pThis->iMsg;\n\t\t\t}\n\n\t\t\tmemcpy(pThis->pMsg + pThis->iMsg, *buff, octatesToCopy);\n\t\t\tpThis->iMsg += octatesToCopy;\n\t\t\tpThis->iOctetsRemain -= (octatesToCopy + octatesToDiscard);\n\t\t\t*buff += (octatesToCopy + octatesToDiscard - 1);\n\t\t\tif (pThis->iOctetsRemain == 0) {\n\t\t\t\t/* we have end of frame! */\n\t\t\t\tdoSubmitMsg(pThis, stTime, ttGenTime, pMultiSub);\n\t\t\t\t++(*pnMsgs);\n\t\t\t\tpThis->inputState = eAtStrtFram;\n\t\t\t}\n\t\t}\n\n\t}\n\nfinalize_it:\n\tRETiRet;\n}", "func_hash": 319180109338452321529530788318348241217, "file_name": "imptcp.c", "file_hash": 222511081390723120608536252618686301143, "cwe": ["CWE-190"], "cve": "CVE-2018-16881", "cve_desc": "A denial of service vulnerability was found in rsyslog in the imptcp module. An attacker could send a specially crafted message to the imptcp socket, which would cause rsyslog to crash. Versions before 8.27.0 are vulnerable.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2018-16881", "file_path": "plugins/imptcp/imptcp.c"}
