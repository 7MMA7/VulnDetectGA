{"idx": 208522, "project": "unbound", "commit_id": "02080f6b180232f43b77f403d0c038e9360a460f", "project_url": "https://github.com/NLnetLabs/unbound", "commit_url": "https://github.com/NLnetLabs/unbound/commit/02080f6b180232f43b77f403d0c038e9360a460f", "commit_message": "- Fix Integer Overflows in Size Calculations,\n  reported by X41 D-Sec.", "target": 1, "func": "dnsc_load_local_data(struct dnsc_env* dnscenv, struct config_file *cfg)\n{\n    size_t i, j;\n\t// Insert 'local-zone: \"2.dnscrypt-cert.example.com\" deny'\n    if(!cfg_str2list_insert(&cfg->local_zones,\n                            strdup(dnscenv->provider_name),\n                            strdup(\"deny\"))) {\n        log_err(\"Could not load dnscrypt local-zone: %s deny\",\n                dnscenv->provider_name);\n        return -1;\n    }\n\n    // Add local data entry of type:\n    // 2.dnscrypt-cert.example.com 86400 IN TXT \"DNSC......\"\n    for(i=0; i<dnscenv->signed_certs_count; i++) {\n        const char *ttl_class_type = \" 86400 IN TXT \\\"\";\n        int rotated_cert = 0;\n\tuint32_t serial;\n\tuint16_t rrlen;\n\tchar* rr;\n        struct SignedCert *cert = dnscenv->signed_certs + i;\n\t\t// Check if the certificate is being rotated and should not be published\n        for(j=0; j<dnscenv->rotated_certs_count; j++){\n            if(cert == dnscenv->rotated_certs[j]) {\n                rotated_cert = 1;\n                break;\n            }\n        }\n\t\tmemcpy(&serial, cert->serial, sizeof serial);\n\t\tserial = htonl(serial);\n        if(rotated_cert) {\n            verbose(VERB_OPS,\n                \"DNSCrypt: not adding cert with serial #%\"\n                PRIu32\n                \" to local-data as it is rotated\",\n                serial\n            );\n            continue;\n        }\n        rrlen = strlen(dnscenv->provider_name) +\n                         strlen(ttl_class_type) +\n                         4 * sizeof(struct SignedCert) + // worst case scenario\n                         1 + // trailing double quote\n                         1;\n        rr = malloc(rrlen);\n        if(!rr) {\n            log_err(\"Could not allocate memory\");\n            return -2;\n        }\n        snprintf(rr, rrlen - 1, \"%s 86400 IN TXT \\\"\", dnscenv->provider_name);\n        for(j=0; j<sizeof(struct SignedCert); j++) {\n\t\t\tint c = (int)*((const uint8_t *) cert + j);\n            if (isprint(c) && c != '\"' && c != '\\\\') {\n                snprintf(rr + strlen(rr), rrlen - 1 - strlen(rr), \"%c\", c);\n            } else {\n                snprintf(rr + strlen(rr), rrlen - 1 - strlen(rr), \"\\\\%03d\", c);\n            }\n        }\n        verbose(VERB_OPS,\n\t\t\t\"DNSCrypt: adding cert with serial #%\"\n\t\t\tPRIu32\n\t\t\t\" to local-data to config: %s\",\n\t\t\tserial, rr\n\t\t);\n        snprintf(rr + strlen(rr), rrlen - 1 - strlen(rr), \"\\\"\");\n        cfg_strlist_insert(&cfg->local_data, strdup(rr));\n        free(rr);\n    }\n    return dnscenv->signed_certs_count;\n}", "func_hash": 44451332163685602086826854088983200257, "file_name": "dnscrypt.c", "file_hash": 338731906376917706393921999097571082291, "cwe": ["CWE-190"], "cve": "CVE-2019-25038", "cve_desc": "Unbound before 1.9.5 allows an integer overflow in a size calculation in dnscrypt/dnscrypt.c. NOTE: The vendor disputes that this is a vulnerability. Although the code may be vulnerable, a running Unbound installation cannot be remotely or locally exploited", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2019-25038", "file_path": "dnscrypt/dnscrypt.c"}
{"idx": 412117, "project": "unbound", "commit_id": "02080f6b180232f43b77f403d0c038e9360a460f", "project_url": "https://github.com/NLnetLabs/unbound", "commit_url": "https://github.com/NLnetLabs/unbound/commit/02080f6b180232f43b77f403d0c038e9360a460f", "commit_message": "- Fix Integer Overflows in Size Calculations,\n  reported by X41 D-Sec.", "target": 0, "func": "dnsc_load_local_data(struct dnsc_env* dnscenv, struct config_file *cfg)\n{\n    size_t i, j;\n\t// Insert 'local-zone: \"2.dnscrypt-cert.example.com\" deny'\n    if(!cfg_str2list_insert(&cfg->local_zones,\n                            strdup(dnscenv->provider_name),\n                            strdup(\"deny\"))) {\n        log_err(\"Could not load dnscrypt local-zone: %s deny\",\n                dnscenv->provider_name);\n        return -1;\n    }\n\n    // Add local data entry of type:\n    // 2.dnscrypt-cert.example.com 86400 IN TXT \"DNSC......\"\n    for(i=0; i<dnscenv->signed_certs_count; i++) {\n        const char *ttl_class_type = \" 86400 IN TXT \\\"\";\n        int rotated_cert = 0;\n\tuint32_t serial;\n\tuint16_t rrlen;\n\tchar* rr;\n        struct SignedCert *cert = dnscenv->signed_certs + i;\n\t\t// Check if the certificate is being rotated and should not be published\n        for(j=0; j<dnscenv->rotated_certs_count; j++){\n            if(cert == dnscenv->rotated_certs[j]) {\n                rotated_cert = 1;\n                break;\n            }\n        }\n\t\tmemcpy(&serial, cert->serial, sizeof serial);\n\t\tserial = htonl(serial);\n        if(rotated_cert) {\n            verbose(VERB_OPS,\n                \"DNSCrypt: not adding cert with serial #%\"\n                PRIu32\n                \" to local-data as it is rotated\",\n                serial\n            );\n            continue;\n        }\n\tif((unsigned)strlen(dnscenv->provider_name) >= (unsigned)0xffff0000) {\n\t\t/* guard against integer overflow in rrlen calculation */\n\t\tverbose(VERB_OPS, \"cert #%\" PRIu32 \" is too long\", serial);\n\t\tcontinue\n\t}\n        rrlen = strlen(dnscenv->provider_name) +\n                         strlen(ttl_class_type) +\n                         4 * sizeof(struct SignedCert) + // worst case scenario\n                         1 + // trailing double quote\n                         1;\n        rr = malloc(rrlen);\n        if(!rr) {\n            log_err(\"Could not allocate memory\");\n            return -2;\n        }\n        snprintf(rr, rrlen - 1, \"%s 86400 IN TXT \\\"\", dnscenv->provider_name);\n        for(j=0; j<sizeof(struct SignedCert); j++) {\n\t\t\tint c = (int)*((const uint8_t *) cert + j);\n            if (isprint(c) && c != '\"' && c != '\\\\') {\n                snprintf(rr + strlen(rr), rrlen - 1 - strlen(rr), \"%c\", c);\n            } else {\n                snprintf(rr + strlen(rr), rrlen - 1 - strlen(rr), \"\\\\%03d\", c);\n            }\n        }\n        verbose(VERB_OPS,\n\t\t\t\"DNSCrypt: adding cert with serial #%\"\n\t\t\tPRIu32\n\t\t\t\" to local-data to config: %s\",\n\t\t\tserial, rr\n\t\t);\n        snprintf(rr + strlen(rr), rrlen - 1 - strlen(rr), \"\\\"\");\n        cfg_strlist_insert(&cfg->local_data, strdup(rr));\n        free(rr);\n    }\n    return dnscenv->signed_certs_count;\n}", "func_hash": 220864762997315196932796822660985000469, "file_name": "dnscrypt.c", "file_hash": 151631660973156645492009635074477412124, "cwe": ["CWE-190"], "cve": "CVE-2019-25038", "cve_desc": "Unbound before 1.9.5 allows an integer overflow in a size calculation in dnscrypt/dnscrypt.c. NOTE: The vendor disputes that this is a vulnerability. Although the code may be vulnerable, a running Unbound installation cannot be remotely or locally exploited", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2019-25038", "file_path": "dnscrypt/dnscrypt.c"}
