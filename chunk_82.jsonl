{"idx": 206625, "project": "raptor", "commit_id": "590681e546cd9aa18d57dc2ea1858cb734a3863f", "project_url": "https://github.com/dajobe/raptor", "commit_url": "https://github.com/dajobe/raptor/commit/590681e546cd9aa18d57dc2ea1858cb734a3863f", "commit_message": "Calcualte max nspace declarations correctly for XML writer\n\n(raptor_xml_writer_start_element_common): Calculate max including for\neach attribute a potential name and value.\n\nFixes Issues #0000617 http://bugs.librdf.org/mantis/view.php?id=617\nand #0000618 http://bugs.librdf.org/mantis/view.php?id=618", "target": 1, "func": "raptor_xml_writer_start_element_common(raptor_xml_writer* xml_writer,\n                                       raptor_xml_element* element,\n                                       int auto_empty)\n{\n  raptor_iostream* iostr = xml_writer->iostr;\n  raptor_namespace_stack *nstack = xml_writer->nstack;\n  int depth = xml_writer->depth;\n  int auto_indent = XML_WRITER_AUTO_INDENT(xml_writer);\n  struct nsd *nspace_declarations = NULL;\n  size_t nspace_declarations_count = 0;  \n  unsigned int i;\n\n  /* max is 1 per element and 1 for each attribute + size of declared */\n  if(nstack) {\n    int nspace_max_count = element->attribute_count+1;\n    if(element->declared_nspaces)\n      nspace_max_count += raptor_sequence_size(element->declared_nspaces);\n    if(element->xml_language)\n      nspace_max_count++;\n\n    nspace_declarations = RAPTOR_CALLOC(struct nsd*, nspace_max_count,\n                                        sizeof(struct nsd));\n    if(!nspace_declarations)\n      return 1;\n  }\n\n  if(element->name->nspace) {\n    if(nstack && !raptor_namespaces_namespace_in_scope(nstack, element->name->nspace)) {\n      nspace_declarations[0].declaration=\n        raptor_namespace_format_as_xml(element->name->nspace,\n                                       &nspace_declarations[0].length);\n      if(!nspace_declarations[0].declaration)\n        goto error;\n      nspace_declarations[0].nspace = element->name->nspace;\n      nspace_declarations_count++;\n    }\n  }\n\n  if(nstack && element->attributes) {\n    for(i = 0; i < element->attribute_count; i++) {\n      /* qname */\n      if(element->attributes[i]->nspace) {\n        /* Check if we need a namespace declaration attribute */\n        if(nstack && \n           !raptor_namespaces_namespace_in_scope(nstack, element->attributes[i]->nspace) && element->attributes[i]->nspace != element->name->nspace) {\n          /* not in scope and not same as element (so already going to be declared)*/\n          unsigned int j;\n          int declare_me = 1;\n          \n          /* check it wasn't an earlier declaration too */\n          for(j = 0; j < nspace_declarations_count; j++)\n            if(nspace_declarations[j].nspace == element->attributes[j]->nspace) {\n              declare_me = 0;\n              break;\n            }\n            \n          if(declare_me) {\n            nspace_declarations[nspace_declarations_count].declaration=\n              raptor_namespace_format_as_xml(element->attributes[i]->nspace,\n                                             &nspace_declarations[nspace_declarations_count].length);\n            if(!nspace_declarations[nspace_declarations_count].declaration)\n              goto error;\n            nspace_declarations[nspace_declarations_count].nspace = element->attributes[i]->nspace;\n            nspace_declarations_count++;\n          }\n        }\n      }\n\n      /* Add the attribute + value */\n      nspace_declarations[nspace_declarations_count].declaration=\n        raptor_qname_format_as_xml(element->attributes[i],\n                                   &nspace_declarations[nspace_declarations_count].length);\n      if(!nspace_declarations[nspace_declarations_count].declaration)\n        goto error;\n      nspace_declarations[nspace_declarations_count].nspace = NULL;\n      nspace_declarations_count++;\n\n    }\n  }\n\n  if(nstack && element->declared_nspaces &&\n     raptor_sequence_size(element->declared_nspaces) > 0) {\n    for(i = 0; i< (unsigned int)raptor_sequence_size(element->declared_nspaces); i++) {\n      raptor_namespace* nspace = (raptor_namespace*)raptor_sequence_get_at(element->declared_nspaces, i);\n      unsigned int j;\n      int declare_me = 1;\n      \n      /* check it wasn't an earlier declaration too */\n      for(j = 0; j < nspace_declarations_count; j++)\n        if(nspace_declarations[j].nspace == nspace) {\n          declare_me = 0;\n          break;\n        }\n      \n      if(declare_me) {\n        nspace_declarations[nspace_declarations_count].declaration=\n          raptor_namespace_format_as_xml(nspace,\n                                         &nspace_declarations[nspace_declarations_count].length);\n        if(!nspace_declarations[nspace_declarations_count].declaration)\n          goto error;\n        nspace_declarations[nspace_declarations_count].nspace = nspace;\n        nspace_declarations_count++;\n      }\n\n    }\n  }\n\n  if(nstack && element->xml_language) {\n    size_t lang_len = strlen(RAPTOR_GOOD_CAST(char*, element->xml_language));\n#define XML_LANG_PREFIX_LEN 10\n    size_t buf_length = XML_LANG_PREFIX_LEN + lang_len + 1;\n    unsigned char* buffer = RAPTOR_MALLOC(unsigned char*, buf_length + 1);\n    const char quote = '\\\"';\n    unsigned char* p;\n\n    memcpy(buffer, \"xml:lang=\\\"\", XML_LANG_PREFIX_LEN);\n    p = buffer + XML_LANG_PREFIX_LEN;\n    p += raptor_xml_escape_string(xml_writer->world,\n                                  element->xml_language, lang_len,\n                                  p, buf_length, quote);\n    *p++ = quote;\n    *p = '\\0';\n\n    nspace_declarations[nspace_declarations_count].declaration = buffer;\n    nspace_declarations[nspace_declarations_count].length = buf_length;\n    nspace_declarations[nspace_declarations_count].nspace = NULL;\n    nspace_declarations_count++;\n  }\n  \n\n  raptor_iostream_write_byte('<', iostr);\n\n  if(element->name->nspace && element->name->nspace->prefix_length > 0) {\n    raptor_iostream_counted_string_write((const char*)element->name->nspace->prefix, \n                                         element->name->nspace->prefix_length,\n                                         iostr);\n    raptor_iostream_write_byte(':', iostr);\n  }\n  raptor_iostream_counted_string_write((const char*)element->name->local_name,\n                                       element->name->local_name_length,\n                                       iostr);\n\n  /* declare namespaces and attributes */\n  if(nspace_declarations_count) {\n    int need_indent = 0;\n    \n    /* sort them into the canonical order */\n    qsort((void*)nspace_declarations, \n          nspace_declarations_count, sizeof(struct nsd),\n          raptor_xml_writer_nsd_compare);\n\n    /* declare namespaces first */\n    for(i = 0; i < nspace_declarations_count; i++) {\n      if(!nspace_declarations[i].nspace)\n        continue;\n\n      if(auto_indent && need_indent) {\n        /* indent attributes */\n        raptor_xml_writer_newline(xml_writer);\n        xml_writer->depth++;\n        raptor_xml_writer_indent(xml_writer);\n        xml_writer->depth--;\n      }\n      raptor_iostream_write_byte(' ', iostr);\n      raptor_iostream_counted_string_write((const char*)nspace_declarations[i].declaration,\n                                           nspace_declarations[i].length,\n                                           iostr);\n      RAPTOR_FREE(char*, nspace_declarations[i].declaration);\n      nspace_declarations[i].declaration = NULL;\n      need_indent = 1;\n      \n      if(raptor_namespace_stack_start_namespace(nstack,\n                                                (raptor_namespace*)nspace_declarations[i].nspace,\n                                                depth))\n        goto error;\n    }\n\n    /* declare attributes */\n    for(i = 0; i < nspace_declarations_count; i++) {\n      if(nspace_declarations[i].nspace)\n        continue;\n\n      if(auto_indent && need_indent) {\n        /* indent attributes */\n        raptor_xml_writer_newline(xml_writer);\n        xml_writer->depth++;\n        raptor_xml_writer_indent(xml_writer);\n        xml_writer->depth--;\n      }\n      raptor_iostream_write_byte(' ', iostr);\n      raptor_iostream_counted_string_write((const char*)nspace_declarations[i].declaration,\n                                           nspace_declarations[i].length,\n                                           iostr);\n      need_indent = 1;\n\n      RAPTOR_FREE(char*, nspace_declarations[i].declaration);\n      nspace_declarations[i].declaration = NULL;\n    }\n  }\n\n  if(!auto_empty)\n    raptor_iostream_write_byte('>', iostr);\n\n  if(nstack)\n    RAPTOR_FREE(stringarray, nspace_declarations);\n\n  return 0;\n\n  /* Clean up nspace_declarations on error */\n  error:\n\n  for(i = 0; i < nspace_declarations_count; i++) {\n    if(nspace_declarations[i].declaration)\n      RAPTOR_FREE(char*, nspace_declarations[i].declaration);\n  }\n\n  RAPTOR_FREE(stringarray, nspace_declarations);\n\n  return 1;\n}", "func_hash": 183974089624650942434351568312452779610, "file_name": "raptor_xml_writer.c", "file_hash": 303005196227120175198140448209688194758, "cwe": ["CWE-787"], "cve": "CVE-2017-18926", "cve_desc": "raptor_xml_writer_start_element_common in raptor_xml_writer.c in Raptor RDF Syntax Library 2.0.15 miscalculates the maximum nspace declarations for the XML writer, leading to heap-based buffer overflows (sometimes seen in raptor_qname_format_as_xml).", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-18926", "file_path": "src/raptor_xml_writer.c"}
{"idx": 384124, "project": "raptor", "commit_id": "590681e546cd9aa18d57dc2ea1858cb734a3863f", "project_url": "https://github.com/dajobe/raptor", "commit_url": "https://github.com/dajobe/raptor/commit/590681e546cd9aa18d57dc2ea1858cb734a3863f", "commit_message": "Calcualte max nspace declarations correctly for XML writer\n\n(raptor_xml_writer_start_element_common): Calculate max including for\neach attribute a potential name and value.\n\nFixes Issues #0000617 http://bugs.librdf.org/mantis/view.php?id=617\nand #0000618 http://bugs.librdf.org/mantis/view.php?id=618", "target": 0, "func": "raptor_xml_writer_start_element_common(raptor_xml_writer* xml_writer,\n                                       raptor_xml_element* element,\n                                       int auto_empty)\n{\n  raptor_iostream* iostr = xml_writer->iostr;\n  raptor_namespace_stack *nstack = xml_writer->nstack;\n  int depth = xml_writer->depth;\n  int auto_indent = XML_WRITER_AUTO_INDENT(xml_writer);\n  struct nsd *nspace_declarations = NULL;\n  size_t nspace_declarations_count = 0;  \n  unsigned int i;\n\n  if(nstack) {\n    int nspace_max_count = element->attribute_count * 2; /* attr and value */\n    if(element->name->nspace)\n      nspace_max_count++;\n    if(element->declared_nspaces)\n      nspace_max_count += raptor_sequence_size(element->declared_nspaces);\n    if(element->xml_language)\n      nspace_max_count++;\n\n    nspace_declarations = RAPTOR_CALLOC(struct nsd*, nspace_max_count,\n                                        sizeof(struct nsd));\n    if(!nspace_declarations)\n      return 1;\n  }\n\n  if(element->name->nspace) {\n    if(nstack && !raptor_namespaces_namespace_in_scope(nstack, element->name->nspace)) {\n      nspace_declarations[0].declaration=\n        raptor_namespace_format_as_xml(element->name->nspace,\n                                       &nspace_declarations[0].length);\n      if(!nspace_declarations[0].declaration)\n        goto error;\n      nspace_declarations[0].nspace = element->name->nspace;\n      nspace_declarations_count++;\n    }\n  }\n\n  if(nstack && element->attributes) {\n    for(i = 0; i < element->attribute_count; i++) {\n      /* qname */\n      if(element->attributes[i]->nspace) {\n        /* Check if we need a namespace declaration attribute */\n        if(nstack && \n           !raptor_namespaces_namespace_in_scope(nstack, element->attributes[i]->nspace) && element->attributes[i]->nspace != element->name->nspace) {\n          /* not in scope and not same as element (so already going to be declared)*/\n          unsigned int j;\n          int declare_me = 1;\n          \n          /* check it wasn't an earlier declaration too */\n          for(j = 0; j < nspace_declarations_count; j++)\n            if(nspace_declarations[j].nspace == element->attributes[j]->nspace) {\n              declare_me = 0;\n              break;\n            }\n            \n          if(declare_me) {\n            nspace_declarations[nspace_declarations_count].declaration=\n              raptor_namespace_format_as_xml(element->attributes[i]->nspace,\n                                             &nspace_declarations[nspace_declarations_count].length);\n            if(!nspace_declarations[nspace_declarations_count].declaration)\n              goto error;\n            nspace_declarations[nspace_declarations_count].nspace = element->attributes[i]->nspace;\n            nspace_declarations_count++;\n          }\n        }\n      }\n\n      /* Add the attribute's value */\n      nspace_declarations[nspace_declarations_count].declaration=\n        raptor_qname_format_as_xml(element->attributes[i],\n                                   &nspace_declarations[nspace_declarations_count].length);\n      if(!nspace_declarations[nspace_declarations_count].declaration)\n        goto error;\n      nspace_declarations[nspace_declarations_count].nspace = NULL;\n      nspace_declarations_count++;\n\n    }\n  }\n\n  if(nstack && element->declared_nspaces &&\n     raptor_sequence_size(element->declared_nspaces) > 0) {\n    for(i = 0; i< (unsigned int)raptor_sequence_size(element->declared_nspaces); i++) {\n      raptor_namespace* nspace = (raptor_namespace*)raptor_sequence_get_at(element->declared_nspaces, i);\n      unsigned int j;\n      int declare_me = 1;\n      \n      /* check it wasn't an earlier declaration too */\n      for(j = 0; j < nspace_declarations_count; j++)\n        if(nspace_declarations[j].nspace == nspace) {\n          declare_me = 0;\n          break;\n        }\n      \n      if(declare_me) {\n        nspace_declarations[nspace_declarations_count].declaration=\n          raptor_namespace_format_as_xml(nspace,\n                                         &nspace_declarations[nspace_declarations_count].length);\n        if(!nspace_declarations[nspace_declarations_count].declaration)\n          goto error;\n        nspace_declarations[nspace_declarations_count].nspace = nspace;\n        nspace_declarations_count++;\n      }\n\n    }\n  }\n\n  if(nstack && element->xml_language) {\n    size_t lang_len = strlen(RAPTOR_GOOD_CAST(char*, element->xml_language));\n#define XML_LANG_PREFIX_LEN 10\n    size_t buf_length = XML_LANG_PREFIX_LEN + lang_len + 1;\n    unsigned char* buffer = RAPTOR_MALLOC(unsigned char*, buf_length + 1);\n    const char quote = '\\\"';\n    unsigned char* p;\n\n    memcpy(buffer, \"xml:lang=\\\"\", XML_LANG_PREFIX_LEN);\n    p = buffer + XML_LANG_PREFIX_LEN;\n    p += raptor_xml_escape_string(xml_writer->world,\n                                  element->xml_language, lang_len,\n                                  p, buf_length, quote);\n    *p++ = quote;\n    *p = '\\0';\n\n    nspace_declarations[nspace_declarations_count].declaration = buffer;\n    nspace_declarations[nspace_declarations_count].length = buf_length;\n    nspace_declarations[nspace_declarations_count].nspace = NULL;\n    nspace_declarations_count++;\n  }\n  \n\n  raptor_iostream_write_byte('<', iostr);\n\n  if(element->name->nspace && element->name->nspace->prefix_length > 0) {\n    raptor_iostream_counted_string_write((const char*)element->name->nspace->prefix, \n                                         element->name->nspace->prefix_length,\n                                         iostr);\n    raptor_iostream_write_byte(':', iostr);\n  }\n  raptor_iostream_counted_string_write((const char*)element->name->local_name,\n                                       element->name->local_name_length,\n                                       iostr);\n\n  /* declare namespaces and attributes */\n  if(nspace_declarations_count) {\n    int need_indent = 0;\n    \n    /* sort them into the canonical order */\n    qsort((void*)nspace_declarations, \n          nspace_declarations_count, sizeof(struct nsd),\n          raptor_xml_writer_nsd_compare);\n\n    /* declare namespaces first */\n    for(i = 0; i < nspace_declarations_count; i++) {\n      if(!nspace_declarations[i].nspace)\n        continue;\n\n      if(auto_indent && need_indent) {\n        /* indent attributes */\n        raptor_xml_writer_newline(xml_writer);\n        xml_writer->depth++;\n        raptor_xml_writer_indent(xml_writer);\n        xml_writer->depth--;\n      }\n      raptor_iostream_write_byte(' ', iostr);\n      raptor_iostream_counted_string_write((const char*)nspace_declarations[i].declaration,\n                                           nspace_declarations[i].length,\n                                           iostr);\n      RAPTOR_FREE(char*, nspace_declarations[i].declaration);\n      nspace_declarations[i].declaration = NULL;\n      need_indent = 1;\n      \n      if(raptor_namespace_stack_start_namespace(nstack,\n                                                (raptor_namespace*)nspace_declarations[i].nspace,\n                                                depth))\n        goto error;\n    }\n\n    /* declare attributes */\n    for(i = 0; i < nspace_declarations_count; i++) {\n      if(nspace_declarations[i].nspace)\n        continue;\n\n      if(auto_indent && need_indent) {\n        /* indent attributes */\n        raptor_xml_writer_newline(xml_writer);\n        xml_writer->depth++;\n        raptor_xml_writer_indent(xml_writer);\n        xml_writer->depth--;\n      }\n      raptor_iostream_write_byte(' ', iostr);\n      raptor_iostream_counted_string_write((const char*)nspace_declarations[i].declaration,\n                                           nspace_declarations[i].length,\n                                           iostr);\n      need_indent = 1;\n\n      RAPTOR_FREE(char*, nspace_declarations[i].declaration);\n      nspace_declarations[i].declaration = NULL;\n    }\n  }\n\n  if(!auto_empty)\n    raptor_iostream_write_byte('>', iostr);\n\n  if(nstack)\n    RAPTOR_FREE(stringarray, nspace_declarations);\n\n  return 0;\n\n  /* Clean up nspace_declarations on error */\n  error:\n\n  for(i = 0; i < nspace_declarations_count; i++) {\n    if(nspace_declarations[i].declaration)\n      RAPTOR_FREE(char*, nspace_declarations[i].declaration);\n  }\n\n  RAPTOR_FREE(stringarray, nspace_declarations);\n\n  return 1;\n}", "func_hash": 82963305933956175677502497774267767451, "file_name": "raptor_xml_writer.c", "file_hash": 139112831165877018854969912519011883099, "cwe": ["CWE-787"], "cve": "CVE-2017-18926", "cve_desc": "raptor_xml_writer_start_element_common in raptor_xml_writer.c in Raptor RDF Syntax Library 2.0.15 miscalculates the maximum nspace declarations for the XML writer, leading to heap-based buffer overflows (sometimes seen in raptor_qname_format_as_xml).", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-18926", "file_path": "src/raptor_xml_writer.c"}
{"idx": 206639, "project": "linux", "commit_id": "e02f0d3970404bfea385b6edb86f2d936db0ea2b", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/e02f0d3970404bfea385b6edb86f2d936db0ea2b", "commit_message": "netfilter: nf_tables: disallow binding to already bound chain\n\nUpdate nft_data_init() to report EINVAL if chain is already bound.\n\nFixes: d0e2c7de92c7 (\"netfilter: nf_tables: add NFT_CHAIN_BINDING\")\nReported-by: Gwangun Jung <exsociety@gmail.com>\nSigned-off-by: Pablo Neira Ayuso <pablo@netfilter.org>", "target": 1, "func": "static int nft_verdict_init(const struct nft_ctx *ctx, struct nft_data *data,\n\t\t\t    struct nft_data_desc *desc, const struct nlattr *nla)\n{\n\tu8 genmask = nft_genmask_next(ctx->net);\n\tstruct nlattr *tb[NFTA_VERDICT_MAX + 1];\n\tstruct nft_chain *chain;\n\tint err;\n\n\terr = nla_parse_nested_deprecated(tb, NFTA_VERDICT_MAX, nla,\n\t\t\t\t\t  nft_verdict_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!tb[NFTA_VERDICT_CODE])\n\t\treturn -EINVAL;\n\tdata->verdict.code = ntohl(nla_get_be32(tb[NFTA_VERDICT_CODE]));\n\n\tswitch (data->verdict.code) {\n\tdefault:\n\t\tswitch (data->verdict.code & NF_VERDICT_MASK) {\n\t\tcase NF_ACCEPT:\n\t\tcase NF_DROP:\n\t\tcase NF_QUEUE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tfallthrough;\n\tcase NFT_CONTINUE:\n\tcase NFT_BREAK:\n\tcase NFT_RETURN:\n\t\tbreak;\n\tcase NFT_JUMP:\n\tcase NFT_GOTO:\n\t\tif (tb[NFTA_VERDICT_CHAIN]) {\n\t\t\tchain = nft_chain_lookup(ctx->net, ctx->table,\n\t\t\t\t\t\t tb[NFTA_VERDICT_CHAIN],\n\t\t\t\t\t\t genmask);\n\t\t} else if (tb[NFTA_VERDICT_CHAIN_ID]) {\n\t\t\tchain = nft_chain_lookup_byid(ctx->net, ctx->table,\n\t\t\t\t\t\t      tb[NFTA_VERDICT_CHAIN_ID]);\n\t\t\tif (IS_ERR(chain))\n\t\t\t\treturn PTR_ERR(chain);\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (IS_ERR(chain))\n\t\t\treturn PTR_ERR(chain);\n\t\tif (nft_is_base_chain(chain))\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (desc->flags & NFT_DATA_DESC_SETELEM &&\n\t\t    chain->flags & NFT_CHAIN_BINDING)\n\t\t\treturn -EINVAL;\n\n\t\tchain->use++;\n\t\tdata->verdict.chain = chain;\n\t\tbreak;\n\t}\n\n\tdesc->len = sizeof(data->verdict);\n\n\treturn 0;\n}", "func_hash": 76294390154807140346030498178733770308, "file_name": "nf_tables_api.c", "file_hash": 280373467088228575441623327249382307245, "cwe": ["CWE-703"], "cve": "CVE-2022-39190", "cve_desc": "An issue was discovered in net/netfilter/nf_tables_api.c in the Linux kernel before 5.19.6. A denial of service can occur upon binding to an already bound chain.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-39190", "file_path": "net/netfilter/nf_tables_api.c"}
{"idx": 384201, "project": "linux", "commit_id": "e02f0d3970404bfea385b6edb86f2d936db0ea2b", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/e02f0d3970404bfea385b6edb86f2d936db0ea2b", "commit_message": "netfilter: nf_tables: disallow binding to already bound chain\n\nUpdate nft_data_init() to report EINVAL if chain is already bound.\n\nFixes: d0e2c7de92c7 (\"netfilter: nf_tables: add NFT_CHAIN_BINDING\")\nReported-by: Gwangun Jung <exsociety@gmail.com>\nSigned-off-by: Pablo Neira Ayuso <pablo@netfilter.org>", "target": 0, "func": "static int nft_verdict_init(const struct nft_ctx *ctx, struct nft_data *data,\n\t\t\t    struct nft_data_desc *desc, const struct nlattr *nla)\n{\n\tu8 genmask = nft_genmask_next(ctx->net);\n\tstruct nlattr *tb[NFTA_VERDICT_MAX + 1];\n\tstruct nft_chain *chain;\n\tint err;\n\n\terr = nla_parse_nested_deprecated(tb, NFTA_VERDICT_MAX, nla,\n\t\t\t\t\t  nft_verdict_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!tb[NFTA_VERDICT_CODE])\n\t\treturn -EINVAL;\n\tdata->verdict.code = ntohl(nla_get_be32(tb[NFTA_VERDICT_CODE]));\n\n\tswitch (data->verdict.code) {\n\tdefault:\n\t\tswitch (data->verdict.code & NF_VERDICT_MASK) {\n\t\tcase NF_ACCEPT:\n\t\tcase NF_DROP:\n\t\tcase NF_QUEUE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tfallthrough;\n\tcase NFT_CONTINUE:\n\tcase NFT_BREAK:\n\tcase NFT_RETURN:\n\t\tbreak;\n\tcase NFT_JUMP:\n\tcase NFT_GOTO:\n\t\tif (tb[NFTA_VERDICT_CHAIN]) {\n\t\t\tchain = nft_chain_lookup(ctx->net, ctx->table,\n\t\t\t\t\t\t tb[NFTA_VERDICT_CHAIN],\n\t\t\t\t\t\t genmask);\n\t\t} else if (tb[NFTA_VERDICT_CHAIN_ID]) {\n\t\t\tchain = nft_chain_lookup_byid(ctx->net, ctx->table,\n\t\t\t\t\t\t      tb[NFTA_VERDICT_CHAIN_ID]);\n\t\t\tif (IS_ERR(chain))\n\t\t\t\treturn PTR_ERR(chain);\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (IS_ERR(chain))\n\t\t\treturn PTR_ERR(chain);\n\t\tif (nft_is_base_chain(chain))\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (nft_chain_is_bound(chain))\n\t\t\treturn -EINVAL;\n\t\tif (desc->flags & NFT_DATA_DESC_SETELEM &&\n\t\t    chain->flags & NFT_CHAIN_BINDING)\n\t\t\treturn -EINVAL;\n\n\t\tchain->use++;\n\t\tdata->verdict.chain = chain;\n\t\tbreak;\n\t}\n\n\tdesc->len = sizeof(data->verdict);\n\n\treturn 0;\n}", "func_hash": 189225679685979204194302814541477257663, "file_name": "nf_tables_api.c", "file_hash": 161585463478410786724773068235961577198, "cwe": ["CWE-703"], "cve": "CVE-2022-39190", "cve_desc": "An issue was discovered in net/netfilter/nf_tables_api.c in the Linux kernel before 5.19.6. A denial of service can occur upon binding to an already bound chain.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-39190", "file_path": "net/netfilter/nf_tables_api.c"}
{"idx": 206670, "project": "nbdkit", "commit_id": "6c5faac6a37077cf2366388a80862bb00616d0d8", "project_url": "https://github.com/libguestfs/nbdkit", "commit_url": "https://gitlab.com/nbdkit/nbdkit/-/commit/6c5faac6a37077cf2366388a80862bb00616d0d8", "commit_message": "server: reset meta context replies on starttls\n\nRelated to CVE-2021-3716, but not as severe.  No compliant client will\nsend NBD_CMD_BLOCK_STATUS unless it first negotiates\nNBD_OPT_SET_META_CONTEXT.  If an attacker injects a premature\nSET_META_CONTEXT, either the client will never notice (because it\nnever uses BLOCK_STATUS), or the client will overwrite the attacker's\nattempt with the client's own SET_META_CONTEXT request after\nencryption is enabled.  So I don't class this as having the potential\nto trigger denial-of-service due to any protocol mismatch between\ncompliant client and server (I don't care what happens with\nnon-compliant clients).\n\nFixes: 26455d45 (server: protocol: Implement Block Status \"base:allocation\".)", "target": 1, "func": "negotiate_handshake_newstyle_options (void)\n{\n  GET_CONN;\n  struct nbd_new_option new_option;\n  size_t nr_options;\n  bool list_seen = false;\n  uint64_t version;\n  uint32_t option;\n  uint32_t optlen;\n  struct nbd_export_name_option_reply handshake_finish;\n  const char *optname;\n  uint64_t exportsize;\n  struct backend *b;\n\n  for (nr_options = MAX_NR_OPTIONS; nr_options > 0; --nr_options) {\n    CLEANUP_FREE char *data = NULL;\n\n    if (conn_recv_full (&new_option, sizeof new_option,\n                        \"reading option: conn->recv: %m\") == -1)\n      return -1;\n\n    version = be64toh (new_option.version);\n    if (version != NBD_NEW_VERSION) {\n      nbdkit_error (\"unknown option version %\" PRIx64\n                    \", expecting %\" PRIx64,\n                    version, NBD_NEW_VERSION);\n      return -1;\n    }\n\n    /* There is a maximum option length we will accept, regardless\n     * of the option type.\n     */\n    optlen = be32toh (new_option.optlen);\n    if (optlen > MAX_REQUEST_SIZE) {\n      nbdkit_error (\"client option data too long (%\" PRIu32 \")\", optlen);\n      return -1;\n    }\n    data = malloc (optlen + 1); /* Allowing a trailing NUL helps some uses */\n    if (data == NULL) {\n      nbdkit_error (\"malloc: %m\");\n      return -1;\n    }\n\n    option = be32toh (new_option.option);\n    optname = name_of_nbd_opt (option);\n\n    /* If the client lacks fixed newstyle support, it should only send\n     * NBD_OPT_EXPORT_NAME.\n     */\n    if (!(conn->cflags & NBD_FLAG_FIXED_NEWSTYLE) &&\n        option != NBD_OPT_EXPORT_NAME) {\n      if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID))\n        return -1;\n      continue;\n    }\n\n    /* In --tls=require / FORCEDTLS mode the only options allowed\n     * before TLS negotiation are NBD_OPT_ABORT and NBD_OPT_STARTTLS.\n     */\n    if (tls == 2 && !conn->using_tls &&\n        !(option == NBD_OPT_ABORT || option == NBD_OPT_STARTTLS)) {\n      if (send_newstyle_option_reply (option, NBD_REP_ERR_TLS_REQD))\n        return -1;\n      continue;\n    }\n\n    switch (option) {\n    case NBD_OPT_EXPORT_NAME:\n      if (conn_recv_full (data, optlen,\n                          \"read: %s: %m\", name_of_nbd_opt (option)) == -1)\n        return -1;\n      if (check_export_name (option, data, optlen, optlen) == -1)\n        return -1;\n\n      /* We have to finish the handshake by sending handshake_finish.\n       * On failure, we have to disconnect.\n       */\n      if (finish_newstyle_options (&exportsize, data, optlen) == -1)\n        return -1;\n\n      memset (&handshake_finish, 0, sizeof handshake_finish);\n      handshake_finish.exportsize = htobe64 (exportsize);\n      handshake_finish.eflags = htobe16 (conn->eflags);\n\n      if (conn->send (&handshake_finish,\n                      (conn->cflags & NBD_FLAG_NO_ZEROES)\n                      ? offsetof (struct nbd_export_name_option_reply, zeroes)\n                      : sizeof handshake_finish, 0) == -1) {\n        nbdkit_error (\"write: %s: %m\", optname);\n        return -1;\n      }\n      break;\n\n    case NBD_OPT_ABORT:\n      if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)\n        return -1;\n      debug (\"client sent %s to abort the connection\",\n             name_of_nbd_opt (option));\n      return -1;\n\n    case NBD_OPT_LIST:\n      if (optlen != 0) {\n        if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)\n            == -1)\n          return -1;\n        if (conn_recv_full (data, optlen,\n                            \"read: %s: %m\", name_of_nbd_opt (option)) == -1)\n          return -1;\n        continue;\n      }\n\n      if (list_seen) {\n        debug (\"newstyle negotiation: %s: export list already advertised\",\n               name_of_nbd_opt (option));\n        if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID) == -1)\n          return -1;\n        continue;\n      }\n      else {\n        /* Send back the exportname list. */\n        debug (\"newstyle negotiation: %s: advertising exports\",\n               name_of_nbd_opt (option));\n        if (send_newstyle_option_reply_exportnames (option, &nr_options) == -1)\n          return -1;\n        list_seen = true;\n      }\n      break;\n\n    case NBD_OPT_STARTTLS:\n      if (optlen != 0) {\n        if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)\n            == -1)\n          return -1;\n        if (conn_recv_full (data, optlen,\n                            \"read: %s: %m\", name_of_nbd_opt (option)) == -1)\n          return -1;\n        continue;\n      }\n\n      if (tls == 0) {           /* --tls=off (NOTLS mode). */\n#ifdef HAVE_GNUTLS\n#define NO_TLS_REPLY NBD_REP_ERR_POLICY\n#else\n#define NO_TLS_REPLY NBD_REP_ERR_UNSUP\n#endif\n        if (send_newstyle_option_reply (option, NO_TLS_REPLY) == -1)\n          return -1;\n      }\n      else /* --tls=on or --tls=require */ {\n        /* We can't upgrade to TLS twice on the same connection. */\n        if (conn->using_tls) {\n          if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID) == -1)\n            return -1;\n          continue;\n        }\n\n        /* We have to send the (unencrypted) reply before starting\n         * the handshake.\n         */\n        if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)\n          return -1;\n\n        /* Upgrade the connection to TLS.  Also performs access control. */\n        if (crypto_negotiate_tls (conn->sockin, conn->sockout) == -1)\n          return -1;\n        conn->using_tls = true;\n        debug (\"using TLS on this connection\");\n        /* Wipe out any cached state. */\n        conn->structured_replies = false;\n        for_each_backend (b) {\n          free (conn->default_exportname[b->i]);\n          conn->default_exportname[b->i] = NULL;\n        }\n      }\n      break;\n\n    case NBD_OPT_INFO:\n    case NBD_OPT_GO:\n      if (conn_recv_full (data, optlen, \"read: %s: %m\", optname) == -1)\n        return -1;\n\n      if (optlen < 6) { /* 32 bit export length + 16 bit nr info */\n        debug (\"newstyle negotiation: %s option length < 6\", optname);\n\n        if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)\n            == -1)\n          return -1;\n        continue;\n      }\n\n      {\n        uint32_t exportnamelen;\n        uint16_t nrinfos;\n        uint16_t info;\n        size_t i;\n\n        /* Validate the name length and number of INFO requests. */\n        memcpy (&exportnamelen, &data[0], 4);\n        exportnamelen = be32toh (exportnamelen);\n        if (exportnamelen > optlen-6 /* NB optlen >= 6, see above */) {\n          debug (\"newstyle negotiation: %s: export name too long\", optname);\n          if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)\n              == -1)\n            return -1;\n          continue;\n        }\n        memcpy (&nrinfos, &data[exportnamelen+4], 2);\n        nrinfos = be16toh (nrinfos);\n        if (optlen != 4 + exportnamelen + 2 + 2*nrinfos) {\n          debug (\"newstyle negotiation: %s: \"\n                 \"number of information requests incorrect\", optname);\n          if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)\n              == -1)\n            return -1;\n          continue;\n        }\n\n        /* As with NBD_OPT_EXPORT_NAME we print the export name and\n         * save it in the connection.  If an earlier\n         * NBD_OPT_SET_META_CONTEXT used an export name, it must match\n         * or else we drop the support for that context.\n         */\n        if (check_export_name (option, &data[4], exportnamelen,\n                               optlen - 6) == -1) {\n          if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)\n              == -1)\n            return -1;\n          continue;\n        }\n\n        /* The spec is confusing, but it is required that we send back\n         * NBD_INFO_EXPORT, even if the client did not request it!\n         * qemu client in particular does not request this, but will\n         * fail if we don't send it.  Note that if .open fails, but we\n         * succeed at .close, then we merely return an error to the\n         * client and let them try another NBD_OPT, rather than\n         * disconnecting.\n         */\n        if (finish_newstyle_options (&exportsize,\n                                     &data[4], exportnamelen) == -1) {\n          if (conn->top_context) {\n            if (backend_finalize (conn->top_context) == -1)\n              return -1;\n            backend_close (conn->top_context);\n            conn->top_context = NULL;\n          }\n          if (send_newstyle_option_reply (option, NBD_REP_ERR_UNKNOWN) == -1)\n            return -1;\n          continue;\n        }\n\n        if (send_newstyle_option_reply_info_export (option,\n                                                    NBD_REP_INFO,\n                                                    NBD_INFO_EXPORT,\n                                                    exportsize) == -1)\n          return -1;\n\n        /* For now we send NBD_INFO_NAME and NBD_INFO_DESCRIPTION if\n         * requested, and ignore all other info requests (including\n         * NBD_INFO_EXPORT if it was requested, because we replied\n         * already above).\n         */\n        for (i = 0; i < nrinfos; ++i) {\n          memcpy (&info, &data[4 + exportnamelen + 2 + i*2], 2);\n          info = be16toh (info);\n          switch (info) {\n          case NBD_INFO_EXPORT: /* ignore - reply sent above */ break;\n          case NBD_INFO_NAME:\n            {\n              const char *name = &data[4];\n              size_t namelen = exportnamelen;\n\n              if (exportnamelen == 0) {\n                name = backend_default_export (top, read_only);\n                if (!name) {\n                  debug (\"newstyle negotiation: %s: \"\n                         \"NBD_INFO_NAME: no name to send\", optname);\n                  break;\n                }\n                namelen = -1;\n              }\n              if (send_newstyle_option_reply_info_str (option,\n                                                       NBD_REP_INFO,\n                                                       NBD_INFO_NAME,\n                                                       name, namelen) == -1)\n                return -1;\n            }\n            break;\n          case NBD_INFO_DESCRIPTION:\n            {\n              const char *desc = backend_export_description (conn->top_context);\n\n              if (!desc) {\n                debug (\"newstyle negotiation: %s: \"\n                       \"NBD_INFO_DESCRIPTION: no description to send\",\n                       optname);\n                break;\n              }\n              if (send_newstyle_option_reply_info_str (option,\n                                                       NBD_REP_INFO,\n                                                       NBD_INFO_DESCRIPTION,\n                                                       desc, -1) == -1)\n                return -1;\n            }\n            break;\n          default:\n            debug (\"newstyle negotiation: %s: \"\n                   \"ignoring NBD_INFO_* request %u (%s)\",\n                   optname, (unsigned) info, name_of_nbd_info (info));\n            break;\n          }\n        }\n      }\n\n      /* Unlike NBD_OPT_EXPORT_NAME, NBD_OPT_GO sends back an ACK\n       * or ERROR packet.  If this was NBD_OPT_LIST, call .close.\n       */\n      if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)\n        return -1;\n\n      if (option == NBD_OPT_INFO) {\n        if (backend_finalize (conn->top_context) == -1)\n          return -1;\n        backend_close (conn->top_context);\n        conn->top_context = NULL;\n      }\n\n      break;\n\n    case NBD_OPT_STRUCTURED_REPLY:\n      if (optlen != 0) {\n        if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)\n            == -1)\n          return -1;\n        if (conn_recv_full (data, optlen,\n                            \"read: %s: %m\", name_of_nbd_opt (option)) == -1)\n          return -1;\n        continue;\n      }\n\n      debug (\"newstyle negotiation: %s: client requested structured replies\",\n             name_of_nbd_opt (option));\n\n      if (no_sr) {\n        /* Must fail with ERR_UNSUP for qemu 4.2 to remain happy;\n         * but failing with ERR_POLICY would have been nicer.\n         */\n        if (send_newstyle_option_reply (option, NBD_REP_ERR_UNSUP) == -1)\n          return -1;\n        debug (\"newstyle negotiation: %s: structured replies are disabled\",\n               name_of_nbd_opt (option));\n        break;\n      }\n\n      if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)\n        return -1;\n\n      conn->structured_replies = true;\n      break;\n\n    case NBD_OPT_LIST_META_CONTEXT:\n    case NBD_OPT_SET_META_CONTEXT:\n      {\n        uint32_t opt_index;\n        uint32_t exportnamelen;\n        uint32_t nr_queries;\n        uint32_t querylen;\n        const char *what;\n\n        if (conn_recv_full (data, optlen, \"read: %s: %m\", optname) == -1)\n          return -1;\n\n        /* Note that we support base:allocation whether or not the plugin\n         * supports can_extents.\n         */\n        if (!conn->structured_replies) {\n          if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)\n              == -1)\n            return -1;\n          continue;\n        }\n\n        /* Minimum length of the option payload is:\n         *   32 bit export name length followed by empty export name\n         * + 32 bit number of queries followed by no queries\n         * = 8 bytes.\n         */\n        what = \"optlen < 8\";\n        if (optlen < 8) {\n        opt_meta_invalid_option_len:\n          debug (\"newstyle negotiation: %s: invalid option length: %s\",\n                 optname, what);\n\n          if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)\n              == -1)\n            return -1;\n          continue;\n        }\n\n        memcpy (&exportnamelen, &data[0], 4);\n        exportnamelen = be32toh (exportnamelen);\n        what = \"validating export name\";\n        if (check_export_name (option, &data[4], exportnamelen,\n                               optlen - 8) == -1)\n          goto opt_meta_invalid_option_len;\n\n        /* Remember the export name: the NBD spec says that if the client\n         * later uses NBD_OPT_GO on a different export, then the context\n         * returned here is not usable.\n         */\n        if (option == NBD_OPT_SET_META_CONTEXT) {\n          conn->exportname_from_set_meta_context =\n            strndup (&data[4], exportnamelen);\n          if (conn->exportname_from_set_meta_context == NULL) {\n            nbdkit_error (\"malloc: %m\");\n            return -1;\n          }\n        }\n\n        opt_index = 4 + exportnamelen;\n\n        /* Read the number of queries. */\n        what = \"reading number of queries\";\n        if (opt_index+4 > optlen)\n          goto opt_meta_invalid_option_len;\n        memcpy (&nr_queries, &data[opt_index], 4);\n        nr_queries = be32toh (nr_queries);\n        opt_index += 4;\n\n        /* for LIST: nr_queries == 0 means return all meta contexts\n         * for SET: nr_queries == 0 means reset all contexts\n         */\n        debug (\"newstyle negotiation: %s: %s count: %d\", optname,\n               option == NBD_OPT_LIST_META_CONTEXT ? \"query\" : \"set\",\n               nr_queries);\n        if (option == NBD_OPT_SET_META_CONTEXT)\n          conn->meta_context_base_allocation = false;\n        if (nr_queries == 0) {\n          if (option == NBD_OPT_LIST_META_CONTEXT) {\n            if (send_newstyle_option_reply_meta_context (option,\n                                                         NBD_REP_META_CONTEXT,\n                                                         0, \"base:allocation\")\n                == -1)\n              return -1;\n          }\n\n          if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)\n            return -1;\n        }\n        else {\n          /* Read and answer each query. */\n          while (nr_queries > 0) {\n            what = \"reading query string length\";\n            if (opt_index+4 > optlen)\n              goto opt_meta_invalid_option_len;\n            memcpy (&querylen, &data[opt_index], 4);\n            querylen = be32toh (querylen);\n            opt_index += 4;\n            what = \"reading query string\";\n            if (check_string (option, &data[opt_index], querylen,\n                              optlen - opt_index, \"meta context query\") == -1)\n              goto opt_meta_invalid_option_len;\n\n            debug (\"newstyle negotiation: %s: %s %.*s\",\n                   optname,\n                   option == NBD_OPT_LIST_META_CONTEXT ? \"query\" : \"set\",\n                   (int) querylen, &data[opt_index]);\n\n            /* For LIST, \"base:\" returns all supported contexts in the\n             * base namespace.  We only support \"base:allocation\".\n             */\n            if (option == NBD_OPT_LIST_META_CONTEXT &&\n                querylen == 5 &&\n                strncmp (&data[opt_index], \"base:\", 5) == 0) {\n              if (send_newstyle_option_reply_meta_context\n                  (option, NBD_REP_META_CONTEXT,\n                   0, \"base:allocation\") == -1)\n                return -1;\n            }\n            /* \"base:allocation\" requested by name. */\n            else if (querylen == 15 &&\n                     strncmp (&data[opt_index], \"base:allocation\", 15) == 0) {\n              if (send_newstyle_option_reply_meta_context\n                  (option, NBD_REP_META_CONTEXT,\n                   option == NBD_OPT_SET_META_CONTEXT\n                   ? base_allocation_id : 0,\n                   \"base:allocation\") == -1)\n                return -1;\n              if (option == NBD_OPT_SET_META_CONTEXT)\n                conn->meta_context_base_allocation = true;\n            }\n            /* Every other query must be ignored. */\n\n            opt_index += querylen;\n            nr_queries--;\n          }\n          if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)\n            return -1;\n        }\n        debug (\"newstyle negotiation: %s: reply complete\", optname);\n      }\n      break;\n\n    default:\n      /* Unknown option. */\n      if (send_newstyle_option_reply (option, NBD_REP_ERR_UNSUP) == -1)\n        return -1;\n      if (conn_recv_full (data, optlen,\n                          \"reading unknown option data: conn->recv: %m\") == -1)\n        return -1;\n    }\n\n    /* Note, since it's not very clear from the protocol doc, that the\n     * client must send NBD_OPT_EXPORT_NAME or NBD_OPT_GO last, and\n     * that ends option negotiation.\n     */\n    if (option == NBD_OPT_EXPORT_NAME || option == NBD_OPT_GO)\n      break;\n  }\n\n  if (nr_options == 0) {\n    nbdkit_error (\"client spent too much time negotiating without selecting \"\n                  \"an export\");\n    return -1;\n  }\n\n  /* In --tls=require / FORCEDTLS mode, we must have upgraded to TLS\n   * by the time we finish option negotiation.  If not, give up.\n   */\n  if (tls == 2 && !conn->using_tls) {\n    nbdkit_error (\"non-TLS client tried to connect in --tls=require mode\");\n    return -1;\n  }\n\n  return 0;\n}", "func_hash": 230092713719482299459555478858076762309, "file_name": "protocol-handshake-newstyle.c", "file_hash": 263209595426945567952192628081217546469, "cwe": ["CWE-924"], "cve": "CVE-2021-3716", "cve_desc": "A flaw was found in nbdkit due to to improperly caching plaintext state across the STARTTLS encryption boundary. A MitM attacker could use this flaw to inject a plaintext NBD_OPT_STRUCTURED_REPLY before proxying everything else a client sends to the server, potentially leading the client to terminate the NBD session. The highest threat from this vulnerability is to system availability.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-3716", "file_path": "server/protocol-handshake-newstyle.c"}
