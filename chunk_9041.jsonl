{"idx": 481267, "project": "linux", "commit_id": "c8c2a057fdc7de1cd16f4baa51425b932a42eb39", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/c8c2a057fdc7de1cd16f4baa51425b932a42eb39", "commit_message": "net/mlx5: prevent memory leak in mlx5_fpga_conn_create_cq\n\nIn mlx5_fpga_conn_create_cq if mlx5_vector2eqn fails the allocated\nmemory should be released.\n\nFixes: 537a50574175 (\"net/mlx5: FPGA, Add high-speed connection routines\")\nSigned-off-by: Navid Emamdoost <navid.emamdoost@gmail.com>\nSigned-off-by: Saeed Mahameed <saeedm@mellanox.com>", "target": 0, "func": "static int mlx5_fpga_conn_create_cq(struct mlx5_fpga_conn *conn, int cq_size)\n{\n\tstruct mlx5_fpga_device *fdev = conn->fdev;\n\tstruct mlx5_core_dev *mdev = fdev->mdev;\n\tu32 temp_cqc[MLX5_ST_SZ_DW(cqc)] = {0};\n\tu32 out[MLX5_ST_SZ_DW(create_cq_out)];\n\tstruct mlx5_wq_param wqp;\n\tstruct mlx5_cqe64 *cqe;\n\tint inlen, err, eqn;\n\tunsigned int irqn;\n\tvoid *cqc, *in;\n\t__be64 *pas;\n\tu32 i;\n\n\tcq_size = roundup_pow_of_two(cq_size);\n\tMLX5_SET(cqc, temp_cqc, log_cq_size, ilog2(cq_size));\n\n\twqp.buf_numa_node = mdev->priv.numa_node;\n\twqp.db_numa_node  = mdev->priv.numa_node;\n\n\terr = mlx5_cqwq_create(mdev, &wqp, temp_cqc, &conn->cq.wq,\n\t\t\t       &conn->cq.wq_ctrl);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < mlx5_cqwq_get_size(&conn->cq.wq); i++) {\n\t\tcqe = mlx5_cqwq_get_wqe(&conn->cq.wq, i);\n\t\tcqe->op_own = MLX5_CQE_INVALID << 4 | MLX5_CQE_OWNER_MASK;\n\t}\n\n\tinlen = MLX5_ST_SZ_BYTES(create_cq_in) +\n\t\tsizeof(u64) * conn->cq.wq_ctrl.buf.npages;\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in) {\n\t\terr = -ENOMEM;\n\t\tgoto err_cqwq;\n\t}\n\n\terr = mlx5_vector2eqn(mdev, smp_processor_id(), &eqn, &irqn);\n\tif (err) {\n\t\tkvfree(in);\n\t\tgoto err_cqwq;\n\t}\n\n\tcqc = MLX5_ADDR_OF(create_cq_in, in, cq_context);\n\tMLX5_SET(cqc, cqc, log_cq_size, ilog2(cq_size));\n\tMLX5_SET(cqc, cqc, c_eqn, eqn);\n\tMLX5_SET(cqc, cqc, uar_page, fdev->conn_res.uar->index);\n\tMLX5_SET(cqc, cqc, log_page_size, conn->cq.wq_ctrl.buf.page_shift -\n\t\t\t   MLX5_ADAPTER_PAGE_SHIFT);\n\tMLX5_SET64(cqc, cqc, dbr_addr, conn->cq.wq_ctrl.db.dma);\n\n\tpas = (__be64 *)MLX5_ADDR_OF(create_cq_in, in, pas);\n\tmlx5_fill_page_frag_array(&conn->cq.wq_ctrl.buf, pas);\n\n\terr = mlx5_core_create_cq(mdev, &conn->cq.mcq, in, inlen, out, sizeof(out));\n\tkvfree(in);\n\n\tif (err)\n\t\tgoto err_cqwq;\n\n\tconn->cq.mcq.cqe_sz     = 64;\n\tconn->cq.mcq.set_ci_db  = conn->cq.wq_ctrl.db.db;\n\tconn->cq.mcq.arm_db     = conn->cq.wq_ctrl.db.db + 1;\n\t*conn->cq.mcq.set_ci_db = 0;\n\t*conn->cq.mcq.arm_db    = 0;\n\tconn->cq.mcq.vector     = 0;\n\tconn->cq.mcq.comp       = mlx5_fpga_conn_cq_complete;\n\tconn->cq.mcq.event      = mlx5_fpga_conn_cq_event;\n\tconn->cq.mcq.irqn       = irqn;\n\tconn->cq.mcq.uar        = fdev->conn_res.uar;\n\ttasklet_init(&conn->cq.tasklet, mlx5_fpga_conn_cq_tasklet,\n\t\t     (unsigned long)conn);\n\n\tmlx5_fpga_dbg(fdev, \"Created CQ #0x%x\\n\", conn->cq.mcq.cqn);\n\n\tgoto out;\n\nerr_cqwq:\n\tmlx5_wq_destroy(&conn->cq.wq_ctrl);\nout:\n\treturn err;\n}", "func_hash": 166786309951983227645990078525765970677, "file_name": "conn.c", "file_hash": 179201474190149214779616550859114985162, "cwe": ["CWE-401"], "cve": "CVE-2019-19045", "cve_desc": "A memory leak in the mlx5_fpga_conn_create_cq() function in drivers/net/ethernet/mellanox/mlx5/core/fpga/conn.c in the Linux kernel before 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering mlx5_vector2eqn() failures, aka CID-c8c2a057fdc7.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2019-19045", "file_path": "drivers/net/ethernet/mellanox/mlx5/core/fpga/conn.c"}
{"idx": 214948, "project": "nagioscore", "commit_id": "b1a92a3b52d292ccb601e77a0b29cb1e67ac9d76", "project_url": "https://github.com/NagiosEnterprises/nagioscore", "commit_url": "https://github.com/NagiosEnterprises/nagioscore/commit/b1a92a3b52d292ccb601e77a0b29cb1e67ac9d76", "commit_message": "merge accidental master PR (#553) into maint and fix changelog\nmerge conflict", "target": 1, "func": "static int qh_help(int sd, char *buf, unsigned int len)\n{\n\tstruct query_handler *qh = NULL;\n\n\tif (!*buf || !strcmp(buf, \"help\")) {\n\t\tnsock_printf_nul(sd,\n\t\t\t\"  help <name>   show help for handler <name>\\n\"\n\t\t\t\"  help list     list registered handlers\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(buf, \"list\")) {\n\n\t\tfor (qh = qhandlers; qh != NULL; qh = qh->next_qh) {\n\t\t\tnsock_printf(sd, \"%-10s %s\\n\", qh->name, qh->description ? qh->description : \"(No description available)\");\n\t\t}\n\n\t\tnsock_printf(sd, \"%c\", 0);\n\t\treturn 0;\n\t}\n\n\tqh = qh_find_handler(buf);\n\tif (qh == NULL) {\n\n\t\tnsock_printf_nul(sd, \"No handler named '%s' is registered\\n\", buf);\n\n\t} else if (qh->handler(sd, \"help\", 4) > 200) {\n\n\t\tnsock_printf_nul(sd, \"The handler %s doesn't have any help yet.\", buf);\n\t}\n\n\treturn 0;\n}", "func_hash": 94205848469413247134990431510795041073, "file_name": "query-handler.c", "file_hash": 69411467652185615530893490033539842403, "cwe": ["CWE-476"], "cve": "CVE-2018-13441", "cve_desc": "qh_help in Nagios Core version 4.4.1 and earlier is prone to a NULL pointer dereference vulnerability, which allows attacker to cause a local denial-of-service condition by sending a crafted payload to the listening UNIX socket.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2018-13441", "file_path": "base/query-handler.c"}
{"idx": 481787, "project": "nagioscore", "commit_id": "b1a92a3b52d292ccb601e77a0b29cb1e67ac9d76", "project_url": "https://github.com/NagiosEnterprises/nagioscore", "commit_url": "https://github.com/NagiosEnterprises/nagioscore/commit/b1a92a3b52d292ccb601e77a0b29cb1e67ac9d76", "commit_message": "merge accidental master PR (#553) into maint and fix changelog\nmerge conflict", "target": 0, "func": "static int qh_help(int sd, char *buf, unsigned int len)\n{\n\tstruct query_handler *qh = NULL;\n\n\tif (buf == NULL || !strcmp(buf, \"help\")) {\n\t\tnsock_printf_nul(sd,\n\t\t\t\"  help <name>   show help for handler <name>\\n\"\n\t\t\t\"  help list     list registered handlers\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(buf, \"list\")) {\n\n\t\tfor (qh = qhandlers; qh != NULL; qh = qh->next_qh) {\n\t\t\tnsock_printf(sd, \"%-10s %s\\n\", qh->name, qh->description ? qh->description : \"(No description available)\");\n\t\t}\n\n\t\tnsock_printf(sd, \"%c\", 0);\n\t\treturn 0;\n\t}\n\n\tqh = qh_find_handler(buf);\n\tif (qh == NULL) {\n\n\t\tnsock_printf_nul(sd, \"No handler named '%s' is registered\\n\", buf);\n\n\t} else if (qh->handler(sd, \"help\", 4) > 200) {\n\n\t\tnsock_printf_nul(sd, \"The handler %s doesn't have any help yet.\", buf);\n\t}\n\n\treturn 0;\n}", "func_hash": 205155132129673453942496407625358391443, "file_name": "query-handler.c", "file_hash": 275184931270866221094094086326042798019, "cwe": ["CWE-476"], "cve": "CVE-2018-13441", "cve_desc": "qh_help in Nagios Core version 4.4.1 and earlier is prone to a NULL pointer dereference vulnerability, which allows attacker to cause a local denial-of-service condition by sending a crafted payload to the listening UNIX socket.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2018-13441", "file_path": "base/query-handler.c"}
{"idx": 214997, "project": "liblouis", "commit_id": "2e4772befb2b1c37cb4b9d6572945115ee28630a", "project_url": "https://github.com/liblouis/liblouis", "commit_url": "https://github.com/liblouis/liblouis/commit/2e4772befb2b1c37cb4b9d6572945115ee28630a", "commit_message": "Prevent an invalid memory writes in compileRule\n\nThanks to Han Zheng for reporting it\n\nFixes #1214", "target": 1, "func": "compileRule(FileInfo *file, TranslationTableHeader **table,\n\t\tDisplayTableHeader **displayTable, const MacroList **inScopeMacros) {\n\tCharsString token;\n\tTranslationTableOpcode opcode;\n\tCharsString ruleChars;\n\tCharsString ruleDots;\n\tCharsString cells;\n\tCharsString scratchPad;\n\tCharsString emphClass;\n\tTranslationTableCharacterAttributes after = 0;\n\tTranslationTableCharacterAttributes before = 0;\n\tint noback, nofor, nocross;\n\tnoback = nofor = nocross = 0;\ndoOpcode:\n\tif (!getToken(file, &token, NULL)) return 1;\t\t\t\t  /* blank line */\n\tif (token.chars[0] == '#' || token.chars[0] == '<') return 1; /* comment */\n\tif (file->lineNumber == 1 &&\n\t\t\t(eqasc2uni((unsigned char *)\"ISO\", token.chars, 3) ||\n\t\t\t\t\teqasc2uni((unsigned char *)\"UTF-8\", token.chars, 5))) {\n\t\tif (table)\n\t\t\tcompileHyphenation(file, &token, table);\n\t\telse\n\t\t\t/* ignore the whole file */\n\t\t\twhile (_lou_getALine(file))\n\t\t\t\t;\n\t\treturn 1;\n\t}\n\topcode = getOpcode(file, &token);\n\tswitch (opcode) {\n\tcase CTO_Macro: {\n\t\tconst Macro *macro;\n#ifdef ENABLE_MACROS\n\t\tif (!inScopeMacros) {\n\t\t\tcompileError(file, \"Defining macros only allowed in table files.\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (compileMacro(file, &macro)) {\n\t\t\t*inScopeMacros = cons_macro(macro, *inScopeMacros);\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n#else\n\t\tcompileError(file, \"Macro feature is disabled.\");\n\t\treturn 0;\n#endif\n\t}\n\tcase CTO_IncludeFile: {\n\t\tCharsString includedFile;\n\t\tif (!getToken(file, &token, \"include file name\")) return 0;\n\t\tif (!parseChars(file, &includedFile, &token)) return 0;\n\t\treturn includeFile(file, &includedFile, table, displayTable);\n\t}\n\tcase CTO_NoBack:\n\t\tif (nofor) {\n\t\t\tcompileError(file, \"%s already specified.\", _lou_findOpcodeName(CTO_NoFor));\n\t\t\treturn 0;\n\t\t}\n\t\tnoback = 1;\n\t\tgoto doOpcode;\n\tcase CTO_NoFor:\n\t\tif (noback) {\n\t\t\tcompileError(file, \"%s already specified.\", _lou_findOpcodeName(CTO_NoBack));\n\t\t\treturn 0;\n\t\t}\n\t\tnofor = 1;\n\t\tgoto doOpcode;\n\tcase CTO_Space:\n\t\treturn compileCharDef(\n\t\t\t\tfile, opcode, CTC_Space, noback, nofor, table, displayTable);\n\tcase CTO_Digit:\n\t\treturn compileCharDef(\n\t\t\t\tfile, opcode, CTC_Digit, noback, nofor, table, displayTable);\n\tcase CTO_LitDigit:\n\t\treturn compileCharDef(\n\t\t\t\tfile, opcode, CTC_LitDigit, noback, nofor, table, displayTable);\n\tcase CTO_Punctuation:\n\t\treturn compileCharDef(\n\t\t\t\tfile, opcode, CTC_Punctuation, noback, nofor, table, displayTable);\n\tcase CTO_Math:\n\t\treturn compileCharDef(file, opcode, CTC_Math, noback, nofor, table, displayTable);\n\tcase CTO_Sign:\n\t\treturn compileCharDef(file, opcode, CTC_Sign, noback, nofor, table, displayTable);\n\tcase CTO_Letter:\n\t\treturn compileCharDef(\n\t\t\t\tfile, opcode, CTC_Letter, noback, nofor, table, displayTable);\n\tcase CTO_UpperCase:\n\t\treturn compileCharDef(\n\t\t\t\tfile, opcode, CTC_UpperCase, noback, nofor, table, displayTable);\n\tcase CTO_LowerCase:\n\t\treturn compileCharDef(\n\t\t\t\tfile, opcode, CTC_LowerCase, noback, nofor, table, displayTable);\n\tcase CTO_Grouping:\n\t\treturn compileGrouping(file, noback, nofor, table, displayTable);\n\tcase CTO_Display:\n\t\tif (!displayTable) return 1;  // ignore\n\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\tif (!getRuleDotsPattern(file, &ruleDots)) return 0;\n\t\tif (ruleChars.length != 1 || ruleDots.length != 1) {\n\t\t\tcompileError(file, \"Exactly one character and one cell are required.\");\n\t\t\treturn 0;\n\t\t}\n\t\treturn putCharDotsMapping(\n\t\t\t\tfile, ruleChars.chars[0], ruleDots.chars[0], displayTable);\n\tcase CTO_UpLow:\n\tcase CTO_None: {\n\t\t// check if token is a macro name\n\t\tif (inScopeMacros) {\n\t\t\tconst MacroList *macros = *inScopeMacros;\n\t\t\twhile (macros) {\n\t\t\t\tconst Macro *m = macros->head;\n\t\t\t\tif (token.length == strlen(m->name) &&\n\t\t\t\t\t\teqasc2uni((unsigned char *)m->name, token.chars, token.length)) {\n\t\t\t\t\tif (!inScopeMacros) {\n\t\t\t\t\t\tcompileError(file, \"Calling macros only allowed in table files.\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tFileInfo tmpFile;\n\t\t\t\t\tmemset(&tmpFile, 0, sizeof(tmpFile));\n\t\t\t\t\ttmpFile.fileName = file->fileName;\n\t\t\t\t\ttmpFile.sourceFile = file->sourceFile;\n\t\t\t\t\ttmpFile.lineNumber = file->lineNumber;\n\t\t\t\t\ttmpFile.encoding = noEncoding;\n\t\t\t\t\ttmpFile.status = 0;\n\t\t\t\t\ttmpFile.linepos = 0;\n\t\t\t\t\ttmpFile.linelen = 0;\n\t\t\t\t\tint argument_count = 0;\n\t\t\t\t\tCharsString *arguments =\n\t\t\t\t\t\t\tmalloc(m->argument_count * sizeof(CharsString));\n\t\t\t\t\twhile (argument_count < m->argument_count) {\n\t\t\t\t\t\tif (getToken(file, &token, \"macro argument\"))\n\t\t\t\t\t\t\targuments[argument_count++] = token;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (argument_count < m->argument_count) {\n\t\t\t\t\t\tcompileError(file, \"Expected %d arguments\", m->argument_count);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tint i = 0;\n\t\t\t\t\tint subst = 0;\n\t\t\t\t\tint next = subst < m->substitution_count ? m->substitutions[2 * subst]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t : m->definition_length;\n\t\t\t\t\tfor (;;) {\n\t\t\t\t\t\twhile (i < next) {\n\t\t\t\t\t\t\twidechar c = m->definition[i++];\n\t\t\t\t\t\t\tif (c == '\\n') {\n\t\t\t\t\t\t\t\tif (!compileRule(&tmpFile, table, displayTable,\n\t\t\t\t\t\t\t\t\t\t\tinScopeMacros)) {\n\t\t\t\t\t\t\t\t\t_lou_logMessage(LOU_LOG_ERROR,\n\t\t\t\t\t\t\t\t\t\t\t\"result of macro expansion was: %s\",\n\t\t\t\t\t\t\t\t\t\t\t_lou_showString(\n\t\t\t\t\t\t\t\t\t\t\t\t\ttmpFile.line, tmpFile.linelen, 0));\n\t\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttmpFile.linepos = 0;\n\t\t\t\t\t\t\t\ttmpFile.linelen = 0;\n\t\t\t\t\t\t\t} else if (tmpFile.linelen >= MAXSTRING) {\n\t\t\t\t\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\t\t\t\t\"Line exceeds %d characters (post macro \"\n\t\t\t\t\t\t\t\t\t\t\"expansion)\",\n\t\t\t\t\t\t\t\t\t\tMAXSTRING);\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\ttmpFile.line[tmpFile.linelen++] = c;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (subst < m->substitution_count) {\n\t\t\t\t\t\t\tCharsString arg =\n\t\t\t\t\t\t\t\t\targuments[m->substitutions[2 * subst + 1] - 1];\n\t\t\t\t\t\t\tfor (int j = 0; j < arg.length; j++)\n\t\t\t\t\t\t\t\ttmpFile.line[tmpFile.linelen++] = arg.chars[j];\n\t\t\t\t\t\t\tsubst++;\n\t\t\t\t\t\t\tnext = subst < m->substitution_count\n\t\t\t\t\t\t\t\t\t? m->substitutions[2 * subst]\n\t\t\t\t\t\t\t\t\t: m->definition_length;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (!compileRule(\n\t\t\t\t\t\t\t\t\t\t&tmpFile, table, displayTable, inScopeMacros)) {\n\t\t\t\t\t\t\t\t_lou_logMessage(LOU_LOG_ERROR,\n\t\t\t\t\t\t\t\t\t\t\"result of macro expansion was: %s\",\n\t\t\t\t\t\t\t\t\t\t_lou_showString(\n\t\t\t\t\t\t\t\t\t\t\t\ttmpFile.line, tmpFile.linelen, 0));\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tmacros = macros->tail;\n\t\t\t}\n\t\t}\n\t\tif (opcode == CTO_UpLow) {\n\t\t\tcompileError(file, \"The uplow opcode is deprecated.\");\n\t\t\treturn 0;\n\t\t}\n\t\tcompileError(file, \"opcode %s not defined.\",\n\t\t\t\t_lou_showString(token.chars, token.length, 0));\n\t\treturn 0;\n\t}\n\n\t/* now only opcodes follow that don't modify the display table */\n\tdefault:\n\t\tif (!table) return 1;\n\t\tswitch (opcode) {\n\t\tcase CTO_Locale:\n\t\t\tcompileWarning(file,\n\t\t\t\t\t\"The locale opcode is not implemented. Use the locale meta data \"\n\t\t\t\t\t\"instead.\");\n\t\t\treturn 1;\n\t\tcase CTO_Undefined: {\n\t\t\t// not passing pointer because compileBrailleIndicator may reallocate table\n\t\t\tTranslationTableOffset ruleOffset = (*table)->undefined;\n\t\t\tif (!compileBrailleIndicator(file, \"undefined character opcode\",\n\t\t\t\t\t\tCTO_Undefined, &ruleOffset, noback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\t(*table)->undefined = ruleOffset;\n\t\t\treturn 1;\n\t\t}\n\t\tcase CTO_Match: {\n\t\t\tint ok = 0;\n\t\t\twidechar *patterns = NULL;\n\t\t\tTranslationTableRule *rule;\n\t\t\tTranslationTableOffset ruleOffset;\n\t\t\tCharsString ptn_before, ptn_after;\n\t\t\tTranslationTableOffset patternsOffset;\n\t\t\tint len, mrk;\n\t\t\tsize_t patternsByteSize = sizeof(*patterns) * 27720;\n\t\t\tpatterns = (widechar *)malloc(patternsByteSize);\n\t\t\tif (!patterns) _lou_outOfMemory();\n\t\t\tmemset(patterns, 0xffff, patternsByteSize);\n\t\t\tnoback = 1;\n\t\t\tgetCharacters(file, &ptn_before);\n\t\t\tgetRuleCharsText(file, &ruleChars);\n\t\t\tgetCharacters(file, &ptn_after);\n\t\t\tgetRuleDotsPattern(file, &ruleDots);\n\t\t\tif (!addRule(file, opcode, &ruleChars, &ruleDots, after, before, &ruleOffset,\n\t\t\t\t\t\t&rule, noback, nofor, table))\n\t\t\t\tgoto CTO_Match_cleanup;\n\t\t\tif (ptn_before.chars[0] == '-' && ptn_before.length == 1)\n\t\t\t\tlen = _lou_pattern_compile(\n\t\t\t\t\t\t&ptn_before.chars[0], 0, &patterns[1], 13841, *table, file);\n\t\t\telse\n\t\t\t\tlen = _lou_pattern_compile(&ptn_before.chars[0], ptn_before.length,\n\t\t\t\t\t\t&patterns[1], 13841, *table, file);\n\t\t\tif (!len) goto CTO_Match_cleanup;\n\t\t\tmrk = patterns[0] = len + 1;\n\t\t\t_lou_pattern_reverse(&patterns[1]);\n\t\t\tif (ptn_after.chars[0] == '-' && ptn_after.length == 1)\n\t\t\t\tlen = _lou_pattern_compile(\n\t\t\t\t\t\t&ptn_after.chars[0], 0, &patterns[mrk], 13841, *table, file);\n\t\t\telse\n\t\t\t\tlen = _lou_pattern_compile(&ptn_after.chars[0], ptn_after.length,\n\t\t\t\t\t\t&patterns[mrk], 13841, *table, file);\n\t\t\tif (!len) goto CTO_Match_cleanup;\n\t\t\tlen += mrk;\n\t\t\tif (!allocateSpaceInTranslationTable(\n\t\t\t\t\t\tfile, &patternsOffset, len * sizeof(widechar), table))\n\t\t\t\tgoto CTO_Match_cleanup;\n\t\t\t// allocateSpaceInTranslationTable may have moved table, so make sure rule is\n\t\t\t// still valid\n\t\t\trule = (TranslationTableRule *)&(*table)->ruleArea[ruleOffset];\n\t\t\tmemcpy(&(*table)->ruleArea[patternsOffset], patterns, len * sizeof(widechar));\n\t\t\trule->patterns = patternsOffset;\n\t\t\tok = 1;\n\t\tCTO_Match_cleanup:\n\t\t\tfree(patterns);\n\t\t\treturn ok;\n\t\t}\n\n\t\tcase CTO_BackMatch: {\n\t\t\tint ok = 0;\n\t\t\twidechar *patterns = NULL;\n\t\t\tTranslationTableRule *rule;\n\t\t\tTranslationTableOffset ruleOffset;\n\t\t\tCharsString ptn_before, ptn_after;\n\t\t\tTranslationTableOffset patternOffset;\n\t\t\tint len, mrk;\n\t\t\tsize_t patternsByteSize = sizeof(*patterns) * 27720;\n\t\t\tpatterns = (widechar *)malloc(patternsByteSize);\n\t\t\tif (!patterns) _lou_outOfMemory();\n\t\t\tmemset(patterns, 0xffff, patternsByteSize);\n\t\t\tnofor = 1;\n\t\t\tgetCharacters(file, &ptn_before);\n\t\t\tgetRuleCharsText(file, &ruleChars);\n\t\t\tgetCharacters(file, &ptn_after);\n\t\t\tgetRuleDotsPattern(file, &ruleDots);\n\t\t\tif (!addRule(file, opcode, &ruleChars, &ruleDots, 0, 0, &ruleOffset, &rule,\n\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\tgoto CTO_BackMatch_cleanup;\n\t\t\tif (ptn_before.chars[0] == '-' && ptn_before.length == 1)\n\t\t\t\tlen = _lou_pattern_compile(\n\t\t\t\t\t\t&ptn_before.chars[0], 0, &patterns[1], 13841, *table, file);\n\t\t\telse\n\t\t\t\tlen = _lou_pattern_compile(&ptn_before.chars[0], ptn_before.length,\n\t\t\t\t\t\t&patterns[1], 13841, *table, file);\n\t\t\tif (!len) goto CTO_BackMatch_cleanup;\n\t\t\tmrk = patterns[0] = len + 1;\n\t\t\t_lou_pattern_reverse(&patterns[1]);\n\t\t\tif (ptn_after.chars[0] == '-' && ptn_after.length == 1)\n\t\t\t\tlen = _lou_pattern_compile(\n\t\t\t\t\t\t&ptn_after.chars[0], 0, &patterns[mrk], 13841, *table, file);\n\t\t\telse\n\t\t\t\tlen = _lou_pattern_compile(&ptn_after.chars[0], ptn_after.length,\n\t\t\t\t\t\t&patterns[mrk], 13841, *table, file);\n\t\t\tif (!len) goto CTO_BackMatch_cleanup;\n\t\t\tlen += mrk;\n\t\t\tif (!allocateSpaceInTranslationTable(\n\t\t\t\t\t\tfile, &patternOffset, len * sizeof(widechar), table))\n\t\t\t\tgoto CTO_BackMatch_cleanup;\n\t\t\t// allocateSpaceInTranslationTable may have moved table, so make sure rule is\n\t\t\t// still valid\n\t\t\trule = (TranslationTableRule *)&(*table)->ruleArea[ruleOffset];\n\t\t\tmemcpy(&(*table)->ruleArea[patternOffset], patterns, len * sizeof(widechar));\n\t\t\trule->patterns = patternOffset;\n\t\t\tok = 1;\n\t\tCTO_BackMatch_cleanup:\n\t\t\tfree(patterns);\n\t\t\treturn ok;\n\t\t}\n\n\t\tcase CTO_CapsLetter:\n\t\tcase CTO_BegCapsWord:\n\t\tcase CTO_EndCapsWord:\n\t\tcase CTO_BegCaps:\n\t\tcase CTO_EndCaps:\n\t\tcase CTO_BegCapsPhrase:\n\t\tcase CTO_EndCapsPhrase:\n\t\tcase CTO_LenCapsPhrase:\n\t\t/* these 8 general purpose opcodes are compiled further down to more specific\n\t\t * internal opcodes:\n\t\t * - modeletter\n\t\t * - begmodeword\n\t\t * - endmodeword\n\t\t * - begmode\n\t\t * - endmode\n\t\t * - begmodephrase\n\t\t * - endmodephrase\n\t\t * - lenmodephrase\n\t\t */\n\t\tcase CTO_ModeLetter:\n\t\tcase CTO_BegModeWord:\n\t\tcase CTO_EndModeWord:\n\t\tcase CTO_BegMode:\n\t\tcase CTO_EndMode:\n\t\tcase CTO_BegModePhrase:\n\t\tcase CTO_EndModePhrase:\n\t\tcase CTO_LenModePhrase: {\n\t\t\tTranslationTableCharacterAttributes mode;\n\t\t\tint i;\n\t\t\tswitch (opcode) {\n\t\t\tcase CTO_CapsLetter:\n\t\t\tcase CTO_BegCapsWord:\n\t\t\tcase CTO_EndCapsWord:\n\t\t\tcase CTO_BegCaps:\n\t\t\tcase CTO_EndCaps:\n\t\t\tcase CTO_BegCapsPhrase:\n\t\t\tcase CTO_EndCapsPhrase:\n\t\t\tcase CTO_LenCapsPhrase:\n\t\t\t\tmode = CTC_UpperCase;\n\t\t\t\ti = 0;\n\t\t\t\topcode += (CTO_ModeLetter - CTO_CapsLetter);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (!getToken(file, &token, \"attribute name\")) return 0;\n\t\t\t\tif (!(*table)->characterClasses && !allocateCharacterClasses(*table)) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tconst CharacterClass *characterClass = findCharacterClass(&token, *table);\n\t\t\t\tif (!characterClass) {\n\t\t\t\t\tcharacterClass =\n\t\t\t\t\t\t\taddCharacterClass(file, token.chars, token.length, *table, 1);\n\t\t\t\t\tif (!characterClass) return 0;\n\t\t\t\t}\n\t\t\t\tmode = characterClass->attribute;\n\t\t\t\tif (!(mode == CTC_UpperCase || mode == CTC_Digit) && mode >= CTC_Space &&\n\t\t\t\t\t\tmode <= CTC_LitDigit) {\n\t\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\t\"mode must be \\\"uppercase\\\", \\\"digit\\\", or a custom \"\n\t\t\t\t\t\t\t\"attribute name.\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t/* check if this mode is already defined and if the number of modes does\n\t\t\t\t * not exceed the maximal number */\n\t\t\t\tif (mode == CTC_UpperCase)\n\t\t\t\t\ti = 0;\n\t\t\t\telse {\n\t\t\t\t\tfor (i = 1; i < MAX_MODES && (*table)->modes[i].value; i++) {\n\t\t\t\t\t\tif ((*table)->modes[i].mode == mode) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (i == MAX_MODES) {\n\t\t\t\t\t\tcompileError(file, \"Max number of modes (%i) reached\", MAX_MODES);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!(*table)->modes[i].value)\n\t\t\t\t(*table)->modes[i] = (EmphasisClass){ plain_text, mode,\n\t\t\t\t\t0x1 << (MAX_EMPH_CLASSES + i), MAX_EMPH_CLASSES + i };\n\t\t\tswitch (opcode) {\n\t\t\tcase CTO_BegModePhrase: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][begPhraseOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"first word capital sign\",\n\t\t\t\t\t\t\tCTO_BegCapsPhraseRule + (8 * i), &ruleOffset, noback, nofor,\n\t\t\t\t\t\t\ttable))\n\t\t\t\t\treturn 0;\n\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][begPhraseOffset] = ruleOffset;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcase CTO_EndModePhrase: {\n\t\t\t\tTranslationTableOffset ruleOffset;\n\t\t\t\tswitch (compileBeforeAfter(file)) {\n\t\t\t\tcase 1:\t // before\n\t\t\t\t\tif ((*table)->emphRules[MAX_EMPH_CLASSES + i][endPhraseAfterOffset]) {\n\t\t\t\t\t\tcompileError(\n\t\t\t\t\t\t\t\tfile, \"Capital sign after last word already defined.\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t\t// table\n\t\t\t\t\truleOffset = (*table)->emphRules[MAX_EMPH_CLASSES + i]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[endPhraseBeforeOffset];\n\t\t\t\t\tif (!compileBrailleIndicator(file, \"capital sign before last word\",\n\t\t\t\t\t\t\t\tCTO_EndCapsPhraseBeforeRule + (8 * i), &ruleOffset,\n\t\t\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][endPhraseBeforeOffset] =\n\t\t\t\t\t\t\truleOffset;\n\t\t\t\t\treturn 1;\n\t\t\t\tcase 2:\t // after\n\t\t\t\t\tif ((*table)->emphRules[MAX_EMPH_CLASSES + i]\n\t\t\t\t\t\t\t\t\t\t   [endPhraseBeforeOffset]) {\n\t\t\t\t\t\tcompileError(\n\t\t\t\t\t\t\t\tfile, \"Capital sign before last word already defined.\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t\t// table\n\t\t\t\t\truleOffset = (*table)->emphRules[MAX_EMPH_CLASSES + i]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[endPhraseAfterOffset];\n\t\t\t\t\tif (!compileBrailleIndicator(file, \"capital sign after last word\",\n\t\t\t\t\t\t\t\tCTO_EndCapsPhraseAfterRule + (8 * i), &ruleOffset, noback,\n\t\t\t\t\t\t\t\tnofor, table))\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][endPhraseAfterOffset] =\n\t\t\t\t\t\t\truleOffset;\n\t\t\t\t\treturn 1;\n\t\t\t\tdefault:  // error\n\t\t\t\t\tcompileError(file, \"Invalid lastword indicator location.\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcase CTO_BegMode: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][begOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"first letter capital sign\",\n\t\t\t\t\t\t\tCTO_BegCapsRule + (8 * i), &ruleOffset, noback, nofor, table))\n\t\t\t\t\treturn 0;\n\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][begOffset] = ruleOffset;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcase CTO_EndMode: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][endOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"last letter capital sign\",\n\t\t\t\t\t\t\tCTO_EndCapsRule + (8 * i), &ruleOffset, noback, nofor, table))\n\t\t\t\t\treturn 0;\n\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][endOffset] = ruleOffset;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcase CTO_ModeLetter: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][letterOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"single letter capital sign\",\n\t\t\t\t\t\t\tCTO_CapsLetterRule + (8 * i), &ruleOffset, noback, nofor,\n\t\t\t\t\t\t\ttable))\n\t\t\t\t\treturn 0;\n\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][letterOffset] = ruleOffset;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcase CTO_BegModeWord: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][begWordOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"capital word\",\n\t\t\t\t\t\t\tCTO_BegCapsWordRule + (8 * i), &ruleOffset, noback, nofor,\n\t\t\t\t\t\t\ttable))\n\t\t\t\t\treturn 0;\n\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][begWordOffset] = ruleOffset;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcase CTO_EndModeWord: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][endWordOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"capital word stop\",\n\t\t\t\t\t\t\tCTO_EndCapsWordRule + (8 * i), &ruleOffset, noback, nofor,\n\t\t\t\t\t\t\ttable))\n\t\t\t\t\treturn 0;\n\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][endWordOffset] = ruleOffset;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcase CTO_LenModePhrase:\n\t\t\t\treturn (*table)->emphRules[MAX_EMPH_CLASSES + i][lenPhraseOffset] =\n\t\t\t\t\t\t\t   compileNumber(file);\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/* these 8 general purpose emphasis opcodes are compiled further down to more\n\t\t * specific internal opcodes:\n\t\t * - emphletter\n\t\t * - begemphword\n\t\t * - endemphword\n\t\t * - begemph\n\t\t * - endemph\n\t\t * - begemphphrase\n\t\t * - endemphphrase\n\t\t * - lenemphphrase\n\t\t */\n\t\tcase CTO_EmphClass:\n\t\t\tif (!getToken(file, &emphClass, \"emphasis class\")) {\n\t\t\t\tcompileError(file, \"emphclass must be followed by a valid class name.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tint k, i;\n\t\t\tchar *s = malloc(sizeof(char) * (emphClass.length + 1));\n\t\t\tfor (k = 0; k < emphClass.length; k++) s[k] = (char)emphClass.chars[k];\n\t\t\ts[k++] = '\\0';\n\t\t\tfor (i = 0; i < MAX_EMPH_CLASSES && (*table)->emphClassNames[i]; i++)\n\t\t\t\tif (strcmp(s, (*table)->emphClassNames[i]) == 0) {\n\t\t\t\t\t_lou_logMessage(LOU_LOG_WARN, \"Duplicate emphasis class: %s\", s);\n\t\t\t\t\twarningCount++;\n\t\t\t\t\tfree(s);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\tif (i == MAX_EMPH_CLASSES) {\n\t\t\t\t_lou_logMessage(LOU_LOG_ERROR,\n\t\t\t\t\t\t\"Max number of emphasis classes (%i) reached\", MAX_EMPH_CLASSES);\n\t\t\t\terrorCount++;\n\t\t\t\tfree(s);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tswitch (i) {\n\t\t\t/* For backwards compatibility (i.e. because programs will assume\n\t\t\t * the first 3 typeform bits are `italic', `underline' and `bold')\n\t\t\t * we require that the first 3 emphclass definitions are (in that\n\t\t\t * order):\n\t\t\t *\n\t\t\t *   emphclass italic\n\t\t\t *   emphclass underline\n\t\t\t *   emphclass bold\n\t\t\t *\n\t\t\t * While it would be possible to use the emphclass opcode only for\n\t\t\t * defining _additional_ classes (not allowing for them to be called\n\t\t\t * italic, underline or bold), thereby reducing the amount of\n\t\t\t * boilerplate, we deliberately choose not to do that in order to\n\t\t\t * not give italic, underline and bold any special status. The\n\t\t\t * hope is that eventually all programs will use liblouis for\n\t\t\t * emphasis the recommended way (i.e. by looking up the supported\n\t\t\t * typeforms in the documentation or API) so that we can drop this\n\t\t\t * restriction.\n\t\t\t */\n\t\t\tcase 0:\n\t\t\t\tif (strcmp(s, \"italic\") != 0) {\n\t\t\t\t\t_lou_logMessage(LOU_LOG_ERROR,\n\t\t\t\t\t\t\t\"First emphasis class must be \\\"italic\\\" but got \"\n\t\t\t\t\t\t\t\"%s\",\n\t\t\t\t\t\t\ts);\n\t\t\t\t\terrorCount++;\n\t\t\t\t\tfree(s);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tif (strcmp(s, \"underline\") != 0) {\n\t\t\t\t\t_lou_logMessage(LOU_LOG_ERROR,\n\t\t\t\t\t\t\t\"Second emphasis class must be \\\"underline\\\" but \"\n\t\t\t\t\t\t\t\"got \"\n\t\t\t\t\t\t\t\"%s\",\n\t\t\t\t\t\t\ts);\n\t\t\t\t\terrorCount++;\n\t\t\t\t\tfree(s);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tif (strcmp(s, \"bold\") != 0) {\n\t\t\t\t\t_lou_logMessage(LOU_LOG_ERROR,\n\t\t\t\t\t\t\t\"Third emphasis class must be \\\"bold\\\" but got \"\n\t\t\t\t\t\t\t\"%s\",\n\t\t\t\t\t\t\ts);\n\t\t\t\t\terrorCount++;\n\t\t\t\t\tfree(s);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t(*table)->emphClassNames[i] = s;\n\t\t\t(*table)->emphClasses[i] = (EmphasisClass){ emph_1\n\t\t\t\t\t\t<< i, /* relies on the order of typeforms emph_1..emph_10 */\n\t\t\t\t0, 0x1 << i, i };\n\t\t\treturn 1;\n\t\tcase CTO_EmphLetter:\n\t\tcase CTO_BegEmphWord:\n\t\tcase CTO_EndEmphWord:\n\t\tcase CTO_BegEmph:\n\t\tcase CTO_EndEmph:\n\t\tcase CTO_BegEmphPhrase:\n\t\tcase CTO_EndEmphPhrase:\n\t\tcase CTO_LenEmphPhrase:\n\t\tcase CTO_EmphModeChars:\n\t\tcase CTO_NoEmphChars: {\n\t\t\tif (!getToken(file, &token, \"emphasis class\")) return 0;\n\t\t\tif (!parseChars(file, &emphClass, &token)) return 0;\n\t\t\tchar *s = malloc(sizeof(char) * (emphClass.length + 1));\n\t\t\tint k, i;\n\t\t\tfor (k = 0; k < emphClass.length; k++) s[k] = (char)emphClass.chars[k];\n\t\t\ts[k++] = '\\0';\n\t\t\tfor (i = 0; i < MAX_EMPH_CLASSES && (*table)->emphClassNames[i]; i++)\n\t\t\t\tif (strcmp(s, (*table)->emphClassNames[i]) == 0) break;\n\t\t\tif (i == MAX_EMPH_CLASSES || !(*table)->emphClassNames[i]) {\n\t\t\t\t_lou_logMessage(LOU_LOG_ERROR, \"Emphasis class %s not declared\", s);\n\t\t\t\terrorCount++;\n\t\t\t\tfree(s);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tint ok = 0;\n\t\t\tswitch (opcode) {\n\t\t\tcase CTO_EmphLetter: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset = (*table)->emphRules[i][letterOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"single letter\",\n\t\t\t\t\t\t\tCTO_Emph1LetterRule + letterOffset + (8 * i), &ruleOffset,\n\t\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\t\tbreak;\n\t\t\t\t(*table)->emphRules[i][letterOffset] = ruleOffset;\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CTO_BegEmphWord: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset = (*table)->emphRules[i][begWordOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"word\",\n\t\t\t\t\t\t\tCTO_Emph1LetterRule + begWordOffset + (8 * i), &ruleOffset,\n\t\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\t\tbreak;\n\t\t\t\t(*table)->emphRules[i][begWordOffset] = ruleOffset;\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CTO_EndEmphWord: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset = (*table)->emphRules[i][endWordOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"word stop\",\n\t\t\t\t\t\t\tCTO_Emph1LetterRule + endWordOffset + (8 * i), &ruleOffset,\n\t\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\t\tbreak;\n\t\t\t\t(*table)->emphRules[i][endWordOffset] = ruleOffset;\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CTO_BegEmph: {\n\t\t\t\t/* fail if both begemph and any of begemphphrase or begemphword are\n\t\t\t\t * defined */\n\t\t\t\tif ((*table)->emphRules[i][begWordOffset] ||\n\t\t\t\t\t\t(*table)->emphRules[i][begPhraseOffset]) {\n\t\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\t\"Cannot define emphasis for both no context and word or \"\n\t\t\t\t\t\t\t\"phrase context, i.e. cannot have both begemph and \"\n\t\t\t\t\t\t\t\"begemphword or begemphphrase.\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset = (*table)->emphRules[i][begOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"first letter\",\n\t\t\t\t\t\t\tCTO_Emph1LetterRule + begOffset + (8 * i), &ruleOffset,\n\t\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\t\tbreak;\n\t\t\t\t(*table)->emphRules[i][begOffset] = ruleOffset;\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CTO_EndEmph: {\n\t\t\t\tif ((*table)->emphRules[i][endWordOffset] ||\n\t\t\t\t\t\t(*table)->emphRules[i][endPhraseBeforeOffset] ||\n\t\t\t\t\t\t(*table)->emphRules[i][endPhraseAfterOffset]) {\n\t\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\t\"Cannot define emphasis for both no context and word or \"\n\t\t\t\t\t\t\t\"phrase context, i.e. cannot have both endemph and \"\n\t\t\t\t\t\t\t\"endemphword or endemphphrase.\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset = (*table)->emphRules[i][endOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"last letter\",\n\t\t\t\t\t\t\tCTO_Emph1LetterRule + endOffset + (8 * i), &ruleOffset,\n\t\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\t\tbreak;\n\t\t\t\t(*table)->emphRules[i][endOffset] = ruleOffset;\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CTO_BegEmphPhrase: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t(*table)->emphRules[i][begPhraseOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"first word\",\n\t\t\t\t\t\t\tCTO_Emph1LetterRule + begPhraseOffset + (8 * i), &ruleOffset,\n\t\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\t\tbreak;\n\t\t\t\t(*table)->emphRules[i][begPhraseOffset] = ruleOffset;\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CTO_EndEmphPhrase:\n\t\t\t\tswitch (compileBeforeAfter(file)) {\n\t\t\t\tcase 1: {  // before\n\t\t\t\t\tif ((*table)->emphRules[i][endPhraseAfterOffset]) {\n\t\t\t\t\t\tcompileError(file, \"last word after already defined.\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t\t// table\n\t\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t\t(*table)->emphRules[i][endPhraseBeforeOffset];\n\t\t\t\t\tif (!compileBrailleIndicator(file, \"last word before\",\n\t\t\t\t\t\t\t\tCTO_Emph1LetterRule + endPhraseBeforeOffset + (8 * i),\n\t\t\t\t\t\t\t\t&ruleOffset, noback, nofor, table))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t(*table)->emphRules[i][endPhraseBeforeOffset] = ruleOffset;\n\t\t\t\t\tok = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 2: {  // after\n\t\t\t\t\tif ((*table)->emphRules[i][endPhraseBeforeOffset]) {\n\t\t\t\t\t\tcompileError(file, \"last word before already defined.\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t\t// table\n\t\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t\t(*table)->emphRules[i][endPhraseAfterOffset];\n\t\t\t\t\tif (!compileBrailleIndicator(file, \"last word after\",\n\t\t\t\t\t\t\t\tCTO_Emph1LetterRule + endPhraseAfterOffset + (8 * i),\n\t\t\t\t\t\t\t\t&ruleOffset, noback, nofor, table))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t(*table)->emphRules[i][endPhraseAfterOffset] = ruleOffset;\n\t\t\t\t\tok = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdefault:  // error\n\t\t\t\t\tcompileError(file, \"Invalid lastword indicator location.\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CTO_LenEmphPhrase:\n\t\t\t\tif (((*table)->emphRules[i][lenPhraseOffset] = compileNumber(file)))\n\t\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\tcase CTO_EmphModeChars: {\n\t\t\t\tif (!getRuleCharsText(file, &ruleChars)) break;\n\t\t\t\twidechar *emphmodechars = (*table)->emphModeChars[i];\n\t\t\t\tint len;\n\t\t\t\tfor (len = 0; len < EMPHMODECHARSSIZE && emphmodechars[len]; len++)\n\t\t\t\t\t;\n\t\t\t\tif (len + ruleChars.length > EMPHMODECHARSSIZE) {\n\t\t\t\t\tcompileError(file, \"More than %d characters\", EMPHMODECHARSSIZE);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tok = 1;\n\t\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\t\tif (!getChar(ruleChars.chars[k], *table, NULL)) {\n\t\t\t\t\t\tcompileError(file, \"Emphasis mode character undefined\");\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\temphmodechars[len++] = ruleChars.chars[k];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CTO_NoEmphChars: {\n\t\t\t\tif (!getRuleCharsText(file, &ruleChars)) break;\n\t\t\t\twidechar *noemphchars = (*table)->noEmphChars[i];\n\t\t\t\tint len;\n\t\t\t\tfor (len = 0; len < NOEMPHCHARSSIZE && noemphchars[len]; len++)\n\t\t\t\t\t;\n\t\t\t\tif (len + ruleChars.length > NOEMPHCHARSSIZE) {\n\t\t\t\t\tcompileError(file, \"More than %d characters\", NOEMPHCHARSSIZE);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tok = 1;\n\t\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\t\tif (!getChar(ruleChars.chars[k], *table, NULL)) {\n\t\t\t\t\t\tcompileError(file, \"Character undefined\");\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tnoemphchars[len++] = ruleChars.chars[k];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfree(s);\n\t\t\treturn ok;\n\t\t}\n\t\tcase CTO_LetterSign: {\n\t\t\t// not passing pointer because compileBrailleIndicator may reallocate table\n\t\t\tTranslationTableOffset ruleOffset = (*table)->letterSign;\n\t\t\tif (!compileBrailleIndicator(file, \"letter sign\", CTO_LetterRule, &ruleOffset,\n\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\t(*table)->letterSign = ruleOffset;\n\t\t\treturn 1;\n\t\t}\n\t\tcase CTO_NoLetsignBefore:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (((*table)->noLetsignBeforeCount + ruleChars.length) > LETSIGNBEFORESIZE) {\n\t\t\t\tcompileError(file, \"More than %d characters\", LETSIGNBEFORESIZE);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor (int k = 0; k < ruleChars.length; k++)\n\t\t\t\t(*table)->noLetsignBefore[(*table)->noLetsignBeforeCount++] =\n\t\t\t\t\t\truleChars.chars[k];\n\t\t\treturn 1;\n\t\tcase CTO_NoLetsign:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (((*table)->noLetsignCount + ruleChars.length) > LETSIGNSIZE) {\n\t\t\t\tcompileError(file, \"More than %d characters\", LETSIGNSIZE);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor (int k = 0; k < ruleChars.length; k++)\n\t\t\t\t(*table)->noLetsign[(*table)->noLetsignCount++] = ruleChars.chars[k];\n\t\t\treturn 1;\n\t\tcase CTO_NoLetsignAfter:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (((*table)->noLetsignAfterCount + ruleChars.length) > LETSIGNAFTERSIZE) {\n\t\t\t\tcompileError(file, \"More than %d characters\", LETSIGNAFTERSIZE);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor (int k = 0; k < ruleChars.length; k++)\n\t\t\t\t(*table)->noLetsignAfter[(*table)->noLetsignAfterCount++] =\n\t\t\t\t\t\truleChars.chars[k];\n\t\t\treturn 1;\n\t\tcase CTO_NumberSign: {\n\t\t\t// not passing pointer because compileBrailleIndicator may reallocate table\n\t\t\tTranslationTableOffset ruleOffset = (*table)->numberSign;\n\t\t\tif (!compileBrailleIndicator(file, \"number sign\", CTO_NumberRule, &ruleOffset,\n\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\t(*table)->numberSign = ruleOffset;\n\t\t\treturn 1;\n\t\t}\n\n\t\tcase CTO_NumericModeChars:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!c) {\n\t\t\t\t\tcompileError(file, \"Numeric mode character undefined: %s\",\n\t\t\t\t\t\t\t_lou_showString(&ruleChars.chars[k], 1, 0));\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc->attributes |= CTC_NumericMode;\n\t\t\t\t(*table)->usesNumericMode = 1;\n\t\t\t}\n\t\t\treturn 1;\n\n\t\tcase CTO_MidEndNumericModeChars:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!c) {\n\t\t\t\t\tcompileError(file, \"Midendnumeric mode character undefined\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc->attributes |= CTC_MidEndNumericMode;\n\t\t\t\t(*table)->usesNumericMode = 1;\n\t\t\t}\n\t\t\treturn 1;\n\n\t\tcase CTO_NumericNoContractChars:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!c) {\n\t\t\t\t\tcompileError(file, \"Numeric no contraction character undefined\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc->attributes |= CTC_NumericNoContract;\n\t\t\t\t(*table)->usesNumericMode = 1;\n\t\t\t}\n\t\t\treturn 1;\n\n\t\tcase CTO_NoContractSign: {\n\t\t\t// not passing pointer because compileBrailleIndicator may reallocate table\n\t\t\tTranslationTableOffset ruleOffset = (*table)->noContractSign;\n\t\t\tif (!compileBrailleIndicator(file, \"no contractions sign\", CTO_NoContractRule,\n\t\t\t\t\t\t&ruleOffset, noback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\t(*table)->noContractSign = ruleOffset;\n\t\t\treturn 1;\n\t\t}\n\t\tcase CTO_SeqDelimiter:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!c) {\n\t\t\t\t\tcompileError(file, \"Sequence delimiter character undefined\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc->attributes |= CTC_SeqDelimiter;\n\t\t\t\t(*table)->usesSequences = 1;\n\t\t\t}\n\t\t\treturn 1;\n\n\t\tcase CTO_SeqBeforeChars:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!c) {\n\t\t\t\t\tcompileError(file, \"Sequence before character undefined\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc->attributes |= CTC_SeqBefore;\n\t\t\t}\n\t\t\treturn 1;\n\n\t\tcase CTO_SeqAfterChars:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!c) {\n\t\t\t\t\tcompileError(file, \"Sequence after character undefined\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc->attributes |= CTC_SeqAfter;\n\t\t\t}\n\t\t\treturn 1;\n\n\t\tcase CTO_SeqAfterPattern:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (((*table)->seqPatternsCount + ruleChars.length + 1) > SEQPATTERNSIZE) {\n\t\t\t\tcompileError(file, \"More than %d characters\", SEQPATTERNSIZE);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor (int k = 0; k < ruleChars.length; k++)\n\t\t\t\t(*table)->seqPatterns[(*table)->seqPatternsCount++] = ruleChars.chars[k];\n\t\t\t(*table)->seqPatterns[(*table)->seqPatternsCount++] = 0;\n\t\t\treturn 1;\n\n\t\tcase CTO_SeqAfterExpression:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor ((*table)->seqAfterExpressionLength = 0;\n\t\t\t\t\t(*table)->seqAfterExpressionLength < ruleChars.length;\n\t\t\t\t\t(*table)->seqAfterExpressionLength++)\n\t\t\t\t(*table)->seqAfterExpression[(*table)->seqAfterExpressionLength] =\n\t\t\t\t\t\truleChars.chars[(*table)->seqAfterExpressionLength];\n\t\t\t(*table)->seqAfterExpression[(*table)->seqAfterExpressionLength] = 0;\n\t\t\treturn 1;\n\n\t\tcase CTO_CapsModeChars:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!c) {\n\t\t\t\t\tcompileError(file, \"Capital mode character undefined\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc->attributes |= CTC_CapsMode;\n\t\t\t\t(*table)->hasCapsModeChars = 1;\n\t\t\t}\n\t\t\treturn 1;\n\n\t\tcase CTO_BegComp: {\n\t\t\t// not passing pointer because compileBrailleIndicator may reallocate table\n\t\t\tTranslationTableOffset ruleOffset = (*table)->begComp;\n\t\t\tif (!compileBrailleIndicator(file, \"begin computer braille\", CTO_BegCompRule,\n\t\t\t\t\t\t&ruleOffset, noback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\t(*table)->begComp = ruleOffset;\n\t\t\treturn 1;\n\t\t}\n\t\tcase CTO_EndComp: {\n\t\t\t// not passing pointer because compileBrailleIndicator may reallocate table\n\t\t\tTranslationTableOffset ruleOffset = (*table)->endComp;\n\t\t\tif (!compileBrailleIndicator(file, \"end computer braslle\", CTO_EndCompRule,\n\t\t\t\t\t\t&ruleOffset, noback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\t(*table)->endComp = ruleOffset;\n\t\t\treturn 1;\n\t\t}\n\t\tcase CTO_NoCross:\n\t\t\tif (nocross) {\n\t\t\t\tcompileError(\n\t\t\t\t\t\tfile, \"%s already specified.\", _lou_findOpcodeName(CTO_NoCross));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tnocross = 1;\n\t\t\tgoto doOpcode;\n\t\tcase CTO_Syllable:\n\t\t\t(*table)->syllables = 1;\n\t\tcase CTO_Always:\n\t\tcase CTO_LargeSign:\n\t\tcase CTO_WholeWord:\n\t\tcase CTO_PartWord:\n\t\tcase CTO_JoinNum:\n\t\tcase CTO_JoinableWord:\n\t\tcase CTO_LowWord:\n\t\tcase CTO_SuffixableWord:\n\t\tcase CTO_PrefixableWord:\n\t\tcase CTO_BegWord:\n\t\tcase CTO_BegMidWord:\n\t\tcase CTO_MidWord:\n\t\tcase CTO_MidEndWord:\n\t\tcase CTO_EndWord:\n\t\tcase CTO_PrePunc:\n\t\tcase CTO_PostPunc:\n\t\tcase CTO_BegNum:\n\t\tcase CTO_MidNum:\n\t\tcase CTO_EndNum:\n\t\tcase CTO_Repeated:\n\t\tcase CTO_RepWord:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (!getRuleDotsPattern(file, &ruleDots)) return 0;\n\t\t\tif (ruleDots.length == 0)\n\t\t\t\t// check that all characters in a rule with `=` as second operand are\n\t\t\t\t// defined (or based on another character)\n\t\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\t\tTranslationTableCharacter *c =\n\t\t\t\t\t\t\tgetChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\t\tif (!(c && (c->definitionRule || c->basechar))) {\n\t\t\t\t\t\tcompileError(file, \"Character %s is not defined\",\n\t\t\t\t\t\t\t\t_lou_showString(&ruleChars.chars[k], 1, 0));\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tTranslationTableRule *r;\n\t\t\tif (!addRule(file, opcode, &ruleChars, &ruleDots, after, before, NULL, &r,\n\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\tif (nocross) r->nocross = 1;\n\t\t\treturn 1;\n\t\t\t// if (opcode == CTO_MidNum)\n\t\t\t// {\n\t\t\t//   TranslationTableCharacter *c = getChar(ruleChars.chars[0]);\n\t\t\t//   if(c)\n\t\t\t//     c->attributes |= CTC_NumericMode;\n\t\t\t// }\n\t\tcase CTO_RepEndWord:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tCharsString dots;\n\t\t\tif (!getToken(file, &dots, \"dots,dots operand\")) return 0;\n\t\t\tint len = dots.length;\n\t\t\tfor (int k = 0; k < len - 1; k++) {\n\t\t\t\tif (dots.chars[k] == ',') {\n\t\t\t\t\tdots.length = k;\n\t\t\t\t\tif (!parseDots(file, &ruleDots, &dots)) return 0;\n\t\t\t\t\truleDots.chars[ruleDots.length++] = ',';\n\t\t\t\t\tk++;\n\t\t\t\t\tif (k == len - 1 && dots.chars[k] == '=') {\n\t\t\t\t\t\t// check that all characters are defined (or based on another\n\t\t\t\t\t\t// character)\n\t\t\t\t\t\tfor (int l = 0; l < ruleChars.length; l++) {\n\t\t\t\t\t\t\tTranslationTableCharacter *c =\n\t\t\t\t\t\t\t\t\tgetChar(ruleChars.chars[l], *table, NULL);\n\t\t\t\t\t\t\tif (!(c && (c->definitionRule || c->basechar))) {\n\t\t\t\t\t\t\t\tcompileError(file, \"Character %s is not defined\",\n\t\t\t\t\t\t\t\t\t\t_lou_showString(&ruleChars.chars[l], 1, 0));\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tCharsString x, y;\n\t\t\t\t\t\tx.length = 0;\n\t\t\t\t\t\twhile (k < len) x.chars[x.length++] = dots.chars[k++];\n\t\t\t\t\t\tif (parseDots(file, &y, &x))\n\t\t\t\t\t\t\tfor (int l = 0; l < y.length; l++)\n\t\t\t\t\t\t\t\truleDots.chars[ruleDots.length++] = y.chars[l];\n\t\t\t\t\t}\n\t\t\t\t\treturn addRule(file, opcode, &ruleChars, &ruleDots, after, before,\n\t\t\t\t\t\t\tNULL, NULL, noback, nofor, table);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\tcase CTO_CompDots:\n\t\tcase CTO_Comp6: {\n\t\t\tTranslationTableOffset ruleOffset;\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (ruleChars.length != 1) {\n\t\t\t\tcompileError(file, \"first operand must be 1 character\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (nofor || noback) {\n\t\t\t\tcompileWarning(file, \"nofor and noback not allowed on comp6 rules\");\n\t\t\t}\n\t\t\tif (!getRuleDotsPattern(file, &ruleDots)) return 0;\n\t\t\tif (!addRule(file, opcode, &ruleChars, &ruleDots, after, before, &ruleOffset,\n\t\t\t\t\t\tNULL, noback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\treturn 1;\n\t\t}\n\t\tcase CTO_ExactDots:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (ruleChars.chars[0] != '@') {\n\t\t\t\tcompileError(file, \"The operand must begin with an at sign (@)\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor (int k = 1; k < ruleChars.length; k++)\n\t\t\t\tscratchPad.chars[k - 1] = ruleChars.chars[k];\n\t\t\tscratchPad.length = ruleChars.length - 1;\n\t\t\tif (!parseDots(file, &ruleDots, &scratchPad)) return 0;\n\t\t\treturn addRule(file, opcode, &ruleChars, &ruleDots, before, after, NULL, NULL,\n\t\t\t\t\tnoback, nofor, table);\n\t\tcase CTO_CapsNoCont: {\n\t\t\tTranslationTableOffset ruleOffset;\n\t\t\truleChars.length = 1;\n\t\t\truleChars.chars[0] = 'a';\n\t\t\tif (!addRule(file, CTO_CapsNoContRule, &ruleChars, NULL, after, before,\n\t\t\t\t\t\t&ruleOffset, NULL, noback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\t(*table)->capsNoCont = ruleOffset;\n\t\t\treturn 1;\n\t\t}\n\t\tcase CTO_Replace:\n\t\t\tif (getRuleCharsText(file, &ruleChars)) {\n\t\t\t\tif (atEndOfLine(file))\n\t\t\t\t\truleDots.length = ruleDots.chars[0] = 0;\n\t\t\t\telse {\n\t\t\t\t\tgetRuleDotsText(file, &ruleDots);\n\t\t\t\t\tif (ruleDots.chars[0] == '#')\n\t\t\t\t\t\truleDots.length = ruleDots.chars[0] = 0;\n\t\t\t\t\telse if (ruleDots.chars[0] == '\\\\' && ruleDots.chars[1] == '#')\n\t\t\t\t\t\tmemmove(&ruleDots.chars[0], &ruleDots.chars[1],\n\t\t\t\t\t\t\t\truleDots.length-- * CHARSIZE);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int k = 0; k < ruleChars.length; k++)\n\t\t\t\tputChar(file, ruleChars.chars[k], table, NULL);\n\t\t\tfor (int k = 0; k < ruleDots.length; k++)\n\t\t\t\tputChar(file, ruleDots.chars[k], table, NULL);\n\t\t\treturn addRule(file, opcode, &ruleChars, &ruleDots, after, before, NULL, NULL,\n\t\t\t\t\tnoback, nofor, table);\n\t\tcase CTO_Correct:\n\t\t\t(*table)->corrections = 1;\n\t\t\tgoto doPass;\n\t\tcase CTO_Pass2:\n\t\t\tif ((*table)->numPasses < 2) (*table)->numPasses = 2;\n\t\t\tgoto doPass;\n\t\tcase CTO_Pass3:\n\t\t\tif ((*table)->numPasses < 3) (*table)->numPasses = 3;\n\t\t\tgoto doPass;\n\t\tcase CTO_Pass4:\n\t\t\tif ((*table)->numPasses < 4) (*table)->numPasses = 4;\n\t\tdoPass:\n\t\tcase CTO_Context:\n\t\t\tif (!(nofor || noback)) {\n\t\t\t\tcompileError(file, \"%s or %s must be specified.\",\n\t\t\t\t\t\t_lou_findOpcodeName(CTO_NoFor), _lou_findOpcodeName(CTO_NoBack));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn compilePassOpcode(file, opcode, noback, nofor, table);\n\t\tcase CTO_Contraction:\n\t\tcase CTO_NoCont:\n\t\tcase CTO_CompBrl:\n\t\tcase CTO_Literal:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\t// check that all characters in a compbrl, contraction,\n\t\t\t// nocont or literal rule are defined (or based on another\n\t\t\t// character)\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!(c && (c->definitionRule || c->basechar))) {\n\t\t\t\t\tcompileError(file, \"Character %s is not defined\",\n\t\t\t\t\t\t\t_lou_showString(&ruleChars.chars[k], 1, 0));\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn addRule(file, opcode, &ruleChars, NULL, after, before, NULL, NULL,\n\t\t\t\t\tnoback, nofor, table);\n\t\tcase CTO_MultInd: {\n\t\t\truleChars.length = 0;\n\t\t\tif (!getToken(file, &token, \"multiple braille indicators\") ||\n\t\t\t\t\t!parseDots(file, &cells, &token))\n\t\t\t\treturn 0;\n\t\t\twhile (getToken(file, &token, \"multind opcodes\")) {\n\t\t\t\topcode = getOpcode(file, &token);\n\t\t\t\tif (opcode == CTO_None) {\n\t\t\t\t\tcompileError(file, \"opcode %s not defined.\",\n\t\t\t\t\t\t\t_lou_showString(token.chars, token.length, 0));\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif (!(opcode >= CTO_CapsLetter && opcode < CTO_MultInd)) {\n\t\t\t\t\tcompileError(file, \"Not a braille indicator opcode.\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\truleChars.chars[ruleChars.length++] = (widechar)opcode;\n\t\t\t\tif (atEndOfLine(file)) break;\n\t\t\t}\n\t\t\treturn addRule(file, CTO_MultInd, &ruleChars, &cells, after, before, NULL,\n\t\t\t\t\tNULL, noback, nofor, table);\n\t\t}\n\n\t\tcase CTO_Class:\n\t\t\tcompileWarning(file, \"class is deprecated, use attribute instead\");\n\t\tcase CTO_Attribute: {\n\t\t\tif (nofor || noback) {\n\t\t\t\tcompileWarning(\n\t\t\t\t\t\tfile, \"nofor and noback not allowed before class/attribute\");\n\t\t\t}\n\t\t\tif ((opcode == CTO_Class && (*table)->usesAttributeOrClass == 1) ||\n\t\t\t\t\t(opcode == CTO_Attribute && (*table)->usesAttributeOrClass == 2)) {\n\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\"attribute and class rules must not be both present in a table\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (opcode == CTO_Class)\n\t\t\t\t(*table)->usesAttributeOrClass = 2;\n\t\t\telse\n\t\t\t\t(*table)->usesAttributeOrClass = 1;\n\t\t\tif (!getToken(file, &token, \"attribute name\")) {\n\t\t\t\tcompileError(file, \"Expected %s\", \"attribute name\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!(*table)->characterClasses && !allocateCharacterClasses(*table)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tTranslationTableCharacterAttributes attribute = 0;\n\t\t\t{\n\t\t\t\tint attrNumber = -1;\n\t\t\t\tswitch (token.chars[0]) {\n\t\t\t\tcase '0':\n\t\t\t\tcase '1':\n\t\t\t\tcase '2':\n\t\t\t\tcase '3':\n\t\t\t\tcase '4':\n\t\t\t\tcase '5':\n\t\t\t\tcase '6':\n\t\t\t\tcase '7':\n\t\t\t\tcase '8':\n\t\t\t\tcase '9':\n\t\t\t\t\tattrNumber = token.chars[0] - '0';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (attrNumber >= 0) {\n\t\t\t\t\tif (opcode == CTO_Class) {\n\t\t\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\t\t\"Invalid class name: may not contain digits, use \"\n\t\t\t\t\t\t\t\t\"attribute instead of class\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (token.length > 1 || attrNumber > 7) {\n\t\t\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\t\t\"Invalid attribute name: must be a digit between 0 and 7 \"\n\t\t\t\t\t\t\t\t\"or a word containing only letters\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (!(*table)->numberedAttributes[attrNumber])\n\t\t\t\t\t\t// attribute not used before yet: assign it a value\n\t\t\t\t\t\t(*table)->numberedAttributes[attrNumber] =\n\t\t\t\t\t\t\t\tgetNextNumberedAttribute(*table);\n\t\t\t\t\tattribute = (*table)->numberedAttributes[attrNumber];\n\t\t\t\t} else {\n\t\t\t\t\tconst CharacterClass *namedAttr = findCharacterClass(&token, *table);\n\t\t\t\t\tif (!namedAttr) {\n\t\t\t\t\t\t// no class with that name: create one\n\t\t\t\t\t\tnamedAttr = addCharacterClass(\n\t\t\t\t\t\t\t\tfile, &token.chars[0], token.length, *table, 1);\n\t\t\t\t\t\tif (!namedAttr) return 0;\n\t\t\t\t\t}\n\t\t\t\t\t// there is a class with that name or a new class was successfully\n\t\t\t\t\t// created\n\t\t\t\t\tattribute = namedAttr->attribute;\n\t\t\t\t\tif (attribute == CTC_UpperCase || attribute == CTC_LowerCase)\n\t\t\t\t\t\tattribute |= CTC_Letter;\n\t\t\t\t}\n\t\t\t}\n\t\t\tCharsString characters;\n\t\t\tif (!getCharacters(file, &characters)) return 0;\n\t\t\tfor (int i = 0; i < characters.length; i++) {\n\t\t\t\t// get the character from the table, or if it is not defined yet,\n\t\t\t\t// define it\n\t\t\t\tTranslationTableCharacter *character =\n\t\t\t\t\t\tputChar(file, characters.chars[i], table, NULL);\n\t\t\t\t// set the attribute\n\t\t\t\tcharacter->attributes |= attribute;\n\t\t\t\t// also set the attribute on the associated dots (if any)\n\t\t\t\tif (character->basechar)\n\t\t\t\t\tcharacter = (TranslationTableCharacter *)&(*table)\n\t\t\t\t\t\t\t\t\t\t->ruleArea[character->basechar];\n\t\t\t\tif (character->definitionRule) {\n\t\t\t\t\tTranslationTableRule *defRule =\n\t\t\t\t\t\t\t(TranslationTableRule *)&(*table)\n\t\t\t\t\t\t\t\t\t->ruleArea[character->definitionRule];\n\t\t\t\t\tif (defRule->dotslen == 1) {\n\t\t\t\t\t\tTranslationTableCharacter *dots =\n\t\t\t\t\t\t\t\tgetDots(defRule->charsdots[defRule->charslen], *table);\n\t\t\t\t\t\tif (dots) dots->attributes |= attribute;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\n\t\t\t{\n\t\t\t\tTranslationTableCharacterAttributes *attributes;\n\t\t\t\tconst CharacterClass *class;\n\t\t\tcase CTO_After:\n\t\t\t\tattributes = &after;\n\t\t\t\tgoto doBeforeAfter;\n\t\t\tcase CTO_Before:\n\t\t\t\tattributes = &before;\n\t\t\tdoBeforeAfter:\n\t\t\t\tif (!(*table)->characterClasses) {\n\t\t\t\t\tif (!allocateCharacterClasses(*table)) return 0;\n\t\t\t\t}\n\t\t\t\tif (!getToken(file, &token, \"attribute name\")) return 0;\n\t\t\t\tif (!(class = findCharacterClass(&token, *table))) {\n\t\t\t\t\tcompileError(file, \"attribute not defined\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t*attributes |= class->attribute;\n\t\t\t\tgoto doOpcode;\n\t\t\t}\n\t\tcase CTO_Base:\n\t\t\tif (nofor || noback) {\n\t\t\t\tcompileWarning(file, \"nofor and noback not allowed before base\");\n\t\t\t}\n\t\t\tif (!getToken(file, &token, \"attribute name\")) {\n\t\t\t\tcompileError(\n\t\t\t\t\t\tfile, \"base opcode must be followed by a valid attribute name.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!(*table)->characterClasses && !allocateCharacterClasses(*table)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tconst CharacterClass *mode = findCharacterClass(&token, *table);\n\t\t\tif (!mode) {\n\t\t\t\tmode = addCharacterClass(file, token.chars, token.length, *table, 1);\n\t\t\t\tif (!mode) return 0;\n\t\t\t}\n\t\t\tif (!(mode->attribute == CTC_UpperCase || mode->attribute == CTC_Digit) &&\n\t\t\t\t\tmode->attribute >= CTC_Space && mode->attribute <= CTC_LitDigit) {\n\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\"base opcode must be followed by \\\"uppercase\\\", \\\"digit\\\", or a \"\n\t\t\t\t\t\t\"custom attribute name.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!getRuleCharsText(file, &token)) return 0;\n\t\t\tif (token.length != 1) {\n\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\"Exactly one character followed by one base character is \"\n\t\t\t\t\t\t\"required.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tTranslationTableOffset characterOffset;\n\t\t\tTranslationTableCharacter *character =\n\t\t\t\t\tputChar(file, token.chars[0], table, &characterOffset);\n\t\t\tif (!getRuleCharsText(file, &token)) return 0;\n\t\t\tif (token.length != 1) {\n\t\t\t\tcompileError(file, \"Exactly one base character is required.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (character->definitionRule) {\n\t\t\t\tTranslationTableRule *prevRule =\n\t\t\t\t\t\t(TranslationTableRule *)&(*table)\n\t\t\t\t\t\t\t\t->ruleArea[character->definitionRule];\n\t\t\t\t_lou_logMessage(LOU_LOG_DEBUG,\n\t\t\t\t\t\t\"%s:%d: Character already defined (%s). The base rule will take \"\n\t\t\t\t\t\t\"precedence.\",\n\t\t\t\t\t\tfile->fileName, file->lineNumber,\n\t\t\t\t\t\tprintSource(file, prevRule->sourceFile, prevRule->sourceLine));\n\t\t\t\tcharacter->definitionRule = 0;\n\t\t\t}\n\t\t\tTranslationTableOffset basechar;\n\t\t\tputChar(file, token.chars[0], table, &basechar);\n\t\t\t// putChar may have moved table, so make sure character is still valid\n\t\t\tcharacter = (TranslationTableCharacter *)&(*table)->ruleArea[characterOffset];\n\t\t\tif (character->basechar) {\n\t\t\t\tif (character->basechar == basechar &&\n\t\t\t\t\t\tcharacter->mode == mode->attribute) {\n\t\t\t\t\t_lou_logMessage(LOU_LOG_DEBUG, \"%s:%d: Duplicate base rule.\",\n\t\t\t\t\t\t\tfile->fileName, file->lineNumber);\n\t\t\t\t} else {\n\t\t\t\t\t_lou_logMessage(LOU_LOG_DEBUG,\n\t\t\t\t\t\t\t\"%s:%d: A different base rule already exists for this \"\n\t\t\t\t\t\t\t\"character (%s). The new rule will take precedence.\",\n\t\t\t\t\t\t\tfile->fileName, file->lineNumber,\n\t\t\t\t\t\t\tprintSource(\n\t\t\t\t\t\t\t\t\tfile, character->sourceFile, character->sourceLine));\n\t\t\t\t}\n\t\t\t}\n\t\t\tcharacter->basechar = basechar;\n\t\t\tcharacter->mode = mode->attribute;\n\t\t\tcharacter->sourceFile = file->sourceFile;\n\t\t\tcharacter->sourceLine = file->lineNumber;\n\t\t\t/* some other processing is done at the end of the compilation, in\n\t\t\t * finalizeTable() */\n\t\t\treturn 1;\n\t\tcase CTO_EmpMatchBefore:\n\t\t\tbefore |= CTC_EmpMatch;\n\t\t\tgoto doOpcode;\n\t\tcase CTO_EmpMatchAfter:\n\t\t\tafter |= CTC_EmpMatch;\n\t\t\tgoto doOpcode;\n\n\t\tcase CTO_SwapCc:\n\t\tcase CTO_SwapCd:\n\t\tcase CTO_SwapDd:\n\t\t\treturn compileSwap(file, opcode, noback, nofor, table);\n\t\tcase CTO_Hyphen:\n\t\tcase CTO_DecPoint:\n\t\t\t//\tcase CTO_Apostrophe:\n\t\t\t//\tcase CTO_Initial:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (!getRuleDotsPattern(file, &ruleDots)) return 0;\n\t\t\tif (ruleChars.length != 1 || ruleDots.length < 1) {\n\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\"One Unicode character and at least one cell are \"\n\t\t\t\t\t\t\"required.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn addRule(file, opcode, &ruleChars, &ruleDots, after, before, NULL, NULL,\n\t\t\t\t\tnoback, nofor, table);\n\t\t\t// if (opcode == CTO_DecPoint)\n\t\t\t// {\n\t\t\t//   TranslationTableCharacter *c =\n\t\t\t//   getChar(ruleChars.chars[0]);\n\t\t\t//   if(c)\n\t\t\t//     c->attributes |= CTC_NumericMode;\n\t\t\t// }\n\t\tdefault:\n\t\t\tcompileError(file, \"unimplemented opcode.\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}", "func_hash": 114188111189139492438388270487144198902, "file_name": "compileTranslationTable.c", "file_hash": 130160890521779483138755278607355501086, "cwe": ["CWE-787"], "cve": "CVE-2022-31783", "cve_desc": "Liblouis 3.21.0 has an out-of-bounds write in compileRule in compileTranslationTable.c, as demonstrated by lou_trace.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-31783", "file_path": "liblouis/compileTranslationTable.c"}
{"idx": 482533, "project": "liblouis", "commit_id": "2e4772befb2b1c37cb4b9d6572945115ee28630a", "project_url": "https://github.com/liblouis/liblouis", "commit_url": "https://github.com/liblouis/liblouis/commit/2e4772befb2b1c37cb4b9d6572945115ee28630a", "commit_message": "Prevent an invalid memory writes in compileRule\n\nThanks to Han Zheng for reporting it\n\nFixes #1214", "target": 0, "func": "compileRule(FileInfo *file, TranslationTableHeader **table,\n\t\tDisplayTableHeader **displayTable, const MacroList **inScopeMacros) {\n\tCharsString token;\n\tTranslationTableOpcode opcode;\n\tCharsString ruleChars;\n\tCharsString ruleDots;\n\tCharsString cells;\n\tCharsString scratchPad;\n\tCharsString emphClass;\n\tTranslationTableCharacterAttributes after = 0;\n\tTranslationTableCharacterAttributes before = 0;\n\tint noback, nofor, nocross;\n\tnoback = nofor = nocross = 0;\ndoOpcode:\n\tif (!getToken(file, &token, NULL)) return 1;\t\t\t\t  /* blank line */\n\tif (token.chars[0] == '#' || token.chars[0] == '<') return 1; /* comment */\n\tif (file->lineNumber == 1 &&\n\t\t\t(eqasc2uni((unsigned char *)\"ISO\", token.chars, 3) ||\n\t\t\t\t\teqasc2uni((unsigned char *)\"UTF-8\", token.chars, 5))) {\n\t\tif (table)\n\t\t\tcompileHyphenation(file, &token, table);\n\t\telse\n\t\t\t/* ignore the whole file */\n\t\t\twhile (_lou_getALine(file))\n\t\t\t\t;\n\t\treturn 1;\n\t}\n\topcode = getOpcode(file, &token);\n\tswitch (opcode) {\n\tcase CTO_Macro: {\n\t\tconst Macro *macro;\n#ifdef ENABLE_MACROS\n\t\tif (!inScopeMacros) {\n\t\t\tcompileError(file, \"Defining macros only allowed in table files.\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (compileMacro(file, &macro)) {\n\t\t\t*inScopeMacros = cons_macro(macro, *inScopeMacros);\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n#else\n\t\tcompileError(file, \"Macro feature is disabled.\");\n\t\treturn 0;\n#endif\n\t}\n\tcase CTO_IncludeFile: {\n\t\tCharsString includedFile;\n\t\tif (!getToken(file, &token, \"include file name\")) return 0;\n\t\tif (!parseChars(file, &includedFile, &token)) return 0;\n\t\treturn includeFile(file, &includedFile, table, displayTable);\n\t}\n\tcase CTO_NoBack:\n\t\tif (nofor) {\n\t\t\tcompileError(file, \"%s already specified.\", _lou_findOpcodeName(CTO_NoFor));\n\t\t\treturn 0;\n\t\t}\n\t\tnoback = 1;\n\t\tgoto doOpcode;\n\tcase CTO_NoFor:\n\t\tif (noback) {\n\t\t\tcompileError(file, \"%s already specified.\", _lou_findOpcodeName(CTO_NoBack));\n\t\t\treturn 0;\n\t\t}\n\t\tnofor = 1;\n\t\tgoto doOpcode;\n\tcase CTO_Space:\n\t\treturn compileCharDef(\n\t\t\t\tfile, opcode, CTC_Space, noback, nofor, table, displayTable);\n\tcase CTO_Digit:\n\t\treturn compileCharDef(\n\t\t\t\tfile, opcode, CTC_Digit, noback, nofor, table, displayTable);\n\tcase CTO_LitDigit:\n\t\treturn compileCharDef(\n\t\t\t\tfile, opcode, CTC_LitDigit, noback, nofor, table, displayTable);\n\tcase CTO_Punctuation:\n\t\treturn compileCharDef(\n\t\t\t\tfile, opcode, CTC_Punctuation, noback, nofor, table, displayTable);\n\tcase CTO_Math:\n\t\treturn compileCharDef(file, opcode, CTC_Math, noback, nofor, table, displayTable);\n\tcase CTO_Sign:\n\t\treturn compileCharDef(file, opcode, CTC_Sign, noback, nofor, table, displayTable);\n\tcase CTO_Letter:\n\t\treturn compileCharDef(\n\t\t\t\tfile, opcode, CTC_Letter, noback, nofor, table, displayTable);\n\tcase CTO_UpperCase:\n\t\treturn compileCharDef(\n\t\t\t\tfile, opcode, CTC_UpperCase, noback, nofor, table, displayTable);\n\tcase CTO_LowerCase:\n\t\treturn compileCharDef(\n\t\t\t\tfile, opcode, CTC_LowerCase, noback, nofor, table, displayTable);\n\tcase CTO_Grouping:\n\t\treturn compileGrouping(file, noback, nofor, table, displayTable);\n\tcase CTO_Display:\n\t\tif (!displayTable) return 1;  // ignore\n\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\tif (!getRuleDotsPattern(file, &ruleDots)) return 0;\n\t\tif (ruleChars.length != 1 || ruleDots.length != 1) {\n\t\t\tcompileError(file, \"Exactly one character and one cell are required.\");\n\t\t\treturn 0;\n\t\t}\n\t\treturn putCharDotsMapping(\n\t\t\t\tfile, ruleChars.chars[0], ruleDots.chars[0], displayTable);\n\tcase CTO_UpLow:\n\tcase CTO_None: {\n\t\t// check if token is a macro name\n\t\tif (inScopeMacros) {\n\t\t\tconst MacroList *macros = *inScopeMacros;\n\t\t\twhile (macros) {\n\t\t\t\tconst Macro *m = macros->head;\n\t\t\t\tif (token.length == strlen(m->name) &&\n\t\t\t\t\t\teqasc2uni((unsigned char *)m->name, token.chars, token.length)) {\n\t\t\t\t\tif (!inScopeMacros) {\n\t\t\t\t\t\tcompileError(file, \"Calling macros only allowed in table files.\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tFileInfo tmpFile;\n\t\t\t\t\tmemset(&tmpFile, 0, sizeof(tmpFile));\n\t\t\t\t\ttmpFile.fileName = file->fileName;\n\t\t\t\t\ttmpFile.sourceFile = file->sourceFile;\n\t\t\t\t\ttmpFile.lineNumber = file->lineNumber;\n\t\t\t\t\ttmpFile.encoding = noEncoding;\n\t\t\t\t\ttmpFile.status = 0;\n\t\t\t\t\ttmpFile.linepos = 0;\n\t\t\t\t\ttmpFile.linelen = 0;\n\t\t\t\t\tint argument_count = 0;\n\t\t\t\t\tCharsString *arguments =\n\t\t\t\t\t\t\tmalloc(m->argument_count * sizeof(CharsString));\n\t\t\t\t\twhile (argument_count < m->argument_count) {\n\t\t\t\t\t\tif (getToken(file, &token, \"macro argument\"))\n\t\t\t\t\t\t\targuments[argument_count++] = token;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (argument_count < m->argument_count) {\n\t\t\t\t\t\tcompileError(file, \"Expected %d arguments\", m->argument_count);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tint i = 0;\n\t\t\t\t\tint subst = 0;\n\t\t\t\t\tint next = subst < m->substitution_count ? m->substitutions[2 * subst]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t : m->definition_length;\n\t\t\t\t\tfor (;;) {\n\t\t\t\t\t\twhile (i < next) {\n\t\t\t\t\t\t\twidechar c = m->definition[i++];\n\t\t\t\t\t\t\tif (c == '\\n') {\n\t\t\t\t\t\t\t\tif (!compileRule(&tmpFile, table, displayTable,\n\t\t\t\t\t\t\t\t\t\t\tinScopeMacros)) {\n\t\t\t\t\t\t\t\t\t_lou_logMessage(LOU_LOG_ERROR,\n\t\t\t\t\t\t\t\t\t\t\t\"result of macro expansion was: %s\",\n\t\t\t\t\t\t\t\t\t\t\t_lou_showString(\n\t\t\t\t\t\t\t\t\t\t\t\t\ttmpFile.line, tmpFile.linelen, 0));\n\t\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttmpFile.linepos = 0;\n\t\t\t\t\t\t\t\ttmpFile.linelen = 0;\n\t\t\t\t\t\t\t} else if (tmpFile.linelen >= MAXSTRING) {\n\t\t\t\t\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\t\t\t\t\"Line exceeds %d characters (post macro \"\n\t\t\t\t\t\t\t\t\t\t\"expansion)\",\n\t\t\t\t\t\t\t\t\t\tMAXSTRING);\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\ttmpFile.line[tmpFile.linelen++] = c;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (subst < m->substitution_count) {\n\t\t\t\t\t\t\tCharsString arg =\n\t\t\t\t\t\t\t\t\targuments[m->substitutions[2 * subst + 1] - 1];\n\t\t\t\t\t\t\tfor (int j = 0; j < arg.length; j++)\n\t\t\t\t\t\t\t\ttmpFile.line[tmpFile.linelen++] = arg.chars[j];\n\t\t\t\t\t\t\tsubst++;\n\t\t\t\t\t\t\tnext = subst < m->substitution_count\n\t\t\t\t\t\t\t\t\t? m->substitutions[2 * subst]\n\t\t\t\t\t\t\t\t\t: m->definition_length;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (!compileRule(\n\t\t\t\t\t\t\t\t\t\t&tmpFile, table, displayTable, inScopeMacros)) {\n\t\t\t\t\t\t\t\t_lou_logMessage(LOU_LOG_ERROR,\n\t\t\t\t\t\t\t\t\t\t\"result of macro expansion was: %s\",\n\t\t\t\t\t\t\t\t\t\t_lou_showString(\n\t\t\t\t\t\t\t\t\t\t\t\ttmpFile.line, tmpFile.linelen, 0));\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tmacros = macros->tail;\n\t\t\t}\n\t\t}\n\t\tif (opcode == CTO_UpLow) {\n\t\t\tcompileError(file, \"The uplow opcode is deprecated.\");\n\t\t\treturn 0;\n\t\t}\n\t\tcompileError(file, \"opcode %s not defined.\",\n\t\t\t\t_lou_showString(token.chars, token.length, 0));\n\t\treturn 0;\n\t}\n\n\t/* now only opcodes follow that don't modify the display table */\n\tdefault:\n\t\tif (!table) return 1;\n\t\tswitch (opcode) {\n\t\tcase CTO_Locale:\n\t\t\tcompileWarning(file,\n\t\t\t\t\t\"The locale opcode is not implemented. Use the locale meta data \"\n\t\t\t\t\t\"instead.\");\n\t\t\treturn 1;\n\t\tcase CTO_Undefined: {\n\t\t\t// not passing pointer because compileBrailleIndicator may reallocate table\n\t\t\tTranslationTableOffset ruleOffset = (*table)->undefined;\n\t\t\tif (!compileBrailleIndicator(file, \"undefined character opcode\",\n\t\t\t\t\t\tCTO_Undefined, &ruleOffset, noback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\t(*table)->undefined = ruleOffset;\n\t\t\treturn 1;\n\t\t}\n\t\tcase CTO_Match: {\n\t\t\tint ok = 0;\n\t\t\twidechar *patterns = NULL;\n\t\t\tTranslationTableRule *rule;\n\t\t\tTranslationTableOffset ruleOffset;\n\t\t\tCharsString ptn_before, ptn_after;\n\t\t\tTranslationTableOffset patternsOffset;\n\t\t\tint len, mrk;\n\t\t\tsize_t patternsByteSize = sizeof(*patterns) * 27720;\n\t\t\tpatterns = (widechar *)malloc(patternsByteSize);\n\t\t\tif (!patterns) _lou_outOfMemory();\n\t\t\tmemset(patterns, 0xffff, patternsByteSize);\n\t\t\tnoback = 1;\n\t\t\tgetCharacters(file, &ptn_before);\n\t\t\tgetRuleCharsText(file, &ruleChars);\n\t\t\tgetCharacters(file, &ptn_after);\n\t\t\tgetRuleDotsPattern(file, &ruleDots);\n\t\t\tif (!addRule(file, opcode, &ruleChars, &ruleDots, after, before, &ruleOffset,\n\t\t\t\t\t\t&rule, noback, nofor, table))\n\t\t\t\tgoto CTO_Match_cleanup;\n\t\t\tif (ptn_before.chars[0] == '-' && ptn_before.length == 1)\n\t\t\t\tlen = _lou_pattern_compile(\n\t\t\t\t\t\t&ptn_before.chars[0], 0, &patterns[1], 13841, *table, file);\n\t\t\telse\n\t\t\t\tlen = _lou_pattern_compile(&ptn_before.chars[0], ptn_before.length,\n\t\t\t\t\t\t&patterns[1], 13841, *table, file);\n\t\t\tif (!len) goto CTO_Match_cleanup;\n\t\t\tmrk = patterns[0] = len + 1;\n\t\t\t_lou_pattern_reverse(&patterns[1]);\n\t\t\tif (ptn_after.chars[0] == '-' && ptn_after.length == 1)\n\t\t\t\tlen = _lou_pattern_compile(\n\t\t\t\t\t\t&ptn_after.chars[0], 0, &patterns[mrk], 13841, *table, file);\n\t\t\telse\n\t\t\t\tlen = _lou_pattern_compile(&ptn_after.chars[0], ptn_after.length,\n\t\t\t\t\t\t&patterns[mrk], 13841, *table, file);\n\t\t\tif (!len) goto CTO_Match_cleanup;\n\t\t\tlen += mrk;\n\t\t\tif (!allocateSpaceInTranslationTable(\n\t\t\t\t\t\tfile, &patternsOffset, len * sizeof(widechar), table))\n\t\t\t\tgoto CTO_Match_cleanup;\n\t\t\t// allocateSpaceInTranslationTable may have moved table, so make sure rule is\n\t\t\t// still valid\n\t\t\trule = (TranslationTableRule *)&(*table)->ruleArea[ruleOffset];\n\t\t\tmemcpy(&(*table)->ruleArea[patternsOffset], patterns, len * sizeof(widechar));\n\t\t\trule->patterns = patternsOffset;\n\t\t\tok = 1;\n\t\tCTO_Match_cleanup:\n\t\t\tfree(patterns);\n\t\t\treturn ok;\n\t\t}\n\n\t\tcase CTO_BackMatch: {\n\t\t\tint ok = 0;\n\t\t\twidechar *patterns = NULL;\n\t\t\tTranslationTableRule *rule;\n\t\t\tTranslationTableOffset ruleOffset;\n\t\t\tCharsString ptn_before, ptn_after;\n\t\t\tTranslationTableOffset patternOffset;\n\t\t\tint len, mrk;\n\t\t\tsize_t patternsByteSize = sizeof(*patterns) * 27720;\n\t\t\tpatterns = (widechar *)malloc(patternsByteSize);\n\t\t\tif (!patterns) _lou_outOfMemory();\n\t\t\tmemset(patterns, 0xffff, patternsByteSize);\n\t\t\tnofor = 1;\n\t\t\tgetCharacters(file, &ptn_before);\n\t\t\tgetRuleCharsText(file, &ruleChars);\n\t\t\tgetCharacters(file, &ptn_after);\n\t\t\tgetRuleDotsPattern(file, &ruleDots);\n\t\t\tif (!addRule(file, opcode, &ruleChars, &ruleDots, 0, 0, &ruleOffset, &rule,\n\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\tgoto CTO_BackMatch_cleanup;\n\t\t\tif (ptn_before.chars[0] == '-' && ptn_before.length == 1)\n\t\t\t\tlen = _lou_pattern_compile(\n\t\t\t\t\t\t&ptn_before.chars[0], 0, &patterns[1], 13841, *table, file);\n\t\t\telse\n\t\t\t\tlen = _lou_pattern_compile(&ptn_before.chars[0], ptn_before.length,\n\t\t\t\t\t\t&patterns[1], 13841, *table, file);\n\t\t\tif (!len) goto CTO_BackMatch_cleanup;\n\t\t\tmrk = patterns[0] = len + 1;\n\t\t\t_lou_pattern_reverse(&patterns[1]);\n\t\t\tif (ptn_after.chars[0] == '-' && ptn_after.length == 1)\n\t\t\t\tlen = _lou_pattern_compile(\n\t\t\t\t\t\t&ptn_after.chars[0], 0, &patterns[mrk], 13841, *table, file);\n\t\t\telse\n\t\t\t\tlen = _lou_pattern_compile(&ptn_after.chars[0], ptn_after.length,\n\t\t\t\t\t\t&patterns[mrk], 13841, *table, file);\n\t\t\tif (!len) goto CTO_BackMatch_cleanup;\n\t\t\tlen += mrk;\n\t\t\tif (!allocateSpaceInTranslationTable(\n\t\t\t\t\t\tfile, &patternOffset, len * sizeof(widechar), table))\n\t\t\t\tgoto CTO_BackMatch_cleanup;\n\t\t\t// allocateSpaceInTranslationTable may have moved table, so make sure rule is\n\t\t\t// still valid\n\t\t\trule = (TranslationTableRule *)&(*table)->ruleArea[ruleOffset];\n\t\t\tmemcpy(&(*table)->ruleArea[patternOffset], patterns, len * sizeof(widechar));\n\t\t\trule->patterns = patternOffset;\n\t\t\tok = 1;\n\t\tCTO_BackMatch_cleanup:\n\t\t\tfree(patterns);\n\t\t\treturn ok;\n\t\t}\n\n\t\tcase CTO_CapsLetter:\n\t\tcase CTO_BegCapsWord:\n\t\tcase CTO_EndCapsWord:\n\t\tcase CTO_BegCaps:\n\t\tcase CTO_EndCaps:\n\t\tcase CTO_BegCapsPhrase:\n\t\tcase CTO_EndCapsPhrase:\n\t\tcase CTO_LenCapsPhrase:\n\t\t/* these 8 general purpose opcodes are compiled further down to more specific\n\t\t * internal opcodes:\n\t\t * - modeletter\n\t\t * - begmodeword\n\t\t * - endmodeword\n\t\t * - begmode\n\t\t * - endmode\n\t\t * - begmodephrase\n\t\t * - endmodephrase\n\t\t * - lenmodephrase\n\t\t */\n\t\tcase CTO_ModeLetter:\n\t\tcase CTO_BegModeWord:\n\t\tcase CTO_EndModeWord:\n\t\tcase CTO_BegMode:\n\t\tcase CTO_EndMode:\n\t\tcase CTO_BegModePhrase:\n\t\tcase CTO_EndModePhrase:\n\t\tcase CTO_LenModePhrase: {\n\t\t\tTranslationTableCharacterAttributes mode;\n\t\t\tint i;\n\t\t\tswitch (opcode) {\n\t\t\tcase CTO_CapsLetter:\n\t\t\tcase CTO_BegCapsWord:\n\t\t\tcase CTO_EndCapsWord:\n\t\t\tcase CTO_BegCaps:\n\t\t\tcase CTO_EndCaps:\n\t\t\tcase CTO_BegCapsPhrase:\n\t\t\tcase CTO_EndCapsPhrase:\n\t\t\tcase CTO_LenCapsPhrase:\n\t\t\t\tmode = CTC_UpperCase;\n\t\t\t\ti = 0;\n\t\t\t\topcode += (CTO_ModeLetter - CTO_CapsLetter);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (!getToken(file, &token, \"attribute name\")) return 0;\n\t\t\t\tif (!(*table)->characterClasses && !allocateCharacterClasses(*table)) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tconst CharacterClass *characterClass = findCharacterClass(&token, *table);\n\t\t\t\tif (!characterClass) {\n\t\t\t\t\tcharacterClass =\n\t\t\t\t\t\t\taddCharacterClass(file, token.chars, token.length, *table, 1);\n\t\t\t\t\tif (!characterClass) return 0;\n\t\t\t\t}\n\t\t\t\tmode = characterClass->attribute;\n\t\t\t\tif (!(mode == CTC_UpperCase || mode == CTC_Digit) && mode >= CTC_Space &&\n\t\t\t\t\t\tmode <= CTC_LitDigit) {\n\t\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\t\"mode must be \\\"uppercase\\\", \\\"digit\\\", or a custom \"\n\t\t\t\t\t\t\t\"attribute name.\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t/* check if this mode is already defined and if the number of modes does\n\t\t\t\t * not exceed the maximal number */\n\t\t\t\tif (mode == CTC_UpperCase)\n\t\t\t\t\ti = 0;\n\t\t\t\telse {\n\t\t\t\t\tfor (i = 1; i < MAX_MODES && (*table)->modes[i].value; i++) {\n\t\t\t\t\t\tif ((*table)->modes[i].mode == mode) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (i == MAX_MODES) {\n\t\t\t\t\t\tcompileError(file, \"Max number of modes (%i) reached\", MAX_MODES);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!(*table)->modes[i].value)\n\t\t\t\t(*table)->modes[i] = (EmphasisClass){ plain_text, mode,\n\t\t\t\t\t0x1 << (MAX_EMPH_CLASSES + i), MAX_EMPH_CLASSES + i };\n\t\t\tswitch (opcode) {\n\t\t\tcase CTO_BegModePhrase: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][begPhraseOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"first word capital sign\",\n\t\t\t\t\t\t\tCTO_BegCapsPhraseRule + (8 * i), &ruleOffset, noback, nofor,\n\t\t\t\t\t\t\ttable))\n\t\t\t\t\treturn 0;\n\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][begPhraseOffset] = ruleOffset;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcase CTO_EndModePhrase: {\n\t\t\t\tTranslationTableOffset ruleOffset;\n\t\t\t\tswitch (compileBeforeAfter(file)) {\n\t\t\t\tcase 1:\t // before\n\t\t\t\t\tif ((*table)->emphRules[MAX_EMPH_CLASSES + i][endPhraseAfterOffset]) {\n\t\t\t\t\t\tcompileError(\n\t\t\t\t\t\t\t\tfile, \"Capital sign after last word already defined.\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t\t// table\n\t\t\t\t\truleOffset = (*table)->emphRules[MAX_EMPH_CLASSES + i]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[endPhraseBeforeOffset];\n\t\t\t\t\tif (!compileBrailleIndicator(file, \"capital sign before last word\",\n\t\t\t\t\t\t\t\tCTO_EndCapsPhraseBeforeRule + (8 * i), &ruleOffset,\n\t\t\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][endPhraseBeforeOffset] =\n\t\t\t\t\t\t\truleOffset;\n\t\t\t\t\treturn 1;\n\t\t\t\tcase 2:\t // after\n\t\t\t\t\tif ((*table)->emphRules[MAX_EMPH_CLASSES + i]\n\t\t\t\t\t\t\t\t\t\t   [endPhraseBeforeOffset]) {\n\t\t\t\t\t\tcompileError(\n\t\t\t\t\t\t\t\tfile, \"Capital sign before last word already defined.\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t\t// table\n\t\t\t\t\truleOffset = (*table)->emphRules[MAX_EMPH_CLASSES + i]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[endPhraseAfterOffset];\n\t\t\t\t\tif (!compileBrailleIndicator(file, \"capital sign after last word\",\n\t\t\t\t\t\t\t\tCTO_EndCapsPhraseAfterRule + (8 * i), &ruleOffset, noback,\n\t\t\t\t\t\t\t\tnofor, table))\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][endPhraseAfterOffset] =\n\t\t\t\t\t\t\truleOffset;\n\t\t\t\t\treturn 1;\n\t\t\t\tdefault:  // error\n\t\t\t\t\tcompileError(file, \"Invalid lastword indicator location.\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcase CTO_BegMode: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][begOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"first letter capital sign\",\n\t\t\t\t\t\t\tCTO_BegCapsRule + (8 * i), &ruleOffset, noback, nofor, table))\n\t\t\t\t\treturn 0;\n\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][begOffset] = ruleOffset;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcase CTO_EndMode: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][endOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"last letter capital sign\",\n\t\t\t\t\t\t\tCTO_EndCapsRule + (8 * i), &ruleOffset, noback, nofor, table))\n\t\t\t\t\treturn 0;\n\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][endOffset] = ruleOffset;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcase CTO_ModeLetter: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][letterOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"single letter capital sign\",\n\t\t\t\t\t\t\tCTO_CapsLetterRule + (8 * i), &ruleOffset, noback, nofor,\n\t\t\t\t\t\t\ttable))\n\t\t\t\t\treturn 0;\n\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][letterOffset] = ruleOffset;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcase CTO_BegModeWord: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][begWordOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"capital word\",\n\t\t\t\t\t\t\tCTO_BegCapsWordRule + (8 * i), &ruleOffset, noback, nofor,\n\t\t\t\t\t\t\ttable))\n\t\t\t\t\treturn 0;\n\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][begWordOffset] = ruleOffset;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcase CTO_EndModeWord: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][endWordOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"capital word stop\",\n\t\t\t\t\t\t\tCTO_EndCapsWordRule + (8 * i), &ruleOffset, noback, nofor,\n\t\t\t\t\t\t\ttable))\n\t\t\t\t\treturn 0;\n\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][endWordOffset] = ruleOffset;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcase CTO_LenModePhrase:\n\t\t\t\treturn (*table)->emphRules[MAX_EMPH_CLASSES + i][lenPhraseOffset] =\n\t\t\t\t\t\t\t   compileNumber(file);\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/* these 8 general purpose emphasis opcodes are compiled further down to more\n\t\t * specific internal opcodes:\n\t\t * - emphletter\n\t\t * - begemphword\n\t\t * - endemphword\n\t\t * - begemph\n\t\t * - endemph\n\t\t * - begemphphrase\n\t\t * - endemphphrase\n\t\t * - lenemphphrase\n\t\t */\n\t\tcase CTO_EmphClass:\n\t\t\tif (!getToken(file, &emphClass, \"emphasis class\")) {\n\t\t\t\tcompileError(file, \"emphclass must be followed by a valid class name.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tint k, i;\n\t\t\tchar *s = malloc(sizeof(char) * (emphClass.length + 1));\n\t\t\tfor (k = 0; k < emphClass.length; k++) s[k] = (char)emphClass.chars[k];\n\t\t\ts[k++] = '\\0';\n\t\t\tfor (i = 0; i < MAX_EMPH_CLASSES && (*table)->emphClassNames[i]; i++)\n\t\t\t\tif (strcmp(s, (*table)->emphClassNames[i]) == 0) {\n\t\t\t\t\t_lou_logMessage(LOU_LOG_WARN, \"Duplicate emphasis class: %s\", s);\n\t\t\t\t\twarningCount++;\n\t\t\t\t\tfree(s);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\tif (i == MAX_EMPH_CLASSES) {\n\t\t\t\t_lou_logMessage(LOU_LOG_ERROR,\n\t\t\t\t\t\t\"Max number of emphasis classes (%i) reached\", MAX_EMPH_CLASSES);\n\t\t\t\terrorCount++;\n\t\t\t\tfree(s);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tswitch (i) {\n\t\t\t/* For backwards compatibility (i.e. because programs will assume\n\t\t\t * the first 3 typeform bits are `italic', `underline' and `bold')\n\t\t\t * we require that the first 3 emphclass definitions are (in that\n\t\t\t * order):\n\t\t\t *\n\t\t\t *   emphclass italic\n\t\t\t *   emphclass underline\n\t\t\t *   emphclass bold\n\t\t\t *\n\t\t\t * While it would be possible to use the emphclass opcode only for\n\t\t\t * defining _additional_ classes (not allowing for them to be called\n\t\t\t * italic, underline or bold), thereby reducing the amount of\n\t\t\t * boilerplate, we deliberately choose not to do that in order to\n\t\t\t * not give italic, underline and bold any special status. The\n\t\t\t * hope is that eventually all programs will use liblouis for\n\t\t\t * emphasis the recommended way (i.e. by looking up the supported\n\t\t\t * typeforms in the documentation or API) so that we can drop this\n\t\t\t * restriction.\n\t\t\t */\n\t\t\tcase 0:\n\t\t\t\tif (strcmp(s, \"italic\") != 0) {\n\t\t\t\t\t_lou_logMessage(LOU_LOG_ERROR,\n\t\t\t\t\t\t\t\"First emphasis class must be \\\"italic\\\" but got \"\n\t\t\t\t\t\t\t\"%s\",\n\t\t\t\t\t\t\ts);\n\t\t\t\t\terrorCount++;\n\t\t\t\t\tfree(s);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tif (strcmp(s, \"underline\") != 0) {\n\t\t\t\t\t_lou_logMessage(LOU_LOG_ERROR,\n\t\t\t\t\t\t\t\"Second emphasis class must be \\\"underline\\\" but \"\n\t\t\t\t\t\t\t\"got \"\n\t\t\t\t\t\t\t\"%s\",\n\t\t\t\t\t\t\ts);\n\t\t\t\t\terrorCount++;\n\t\t\t\t\tfree(s);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tif (strcmp(s, \"bold\") != 0) {\n\t\t\t\t\t_lou_logMessage(LOU_LOG_ERROR,\n\t\t\t\t\t\t\t\"Third emphasis class must be \\\"bold\\\" but got \"\n\t\t\t\t\t\t\t\"%s\",\n\t\t\t\t\t\t\ts);\n\t\t\t\t\terrorCount++;\n\t\t\t\t\tfree(s);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t(*table)->emphClassNames[i] = s;\n\t\t\t(*table)->emphClasses[i] = (EmphasisClass){ emph_1\n\t\t\t\t\t\t<< i, /* relies on the order of typeforms emph_1..emph_10 */\n\t\t\t\t0, 0x1 << i, i };\n\t\t\treturn 1;\n\t\tcase CTO_EmphLetter:\n\t\tcase CTO_BegEmphWord:\n\t\tcase CTO_EndEmphWord:\n\t\tcase CTO_BegEmph:\n\t\tcase CTO_EndEmph:\n\t\tcase CTO_BegEmphPhrase:\n\t\tcase CTO_EndEmphPhrase:\n\t\tcase CTO_LenEmphPhrase:\n\t\tcase CTO_EmphModeChars:\n\t\tcase CTO_NoEmphChars: {\n\t\t\tif (!getToken(file, &token, \"emphasis class\")) return 0;\n\t\t\tif (!parseChars(file, &emphClass, &token)) return 0;\n\t\t\tchar *s = malloc(sizeof(char) * (emphClass.length + 1));\n\t\t\tint k, i;\n\t\t\tfor (k = 0; k < emphClass.length; k++) s[k] = (char)emphClass.chars[k];\n\t\t\ts[k++] = '\\0';\n\t\t\tfor (i = 0; i < MAX_EMPH_CLASSES && (*table)->emphClassNames[i]; i++)\n\t\t\t\tif (strcmp(s, (*table)->emphClassNames[i]) == 0) break;\n\t\t\tif (i == MAX_EMPH_CLASSES || !(*table)->emphClassNames[i]) {\n\t\t\t\t_lou_logMessage(LOU_LOG_ERROR, \"Emphasis class %s not declared\", s);\n\t\t\t\terrorCount++;\n\t\t\t\tfree(s);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tint ok = 0;\n\t\t\tswitch (opcode) {\n\t\t\tcase CTO_EmphLetter: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset = (*table)->emphRules[i][letterOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"single letter\",\n\t\t\t\t\t\t\tCTO_Emph1LetterRule + letterOffset + (8 * i), &ruleOffset,\n\t\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\t\tbreak;\n\t\t\t\t(*table)->emphRules[i][letterOffset] = ruleOffset;\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CTO_BegEmphWord: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset = (*table)->emphRules[i][begWordOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"word\",\n\t\t\t\t\t\t\tCTO_Emph1LetterRule + begWordOffset + (8 * i), &ruleOffset,\n\t\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\t\tbreak;\n\t\t\t\t(*table)->emphRules[i][begWordOffset] = ruleOffset;\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CTO_EndEmphWord: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset = (*table)->emphRules[i][endWordOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"word stop\",\n\t\t\t\t\t\t\tCTO_Emph1LetterRule + endWordOffset + (8 * i), &ruleOffset,\n\t\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\t\tbreak;\n\t\t\t\t(*table)->emphRules[i][endWordOffset] = ruleOffset;\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CTO_BegEmph: {\n\t\t\t\t/* fail if both begemph and any of begemphphrase or begemphword are\n\t\t\t\t * defined */\n\t\t\t\tif ((*table)->emphRules[i][begWordOffset] ||\n\t\t\t\t\t\t(*table)->emphRules[i][begPhraseOffset]) {\n\t\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\t\"Cannot define emphasis for both no context and word or \"\n\t\t\t\t\t\t\t\"phrase context, i.e. cannot have both begemph and \"\n\t\t\t\t\t\t\t\"begemphword or begemphphrase.\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset = (*table)->emphRules[i][begOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"first letter\",\n\t\t\t\t\t\t\tCTO_Emph1LetterRule + begOffset + (8 * i), &ruleOffset,\n\t\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\t\tbreak;\n\t\t\t\t(*table)->emphRules[i][begOffset] = ruleOffset;\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CTO_EndEmph: {\n\t\t\t\tif ((*table)->emphRules[i][endWordOffset] ||\n\t\t\t\t\t\t(*table)->emphRules[i][endPhraseBeforeOffset] ||\n\t\t\t\t\t\t(*table)->emphRules[i][endPhraseAfterOffset]) {\n\t\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\t\"Cannot define emphasis for both no context and word or \"\n\t\t\t\t\t\t\t\"phrase context, i.e. cannot have both endemph and \"\n\t\t\t\t\t\t\t\"endemphword or endemphphrase.\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset = (*table)->emphRules[i][endOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"last letter\",\n\t\t\t\t\t\t\tCTO_Emph1LetterRule + endOffset + (8 * i), &ruleOffset,\n\t\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\t\tbreak;\n\t\t\t\t(*table)->emphRules[i][endOffset] = ruleOffset;\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CTO_BegEmphPhrase: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t(*table)->emphRules[i][begPhraseOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"first word\",\n\t\t\t\t\t\t\tCTO_Emph1LetterRule + begPhraseOffset + (8 * i), &ruleOffset,\n\t\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\t\tbreak;\n\t\t\t\t(*table)->emphRules[i][begPhraseOffset] = ruleOffset;\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CTO_EndEmphPhrase:\n\t\t\t\tswitch (compileBeforeAfter(file)) {\n\t\t\t\tcase 1: {  // before\n\t\t\t\t\tif ((*table)->emphRules[i][endPhraseAfterOffset]) {\n\t\t\t\t\t\tcompileError(file, \"last word after already defined.\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t\t// table\n\t\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t\t(*table)->emphRules[i][endPhraseBeforeOffset];\n\t\t\t\t\tif (!compileBrailleIndicator(file, \"last word before\",\n\t\t\t\t\t\t\t\tCTO_Emph1LetterRule + endPhraseBeforeOffset + (8 * i),\n\t\t\t\t\t\t\t\t&ruleOffset, noback, nofor, table))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t(*table)->emphRules[i][endPhraseBeforeOffset] = ruleOffset;\n\t\t\t\t\tok = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 2: {  // after\n\t\t\t\t\tif ((*table)->emphRules[i][endPhraseBeforeOffset]) {\n\t\t\t\t\t\tcompileError(file, \"last word before already defined.\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t\t// table\n\t\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t\t(*table)->emphRules[i][endPhraseAfterOffset];\n\t\t\t\t\tif (!compileBrailleIndicator(file, \"last word after\",\n\t\t\t\t\t\t\t\tCTO_Emph1LetterRule + endPhraseAfterOffset + (8 * i),\n\t\t\t\t\t\t\t\t&ruleOffset, noback, nofor, table))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t(*table)->emphRules[i][endPhraseAfterOffset] = ruleOffset;\n\t\t\t\t\tok = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdefault:  // error\n\t\t\t\t\tcompileError(file, \"Invalid lastword indicator location.\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CTO_LenEmphPhrase:\n\t\t\t\tif (((*table)->emphRules[i][lenPhraseOffset] = compileNumber(file)))\n\t\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\tcase CTO_EmphModeChars: {\n\t\t\t\tif (!getRuleCharsText(file, &ruleChars)) break;\n\t\t\t\twidechar *emphmodechars = (*table)->emphModeChars[i];\n\t\t\t\tint len;\n\t\t\t\tfor (len = 0; len < EMPHMODECHARSSIZE && emphmodechars[len]; len++)\n\t\t\t\t\t;\n\t\t\t\tif (len + ruleChars.length > EMPHMODECHARSSIZE) {\n\t\t\t\t\tcompileError(file, \"More than %d characters\", EMPHMODECHARSSIZE);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tok = 1;\n\t\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\t\tif (!getChar(ruleChars.chars[k], *table, NULL)) {\n\t\t\t\t\t\tcompileError(file, \"Emphasis mode character undefined\");\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\temphmodechars[len++] = ruleChars.chars[k];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CTO_NoEmphChars: {\n\t\t\t\tif (!getRuleCharsText(file, &ruleChars)) break;\n\t\t\t\twidechar *noemphchars = (*table)->noEmphChars[i];\n\t\t\t\tint len;\n\t\t\t\tfor (len = 0; len < NOEMPHCHARSSIZE && noemphchars[len]; len++)\n\t\t\t\t\t;\n\t\t\t\tif (len + ruleChars.length > NOEMPHCHARSSIZE) {\n\t\t\t\t\tcompileError(file, \"More than %d characters\", NOEMPHCHARSSIZE);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tok = 1;\n\t\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\t\tif (!getChar(ruleChars.chars[k], *table, NULL)) {\n\t\t\t\t\t\tcompileError(file, \"Character undefined\");\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tnoemphchars[len++] = ruleChars.chars[k];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfree(s);\n\t\t\treturn ok;\n\t\t}\n\t\tcase CTO_LetterSign: {\n\t\t\t// not passing pointer because compileBrailleIndicator may reallocate table\n\t\t\tTranslationTableOffset ruleOffset = (*table)->letterSign;\n\t\t\tif (!compileBrailleIndicator(file, \"letter sign\", CTO_LetterRule, &ruleOffset,\n\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\t(*table)->letterSign = ruleOffset;\n\t\t\treturn 1;\n\t\t}\n\t\tcase CTO_NoLetsignBefore:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (((*table)->noLetsignBeforeCount + ruleChars.length) > LETSIGNBEFORESIZE) {\n\t\t\t\tcompileError(file, \"More than %d characters\", LETSIGNBEFORESIZE);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor (int k = 0; k < ruleChars.length; k++)\n\t\t\t\t(*table)->noLetsignBefore[(*table)->noLetsignBeforeCount++] =\n\t\t\t\t\t\truleChars.chars[k];\n\t\t\treturn 1;\n\t\tcase CTO_NoLetsign:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (((*table)->noLetsignCount + ruleChars.length) > LETSIGNSIZE) {\n\t\t\t\tcompileError(file, \"More than %d characters\", LETSIGNSIZE);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor (int k = 0; k < ruleChars.length; k++)\n\t\t\t\t(*table)->noLetsign[(*table)->noLetsignCount++] = ruleChars.chars[k];\n\t\t\treturn 1;\n\t\tcase CTO_NoLetsignAfter:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (((*table)->noLetsignAfterCount + ruleChars.length) > LETSIGNAFTERSIZE) {\n\t\t\t\tcompileError(file, \"More than %d characters\", LETSIGNAFTERSIZE);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor (int k = 0; k < ruleChars.length; k++)\n\t\t\t\t(*table)->noLetsignAfter[(*table)->noLetsignAfterCount++] =\n\t\t\t\t\t\truleChars.chars[k];\n\t\t\treturn 1;\n\t\tcase CTO_NumberSign: {\n\t\t\t// not passing pointer because compileBrailleIndicator may reallocate table\n\t\t\tTranslationTableOffset ruleOffset = (*table)->numberSign;\n\t\t\tif (!compileBrailleIndicator(file, \"number sign\", CTO_NumberRule, &ruleOffset,\n\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\t(*table)->numberSign = ruleOffset;\n\t\t\treturn 1;\n\t\t}\n\n\t\tcase CTO_NumericModeChars:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!c) {\n\t\t\t\t\tcompileError(file, \"Numeric mode character undefined: %s\",\n\t\t\t\t\t\t\t_lou_showString(&ruleChars.chars[k], 1, 0));\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc->attributes |= CTC_NumericMode;\n\t\t\t\t(*table)->usesNumericMode = 1;\n\t\t\t}\n\t\t\treturn 1;\n\n\t\tcase CTO_MidEndNumericModeChars:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!c) {\n\t\t\t\t\tcompileError(file, \"Midendnumeric mode character undefined\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc->attributes |= CTC_MidEndNumericMode;\n\t\t\t\t(*table)->usesNumericMode = 1;\n\t\t\t}\n\t\t\treturn 1;\n\n\t\tcase CTO_NumericNoContractChars:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!c) {\n\t\t\t\t\tcompileError(file, \"Numeric no contraction character undefined\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc->attributes |= CTC_NumericNoContract;\n\t\t\t\t(*table)->usesNumericMode = 1;\n\t\t\t}\n\t\t\treturn 1;\n\n\t\tcase CTO_NoContractSign: {\n\t\t\t// not passing pointer because compileBrailleIndicator may reallocate table\n\t\t\tTranslationTableOffset ruleOffset = (*table)->noContractSign;\n\t\t\tif (!compileBrailleIndicator(file, \"no contractions sign\", CTO_NoContractRule,\n\t\t\t\t\t\t&ruleOffset, noback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\t(*table)->noContractSign = ruleOffset;\n\t\t\treturn 1;\n\t\t}\n\t\tcase CTO_SeqDelimiter:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!c) {\n\t\t\t\t\tcompileError(file, \"Sequence delimiter character undefined\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc->attributes |= CTC_SeqDelimiter;\n\t\t\t\t(*table)->usesSequences = 1;\n\t\t\t}\n\t\t\treturn 1;\n\n\t\tcase CTO_SeqBeforeChars:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!c) {\n\t\t\t\t\tcompileError(file, \"Sequence before character undefined\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc->attributes |= CTC_SeqBefore;\n\t\t\t}\n\t\t\treturn 1;\n\n\t\tcase CTO_SeqAfterChars:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!c) {\n\t\t\t\t\tcompileError(file, \"Sequence after character undefined\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc->attributes |= CTC_SeqAfter;\n\t\t\t}\n\t\t\treturn 1;\n\n\t\tcase CTO_SeqAfterPattern:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (((*table)->seqPatternsCount + ruleChars.length + 1) > SEQPATTERNSIZE) {\n\t\t\t\tcompileError(file, \"More than %d characters\", SEQPATTERNSIZE);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor (int k = 0; k < ruleChars.length; k++)\n\t\t\t\t(*table)->seqPatterns[(*table)->seqPatternsCount++] = ruleChars.chars[k];\n\t\t\t(*table)->seqPatterns[(*table)->seqPatternsCount++] = 0;\n\t\t\treturn 1;\n\n\t\tcase CTO_SeqAfterExpression:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif ((ruleChars.length + 1) > SEQPATTERNSIZE) {\n\t\t\t\tcompileError(file, \"More than %d characters\", SEQPATTERNSIZE);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor (int k = 0; k < ruleChars.length; k++)\n\t\t\t\t(*table)->seqAfterExpression[k] = ruleChars.chars[k];\n\t\t\t(*table)->seqAfterExpression[ruleChars.length] = 0;\n\t\t\t(*table)->seqAfterExpressionLength = ruleChars.length;\n\t\t\treturn 1;\n\n\t\tcase CTO_CapsModeChars:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!c) {\n\t\t\t\t\tcompileError(file, \"Capital mode character undefined\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc->attributes |= CTC_CapsMode;\n\t\t\t\t(*table)->hasCapsModeChars = 1;\n\t\t\t}\n\t\t\treturn 1;\n\n\t\tcase CTO_BegComp: {\n\t\t\t// not passing pointer because compileBrailleIndicator may reallocate table\n\t\t\tTranslationTableOffset ruleOffset = (*table)->begComp;\n\t\t\tif (!compileBrailleIndicator(file, \"begin computer braille\", CTO_BegCompRule,\n\t\t\t\t\t\t&ruleOffset, noback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\t(*table)->begComp = ruleOffset;\n\t\t\treturn 1;\n\t\t}\n\t\tcase CTO_EndComp: {\n\t\t\t// not passing pointer because compileBrailleIndicator may reallocate table\n\t\t\tTranslationTableOffset ruleOffset = (*table)->endComp;\n\t\t\tif (!compileBrailleIndicator(file, \"end computer braslle\", CTO_EndCompRule,\n\t\t\t\t\t\t&ruleOffset, noback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\t(*table)->endComp = ruleOffset;\n\t\t\treturn 1;\n\t\t}\n\t\tcase CTO_NoCross:\n\t\t\tif (nocross) {\n\t\t\t\tcompileError(\n\t\t\t\t\t\tfile, \"%s already specified.\", _lou_findOpcodeName(CTO_NoCross));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tnocross = 1;\n\t\t\tgoto doOpcode;\n\t\tcase CTO_Syllable:\n\t\t\t(*table)->syllables = 1;\n\t\tcase CTO_Always:\n\t\tcase CTO_LargeSign:\n\t\tcase CTO_WholeWord:\n\t\tcase CTO_PartWord:\n\t\tcase CTO_JoinNum:\n\t\tcase CTO_JoinableWord:\n\t\tcase CTO_LowWord:\n\t\tcase CTO_SuffixableWord:\n\t\tcase CTO_PrefixableWord:\n\t\tcase CTO_BegWord:\n\t\tcase CTO_BegMidWord:\n\t\tcase CTO_MidWord:\n\t\tcase CTO_MidEndWord:\n\t\tcase CTO_EndWord:\n\t\tcase CTO_PrePunc:\n\t\tcase CTO_PostPunc:\n\t\tcase CTO_BegNum:\n\t\tcase CTO_MidNum:\n\t\tcase CTO_EndNum:\n\t\tcase CTO_Repeated:\n\t\tcase CTO_RepWord:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (!getRuleDotsPattern(file, &ruleDots)) return 0;\n\t\t\tif (ruleDots.length == 0)\n\t\t\t\t// check that all characters in a rule with `=` as second operand are\n\t\t\t\t// defined (or based on another character)\n\t\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\t\tTranslationTableCharacter *c =\n\t\t\t\t\t\t\tgetChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\t\tif (!(c && (c->definitionRule || c->basechar))) {\n\t\t\t\t\t\tcompileError(file, \"Character %s is not defined\",\n\t\t\t\t\t\t\t\t_lou_showString(&ruleChars.chars[k], 1, 0));\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tTranslationTableRule *r;\n\t\t\tif (!addRule(file, opcode, &ruleChars, &ruleDots, after, before, NULL, &r,\n\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\tif (nocross) r->nocross = 1;\n\t\t\treturn 1;\n\t\t\t// if (opcode == CTO_MidNum)\n\t\t\t// {\n\t\t\t//   TranslationTableCharacter *c = getChar(ruleChars.chars[0]);\n\t\t\t//   if(c)\n\t\t\t//     c->attributes |= CTC_NumericMode;\n\t\t\t// }\n\t\tcase CTO_RepEndWord:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tCharsString dots;\n\t\t\tif (!getToken(file, &dots, \"dots,dots operand\")) return 0;\n\t\t\tint len = dots.length;\n\t\t\tfor (int k = 0; k < len - 1; k++) {\n\t\t\t\tif (dots.chars[k] == ',') {\n\t\t\t\t\tdots.length = k;\n\t\t\t\t\tif (!parseDots(file, &ruleDots, &dots)) return 0;\n\t\t\t\t\truleDots.chars[ruleDots.length++] = ',';\n\t\t\t\t\tk++;\n\t\t\t\t\tif (k == len - 1 && dots.chars[k] == '=') {\n\t\t\t\t\t\t// check that all characters are defined (or based on another\n\t\t\t\t\t\t// character)\n\t\t\t\t\t\tfor (int l = 0; l < ruleChars.length; l++) {\n\t\t\t\t\t\t\tTranslationTableCharacter *c =\n\t\t\t\t\t\t\t\t\tgetChar(ruleChars.chars[l], *table, NULL);\n\t\t\t\t\t\t\tif (!(c && (c->definitionRule || c->basechar))) {\n\t\t\t\t\t\t\t\tcompileError(file, \"Character %s is not defined\",\n\t\t\t\t\t\t\t\t\t\t_lou_showString(&ruleChars.chars[l], 1, 0));\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tCharsString x, y;\n\t\t\t\t\t\tx.length = 0;\n\t\t\t\t\t\twhile (k < len) x.chars[x.length++] = dots.chars[k++];\n\t\t\t\t\t\tif (parseDots(file, &y, &x))\n\t\t\t\t\t\t\tfor (int l = 0; l < y.length; l++)\n\t\t\t\t\t\t\t\truleDots.chars[ruleDots.length++] = y.chars[l];\n\t\t\t\t\t}\n\t\t\t\t\treturn addRule(file, opcode, &ruleChars, &ruleDots, after, before,\n\t\t\t\t\t\t\tNULL, NULL, noback, nofor, table);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\tcase CTO_CompDots:\n\t\tcase CTO_Comp6: {\n\t\t\tTranslationTableOffset ruleOffset;\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (ruleChars.length != 1) {\n\t\t\t\tcompileError(file, \"first operand must be 1 character\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (nofor || noback) {\n\t\t\t\tcompileWarning(file, \"nofor and noback not allowed on comp6 rules\");\n\t\t\t}\n\t\t\tif (!getRuleDotsPattern(file, &ruleDots)) return 0;\n\t\t\tif (!addRule(file, opcode, &ruleChars, &ruleDots, after, before, &ruleOffset,\n\t\t\t\t\t\tNULL, noback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\treturn 1;\n\t\t}\n\t\tcase CTO_ExactDots:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (ruleChars.chars[0] != '@') {\n\t\t\t\tcompileError(file, \"The operand must begin with an at sign (@)\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor (int k = 1; k < ruleChars.length; k++)\n\t\t\t\tscratchPad.chars[k - 1] = ruleChars.chars[k];\n\t\t\tscratchPad.length = ruleChars.length - 1;\n\t\t\tif (!parseDots(file, &ruleDots, &scratchPad)) return 0;\n\t\t\treturn addRule(file, opcode, &ruleChars, &ruleDots, before, after, NULL, NULL,\n\t\t\t\t\tnoback, nofor, table);\n\t\tcase CTO_CapsNoCont: {\n\t\t\tTranslationTableOffset ruleOffset;\n\t\t\truleChars.length = 1;\n\t\t\truleChars.chars[0] = 'a';\n\t\t\tif (!addRule(file, CTO_CapsNoContRule, &ruleChars, NULL, after, before,\n\t\t\t\t\t\t&ruleOffset, NULL, noback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\t(*table)->capsNoCont = ruleOffset;\n\t\t\treturn 1;\n\t\t}\n\t\tcase CTO_Replace:\n\t\t\tif (getRuleCharsText(file, &ruleChars)) {\n\t\t\t\tif (atEndOfLine(file))\n\t\t\t\t\truleDots.length = ruleDots.chars[0] = 0;\n\t\t\t\telse {\n\t\t\t\t\tgetRuleDotsText(file, &ruleDots);\n\t\t\t\t\tif (ruleDots.chars[0] == '#')\n\t\t\t\t\t\truleDots.length = ruleDots.chars[0] = 0;\n\t\t\t\t\telse if (ruleDots.chars[0] == '\\\\' && ruleDots.chars[1] == '#')\n\t\t\t\t\t\tmemmove(&ruleDots.chars[0], &ruleDots.chars[1],\n\t\t\t\t\t\t\t\truleDots.length-- * CHARSIZE);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int k = 0; k < ruleChars.length; k++)\n\t\t\t\tputChar(file, ruleChars.chars[k], table, NULL);\n\t\t\tfor (int k = 0; k < ruleDots.length; k++)\n\t\t\t\tputChar(file, ruleDots.chars[k], table, NULL);\n\t\t\treturn addRule(file, opcode, &ruleChars, &ruleDots, after, before, NULL, NULL,\n\t\t\t\t\tnoback, nofor, table);\n\t\tcase CTO_Correct:\n\t\t\t(*table)->corrections = 1;\n\t\t\tgoto doPass;\n\t\tcase CTO_Pass2:\n\t\t\tif ((*table)->numPasses < 2) (*table)->numPasses = 2;\n\t\t\tgoto doPass;\n\t\tcase CTO_Pass3:\n\t\t\tif ((*table)->numPasses < 3) (*table)->numPasses = 3;\n\t\t\tgoto doPass;\n\t\tcase CTO_Pass4:\n\t\t\tif ((*table)->numPasses < 4) (*table)->numPasses = 4;\n\t\tdoPass:\n\t\tcase CTO_Context:\n\t\t\tif (!(nofor || noback)) {\n\t\t\t\tcompileError(file, \"%s or %s must be specified.\",\n\t\t\t\t\t\t_lou_findOpcodeName(CTO_NoFor), _lou_findOpcodeName(CTO_NoBack));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn compilePassOpcode(file, opcode, noback, nofor, table);\n\t\tcase CTO_Contraction:\n\t\tcase CTO_NoCont:\n\t\tcase CTO_CompBrl:\n\t\tcase CTO_Literal:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\t// check that all characters in a compbrl, contraction,\n\t\t\t// nocont or literal rule are defined (or based on another\n\t\t\t// character)\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!(c && (c->definitionRule || c->basechar))) {\n\t\t\t\t\tcompileError(file, \"Character %s is not defined\",\n\t\t\t\t\t\t\t_lou_showString(&ruleChars.chars[k], 1, 0));\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn addRule(file, opcode, &ruleChars, NULL, after, before, NULL, NULL,\n\t\t\t\t\tnoback, nofor, table);\n\t\tcase CTO_MultInd: {\n\t\t\truleChars.length = 0;\n\t\t\tif (!getToken(file, &token, \"multiple braille indicators\") ||\n\t\t\t\t\t!parseDots(file, &cells, &token))\n\t\t\t\treturn 0;\n\t\t\twhile (getToken(file, &token, \"multind opcodes\")) {\n\t\t\t\topcode = getOpcode(file, &token);\n\t\t\t\tif (opcode == CTO_None) {\n\t\t\t\t\tcompileError(file, \"opcode %s not defined.\",\n\t\t\t\t\t\t\t_lou_showString(token.chars, token.length, 0));\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif (!(opcode >= CTO_CapsLetter && opcode < CTO_MultInd)) {\n\t\t\t\t\tcompileError(file, \"Not a braille indicator opcode.\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\truleChars.chars[ruleChars.length++] = (widechar)opcode;\n\t\t\t\tif (atEndOfLine(file)) break;\n\t\t\t}\n\t\t\treturn addRule(file, CTO_MultInd, &ruleChars, &cells, after, before, NULL,\n\t\t\t\t\tNULL, noback, nofor, table);\n\t\t}\n\n\t\tcase CTO_Class:\n\t\t\tcompileWarning(file, \"class is deprecated, use attribute instead\");\n\t\tcase CTO_Attribute: {\n\t\t\tif (nofor || noback) {\n\t\t\t\tcompileWarning(\n\t\t\t\t\t\tfile, \"nofor and noback not allowed before class/attribute\");\n\t\t\t}\n\t\t\tif ((opcode == CTO_Class && (*table)->usesAttributeOrClass == 1) ||\n\t\t\t\t\t(opcode == CTO_Attribute && (*table)->usesAttributeOrClass == 2)) {\n\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\"attribute and class rules must not be both present in a table\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (opcode == CTO_Class)\n\t\t\t\t(*table)->usesAttributeOrClass = 2;\n\t\t\telse\n\t\t\t\t(*table)->usesAttributeOrClass = 1;\n\t\t\tif (!getToken(file, &token, \"attribute name\")) {\n\t\t\t\tcompileError(file, \"Expected %s\", \"attribute name\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!(*table)->characterClasses && !allocateCharacterClasses(*table)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tTranslationTableCharacterAttributes attribute = 0;\n\t\t\t{\n\t\t\t\tint attrNumber = -1;\n\t\t\t\tswitch (token.chars[0]) {\n\t\t\t\tcase '0':\n\t\t\t\tcase '1':\n\t\t\t\tcase '2':\n\t\t\t\tcase '3':\n\t\t\t\tcase '4':\n\t\t\t\tcase '5':\n\t\t\t\tcase '6':\n\t\t\t\tcase '7':\n\t\t\t\tcase '8':\n\t\t\t\tcase '9':\n\t\t\t\t\tattrNumber = token.chars[0] - '0';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (attrNumber >= 0) {\n\t\t\t\t\tif (opcode == CTO_Class) {\n\t\t\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\t\t\"Invalid class name: may not contain digits, use \"\n\t\t\t\t\t\t\t\t\"attribute instead of class\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (token.length > 1 || attrNumber > 7) {\n\t\t\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\t\t\"Invalid attribute name: must be a digit between 0 and 7 \"\n\t\t\t\t\t\t\t\t\"or a word containing only letters\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (!(*table)->numberedAttributes[attrNumber])\n\t\t\t\t\t\t// attribute not used before yet: assign it a value\n\t\t\t\t\t\t(*table)->numberedAttributes[attrNumber] =\n\t\t\t\t\t\t\t\tgetNextNumberedAttribute(*table);\n\t\t\t\t\tattribute = (*table)->numberedAttributes[attrNumber];\n\t\t\t\t} else {\n\t\t\t\t\tconst CharacterClass *namedAttr = findCharacterClass(&token, *table);\n\t\t\t\t\tif (!namedAttr) {\n\t\t\t\t\t\t// no class with that name: create one\n\t\t\t\t\t\tnamedAttr = addCharacterClass(\n\t\t\t\t\t\t\t\tfile, &token.chars[0], token.length, *table, 1);\n\t\t\t\t\t\tif (!namedAttr) return 0;\n\t\t\t\t\t}\n\t\t\t\t\t// there is a class with that name or a new class was successfully\n\t\t\t\t\t// created\n\t\t\t\t\tattribute = namedAttr->attribute;\n\t\t\t\t\tif (attribute == CTC_UpperCase || attribute == CTC_LowerCase)\n\t\t\t\t\t\tattribute |= CTC_Letter;\n\t\t\t\t}\n\t\t\t}\n\t\t\tCharsString characters;\n\t\t\tif (!getCharacters(file, &characters)) return 0;\n\t\t\tfor (int i = 0; i < characters.length; i++) {\n\t\t\t\t// get the character from the table, or if it is not defined yet,\n\t\t\t\t// define it\n\t\t\t\tTranslationTableCharacter *character =\n\t\t\t\t\t\tputChar(file, characters.chars[i], table, NULL);\n\t\t\t\t// set the attribute\n\t\t\t\tcharacter->attributes |= attribute;\n\t\t\t\t// also set the attribute on the associated dots (if any)\n\t\t\t\tif (character->basechar)\n\t\t\t\t\tcharacter = (TranslationTableCharacter *)&(*table)\n\t\t\t\t\t\t\t\t\t\t->ruleArea[character->basechar];\n\t\t\t\tif (character->definitionRule) {\n\t\t\t\t\tTranslationTableRule *defRule =\n\t\t\t\t\t\t\t(TranslationTableRule *)&(*table)\n\t\t\t\t\t\t\t\t\t->ruleArea[character->definitionRule];\n\t\t\t\t\tif (defRule->dotslen == 1) {\n\t\t\t\t\t\tTranslationTableCharacter *dots =\n\t\t\t\t\t\t\t\tgetDots(defRule->charsdots[defRule->charslen], *table);\n\t\t\t\t\t\tif (dots) dots->attributes |= attribute;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\n\t\t\t{\n\t\t\t\tTranslationTableCharacterAttributes *attributes;\n\t\t\t\tconst CharacterClass *class;\n\t\t\tcase CTO_After:\n\t\t\t\tattributes = &after;\n\t\t\t\tgoto doBeforeAfter;\n\t\t\tcase CTO_Before:\n\t\t\t\tattributes = &before;\n\t\t\tdoBeforeAfter:\n\t\t\t\tif (!(*table)->characterClasses) {\n\t\t\t\t\tif (!allocateCharacterClasses(*table)) return 0;\n\t\t\t\t}\n\t\t\t\tif (!getToken(file, &token, \"attribute name\")) return 0;\n\t\t\t\tif (!(class = findCharacterClass(&token, *table))) {\n\t\t\t\t\tcompileError(file, \"attribute not defined\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t*attributes |= class->attribute;\n\t\t\t\tgoto doOpcode;\n\t\t\t}\n\t\tcase CTO_Base:\n\t\t\tif (nofor || noback) {\n\t\t\t\tcompileWarning(file, \"nofor and noback not allowed before base\");\n\t\t\t}\n\t\t\tif (!getToken(file, &token, \"attribute name\")) {\n\t\t\t\tcompileError(\n\t\t\t\t\t\tfile, \"base opcode must be followed by a valid attribute name.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!(*table)->characterClasses && !allocateCharacterClasses(*table)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tconst CharacterClass *mode = findCharacterClass(&token, *table);\n\t\t\tif (!mode) {\n\t\t\t\tmode = addCharacterClass(file, token.chars, token.length, *table, 1);\n\t\t\t\tif (!mode) return 0;\n\t\t\t}\n\t\t\tif (!(mode->attribute == CTC_UpperCase || mode->attribute == CTC_Digit) &&\n\t\t\t\t\tmode->attribute >= CTC_Space && mode->attribute <= CTC_LitDigit) {\n\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\"base opcode must be followed by \\\"uppercase\\\", \\\"digit\\\", or a \"\n\t\t\t\t\t\t\"custom attribute name.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!getRuleCharsText(file, &token)) return 0;\n\t\t\tif (token.length != 1) {\n\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\"Exactly one character followed by one base character is \"\n\t\t\t\t\t\t\"required.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tTranslationTableOffset characterOffset;\n\t\t\tTranslationTableCharacter *character =\n\t\t\t\t\tputChar(file, token.chars[0], table, &characterOffset);\n\t\t\tif (!getRuleCharsText(file, &token)) return 0;\n\t\t\tif (token.length != 1) {\n\t\t\t\tcompileError(file, \"Exactly one base character is required.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (character->definitionRule) {\n\t\t\t\tTranslationTableRule *prevRule =\n\t\t\t\t\t\t(TranslationTableRule *)&(*table)\n\t\t\t\t\t\t\t\t->ruleArea[character->definitionRule];\n\t\t\t\t_lou_logMessage(LOU_LOG_DEBUG,\n\t\t\t\t\t\t\"%s:%d: Character already defined (%s). The base rule will take \"\n\t\t\t\t\t\t\"precedence.\",\n\t\t\t\t\t\tfile->fileName, file->lineNumber,\n\t\t\t\t\t\tprintSource(file, prevRule->sourceFile, prevRule->sourceLine));\n\t\t\t\tcharacter->definitionRule = 0;\n\t\t\t}\n\t\t\tTranslationTableOffset basechar;\n\t\t\tputChar(file, token.chars[0], table, &basechar);\n\t\t\t// putChar may have moved table, so make sure character is still valid\n\t\t\tcharacter = (TranslationTableCharacter *)&(*table)->ruleArea[characterOffset];\n\t\t\tif (character->basechar) {\n\t\t\t\tif (character->basechar == basechar &&\n\t\t\t\t\t\tcharacter->mode == mode->attribute) {\n\t\t\t\t\t_lou_logMessage(LOU_LOG_DEBUG, \"%s:%d: Duplicate base rule.\",\n\t\t\t\t\t\t\tfile->fileName, file->lineNumber);\n\t\t\t\t} else {\n\t\t\t\t\t_lou_logMessage(LOU_LOG_DEBUG,\n\t\t\t\t\t\t\t\"%s:%d: A different base rule already exists for this \"\n\t\t\t\t\t\t\t\"character (%s). The new rule will take precedence.\",\n\t\t\t\t\t\t\tfile->fileName, file->lineNumber,\n\t\t\t\t\t\t\tprintSource(\n\t\t\t\t\t\t\t\t\tfile, character->sourceFile, character->sourceLine));\n\t\t\t\t}\n\t\t\t}\n\t\t\tcharacter->basechar = basechar;\n\t\t\tcharacter->mode = mode->attribute;\n\t\t\tcharacter->sourceFile = file->sourceFile;\n\t\t\tcharacter->sourceLine = file->lineNumber;\n\t\t\t/* some other processing is done at the end of the compilation, in\n\t\t\t * finalizeTable() */\n\t\t\treturn 1;\n\t\tcase CTO_EmpMatchBefore:\n\t\t\tbefore |= CTC_EmpMatch;\n\t\t\tgoto doOpcode;\n\t\tcase CTO_EmpMatchAfter:\n\t\t\tafter |= CTC_EmpMatch;\n\t\t\tgoto doOpcode;\n\n\t\tcase CTO_SwapCc:\n\t\tcase CTO_SwapCd:\n\t\tcase CTO_SwapDd:\n\t\t\treturn compileSwap(file, opcode, noback, nofor, table);\n\t\tcase CTO_Hyphen:\n\t\tcase CTO_DecPoint:\n\t\t\t//\tcase CTO_Apostrophe:\n\t\t\t//\tcase CTO_Initial:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (!getRuleDotsPattern(file, &ruleDots)) return 0;\n\t\t\tif (ruleChars.length != 1 || ruleDots.length < 1) {\n\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\"One Unicode character and at least one cell are \"\n\t\t\t\t\t\t\"required.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn addRule(file, opcode, &ruleChars, &ruleDots, after, before, NULL, NULL,\n\t\t\t\t\tnoback, nofor, table);\n\t\t\t// if (opcode == CTO_DecPoint)\n\t\t\t// {\n\t\t\t//   TranslationTableCharacter *c =\n\t\t\t//   getChar(ruleChars.chars[0]);\n\t\t\t//   if(c)\n\t\t\t//     c->attributes |= CTC_NumericMode;\n\t\t\t// }\n\t\tdefault:\n\t\t\tcompileError(file, \"unimplemented opcode.\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}", "func_hash": 188995041946566375099409962387038802381, "file_name": "compileTranslationTable.c", "file_hash": 129515444966510079462991982245291196170, "cwe": ["CWE-787"], "cve": "CVE-2022-31783", "cve_desc": "Liblouis 3.21.0 has an out-of-bounds write in compileRule in compileTranslationTable.c, as demonstrated by lou_trace.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-31783", "file_path": "liblouis/compileTranslationTable.c"}
