{"idx": 210551, "project": "oniguruma", "commit_id": "4d461376bd85e7994835677b2ff453a43c49cd28", "project_url": "https://github.com/kkos/oniguruma", "commit_url": "https://github.com/kkos/oniguruma/commit/4d461376bd85e7994835677b2ff453a43c49cd28", "commit_message": "don't expand string case folds to alternatives if code length == 1 and byte length is same", "target": 1, "func": "expand_case_fold_string(Node* node, regex_t* reg)\n{\n#define THRESHOLD_CASE_FOLD_ALT_FOR_EXPANSION  8\n\n  int r, n, len, alt_num;\n  UChar *start, *end, *p;\n  Node *top_root, *root, *snode, *prev_node;\n  OnigCaseFoldCodeItem items[ONIGENC_GET_CASE_FOLD_CODES_MAX_NUM];\n  StrNode* sn = STR_(node);\n\n  if (NODE_STRING_IS_AMBIG(node)) return 0;\n\n  start = sn->s;\n  end   = sn->end;\n  if (start >= end) return 0;\n\n  r = 0;\n  top_root = root = prev_node = snode = NULL_NODE;\n  alt_num = 1;\n  p = start;\n  while (p < end) {\n    n = ONIGENC_GET_CASE_FOLD_CODES_BY_STR(reg->enc, reg->case_fold_flag, p, end,\n                                           items);\n    if (n < 0) {\n      r = n;\n      goto err;\n    }\n\n    len = enclen(reg->enc, p);\n\n    if (n == 0) {\n      if (IS_NULL(snode)) {\n        if (IS_NULL(root) && IS_NOT_NULL(prev_node)) {\n          top_root = root = onig_node_list_add(NULL_NODE, prev_node);\n          if (IS_NULL(root)) {\n            onig_node_free(prev_node);\n            goto mem_err;\n          }\n        }\n\n        prev_node = snode = onig_node_new_str(NULL, NULL);\n        if (IS_NULL(snode)) goto mem_err;\n        if (IS_NOT_NULL(root)) {\n          if (IS_NULL(onig_node_list_add(root, snode))) {\n            onig_node_free(snode);\n            goto mem_err;\n          }\n        }\n      }\n\n      r = onig_node_str_cat(snode, p, p + len);\n      if (r != 0) goto err;\n    }\n    else {\n      alt_num *= (n + 1);\n      if (alt_num > THRESHOLD_CASE_FOLD_ALT_FOR_EXPANSION) break;\n\n      if (IS_NULL(root) && IS_NOT_NULL(prev_node)) {\n        top_root = root = onig_node_list_add(NULL_NODE, prev_node);\n        if (IS_NULL(root)) {\n          onig_node_free(prev_node);\n          goto mem_err;\n        }\n      }\n\n      r = expand_case_fold_string_alt(n, items, p, len, end, reg, &prev_node);\n      if (r < 0) goto mem_err;\n      if (r == 1) {\n        if (IS_NULL(root)) {\n          top_root = prev_node;\n        }\n        else {\n          if (IS_NULL(onig_node_list_add(root, prev_node))) {\n            onig_node_free(prev_node);\n            goto mem_err;\n          }\n        }\n\n        root = NODE_CAR(prev_node);\n      }\n      else { /* r == 0 */\n        if (IS_NOT_NULL(root)) {\n          if (IS_NULL(onig_node_list_add(root, prev_node))) {\n            onig_node_free(prev_node);\n            goto mem_err;\n          }\n        }\n      }\n\n      snode = NULL_NODE;\n    }\n\n    p += len;\n  }\n\n  if (p < end) {\n    Node *srem;\n\n    r = expand_case_fold_make_rem_string(&srem, p, end, reg);\n    if (r != 0) goto mem_err;\n\n    if (IS_NOT_NULL(prev_node) && IS_NULL(root)) {\n      top_root = root = onig_node_list_add(NULL_NODE, prev_node);\n      if (IS_NULL(root)) {\n        onig_node_free(srem);\n        onig_node_free(prev_node);\n        goto mem_err;\n      }\n    }\n\n    if (IS_NULL(root)) {\n      prev_node = srem;\n    }\n    else {\n      if (IS_NULL(onig_node_list_add(root, srem))) {\n        onig_node_free(srem);\n        goto mem_err;\n      }\n    }\n  }\n\n  /* ending */\n  top_root = (IS_NOT_NULL(top_root) ? top_root : prev_node);\n  swap_node(node, top_root);\n  onig_node_free(top_root);\n  return 0;\n\n mem_err:\n  r = ONIGERR_MEMORY;\n\n err:\n  onig_node_free(top_root);\n  return r;\n}", "func_hash": 183402285676240178400514858197717953400, "file_name": "regcomp.c", "file_hash": 30592731921158278474590718116243340454, "cwe": ["CWE-125"], "cve": "CVE-2019-19246", "cve_desc": "Oniguruma through 6.9.3, as used in PHP 7.3.x and other products, has a heap-based buffer over-read in str_lower_case_match in regexec.c.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2019-19246", "file_path": "src/regcomp.c"}
{"idx": 437291, "project": "oniguruma", "commit_id": "4d461376bd85e7994835677b2ff453a43c49cd28", "project_url": "https://github.com/kkos/oniguruma", "commit_url": "https://github.com/kkos/oniguruma/commit/4d461376bd85e7994835677b2ff453a43c49cd28", "commit_message": "don't expand string case folds to alternatives if code length == 1 and byte length is same", "target": 0, "func": "expand_case_fold_string(Node* node, regex_t* reg)\n{\n#define THRESHOLD_CASE_FOLD_ALT_FOR_EXPANSION  8\n\n  int r, n, len, alt_num;\n  int is_ambig, fold_len;\n  UChar *start, *end, *p;\n  UChar* foldp;\n  Node *top_root, *root, *snode, *prev_node;\n  OnigCaseFoldCodeItem items[ONIGENC_GET_CASE_FOLD_CODES_MAX_NUM];\n  UChar buf[ONIGENC_MBC_CASE_FOLD_MAXLEN];\n  StrNode* sn = STR_(node);\n\n  if (NODE_STRING_IS_AMBIG(node)) return 0;\n\n  start = sn->s;\n  end   = sn->end;\n  if (start >= end) return 0;\n\n  r = 0;\n  top_root = root = prev_node = snode = NULL_NODE;\n  alt_num = 1;\n  p = start;\n  while (p < end) {\n    n = ONIGENC_GET_CASE_FOLD_CODES_BY_STR(reg->enc, reg->case_fold_flag,\n                                           p, end, items);\n    if (n < 0) {\n      r = n;\n      goto err;\n    }\n\n    len = enclen(reg->enc, p);\n\n    if (n == 0 || IS_NOT_NULL(snode) ||\n        is_good_case_fold_items_for_search(reg->enc, len, n, items)) {\n      if (IS_NULL(snode)) {\n        if (IS_NULL(root) && IS_NOT_NULL(prev_node)) {\n          top_root = root = onig_node_list_add(NULL_NODE, prev_node);\n          if (IS_NULL(root)) {\n            onig_node_free(prev_node);\n            goto mem_err;\n          }\n        }\n\n        prev_node = snode = onig_node_new_str(NULL, NULL);\n        if (IS_NULL(snode)) goto mem_err;\n        if (IS_NOT_NULL(root)) {\n          if (IS_NULL(onig_node_list_add(root, snode))) {\n            onig_node_free(snode);\n            goto mem_err;\n          }\n        }\n\n        is_ambig = -1; /* -1: new */\n      }\n      else {\n        is_ambig = NODE_STRING_IS_AMBIG(snode);\n      }\n\n      if (n != 0) {\n        foldp = p;\n        fold_len = ONIGENC_MBC_CASE_FOLD(reg->enc, reg->case_fold_flag,\n                                         &foldp, end, buf);\n        foldp = buf;\n      }\n      else {\n        foldp = p; fold_len = len;\n      }\n\n      if ((n != 0 && is_ambig == 0) || (n == 0 && is_ambig > 0)) {\n        if (IS_NULL(root) /* && IS_NOT_NULL(prev_node) */) {\n          top_root = root = onig_node_list_add(NULL_NODE, prev_node);\n          if (IS_NULL(root)) {\n            onig_node_free(prev_node);\n            goto mem_err;\n          }\n        }\n\n        prev_node = snode = onig_node_new_str(foldp, foldp + fold_len);\n        if (IS_NULL(snode)) goto mem_err;\n        if (IS_NULL(onig_node_list_add(root, snode))) {\n          onig_node_free(snode);\n          goto mem_err;\n        }\n      }\n      else {\n        r = onig_node_str_cat(snode, foldp, foldp + fold_len);\n        if (r != 0) goto err;\n      }\n\n      if (n != 0) NODE_STRING_SET_AMBIG(snode);\n    }\n    else {\n      alt_num *= (n + 1);\n      if (alt_num > THRESHOLD_CASE_FOLD_ALT_FOR_EXPANSION) break;\n\n      if (IS_NULL(root) && IS_NOT_NULL(prev_node)) {\n        top_root = root = onig_node_list_add(NULL_NODE, prev_node);\n        if (IS_NULL(root)) {\n          onig_node_free(prev_node);\n          goto mem_err;\n        }\n      }\n\n      r = expand_case_fold_string_alt(n, items, p, len, end, reg, &prev_node);\n      if (r < 0) goto mem_err;\n      if (r == 1) {\n        if (IS_NULL(root)) {\n          top_root = prev_node;\n        }\n        else {\n          if (IS_NULL(onig_node_list_add(root, prev_node))) {\n            onig_node_free(prev_node);\n            goto mem_err;\n          }\n        }\n\n        root = NODE_CAR(prev_node);\n      }\n      else { /* r == 0 */\n        if (IS_NOT_NULL(root)) {\n          if (IS_NULL(onig_node_list_add(root, prev_node))) {\n            onig_node_free(prev_node);\n            goto mem_err;\n          }\n        }\n      }\n\n      snode = NULL_NODE;\n    }\n\n    p += len;\n  }\n\n  if (p < end) {\n    Node *srem;\n\n    r = expand_case_fold_make_rem_string(&srem, p, end, reg);\n    if (r != 0) goto mem_err;\n\n    if (IS_NOT_NULL(prev_node) && IS_NULL(root)) {\n      top_root = root = onig_node_list_add(NULL_NODE, prev_node);\n      if (IS_NULL(root)) {\n        onig_node_free(srem);\n        onig_node_free(prev_node);\n        goto mem_err;\n      }\n    }\n\n    if (IS_NULL(root)) {\n      prev_node = srem;\n    }\n    else {\n      if (IS_NULL(onig_node_list_add(root, srem))) {\n        onig_node_free(srem);\n        goto mem_err;\n      }\n    }\n  }\n\n  /* ending */\n  top_root = (IS_NOT_NULL(top_root) ? top_root : prev_node);\n  swap_node(node, top_root);\n  onig_node_free(top_root);\n  return 0;\n\n mem_err:\n  r = ONIGERR_MEMORY;\n\n err:\n  onig_node_free(top_root);\n  return r;\n}", "func_hash": 98258741045227921109976574238500358148, "file_name": "regcomp.c", "file_hash": 65059023969392718812527129333061905098, "cwe": ["CWE-125"], "cve": "CVE-2019-19246", "cve_desc": "Oniguruma through 6.9.3, as used in PHP 7.3.x and other products, has a heap-based buffer over-read in str_lower_case_match in regexec.c.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2019-19246", "file_path": "src/regcomp.c"}
{"idx": 210570, "project": "radare2", "commit_id": "d4ce40b516ffd70cf2e9e36832d8de139117d522", "project_url": "https://github.com/radare/radare2", "commit_url": "https://github.com/radareorg/radare2/commit/d4ce40b516ffd70cf2e9e36832d8de139117d522", "commit_message": "Fix oobread in symbols header parsing ##bin", "target": 1, "func": "static RCoreSymCacheElement *parseDragons(RBinFile *bf, RBuffer *buf, int off, int bits, R_OWN char *file_name) {\n\tD eprintf (\"Dragons at 0x%x\\n\", off);\n\tut64 size = r_buf_size (buf);\n\tif (off >= size) {\n\t\treturn NULL;\n\t}\n\tsize -= off;\n\tif (!size) {\n\t\treturn NULL;\n\t}\n\tut8 *b = malloc (size);\n\tif (!b) {\n\t\treturn NULL;\n\t}\n\tint available = r_buf_read_at (buf, off, b, size);\n\tif (available != size) {\n\t\teprintf (\"Warning: r_buf_read_at failed\\n\");\n\t\treturn NULL;\n\t}\n#if 0\n\t// after the list of sections, there's a bunch of unknown\n\t// data, brobably dwords, and then the same section list again\n\t// this function aims to parse it.\n\t0x00000138 |1a2b b2a1 0300 0000 1a2b b2a1 e055 0000| .+.......+...U..\n                         n_segments ----.          .--- how many sections ?\n\t0x00000148 |0100 0000 ca55 0000 0400 0000 1800 0000| .....U..........\n\t             .---- how many symbols? 0xc7\n\t0x00000158 |c700 0000 0000 0000 0000 0000 0104 0000| ................\n\t0x00000168 |250b e803 0000 0100 0000 0000 bd55 0000| %............U..\n\t0x00000178 |91bb e903 e35a b42c 93a4 340a 8746 9489| .....Z.,..4..F..\n\t0x00000188 |0cea 4c40 0c00 0000 0900 0000 0000 0000| ..L@............\n\t0x00000198 |0000 0000 0000 0000 0000 0000 0000 0000| ................\n\t0x000001a8 |0080 0000 0000 0000 5f5f 5445 5854 0000| ........__TEXT..\n\t0x000001b8 |0000 0000 0000 0000 0080 0000 0000 0000| ................\n\t0x000001c8 |0040 0000 0000 0000 5f5f 4441 5441 0000| .@......__DATA..\n\t0x000001d8 |0000 0000 0000 0000 00c0 0000 0000 0000| ................\n\t0x000001e8 |0000 0100 0000 0000 5f5f 4c4c 564d 0000| ........__LLVM..\n\t0x000001f8 |0000 0000 0000 0000 00c0 0100 0000 0000| ................\n\t0x00000208 |00c0 0000 0000 0000 5f5f 4c49 4e4b 4544| ........__LINKED\n\t0x00000218 |4954 0000 0000 0000 0000 0000 d069 0000| IT...........i..\n#endif\n\t// eprintf (\"Dragon's magic:\\n\");\n\tint magicCombo = 0;\n\tif (!memcmp (\"\\x1a\\x2b\\xb2\\xa1\", b, 4)) { // 0x130  ?\n\t\tmagicCombo++;\n\t}\n\tif (!memcmp (\"\\x1a\\x2b\\xb2\\xa1\", b + 8, 4)) {\n\t\tmagicCombo++;\n\t}\n\tif (magicCombo != 2) {\n\t\t// hack for C22F7494\n\t\tavailable = r_buf_read_at (buf, off - 8, b, size);\n\t\tif (available != size) {\n\t\t\teprintf (\"Warning: r_buf_read_at failed\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!memcmp (\"\\x1a\\x2b\\xb2\\xa1\", b, 4)) { // 0x130  ?\n\t\t\toff -= 8;\n\t\t} else {\n\t\t\teprintf (\"0x%08x  parsing error: invalid magic retry\\n\", off);\n\t\t}\n\t}\n\tD eprintf (\"0x%08x  magic  OK\\n\", off);\n\tD {\n\t\tconst int e0ss = r_read_le32 (b + 12);\n\t\teprintf (\"0x%08x  eoss   0x%x\\n\", off + 12, e0ss);\n\t}\n\tfree (b);\n\treturn r_coresym_cache_element_new (bf, buf, off + 16, bits, file_name);\n}", "func_hash": 12354681142783714645575373162879180963, "file_name": "bin_symbols.c", "file_hash": 5185444036263415559996433677051676690, "cwe": ["CWE-787"], "cve": "CVE-2022-1061", "cve_desc": "Heap Buffer Overflow in parseDragons in GitHub repository radareorg/radare2 prior to 5.6.8.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-1061", "file_path": "libr/bin/p/bin_symbols.c"}
{"idx": 437671, "project": "radare2", "commit_id": "d4ce40b516ffd70cf2e9e36832d8de139117d522", "project_url": "https://github.com/radare/radare2", "commit_url": "https://github.com/radareorg/radare2/commit/d4ce40b516ffd70cf2e9e36832d8de139117d522", "commit_message": "Fix oobread in symbols header parsing ##bin", "target": 0, "func": "static RCoreSymCacheElement *parseDragons(RBinFile *bf, RBuffer *buf, int off, int bits, R_OWN char *file_name) {\n\tD eprintf (\"Dragons at 0x%x\\n\", off);\n\tst64 size = r_buf_size (buf);\n\tif (off >= size) {\n\t\treturn NULL;\n\t}\n\tsize -= off;\n\tif (!size) {\n\t\treturn NULL;\n\t}\n\tif (size < 32) {\n\t\treturn NULL;\n\t}\n\tut8 *b = malloc (size);\n\tif (!b) {\n\t\treturn NULL;\n\t}\n\tint available = r_buf_read_at (buf, off, b, size);\n\tif (available != size) {\n\t\teprintf (\"Warning: r_buf_read_at failed\\n\");\n\t\treturn NULL;\n\t}\n#if 0\n\t// after the list of sections, there's a bunch of unknown\n\t// data, brobably dwords, and then the same section list again\n\t// this function aims to parse it.\n\t0x00000138 |1a2b b2a1 0300 0000 1a2b b2a1 e055 0000| .+.......+...U..\n                         n_segments ----.          .--- how many sections ?\n\t0x00000148 |0100 0000 ca55 0000 0400 0000 1800 0000| .....U..........\n\t             .---- how many symbols? 0xc7\n\t0x00000158 |c700 0000 0000 0000 0000 0000 0104 0000| ................\n\t0x00000168 |250b e803 0000 0100 0000 0000 bd55 0000| %............U..\n\t0x00000178 |91bb e903 e35a b42c 93a4 340a 8746 9489| .....Z.,..4..F..\n\t0x00000188 |0cea 4c40 0c00 0000 0900 0000 0000 0000| ..L@............\n\t0x00000198 |0000 0000 0000 0000 0000 0000 0000 0000| ................\n\t0x000001a8 |0080 0000 0000 0000 5f5f 5445 5854 0000| ........__TEXT..\n\t0x000001b8 |0000 0000 0000 0000 0080 0000 0000 0000| ................\n\t0x000001c8 |0040 0000 0000 0000 5f5f 4441 5441 0000| .@......__DATA..\n\t0x000001d8 |0000 0000 0000 0000 00c0 0000 0000 0000| ................\n\t0x000001e8 |0000 0100 0000 0000 5f5f 4c4c 564d 0000| ........__LLVM..\n\t0x000001f8 |0000 0000 0000 0000 00c0 0100 0000 0000| ................\n\t0x00000208 |00c0 0000 0000 0000 5f5f 4c49 4e4b 4544| ........__LINKED\n\t0x00000218 |4954 0000 0000 0000 0000 0000 d069 0000| IT...........i..\n#endif\n\t// eprintf (\"Dragon's magic:\\n\");\n\tint magicCombo = 0;\n\tif (!memcmp (\"\\x1a\\x2b\\xb2\\xa1\", b, 4)) { // 0x130  ?\n\t\tmagicCombo++;\n\t}\n\tif (!memcmp (\"\\x1a\\x2b\\xb2\\xa1\", b + 8, 4)) {\n\t\tmagicCombo++;\n\t}\n\tif (magicCombo != 2) {\n\t\t// hack for C22F7494\n\t\tavailable = r_buf_read_at (buf, off - 8, b, size);\n\t\tif (available != size) {\n\t\t\teprintf (\"Warning: r_buf_read_at failed\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!memcmp (\"\\x1a\\x2b\\xb2\\xa1\", b, 4)) { // 0x130  ?\n\t\t\toff -= 8;\n\t\t} else {\n\t\t\teprintf (\"0x%08x  parsing error: invalid magic retry\\n\", off);\n\t\t}\n\t}\n\tD eprintf (\"0x%08x  magic  OK\\n\", off);\n\tD {\n\t\tconst int e0ss = r_read_le32 (b + 12);\n\t\teprintf (\"0x%08x  eoss   0x%x\\n\", off + 12, e0ss);\n\t}\n\tfree (b);\n\treturn r_coresym_cache_element_new (bf, buf, off + 16, bits, file_name);\n}", "func_hash": 161522561097046138638560232136347291203, "file_name": "bin_symbols.c", "file_hash": 78009235824912653993940702914741768463, "cwe": ["CWE-787"], "cve": "CVE-2022-1061", "cve_desc": "Heap Buffer Overflow in parseDragons in GitHub repository radareorg/radare2 prior to 5.6.8.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-1061", "file_path": "libr/bin/p/bin_symbols.c"}
{"idx": 210571, "project": "linux", "commit_id": "a7b2df76b42bdd026e3106cf2ba97db41345a177", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/a7b2df76b42bdd026e3106cf2ba97db41345a177", "commit_message": "media: rc: prevent memory leak in cx23888_ir_probe\n\nIn cx23888_ir_probe if kfifo_alloc fails the allocated memory for state\nshould be released.\n\nSigned-off-by: Navid Emamdoost <navid.emamdoost@gmail.com>\nSigned-off-by: Sean Young <sean@mess.org>\nSigned-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>", "target": 1, "func": "int cx23888_ir_probe(struct cx23885_dev *dev)\n{\n\tstruct cx23888_ir_state *state;\n\tstruct v4l2_subdev *sd;\n\tstruct v4l2_subdev_ir_parameters default_params;\n\tint ret;\n\n\tstate = kzalloc(sizeof(struct cx23888_ir_state), GFP_KERNEL);\n\tif (state == NULL)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&state->rx_kfifo_lock);\n\tif (kfifo_alloc(&state->rx_kfifo, CX23888_IR_RX_KFIFO_SIZE, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tstate->dev = dev;\n\tsd = &state->sd;\n\n\tv4l2_subdev_init(sd, &cx23888_ir_controller_ops);\n\tv4l2_set_subdevdata(sd, state);\n\t/* FIXME - fix the formatting of dev->v4l2_dev.name and use it */\n\tsnprintf(sd->name, sizeof(sd->name), \"%s/888-ir\", dev->name);\n\tsd->grp_id = CX23885_HW_888_IR;\n\n\tret = v4l2_device_register_subdev(&dev->v4l2_dev, sd);\n\tif (ret == 0) {\n\t\t/*\n\t\t * Ensure no interrupts arrive from '888 specific conditions,\n\t\t * since we ignore them in this driver to have commonality with\n\t\t * similar IR controller cores.\n\t\t */\n\t\tcx23888_ir_write4(dev, CX23888_IR_IRQEN_REG, 0);\n\n\t\tmutex_init(&state->rx_params_lock);\n\t\tdefault_params = default_rx_params;\n\t\tv4l2_subdev_call(sd, ir, rx_s_parameters, &default_params);\n\n\t\tmutex_init(&state->tx_params_lock);\n\t\tdefault_params = default_tx_params;\n\t\tv4l2_subdev_call(sd, ir, tx_s_parameters, &default_params);\n\t} else {\n\t\tkfifo_free(&state->rx_kfifo);\n\t}\n\treturn ret;\n}", "func_hash": 312936233884251143267490272609054572019, "file_name": "cx23888-ir.c", "file_hash": 272401351605402096339960832660708824692, "cwe": ["CWE-401"], "cve": "CVE-2019-19054", "cve_desc": "A memory leak in the cx23888_ir_probe() function in drivers/media/pci/cx23885/cx23888-ir.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering kfifo_alloc() failures, aka CID-a7b2df76b42b.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2019-19054", "file_path": "drivers/media/pci/cx23885/cx23888-ir.c"}
