{"idx": 205823, "project": "ovs", "commit_id": "803ed12e31b0377c37d7aa8c94b3b92f2081e349", "project_url": "https://github.com/openvswitch/ovs", "commit_url": "https://github.com/openvswitch/ovs/commit/803ed12e31b0377c37d7aa8c94b3b92f2081e349", "commit_message": "ipf: release unhandled packets from the batch\n\nSince 640d4db788ed (\"ipf: Fix a use-after-free error, ...\") the ipf\nframework unconditionally allocates a new dp_packet to track\nindividual fragments.  This prevents a use-after-free.  However, an\nadditional issue was present - even when the packet buffer is cloned,\nif the ip fragment handling code keeps it, the original buffer is\nleaked during the refill loop.  Even in the original processing code,\nthe hardcoded dnsteal branches would always leak a packet buffer from\nthe refill loop.\n\nThis can be confirmed with valgrind:\n\n==717566== 16,672 (4,480 direct, 12,192 indirect) bytes in 8 blocks are definitely lost in loss record 390 of 390\n==717566==    at 0x484086F: malloc (vg_replace_malloc.c:380)\n==717566==    by 0x537BFD: xmalloc__ (util.c:137)\n==717566==    by 0x537BFD: xmalloc (util.c:172)\n==717566==    by 0x46DDD4: dp_packet_new (dp-packet.c:153)\n==717566==    by 0x46DDD4: dp_packet_new_with_headroom (dp-packet.c:163)\n==717566==    by 0x550AA6: netdev_linux_batch_rxq_recv_sock.constprop.0 (netdev-linux.c:1262)\n==717566==    by 0x5512AF: netdev_linux_rxq_recv (netdev-linux.c:1511)\n==717566==    by 0x4AB7E0: netdev_rxq_recv (netdev.c:727)\n==717566==    by 0x47F00D: dp_netdev_process_rxq_port (dpif-netdev.c:4699)\n==717566==    by 0x47FD13: dpif_netdev_run (dpif-netdev.c:5957)\n==717566==    by 0x4331D2: type_run (ofproto-dpif.c:370)\n==717566==    by 0x41DFD8: ofproto_type_run (ofproto.c:1768)\n==717566==    by 0x40A7FB: bridge_run__ (bridge.c:3245)\n==717566==    by 0x411269: bridge_run (bridge.c:3310)\n==717566==    by 0x406E6C: main (ovs-vswitchd.c:127)\n\nThe fix is to delete the original packet when it isn't able to be\nreinserted into the packet batch.  Subsequent valgrind runs show that\nthe packets are not leaked from the batch any longer.\n\nFixes: 640d4db788ed (\"ipf: Fix a use-after-free error, and remove the 'do_not_steal' flag.\")\nFixes: 4ea96698f667 (\"Userspace datapath: Add fragmentation handling.\")\nReported-by: Wan Junjie <wanjunjie@bytedance.com>\nReported-at: https://github.com/openvswitch/ovs-issues/issues/226\nSigned-off-by: Aaron Conole <aconole@redhat.com>\nReviewed-by: David Marchand <david.marchand@redhat.com>\nTested-by: Wan Junjie <wanjunjie@bytedance.com>\nSigned-off-by: Alin-Gabriel Serdean <aserdean@ovn.org>", "target": 1, "func": "ipf_extract_frags_from_batch(struct ipf *ipf, struct dp_packet_batch *pb,\n                             ovs_be16 dl_type, uint16_t zone, long long now,\n                             uint32_t hash_basis)\n{\n    const size_t pb_cnt = dp_packet_batch_size(pb);\n    int pb_idx; /* Index in a packet batch. */\n    struct dp_packet *pkt;\n\n    DP_PACKET_BATCH_REFILL_FOR_EACH (pb_idx, pb_cnt, pkt, pb) {\n        if (OVS_UNLIKELY((dl_type == htons(ETH_TYPE_IP) &&\n                          ipf_is_valid_v4_frag(ipf, pkt))\n                          ||\n                          (dl_type == htons(ETH_TYPE_IPV6) &&\n                          ipf_is_valid_v6_frag(ipf, pkt)))) {\n\n            ovs_mutex_lock(&ipf->ipf_lock);\n            if (!ipf_handle_frag(ipf, pkt, dl_type, zone, now, hash_basis)) {\n                dp_packet_batch_refill(pb, pkt, pb_idx);\n            }\n            ovs_mutex_unlock(&ipf->ipf_lock);\n        } else {\n            dp_packet_batch_refill(pb, pkt, pb_idx);\n        }\n    }\n}", "func_hash": 268719993787134993398351954055334505161, "file_name": "ipf.c", "file_hash": 8691777507480014794600271586586377411, "cwe": ["CWE-401"], "cve": "CVE-2021-3905", "cve_desc": "A memory leak was found in Open vSwitch (OVS) during userspace IP fragmentation processing. An attacker could use this flaw to potentially exhaust available memory by keeping sending packet fragments.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-3905", "file_path": "lib/ipf.c"}
{"idx": 373535, "project": "ovs", "commit_id": "803ed12e31b0377c37d7aa8c94b3b92f2081e349", "project_url": "https://github.com/openvswitch/ovs", "commit_url": "https://github.com/openvswitch/ovs/commit/803ed12e31b0377c37d7aa8c94b3b92f2081e349", "commit_message": "ipf: release unhandled packets from the batch\n\nSince 640d4db788ed (\"ipf: Fix a use-after-free error, ...\") the ipf\nframework unconditionally allocates a new dp_packet to track\nindividual fragments.  This prevents a use-after-free.  However, an\nadditional issue was present - even when the packet buffer is cloned,\nif the ip fragment handling code keeps it, the original buffer is\nleaked during the refill loop.  Even in the original processing code,\nthe hardcoded dnsteal branches would always leak a packet buffer from\nthe refill loop.\n\nThis can be confirmed with valgrind:\n\n==717566== 16,672 (4,480 direct, 12,192 indirect) bytes in 8 blocks are definitely lost in loss record 390 of 390\n==717566==    at 0x484086F: malloc (vg_replace_malloc.c:380)\n==717566==    by 0x537BFD: xmalloc__ (util.c:137)\n==717566==    by 0x537BFD: xmalloc (util.c:172)\n==717566==    by 0x46DDD4: dp_packet_new (dp-packet.c:153)\n==717566==    by 0x46DDD4: dp_packet_new_with_headroom (dp-packet.c:163)\n==717566==    by 0x550AA6: netdev_linux_batch_rxq_recv_sock.constprop.0 (netdev-linux.c:1262)\n==717566==    by 0x5512AF: netdev_linux_rxq_recv (netdev-linux.c:1511)\n==717566==    by 0x4AB7E0: netdev_rxq_recv (netdev.c:727)\n==717566==    by 0x47F00D: dp_netdev_process_rxq_port (dpif-netdev.c:4699)\n==717566==    by 0x47FD13: dpif_netdev_run (dpif-netdev.c:5957)\n==717566==    by 0x4331D2: type_run (ofproto-dpif.c:370)\n==717566==    by 0x41DFD8: ofproto_type_run (ofproto.c:1768)\n==717566==    by 0x40A7FB: bridge_run__ (bridge.c:3245)\n==717566==    by 0x411269: bridge_run (bridge.c:3310)\n==717566==    by 0x406E6C: main (ovs-vswitchd.c:127)\n\nThe fix is to delete the original packet when it isn't able to be\nreinserted into the packet batch.  Subsequent valgrind runs show that\nthe packets are not leaked from the batch any longer.\n\nFixes: 640d4db788ed (\"ipf: Fix a use-after-free error, and remove the 'do_not_steal' flag.\")\nFixes: 4ea96698f667 (\"Userspace datapath: Add fragmentation handling.\")\nReported-by: Wan Junjie <wanjunjie@bytedance.com>\nReported-at: https://github.com/openvswitch/ovs-issues/issues/226\nSigned-off-by: Aaron Conole <aconole@redhat.com>\nReviewed-by: David Marchand <david.marchand@redhat.com>\nTested-by: Wan Junjie <wanjunjie@bytedance.com>\nSigned-off-by: Alin-Gabriel Serdean <aserdean@ovn.org>", "target": 0, "func": "ipf_extract_frags_from_batch(struct ipf *ipf, struct dp_packet_batch *pb,\n                             ovs_be16 dl_type, uint16_t zone, long long now,\n                             uint32_t hash_basis)\n{\n    const size_t pb_cnt = dp_packet_batch_size(pb);\n    int pb_idx; /* Index in a packet batch. */\n    struct dp_packet *pkt;\n\n    DP_PACKET_BATCH_REFILL_FOR_EACH (pb_idx, pb_cnt, pkt, pb) {\n        if (OVS_UNLIKELY((dl_type == htons(ETH_TYPE_IP) &&\n                          ipf_is_valid_v4_frag(ipf, pkt))\n                          ||\n                          (dl_type == htons(ETH_TYPE_IPV6) &&\n                          ipf_is_valid_v6_frag(ipf, pkt)))) {\n\n            ovs_mutex_lock(&ipf->ipf_lock);\n            if (!ipf_handle_frag(ipf, pkt, dl_type, zone, now, hash_basis)) {\n                dp_packet_batch_refill(pb, pkt, pb_idx);\n            } else {\n                dp_packet_delete(pkt);\n            }\n            ovs_mutex_unlock(&ipf->ipf_lock);\n        } else {\n            dp_packet_batch_refill(pb, pkt, pb_idx);\n        }\n    }\n}", "func_hash": 120994420466199339145680136614353279460, "file_name": "ipf.c", "file_hash": 251424754321869382912198899459965953031, "cwe": ["CWE-401"], "cve": "CVE-2021-3905", "cve_desc": "A memory leak was found in Open vSwitch (OVS) during userspace IP fragmentation processing. An attacker could use this flaw to potentially exhaust available memory by keeping sending packet fragments.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-3905", "file_path": "lib/ipf.c"}
{"idx": 206043, "project": "gimp", "commit_id": "c57f9dcf1934a9ab0cd67650f2dea18cb0902270", "project_url": "https://github.com/GNOME/gimp", "commit_url": "https://git.gnome.org/browse/gimp/commit/?id=c57f9dcf1934a9ab0cd67650f2dea18cb0902270", "commit_message": "Bug 790784 - (CVE-2017-17784) heap overread in gbr parser / load_image.\n\nWe were assuming the input name was well formed, hence was\nnul-terminated. As any data coming from external input, this has to be\nthorougly checked.\nSimilar to commit 06d24a79af94837d615d0024916bb95a01bf3c59 but adapted\nto older gimp-2-8 code.", "target": 1, "func": "load_image (const gchar  *filename,\n            GError      **error)\n{\n  gchar             *name;\n  gint               fd;\n  BrushHeader        bh;\n  guchar            *brush_buf = NULL;\n  gint32             image_ID;\n  gint32             layer_ID;\n  GimpParasite      *parasite;\n  GimpDrawable      *drawable;\n  GimpPixelRgn       pixel_rgn;\n  gint               bn_size;\n  GimpImageBaseType  base_type;\n  GimpImageType      image_type;\n  gsize              size;\n\n  fd = g_open (filename, O_RDONLY | _O_BINARY, 0);\n\n  if (fd == -1)\n    {\n      g_set_error (error, G_FILE_ERROR, g_file_error_from_errno (errno),\n                   _(\"Could not open '%s' for reading: %s\"),\n                   gimp_filename_to_utf8 (filename), g_strerror (errno));\n      return -1;\n    }\n\n  gimp_progress_init_printf (_(\"Opening '%s'\"),\n                             gimp_filename_to_utf8 (filename));\n\n  if (read (fd, &bh, sizeof (BrushHeader)) != sizeof (BrushHeader))\n    {\n      close (fd);\n      return -1;\n    }\n\n  /*  rearrange the bytes in each unsigned int  */\n  bh.header_size  = g_ntohl (bh.header_size);\n  bh.version      = g_ntohl (bh.version);\n  bh.width        = g_ntohl (bh.width);\n  bh.height       = g_ntohl (bh.height);\n  bh.bytes        = g_ntohl (bh.bytes);\n  bh.magic_number = g_ntohl (bh.magic_number);\n  bh.spacing      = g_ntohl (bh.spacing);\n\n  /* Sanitize values */\n  if ((bh.width == 0) || (bh.width > GIMP_MAX_IMAGE_SIZE) ||\n      (bh.height == 0) || (bh.height > GIMP_MAX_IMAGE_SIZE) ||\n      ((bh.bytes != 1) && (bh.bytes != 2) && (bh.bytes != 4) &&\n       (bh.bytes != 18)) ||\n      (G_MAXSIZE / bh.width / bh.height / bh.bytes < 1))\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"Invalid header data in '%s': width=%lu, height=%lu, \"\n                     \"bytes=%lu\"), gimp_filename_to_utf8 (filename),\n                   (unsigned long int)bh.width, (unsigned long int)bh.height,\n                   (unsigned long int)bh.bytes);\n      return -1;\n    }\n\n  switch (bh.version)\n    {\n    case 1:\n      /* Version 1 didn't have a magic number and had no spacing  */\n      bh.spacing = 25;\n      /* And we need to rewind the handle, 4 due spacing and 4 due magic */\n      lseek (fd, -8, SEEK_CUR);\n      bh.header_size += 8;\n      break;\n\n    case 3: /*  cinepaint brush  */\n      if (bh.bytes == 18 /* FLOAT16_GRAY_GIMAGE */)\n        {\n          bh.bytes = 2;\n        }\n      else\n        {\n          g_message (_(\"Unsupported brush format\"));\n          close (fd);\n          return -1;\n        }\n      /*  fallthrough  */\n\n    case 2:\n      if (bh.magic_number == GBRUSH_MAGIC &&\n          bh.header_size  >  sizeof (BrushHeader))\n        break;\n\n    default:\n      g_message (_(\"Unsupported brush format\"));\n      close (fd);\n      return -1;\n    }\n\n  if ((bn_size = (bh.header_size - sizeof (BrushHeader))) > 0)\n    {\n      gchar *temp = g_new (gchar, bn_size);\n\n      if ((read (fd, temp, bn_size)) < bn_size)\n        {\n          g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                       _(\"Error in GIMP brush file '%s'\"),\n                       gimp_filename_to_utf8 (filename));\n          close (fd);\n          g_free (temp);\n          return -1;\n        }\n\n      name = gimp_any_to_utf8 (temp, -1,\n                               _(\"Invalid UTF-8 string in brush file '%s'.\"),\n                               gimp_filename_to_utf8 (filename));\n      g_free (temp);\n    }\n  else\n    {\n      name = g_strdup (_(\"Unnamed\"));\n    }\n\n  /* Now there's just raw data left. */\n\n  size = bh.width * bh.height * bh.bytes;\n  brush_buf = g_malloc (size);\n\n  if (read (fd, brush_buf, size) != size)\n    {\n      close (fd);\n      g_free (brush_buf);\n      g_free (name);\n      return -1;\n    }\n\n  switch (bh.bytes)\n    {\n    case 1:\n      {\n        PatternHeader ph;\n\n        /*  For backwards-compatibility, check if a pattern follows.\n            The obsolete .gpb format did it this way.  */\n\n        if (read (fd, &ph, sizeof (PatternHeader)) == sizeof(PatternHeader))\n          {\n            /*  rearrange the bytes in each unsigned int  */\n            ph.header_size  = g_ntohl (ph.header_size);\n            ph.version      = g_ntohl (ph.version);\n            ph.width        = g_ntohl (ph.width);\n            ph.height       = g_ntohl (ph.height);\n            ph.bytes        = g_ntohl (ph.bytes);\n            ph.magic_number = g_ntohl (ph.magic_number);\n\n            if (ph.magic_number == GPATTERN_MAGIC        &&\n                ph.version      == 1                     &&\n                ph.header_size  > sizeof (PatternHeader) &&\n                ph.bytes        == 3                     &&\n                ph.width        == bh.width              &&\n                ph.height       == bh.height             &&\n                lseek (fd, ph.header_size - sizeof (PatternHeader),\n                       SEEK_CUR) > 0)\n              {\n                guchar *plain_brush = brush_buf;\n                gint    i;\n\n                bh.bytes = 4;\n                brush_buf = g_malloc (4 * bh.width * bh.height);\n\n                for (i = 0; i < ph.width * ph.height; i++)\n                  {\n                    if (read (fd, brush_buf + i * 4, 3) != 3)\n                      {\n                        close (fd);\n                        g_free (name);\n                        g_free (plain_brush);\n                        g_free (brush_buf);\n                        return -1;\n                      }\n                    brush_buf[i * 4 + 3] = plain_brush[i];\n                  }\n                g_free (plain_brush);\n              }\n          }\n      }\n      break;\n\n    case 2:\n      {\n        guint16 *buf = (guint16 *) brush_buf;\n        gint     i;\n\n        for (i = 0; i < bh.width * bh.height; i++, buf++)\n          {\n            union\n            {\n              guint16 u[2];\n              gfloat  f;\n            } short_float;\n\n#if G_BYTE_ORDER == G_LITTLE_ENDIAN\n            short_float.u[0] = 0;\n            short_float.u[1] = GUINT16_FROM_BE (*buf);\n#else\n            short_float.u[0] = GUINT16_FROM_BE (*buf);\n            short_float.u[1] = 0;\n#endif\n\n            brush_buf[i] = (guchar) (short_float.f * 255.0 + 0.5);\n          }\n\n        bh.bytes = 1;\n      }\n      break;\n\n    default:\n      break;\n    }\n\n  /*\n   * Create a new image of the proper size and\n   * associate the filename with it.\n   */\n\n  switch (bh.bytes)\n    {\n    case 1:\n      base_type = GIMP_GRAY;\n      image_type = GIMP_GRAY_IMAGE;\n      break;\n\n    case 4:\n      base_type = GIMP_RGB;\n      image_type = GIMP_RGBA_IMAGE;\n      break;\n\n    default:\n      g_message (\"Unsupported brush depth: %d\\n\"\n                 \"GIMP Brushes must be GRAY or RGBA\\n\",\n                 bh.bytes);\n      g_free (name);\n      return -1;\n    }\n\n  image_ID = gimp_image_new (bh.width, bh.height, base_type);\n  gimp_image_set_filename (image_ID, filename);\n\n  parasite = gimp_parasite_new (\"gimp-brush-name\",\n                                GIMP_PARASITE_PERSISTENT,\n                                strlen (name) + 1, name);\n  gimp_image_attach_parasite (image_ID, parasite);\n  gimp_parasite_free (parasite);\n\n  layer_ID = gimp_layer_new (image_ID, name, bh.width, bh.height,\n                             image_type, 100, GIMP_NORMAL_MODE);\n  gimp_image_insert_layer (image_ID, layer_ID, -1, 0);\n\n  g_free (name);\n\n  drawable = gimp_drawable_get (layer_ID);\n  gimp_pixel_rgn_init (&pixel_rgn, drawable,\n                       0, 0, drawable->width, drawable->height,\n                       TRUE, FALSE);\n\n  gimp_pixel_rgn_set_rect (&pixel_rgn, brush_buf,\n                           0, 0, bh.width, bh.height);\n  g_free (brush_buf);\n\n  if (image_type == GIMP_GRAY_IMAGE)\n    gimp_invert (layer_ID);\n\n  close (fd);\n\n  gimp_drawable_flush (drawable);\n  gimp_progress_update (1.0);\n\n  return image_ID;\n}", "func_hash": 219487381392289910094593757172224969152, "file_name": "file-gbr.c", "file_hash": 210537502330856952427982223109888523462, "cwe": ["CWE-125"], "cve": "CVE-2017-17784", "cve_desc": "In GIMP 2.8.22, there is a heap-based buffer over-read in load_image in plug-ins/common/file-gbr.c in the gbr import parser, related to mishandling of UTF-8 data.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-17784", "file_path": "plug-ins/common/file-gbr.c"}
{"idx": 376678, "project": "gimp", "commit_id": "c57f9dcf1934a9ab0cd67650f2dea18cb0902270", "project_url": "https://github.com/GNOME/gimp", "commit_url": "https://git.gnome.org/browse/gimp/commit/?id=c57f9dcf1934a9ab0cd67650f2dea18cb0902270", "commit_message": "Bug 790784 - (CVE-2017-17784) heap overread in gbr parser / load_image.\n\nWe were assuming the input name was well formed, hence was\nnul-terminated. As any data coming from external input, this has to be\nthorougly checked.\nSimilar to commit 06d24a79af94837d615d0024916bb95a01bf3c59 but adapted\nto older gimp-2-8 code.", "target": 0, "func": "load_image (const gchar  *filename,\n            GError      **error)\n{\n  gchar             *name;\n  gint               fd;\n  BrushHeader        bh;\n  guchar            *brush_buf = NULL;\n  gint32             image_ID;\n  gint32             layer_ID;\n  GimpParasite      *parasite;\n  GimpDrawable      *drawable;\n  GimpPixelRgn       pixel_rgn;\n  gint               bn_size;\n  GimpImageBaseType  base_type;\n  GimpImageType      image_type;\n  gsize              size;\n\n  fd = g_open (filename, O_RDONLY | _O_BINARY, 0);\n\n  if (fd == -1)\n    {\n      g_set_error (error, G_FILE_ERROR, g_file_error_from_errno (errno),\n                   _(\"Could not open '%s' for reading: %s\"),\n                   gimp_filename_to_utf8 (filename), g_strerror (errno));\n      return -1;\n    }\n\n  gimp_progress_init_printf (_(\"Opening '%s'\"),\n                             gimp_filename_to_utf8 (filename));\n\n  if (read (fd, &bh, sizeof (BrushHeader)) != sizeof (BrushHeader))\n    {\n      close (fd);\n      return -1;\n    }\n\n  /*  rearrange the bytes in each unsigned int  */\n  bh.header_size  = g_ntohl (bh.header_size);\n  bh.version      = g_ntohl (bh.version);\n  bh.width        = g_ntohl (bh.width);\n  bh.height       = g_ntohl (bh.height);\n  bh.bytes        = g_ntohl (bh.bytes);\n  bh.magic_number = g_ntohl (bh.magic_number);\n  bh.spacing      = g_ntohl (bh.spacing);\n\n  /* Sanitize values */\n  if ((bh.width == 0) || (bh.width > GIMP_MAX_IMAGE_SIZE) ||\n      (bh.height == 0) || (bh.height > GIMP_MAX_IMAGE_SIZE) ||\n      ((bh.bytes != 1) && (bh.bytes != 2) && (bh.bytes != 4) &&\n       (bh.bytes != 18)) ||\n      (G_MAXSIZE / bh.width / bh.height / bh.bytes < 1))\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"Invalid header data in '%s': width=%lu, height=%lu, \"\n                     \"bytes=%lu\"), gimp_filename_to_utf8 (filename),\n                   (unsigned long int)bh.width, (unsigned long int)bh.height,\n                   (unsigned long int)bh.bytes);\n      return -1;\n    }\n\n  switch (bh.version)\n    {\n    case 1:\n      /* Version 1 didn't have a magic number and had no spacing  */\n      bh.spacing = 25;\n      /* And we need to rewind the handle, 4 due spacing and 4 due magic */\n      lseek (fd, -8, SEEK_CUR);\n      bh.header_size += 8;\n      break;\n\n    case 3: /*  cinepaint brush  */\n      if (bh.bytes == 18 /* FLOAT16_GRAY_GIMAGE */)\n        {\n          bh.bytes = 2;\n        }\n      else\n        {\n          g_message (_(\"Unsupported brush format\"));\n          close (fd);\n          return -1;\n        }\n      /*  fallthrough  */\n\n    case 2:\n      if (bh.magic_number == GBRUSH_MAGIC &&\n          bh.header_size  >  sizeof (BrushHeader))\n        break;\n\n    default:\n      g_message (_(\"Unsupported brush format\"));\n      close (fd);\n      return -1;\n    }\n\n  if ((bn_size = (bh.header_size - sizeof (BrushHeader))) > 0)\n    {\n      gchar *temp = g_new (gchar, bn_size);\n\n      if ((read (fd, temp, bn_size)) < bn_size ||\n          temp[bn_size - 1] != '\\0')\n        {\n          g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                       _(\"Error in GIMP brush file '%s'\"),\n                       gimp_filename_to_utf8 (filename));\n          close (fd);\n          g_free (temp);\n          return -1;\n        }\n\n      name = gimp_any_to_utf8 (temp, -1,\n                               _(\"Invalid UTF-8 string in brush file '%s'.\"),\n                               gimp_filename_to_utf8 (filename));\n      g_free (temp);\n    }\n  else\n    {\n      name = g_strdup (_(\"Unnamed\"));\n    }\n\n  /* Now there's just raw data left. */\n\n  size = bh.width * bh.height * bh.bytes;\n  brush_buf = g_malloc (size);\n\n  if (read (fd, brush_buf, size) != size)\n    {\n      close (fd);\n      g_free (brush_buf);\n      g_free (name);\n      return -1;\n    }\n\n  switch (bh.bytes)\n    {\n    case 1:\n      {\n        PatternHeader ph;\n\n        /*  For backwards-compatibility, check if a pattern follows.\n            The obsolete .gpb format did it this way.  */\n\n        if (read (fd, &ph, sizeof (PatternHeader)) == sizeof(PatternHeader))\n          {\n            /*  rearrange the bytes in each unsigned int  */\n            ph.header_size  = g_ntohl (ph.header_size);\n            ph.version      = g_ntohl (ph.version);\n            ph.width        = g_ntohl (ph.width);\n            ph.height       = g_ntohl (ph.height);\n            ph.bytes        = g_ntohl (ph.bytes);\n            ph.magic_number = g_ntohl (ph.magic_number);\n\n            if (ph.magic_number == GPATTERN_MAGIC        &&\n                ph.version      == 1                     &&\n                ph.header_size  > sizeof (PatternHeader) &&\n                ph.bytes        == 3                     &&\n                ph.width        == bh.width              &&\n                ph.height       == bh.height             &&\n                lseek (fd, ph.header_size - sizeof (PatternHeader),\n                       SEEK_CUR) > 0)\n              {\n                guchar *plain_brush = brush_buf;\n                gint    i;\n\n                bh.bytes = 4;\n                brush_buf = g_malloc (4 * bh.width * bh.height);\n\n                for (i = 0; i < ph.width * ph.height; i++)\n                  {\n                    if (read (fd, brush_buf + i * 4, 3) != 3)\n                      {\n                        close (fd);\n                        g_free (name);\n                        g_free (plain_brush);\n                        g_free (brush_buf);\n                        return -1;\n                      }\n                    brush_buf[i * 4 + 3] = plain_brush[i];\n                  }\n                g_free (plain_brush);\n              }\n          }\n      }\n      break;\n\n    case 2:\n      {\n        guint16 *buf = (guint16 *) brush_buf;\n        gint     i;\n\n        for (i = 0; i < bh.width * bh.height; i++, buf++)\n          {\n            union\n            {\n              guint16 u[2];\n              gfloat  f;\n            } short_float;\n\n#if G_BYTE_ORDER == G_LITTLE_ENDIAN\n            short_float.u[0] = 0;\n            short_float.u[1] = GUINT16_FROM_BE (*buf);\n#else\n            short_float.u[0] = GUINT16_FROM_BE (*buf);\n            short_float.u[1] = 0;\n#endif\n\n            brush_buf[i] = (guchar) (short_float.f * 255.0 + 0.5);\n          }\n\n        bh.bytes = 1;\n      }\n      break;\n\n    default:\n      break;\n    }\n\n  /*\n   * Create a new image of the proper size and\n   * associate the filename with it.\n   */\n\n  switch (bh.bytes)\n    {\n    case 1:\n      base_type = GIMP_GRAY;\n      image_type = GIMP_GRAY_IMAGE;\n      break;\n\n    case 4:\n      base_type = GIMP_RGB;\n      image_type = GIMP_RGBA_IMAGE;\n      break;\n\n    default:\n      g_message (\"Unsupported brush depth: %d\\n\"\n                 \"GIMP Brushes must be GRAY or RGBA\\n\",\n                 bh.bytes);\n      g_free (name);\n      return -1;\n    }\n\n  image_ID = gimp_image_new (bh.width, bh.height, base_type);\n  gimp_image_set_filename (image_ID, filename);\n\n  parasite = gimp_parasite_new (\"gimp-brush-name\",\n                                GIMP_PARASITE_PERSISTENT,\n                                strlen (name) + 1, name);\n  gimp_image_attach_parasite (image_ID, parasite);\n  gimp_parasite_free (parasite);\n\n  layer_ID = gimp_layer_new (image_ID, name, bh.width, bh.height,\n                             image_type, 100, GIMP_NORMAL_MODE);\n  gimp_image_insert_layer (image_ID, layer_ID, -1, 0);\n\n  g_free (name);\n\n  drawable = gimp_drawable_get (layer_ID);\n  gimp_pixel_rgn_init (&pixel_rgn, drawable,\n                       0, 0, drawable->width, drawable->height,\n                       TRUE, FALSE);\n\n  gimp_pixel_rgn_set_rect (&pixel_rgn, brush_buf,\n                           0, 0, bh.width, bh.height);\n  g_free (brush_buf);\n\n  if (image_type == GIMP_GRAY_IMAGE)\n    gimp_invert (layer_ID);\n\n  close (fd);\n\n  gimp_drawable_flush (drawable);\n  gimp_progress_update (1.0);\n\n  return image_ID;\n}", "func_hash": 269327823766609487068724383051357537961, "file_name": "file-gbr.c", "file_hash": 146644042188037261041231342134151379601, "cwe": ["CWE-125"], "cve": "CVE-2017-17784", "cve_desc": "In GIMP 2.8.22, there is a heap-based buffer over-read in load_image in plug-ins/common/file-gbr.c in the gbr import parser, related to mishandling of UTF-8 data.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-17784", "file_path": "plug-ins/common/file-gbr.c"}
{"idx": 206262, "project": "vim", "commit_id": "c6fdb15d423df22e1776844811d082322475e48a", "project_url": "https://github.com/vim/vim", "commit_url": "https://github.com/vim/vim/commit/c6fdb15d423df22e1776844811d082322475e48a", "commit_message": "patch 9.0.0025: accessing beyond allocated memory with the cmdline window\n\nProblem:    Accessing beyond allocated memory when using the cmdline window in\n            Ex mode.\nSolution:   Use \"*\" instead of \"'<,'>\" for Visual mode.", "target": 1, "func": "parse_command_modifiers(\n\texarg_T\t    *eap,\n\tchar\t    **errormsg,\n\tcmdmod_T    *cmod,\n\tint\t    skip_only)\n{\n    char_u  *orig_cmd = eap->cmd;\n    char_u  *cmd_start = NULL;\n    int\t    use_plus_cmd = FALSE;\n    int\t    starts_with_colon = FALSE;\n    int\t    vim9script = in_vim9script();\n    int\t    has_visual_range = FALSE;\n\n    CLEAR_POINTER(cmod);\n    cmod->cmod_flags = sticky_cmdmod_flags;\n\n    if (STRNCMP(eap->cmd, \"'<,'>\", 5) == 0)\n    {\n\t// The automatically inserted Visual area range is skipped, so that\n\t// typing \":cmdmod cmd\" in Visual mode works without having to move the\n\t// range to after the modififiers. The command will be\n\t// \"'<,'>cmdmod cmd\", parse \"cmdmod cmd\" and then put back \"'<,'>\"\n\t// before \"cmd\" below.\n\teap->cmd += 5;\n\tcmd_start = eap->cmd;\n\thas_visual_range = TRUE;\n    }\n\n    // Repeat until no more command modifiers are found.\n    for (;;)\n    {\n\tchar_u  *p;\n\n\twhile (*eap->cmd == ' ' || *eap->cmd == '\\t' || *eap->cmd == ':')\n\t{\n\t    if (*eap->cmd == ':')\n\t\tstarts_with_colon = TRUE;\n\t    ++eap->cmd;\n\t}\n\n\t// in ex mode, an empty command (after modifiers) works like :+\n\tif (*eap->cmd == NUL && exmode_active\n\t\t   && (getline_equal(eap->getline, eap->cookie, getexmodeline)\n\t\t       || getline_equal(eap->getline, eap->cookie, getexline))\n\t\t\t&& curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t{\n\t    use_plus_cmd = TRUE;\n\t    if (!skip_only)\n\t\tex_pressedreturn = TRUE;\n\t    break;  // no modifiers following\n\t}\n\n\t// ignore comment and empty lines\n\tif (comment_start(eap->cmd, starts_with_colon))\n\t{\n\t    // a comment ends at a NL\n\t    if (eap->nextcmd == NULL)\n\t    {\n\t\teap->nextcmd = vim_strchr(eap->cmd, '\\n');\n\t\tif (eap->nextcmd != NULL)\n\t\t    ++eap->nextcmd;\n\t    }\n\t    if (vim9script && has_cmdmod(cmod, FALSE))\n\t\t*errormsg = _(e_command_modifier_without_command);\n\t    return FAIL;\n\t}\n\tif (*eap->cmd == NUL)\n\t{\n\t    if (!skip_only)\n\t    {\n\t\tex_pressedreturn = TRUE;\n\t\tif (vim9script && has_cmdmod(cmod, FALSE))\n\t\t    *errormsg = _(e_command_modifier_without_command);\n\t    }\n\t    return FAIL;\n\t}\n\n\tp = skip_range(eap->cmd, TRUE, NULL);\n\n\t// In Vim9 script a variable can shadow a command modifier:\n\t//   verbose = 123\n\t//   verbose += 123\n\t//   silent! verbose = func()\n\t//   verbose.member = 2\n\t//   verbose[expr] = 2\n\t// But not:\n\t//   verbose [a, b] = list\n\tif (vim9script)\n\t{\n\t    char_u *s, *n;\n\n\t    for (s = eap->cmd; ASCII_ISALPHA(*s); ++s)\n\t\t;\n\t    n = skipwhite(s);\n\t    if (*n == '.' || *n == '=' || (*n != NUL && n[1] == '=')\n\t\t    || *s == '[')\n\t\tbreak;\n\t}\n\n\tswitch (*p)\n\t{\n\t    // When adding an entry, also modify cmd_exists().\n\t    case 'a':\tif (!checkforcmd_noparen(&eap->cmd, \"aboveleft\", 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_ABOVE;\n\t\t\tcontinue;\n\n\t    case 'b':\tif (checkforcmd_noparen(&eap->cmd, \"belowright\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_split |= WSP_BELOW;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_opt(&eap->cmd, \"browse\", 3, TRUE))\n\t\t\t{\n#ifdef FEAT_BROWSE_CMD\n\t\t\t    cmod->cmod_flags |= CMOD_BROWSE;\n#endif\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"botright\", 2))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_BOT;\n\t\t\tcontinue;\n\n\t    case 'c':\tif (!checkforcmd_opt(&eap->cmd, \"confirm\", 4, TRUE))\n\t\t\t    break;\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t\t\tcmod->cmod_flags |= CMOD_CONFIRM;\n#endif\n\t\t\tcontinue;\n\n\t    case 'k':\tif (checkforcmd_noparen(&eap->cmd, \"keepmarks\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_KEEPMARKS;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd, \"keepalt\", 5))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_KEEPALT;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd, \"keeppatterns\", 5))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_KEEPPATTERNS;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"keepjumps\", 5))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_KEEPJUMPS;\n\t\t\tcontinue;\n\n\t    case 'f':\t// only accept \":filter {pat} cmd\"\n\t\t\t{\n\t\t\t    char_u  *reg_pat;\n\t\t\t    char_u  *nulp = NULL;\n\t\t\t    int\t    c = 0;\n\n\t\t\t    if (!checkforcmd_noparen(&p, \"filter\", 4)\n\t\t\t\t    || *p == NUL\n\t\t\t\t    || (ends_excmd(*p)\n#ifdef FEAT_EVAL\n\t\t\t\t\t// in \":filter #pat# cmd\" # does not\n\t\t\t\t\t// start a comment\n\t\t\t\t     && (!vim9script || VIM_ISWHITE(p[1]))\n#endif\n\t\t\t\t     ))\n\t\t\t\tbreak;\n\t\t\t    if (*p == '!')\n\t\t\t    {\n\t\t\t\tcmod->cmod_filter_force = TRUE;\n\t\t\t\tp = skipwhite(p + 1);\n\t\t\t\tif (*p == NUL || ends_excmd(*p))\n\t\t\t\t    break;\n\t\t\t    }\n#ifdef FEAT_EVAL\n\t\t\t    // Avoid that \"filter(arg)\" is recognized.\n\t\t\t    if (vim9script && !VIM_ISWHITE(p[-1]))\n\t\t\t\tbreak;\n#endif\n\t\t\t    if (skip_only)\n\t\t\t\tp = skip_vimgrep_pat(p, NULL, NULL);\n\t\t\t    else\n\t\t\t\t// NOTE: This puts a NUL after the pattern.\n\t\t\t\tp = skip_vimgrep_pat_ext(p, &reg_pat, NULL,\n\t\t\t\t\t\t\t\t    &nulp, &c);\n\t\t\t    if (p == NULL || *p == NUL)\n\t\t\t\tbreak;\n\t\t\t    if (!skip_only)\n\t\t\t    {\n\t\t\t\tcmod->cmod_filter_regmatch.regprog =\n\t\t\t\t\t\tvim_regcomp(reg_pat, RE_MAGIC);\n\t\t\t\tif (cmod->cmod_filter_regmatch.regprog == NULL)\n\t\t\t\t    break;\n\t\t\t\t// restore the character overwritten by NUL\n\t\t\t\tif (nulp != NULL)\n\t\t\t\t    *nulp = c;\n\t\t\t    }\n\t\t\t    eap->cmd = p;\n\t\t\t    continue;\n\t\t\t}\n\n\t\t\t// \":hide\" and \":hide | cmd\" are not modifiers\n\t    case 'h':\tif (p != eap->cmd || !checkforcmd_noparen(&p, \"hide\", 3)\n\t\t\t\t\t       || *p == NUL || ends_excmd(*p))\n\t\t\t    break;\n\t\t\teap->cmd = p;\n\t\t\tcmod->cmod_flags |= CMOD_HIDE;\n\t\t\tcontinue;\n\n\t    case 'l':\tif (checkforcmd_noparen(&eap->cmd, \"lockmarks\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_LOCKMARKS;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd, \"legacy\", 3))\n\t\t\t{\n\t\t\t    if (ends_excmd2(p, eap->cmd))\n\t\t\t    {\n\t\t\t\t*errormsg =\n\t\t\t\t      _(e_legacy_must_be_followed_by_command);\n\t\t\t\treturn FAIL;\n\t\t\t    }\n\t\t\t    cmod->cmod_flags |= CMOD_LEGACY;\n\t\t\t    continue;\n\t\t\t}\n\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"leftabove\", 5))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_ABOVE;\n\t\t\tcontinue;\n\n\t    case 'n':\tif (checkforcmd_noparen(&eap->cmd, \"noautocmd\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_NOAUTOCMD;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"noswapfile\", 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_NOSWAPFILE;\n\t\t\tcontinue;\n\n\t    case 'r':\tif (!checkforcmd_noparen(&eap->cmd, \"rightbelow\", 6))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_BELOW;\n\t\t\tcontinue;\n\n\t    case 's':\tif (checkforcmd_noparen(&eap->cmd, \"sandbox\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_SANDBOX;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"silent\", 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_SILENT;\n\t\t\tif (*eap->cmd == '!' && !VIM_ISWHITE(eap->cmd[-1]))\n\t\t\t{\n\t\t\t    // \":silent!\", but not \"silent !cmd\"\n\t\t\t    eap->cmd = skipwhite(eap->cmd + 1);\n\t\t\t    cmod->cmod_flags |= CMOD_ERRSILENT;\n\t\t\t}\n\t\t\tcontinue;\n\n\t    case 't':\tif (checkforcmd_noparen(&p, \"tab\", 3))\n\t\t\t{\n\t\t\t    if (!skip_only)\n\t\t\t    {\n\t\t\t\tlong tabnr = get_address(eap, &eap->cmd,\n\t\t\t\t\t\t    ADDR_TABS, eap->skip,\n\t\t\t\t\t\t    skip_only, FALSE, 1);\n\t\t\t\tif (tabnr == MAXLNUM)\n\t\t\t\t    cmod->cmod_tab = tabpage_index(curtab) + 1;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    if (tabnr < 0 || tabnr > LAST_TAB_NR)\n\t\t\t\t    {\n\t\t\t\t\t*errormsg = _(e_invalid_range);\n\t\t\t\t\treturn FAIL;\n\t\t\t\t    }\n\t\t\t\t    cmod->cmod_tab = tabnr + 1;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    eap->cmd = p;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"topleft\", 2))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_TOP;\n\t\t\tcontinue;\n\n\t    case 'u':\tif (!checkforcmd_noparen(&eap->cmd, \"unsilent\", 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_UNSILENT;\n\t\t\tcontinue;\n\n\t    case 'v':\tif (checkforcmd_noparen(&eap->cmd, \"vertical\", 4))\n\t\t\t{\n\t\t\t    cmod->cmod_split |= WSP_VERT;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd, \"vim9cmd\", 4))\n\t\t\t{\n\t\t\t    if (ends_excmd2(p, eap->cmd))\n\t\t\t    {\n\t\t\t\t*errormsg =\n\t\t\t\t      _(e_vim9cmd_must_be_followed_by_command);\n\t\t\t\treturn FAIL;\n\t\t\t    }\n\t\t\t    cmod->cmod_flags |= CMOD_VIM9CMD;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&p, \"verbose\", 4))\n\t\t\t    break;\n\t\t\tif (vim_isdigit(*eap->cmd))\n\t\t\t{\n\t\t\t    // zero means not set, one is verbose == 0, etc.\n\t\t\t    cmod->cmod_verbose = atoi((char *)eap->cmd) + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t    cmod->cmod_verbose = 2;  // default: verbose == 1\n\t\t\teap->cmd = p;\n\t\t\tcontinue;\n\t}\n\tbreak;\n    }\n\n    if (has_visual_range)\n    {\n\tif (eap->cmd > cmd_start)\n\t{\n\t    // Move the '<,'> range to after the modifiers and insert a colon.\n\t    // Since the modifiers have been parsed put the colon on top of the\n\t    // space: \"'<,'>mod cmd\" -> \"mod:'<,'>cmd\n\t    // Put eap->cmd after the colon.\n\t    if (use_plus_cmd)\n\t    {\n\t\tsize_t len = STRLEN(cmd_start);\n\n\t\t// Special case: empty command uses \"+\":\n\t\t//  \"'<,'>mods\" -> \"mods'<,'>+\n\t\tmch_memmove(orig_cmd, cmd_start, len);\n\t\tSTRCPY(orig_cmd + len, \"'<,'>+\");\n\t    }\n\t    else\n\t    {\n\t\tmch_memmove(cmd_start - 5, cmd_start, eap->cmd - cmd_start);\n\t\teap->cmd -= 5;\n\t\tmch_memmove(eap->cmd - 1, \":'<,'>\", 6);\n\t    }\n\t}\n\telse\n\t    // No modifiers, move the pointer back.\n\t    // Special case: change empty command to \"+\".\n\t    if (use_plus_cmd)\n\t\teap->cmd = (char_u *)\"'<,'>+\";\n\t    else\n\t\teap->cmd = orig_cmd;\n    }\n    else if (use_plus_cmd)\n\teap->cmd = (char_u *)\"+\";\n\n    return OK;\n}", "func_hash": 61928994098668347793112269457604758897, "file_name": "ex_docmd.c", "file_hash": 287878878694425028301990758845576774946, "cwe": ["CWE-787"], "cve": "CVE-2022-2288", "cve_desc": "Out-of-bounds Write in GitHub repository vim/vim prior to 9.0.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-2288", "file_path": "src/ex_docmd.c"}
