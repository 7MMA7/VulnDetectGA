{"idx": 202082, "project": "radare2", "commit_id": "ecc44b6a2f18ee70ac133365de0e509d26d5e168", "project_url": "https://github.com/radare/radare2", "commit_url": "https://github.com/radareorg/radare2/commit/ecc44b6a2f18ee70ac133365de0e509d26d5e168", "commit_message": "Fix oobread in java parser ##crash\n\n* Reported by @bet4it via @huntrdev\n* BountyID c8f4c2de-7d96-4ad4-857a-c099effca2d6\n* Reproducer: bootstrap.class", "target": 1, "func": "R_API RBinJavaAttrInfo *r_bin_java_bootstrap_methods_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tRBinJavaBootStrapMethod *bsm = NULL;\n\tut64 offset = 0;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\toffset += 6;\n\tif (attr) {\n\t\tattr->type = R_BIN_JAVA_ATTR_TYPE_BOOTSTRAP_METHODS_ATTR;\n\t\tattr->info.bootstrap_methods_attr.num_bootstrap_methods = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tattr->info.bootstrap_methods_attr.bootstrap_methods = r_list_newf (r_bin_java_bootstrap_method_free);\n\t\tfor (i = 0; i < attr->info.bootstrap_methods_attr.num_bootstrap_methods; i++) {\n\t\t\t// bsm = r_bin_java_bootstrap_method_new (bin, bin->b->cur);\n\t\t\tif (offset >= sz) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbsm = r_bin_java_bootstrap_method_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\t\tif (bsm) {\n\t\t\t\toffset += bsm->size;\n\t\t\t\tr_list_append (attr->info.bootstrap_methods_attr.bootstrap_methods, (void *) bsm);\n\t\t\t} else {\n\t\t\t\t// TODO eprintf Failed to read the %d boot strap method.\n\t\t\t}\n\t\t}\n\t\tattr->size = offset;\n\t}\n\treturn attr;\n}", "func_hash": 121022317607075696066263684863636152093, "file_name": "class.c", "file_hash": 47177688403428674570419012647523968387, "cwe": ["CWE-125"], "cve": "CVE-2022-1452", "cve_desc": "Out-of-bounds Read in r_bin_java_bootstrap_methods_attr_new function in GitHub repository radareorg/radare2 prior to 5.7.0. The bug causes the program reads data past the end 2f the intented buffer. Typically, this can allow attackers to read sensitive information from other memory locations or cause a crash. More details see [CWE-125: Out-of-bounds read](https://cwe.mitre.org/data/definitions/125.html).", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-1452", "file_path": "shlr/java/class.c"}
{"idx": 328836, "project": "radare2", "commit_id": "ecc44b6a2f18ee70ac133365de0e509d26d5e168", "project_url": "https://github.com/radare/radare2", "commit_url": "https://github.com/radareorg/radare2/commit/ecc44b6a2f18ee70ac133365de0e509d26d5e168", "commit_message": "Fix oobread in java parser ##crash\n\n* Reported by @bet4it via @huntrdev\n* BountyID c8f4c2de-7d96-4ad4-857a-c099effca2d6\n* Reproducer: bootstrap.class", "target": 0, "func": "R_API RBinJavaAttrInfo *r_bin_java_bootstrap_methods_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tRBinJavaBootStrapMethod *bsm = NULL;\n\tut64 offset = 0;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\toffset += 6;\n\tif (attr) {\n\t\tattr->type = R_BIN_JAVA_ATTR_TYPE_BOOTSTRAP_METHODS_ATTR;\n\t\tif (offset + 8 > sz)  {\n\t\t\tfree (attr);\n\t\t\treturn NULL;\n\t\t}\n\t\tattr->info.bootstrap_methods_attr.num_bootstrap_methods = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tattr->info.bootstrap_methods_attr.bootstrap_methods = r_list_newf (r_bin_java_bootstrap_method_free);\n\t\tfor (i = 0; i < attr->info.bootstrap_methods_attr.num_bootstrap_methods; i++) {\n\t\t\t// bsm = r_bin_java_bootstrap_method_new (bin, bin->b->cur);\n\t\t\tif (offset >= sz) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbsm = r_bin_java_bootstrap_method_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\t\tif (bsm) {\n\t\t\t\toffset += bsm->size;\n\t\t\t\tr_list_append (attr->info.bootstrap_methods_attr.bootstrap_methods, (void *) bsm);\n\t\t\t} else {\n\t\t\t\t// TODO eprintf Failed to read the %d boot strap method.\n\t\t\t}\n\t\t}\n\t\tattr->size = offset;\n\t}\n\treturn attr;\n}", "func_hash": 161704709334478835269694958839919177798, "file_name": "class.c", "file_hash": 14172744137787125285025549785651095579, "cwe": ["CWE-125"], "cve": "CVE-2022-1452", "cve_desc": "Out-of-bounds Read in r_bin_java_bootstrap_methods_attr_new function in GitHub repository radareorg/radare2 prior to 5.7.0. The bug causes the program reads data past the end 2f the intented buffer. Typically, this can allow attackers to read sensitive information from other memory locations or cause a crash. More details see [CWE-125: Out-of-bounds read](https://cwe.mitre.org/data/definitions/125.html).", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-1452", "file_path": "shlr/java/class.c"}
{"idx": 202256, "project": "qtbase", "commit_id": "6b400e3147dcfd8cc3a393ace1bd118c93762e0c", "project_url": "https://github.com/qt/qtbase", "commit_url": "https://github.com/qt/qtbase/commit/6b400e3147dcfd8cc3a393ace1bd118c93762e0c", "commit_message": "Improve fix for avoiding huge number of tiny dashes\n\nSome pathological cases were not caught by the previous fix.\n\nFixes: QTBUG-95239\nPick-to: 6.2 6.1 5.15\nChange-Id: I0337ee3923ff93ccb36c4d7b810a9c0667354cc5\nReviewed-by: Robert L\u00f6hning <robert.loehning@qt.io>", "target": 1, "func": "void QPaintEngineEx::stroke(const QVectorPath &path, const QPen &inPen)\n{\n#ifdef QT_DEBUG_DRAW\n    qDebug() << \"QPaintEngineEx::stroke()\" << pen;\n#endif\n\n    Q_D(QPaintEngineEx);\n\n    if (path.isEmpty())\n        return;\n\n    if (!d->strokeHandler) {\n        d->strokeHandler = new StrokeHandler(path.elementCount()+4);\n        d->stroker.setMoveToHook(qpaintengineex_moveTo);\n        d->stroker.setLineToHook(qpaintengineex_lineTo);\n        d->stroker.setCubicToHook(qpaintengineex_cubicTo);\n    }\n\n    QRectF clipRect;\n    QPen pen = inPen;\n    if (pen.style() > Qt::SolidLine) {\n        QRectF cpRect = path.controlPointRect();\n        const QTransform &xf = state()->matrix;\n        if (pen.isCosmetic()) {\n            clipRect = d->exDeviceRect;\n            cpRect.translate(xf.dx(), xf.dy());\n        } else {\n            clipRect = xf.inverted().mapRect(QRectF(d->exDeviceRect));\n        }\n        // Check to avoid generating unwieldy amount of dashes that will not be visible anyway\n        QRectF extentRect = cpRect & clipRect;\n        qreal extent = qMax(extentRect.width(), extentRect.height());\n        qreal patternLength = 0;\n        const QList<qreal> pattern = pen.dashPattern();\n        const int patternSize = qMin(pattern.size(), 32);\n        for (int i = 0; i < patternSize; i++)\n            patternLength += qMax(pattern.at(i), qreal(0));\n        if (pen.widthF())\n            patternLength *= pen.widthF();\n        if (qFuzzyIsNull(patternLength)) {\n            pen.setStyle(Qt::NoPen);\n        } else if (extent / patternLength > 10000) {\n            // approximate stream of tiny dashes with semi-transparent solid line\n            pen.setStyle(Qt::SolidLine);\n            QColor color(pen.color());\n            color.setAlpha(color.alpha() / 2);\n            pen.setColor(color);\n        }\n    }\n\n    if (!qpen_fast_equals(pen, d->strokerPen)) {\n        d->strokerPen = pen;\n        d->stroker.setJoinStyle(pen.joinStyle());\n        d->stroker.setCapStyle(pen.capStyle());\n        d->stroker.setMiterLimit(pen.miterLimit());\n        qreal penWidth = pen.widthF();\n        if (penWidth == 0)\n            d->stroker.setStrokeWidth(1);\n        else\n            d->stroker.setStrokeWidth(penWidth);\n\n        Qt::PenStyle style = pen.style();\n        if (style == Qt::SolidLine) {\n            d->activeStroker = &d->stroker;\n        } else if (style == Qt::NoPen) {\n            d->activeStroker = nullptr;\n        } else {\n            d->dasher.setDashPattern(pen.dashPattern());\n            d->dasher.setDashOffset(pen.dashOffset());\n            d->activeStroker = &d->dasher;\n        }\n    }\n\n    if (!d->activeStroker) {\n        return;\n    }\n\n    if (!clipRect.isNull())\n        d->activeStroker->setClipRect(clipRect);\n\n    if (d->activeStroker == &d->stroker)\n        d->stroker.setForceOpen(path.hasExplicitOpen());\n\n    const QPainterPath::ElementType *types = path.elements();\n    const qreal *points = path.points();\n    int pointCount = path.elementCount();\n\n    const qreal *lastPoint = points + (pointCount<<1);\n\n    d->strokeHandler->types.reset();\n    d->strokeHandler->pts.reset();\n\n    // Some engines might decide to optimize for the non-shape hint later on...\n    uint flags = QVectorPath::WindingFill;\n\n    if (path.elementCount() > 2)\n        flags |= QVectorPath::NonConvexShapeMask;\n\n    if (d->stroker.capStyle() == Qt::RoundCap || d->stroker.joinStyle() == Qt::RoundJoin)\n        flags |= QVectorPath::CurvedShapeMask;\n\n    // ### Perspective Xforms are currently not supported...\n    if (!pen.isCosmetic()) {\n        // We include cosmetic pens in this case to avoid having to\n        // change the current transform. Normal transformed,\n        // non-cosmetic pens will be transformed as part of fill\n        // later, so they are also covered here..\n        d->activeStroker->setCurveThresholdFromTransform(state()->matrix);\n        d->activeStroker->begin(d->strokeHandler);\n        if (types) {\n            while (points < lastPoint) {\n                switch (*types) {\n                case QPainterPath::MoveToElement:\n                    d->activeStroker->moveTo(points[0], points[1]);\n                    points += 2;\n                    ++types;\n                    break;\n                case QPainterPath::LineToElement:\n                    d->activeStroker->lineTo(points[0], points[1]);\n                    points += 2;\n                    ++types;\n                    break;\n                case QPainterPath::CurveToElement:\n                    d->activeStroker->cubicTo(points[0], points[1],\n                                              points[2], points[3],\n                                              points[4], points[5]);\n                    points += 6;\n                    types += 3;\n                    flags |= QVectorPath::CurvedShapeMask;\n                    break;\n                default:\n                    break;\n                }\n            }\n            if (path.hasImplicitClose())\n                d->activeStroker->lineTo(path.points()[0], path.points()[1]);\n\n        } else {\n            d->activeStroker->moveTo(points[0], points[1]);\n            points += 2;\n            while (points < lastPoint) {\n                d->activeStroker->lineTo(points[0], points[1]);\n                points += 2;\n            }\n            if (path.hasImplicitClose())\n                d->activeStroker->lineTo(path.points()[0], path.points()[1]);\n        }\n        d->activeStroker->end();\n\n        if (!d->strokeHandler->types.size()) // an empty path...\n            return;\n\n        QVectorPath strokePath(d->strokeHandler->pts.data(),\n                               d->strokeHandler->types.size(),\n                               d->strokeHandler->types.data(),\n                               flags);\n        fill(strokePath, pen.brush());\n    } else {\n        // For cosmetic pens we need a bit of trickery... We to process xform the input points\n        if (state()->matrix.type() >= QTransform::TxProject) {\n            QPainterPath painterPath = state()->matrix.map(path.convertToPainterPath());\n            d->activeStroker->strokePath(painterPath, d->strokeHandler, QTransform());\n        } else {\n            d->activeStroker->setCurveThresholdFromTransform(QTransform());\n            d->activeStroker->begin(d->strokeHandler);\n            if (types) {\n                while (points < lastPoint) {\n                    switch (*types) {\n                    case QPainterPath::MoveToElement: {\n                        QPointF pt = (*(const QPointF *) points) * state()->matrix;\n                        d->activeStroker->moveTo(pt.x(), pt.y());\n                        points += 2;\n                        ++types;\n                        break;\n                    }\n                    case QPainterPath::LineToElement: {\n                        QPointF pt = (*(const QPointF *) points) * state()->matrix;\n                        d->activeStroker->lineTo(pt.x(), pt.y());\n                        points += 2;\n                        ++types;\n                        break;\n                    }\n                    case QPainterPath::CurveToElement: {\n                        QPointF c1 = ((const QPointF *) points)[0] * state()->matrix;\n                        QPointF c2 = ((const QPointF *) points)[1] * state()->matrix;\n                        QPointF e =  ((const QPointF *) points)[2] * state()->matrix;\n                        d->activeStroker->cubicTo(c1.x(), c1.y(), c2.x(), c2.y(), e.x(), e.y());\n                        points += 6;\n                        types += 3;\n                        flags |= QVectorPath::CurvedShapeMask;\n                        break;\n                    }\n                    default:\n                        break;\n                    }\n                }\n                if (path.hasImplicitClose()) {\n                    QPointF pt = * ((const QPointF *) path.points()) * state()->matrix;\n                    d->activeStroker->lineTo(pt.x(), pt.y());\n                }\n\n            } else {\n                QPointF p = ((const QPointF *)points)[0] * state()->matrix;\n                d->activeStroker->moveTo(p.x(), p.y());\n                points += 2;\n                while (points < lastPoint) {\n                    QPointF p = ((const QPointF *)points)[0] * state()->matrix;\n                    d->activeStroker->lineTo(p.x(), p.y());\n                    points += 2;\n                }\n                if (path.hasImplicitClose())\n                    d->activeStroker->lineTo(p.x(), p.y());\n            }\n            d->activeStroker->end();\n        }\n\n        QVectorPath strokePath(d->strokeHandler->pts.data(),\n                               d->strokeHandler->types.size(),\n                               d->strokeHandler->types.data(),\n                               flags);\n\n        QTransform xform = state()->matrix;\n        state()->matrix = QTransform();\n        transformChanged();\n\n        QBrush brush = pen.brush();\n        if (qbrush_style(brush) != Qt::SolidPattern)\n            brush.setTransform(brush.transform() * xform);\n\n        fill(strokePath, brush);\n\n        state()->matrix = xform;\n        transformChanged();\n    }\n}", "func_hash": 209191742971544690982165605152005956873, "file_name": "qpaintengineex.cpp", "file_hash": 121502439456016918324891600204397406142, "cwe": ["CWE-787"], "cve": "CVE-2021-38593", "cve_desc": "Qt 5.x before 5.15.6 and 6.x through 6.1.2 has an out-of-bounds write in QOutlineMapper::convertPath (called from QRasterPaintEngine::fill and QPaintEngineEx::stroke).", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-38593", "file_path": "src/gui/painting/qpaintengineex.cpp"}
{"idx": 331760, "project": "qtbase", "commit_id": "6b400e3147dcfd8cc3a393ace1bd118c93762e0c", "project_url": "https://github.com/qt/qtbase", "commit_url": "https://github.com/qt/qtbase/commit/6b400e3147dcfd8cc3a393ace1bd118c93762e0c", "commit_message": "Improve fix for avoiding huge number of tiny dashes\n\nSome pathological cases were not caught by the previous fix.\n\nFixes: QTBUG-95239\nPick-to: 6.2 6.1 5.15\nChange-Id: I0337ee3923ff93ccb36c4d7b810a9c0667354cc5\nReviewed-by: Robert L\u00f6hning <robert.loehning@qt.io>", "target": 0, "func": "void QPaintEngineEx::stroke(const QVectorPath &path, const QPen &inPen)\n{\n#ifdef QT_DEBUG_DRAW\n    qDebug() << \"QPaintEngineEx::stroke()\" << pen;\n#endif\n\n    Q_D(QPaintEngineEx);\n\n    if (path.isEmpty())\n        return;\n\n    if (!d->strokeHandler) {\n        d->strokeHandler = new StrokeHandler(path.elementCount()+4);\n        d->stroker.setMoveToHook(qpaintengineex_moveTo);\n        d->stroker.setLineToHook(qpaintengineex_lineTo);\n        d->stroker.setCubicToHook(qpaintengineex_cubicTo);\n    }\n\n    QRectF clipRect;\n    QPen pen = inPen;\n    if (pen.style() > Qt::SolidLine) {\n        QRectF cpRect = path.controlPointRect();\n        const QTransform &xf = state()->matrix;\n        if (pen.isCosmetic()) {\n            clipRect = d->exDeviceRect;\n            cpRect.translate(xf.dx(), xf.dy());\n        } else {\n            clipRect = xf.inverted().mapRect(QRectF(d->exDeviceRect));\n        }\n        // Check to avoid generating unwieldy amount of dashes that will not be visible anyway\n        QRectF extentRect = cpRect & clipRect;\n        qreal extent = qMax(extentRect.width(), extentRect.height());\n        qreal patternLength = 0;\n        const QList<qreal> pattern = pen.dashPattern();\n        const int patternSize = qMin(pattern.size(), 32);\n        for (int i = 0; i < patternSize; i++)\n            patternLength += qMax(pattern.at(i), qreal(0));\n        if (pen.widthF())\n            patternLength *= pen.widthF();\n        if (qFuzzyIsNull(patternLength)) {\n            pen.setStyle(Qt::NoPen);\n        } else if (qFuzzyIsNull(extent) || extent / patternLength > 10000) {\n            // approximate stream of tiny dashes with semi-transparent solid line\n            pen.setStyle(Qt::SolidLine);\n            QColor color(pen.color());\n            color.setAlpha(color.alpha() / 2);\n            pen.setColor(color);\n        }\n    }\n\n    if (!qpen_fast_equals(pen, d->strokerPen)) {\n        d->strokerPen = pen;\n        d->stroker.setJoinStyle(pen.joinStyle());\n        d->stroker.setCapStyle(pen.capStyle());\n        d->stroker.setMiterLimit(pen.miterLimit());\n        qreal penWidth = pen.widthF();\n        if (penWidth == 0)\n            d->stroker.setStrokeWidth(1);\n        else\n            d->stroker.setStrokeWidth(penWidth);\n\n        Qt::PenStyle style = pen.style();\n        if (style == Qt::SolidLine) {\n            d->activeStroker = &d->stroker;\n        } else if (style == Qt::NoPen) {\n            d->activeStroker = nullptr;\n        } else {\n            d->dasher.setDashPattern(pen.dashPattern());\n            d->dasher.setDashOffset(pen.dashOffset());\n            d->activeStroker = &d->dasher;\n        }\n    }\n\n    if (!d->activeStroker) {\n        return;\n    }\n\n    if (!clipRect.isNull())\n        d->activeStroker->setClipRect(clipRect);\n\n    if (d->activeStroker == &d->stroker)\n        d->stroker.setForceOpen(path.hasExplicitOpen());\n\n    const QPainterPath::ElementType *types = path.elements();\n    const qreal *points = path.points();\n    int pointCount = path.elementCount();\n\n    const qreal *lastPoint = points + (pointCount<<1);\n\n    d->strokeHandler->types.reset();\n    d->strokeHandler->pts.reset();\n\n    // Some engines might decide to optimize for the non-shape hint later on...\n    uint flags = QVectorPath::WindingFill;\n\n    if (path.elementCount() > 2)\n        flags |= QVectorPath::NonConvexShapeMask;\n\n    if (d->stroker.capStyle() == Qt::RoundCap || d->stroker.joinStyle() == Qt::RoundJoin)\n        flags |= QVectorPath::CurvedShapeMask;\n\n    // ### Perspective Xforms are currently not supported...\n    if (!pen.isCosmetic()) {\n        // We include cosmetic pens in this case to avoid having to\n        // change the current transform. Normal transformed,\n        // non-cosmetic pens will be transformed as part of fill\n        // later, so they are also covered here..\n        d->activeStroker->setCurveThresholdFromTransform(state()->matrix);\n        d->activeStroker->begin(d->strokeHandler);\n        if (types) {\n            while (points < lastPoint) {\n                switch (*types) {\n                case QPainterPath::MoveToElement:\n                    d->activeStroker->moveTo(points[0], points[1]);\n                    points += 2;\n                    ++types;\n                    break;\n                case QPainterPath::LineToElement:\n                    d->activeStroker->lineTo(points[0], points[1]);\n                    points += 2;\n                    ++types;\n                    break;\n                case QPainterPath::CurveToElement:\n                    d->activeStroker->cubicTo(points[0], points[1],\n                                              points[2], points[3],\n                                              points[4], points[5]);\n                    points += 6;\n                    types += 3;\n                    flags |= QVectorPath::CurvedShapeMask;\n                    break;\n                default:\n                    break;\n                }\n            }\n            if (path.hasImplicitClose())\n                d->activeStroker->lineTo(path.points()[0], path.points()[1]);\n\n        } else {\n            d->activeStroker->moveTo(points[0], points[1]);\n            points += 2;\n            while (points < lastPoint) {\n                d->activeStroker->lineTo(points[0], points[1]);\n                points += 2;\n            }\n            if (path.hasImplicitClose())\n                d->activeStroker->lineTo(path.points()[0], path.points()[1]);\n        }\n        d->activeStroker->end();\n\n        if (!d->strokeHandler->types.size()) // an empty path...\n            return;\n\n        QVectorPath strokePath(d->strokeHandler->pts.data(),\n                               d->strokeHandler->types.size(),\n                               d->strokeHandler->types.data(),\n                               flags);\n        fill(strokePath, pen.brush());\n    } else {\n        // For cosmetic pens we need a bit of trickery... We to process xform the input points\n        if (state()->matrix.type() >= QTransform::TxProject) {\n            QPainterPath painterPath = state()->matrix.map(path.convertToPainterPath());\n            d->activeStroker->strokePath(painterPath, d->strokeHandler, QTransform());\n        } else {\n            d->activeStroker->setCurveThresholdFromTransform(QTransform());\n            d->activeStroker->begin(d->strokeHandler);\n            if (types) {\n                while (points < lastPoint) {\n                    switch (*types) {\n                    case QPainterPath::MoveToElement: {\n                        QPointF pt = (*(const QPointF *) points) * state()->matrix;\n                        d->activeStroker->moveTo(pt.x(), pt.y());\n                        points += 2;\n                        ++types;\n                        break;\n                    }\n                    case QPainterPath::LineToElement: {\n                        QPointF pt = (*(const QPointF *) points) * state()->matrix;\n                        d->activeStroker->lineTo(pt.x(), pt.y());\n                        points += 2;\n                        ++types;\n                        break;\n                    }\n                    case QPainterPath::CurveToElement: {\n                        QPointF c1 = ((const QPointF *) points)[0] * state()->matrix;\n                        QPointF c2 = ((const QPointF *) points)[1] * state()->matrix;\n                        QPointF e =  ((const QPointF *) points)[2] * state()->matrix;\n                        d->activeStroker->cubicTo(c1.x(), c1.y(), c2.x(), c2.y(), e.x(), e.y());\n                        points += 6;\n                        types += 3;\n                        flags |= QVectorPath::CurvedShapeMask;\n                        break;\n                    }\n                    default:\n                        break;\n                    }\n                }\n                if (path.hasImplicitClose()) {\n                    QPointF pt = * ((const QPointF *) path.points()) * state()->matrix;\n                    d->activeStroker->lineTo(pt.x(), pt.y());\n                }\n\n            } else {\n                QPointF p = ((const QPointF *)points)[0] * state()->matrix;\n                d->activeStroker->moveTo(p.x(), p.y());\n                points += 2;\n                while (points < lastPoint) {\n                    QPointF p = ((const QPointF *)points)[0] * state()->matrix;\n                    d->activeStroker->lineTo(p.x(), p.y());\n                    points += 2;\n                }\n                if (path.hasImplicitClose())\n                    d->activeStroker->lineTo(p.x(), p.y());\n            }\n            d->activeStroker->end();\n        }\n\n        QVectorPath strokePath(d->strokeHandler->pts.data(),\n                               d->strokeHandler->types.size(),\n                               d->strokeHandler->types.data(),\n                               flags);\n\n        QTransform xform = state()->matrix;\n        state()->matrix = QTransform();\n        transformChanged();\n\n        QBrush brush = pen.brush();\n        if (qbrush_style(brush) != Qt::SolidPattern)\n            brush.setTransform(brush.transform() * xform);\n\n        fill(strokePath, brush);\n\n        state()->matrix = xform;\n        transformChanged();\n    }\n}", "func_hash": 262258193863623717012890974299984432074, "file_name": "qpaintengineex.cpp", "file_hash": 220664880987933761772605675716001859723, "cwe": ["CWE-787"], "cve": "CVE-2021-38593", "cve_desc": "Qt 5.x before 5.15.6 and 6.x through 6.1.2 has an out-of-bounds write in QOutlineMapper::convertPath (called from QRasterPaintEngine::fill and QPaintEngineEx::stroke).", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-38593", "file_path": "src/gui/painting/qpaintengineex.cpp"}
{"idx": 202392, "project": "php-src", "commit_id": "8fa9d1ce28f3a894b104979df30d0b65e0f21107", "project_url": "https://github.com/php/php-src", "commit_url": "https://git.php.net/?p=php-src.git;a=commit;h=8fa9d1ce28f3a894b104979df30d0b65e0f21107", "commit_message": "improve fix #72558, while (u>=0) with unsigned int will always be true", "target": 1, "func": "static inline LineContribType * _gdContributionsAlloc(unsigned int line_length, unsigned int windows_size)\n{\n\tunsigned int u = 0;\n\tLineContribType *res;\n\tint overflow_error = 0;\n\n\tres = (LineContribType *) gdMalloc(sizeof(LineContribType));\n\tif (!res) {\n\t\treturn NULL;\n\t}\n\tres->WindowSize = windows_size;\n\tres->LineLength = line_length;\n\tif (overflow2(line_length, sizeof(ContributionType))) {\n\t\tgdFree(res);\n\t\treturn NULL;\n\t}\n\tres->ContribRow = (ContributionType *) gdMalloc(line_length * sizeof(ContributionType));\n\tif (res->ContribRow == NULL) {\n\t\tgdFree(res);\n\t\treturn NULL;\n\t}\n\tfor (u = 0 ; u < line_length ; u++) {\n\t\tif (overflow2(windows_size, sizeof(double))) {\n\t\t\toverflow_error = 1;\n\t\t} else {\n\t\t\tres->ContribRow[u].Weights = (double *) gdMalloc(windows_size * sizeof(double));\n\t\t}\n\t\tif (overflow_error == 1 || res->ContribRow[u].Weights == NULL) {\n\t\t\tu--;\n\t\t\twhile (u >= 0) {\n\t\t\t\tgdFree(res->ContribRow[u].Weights);\n\t\t\t\tu--;\n\t\t\t}\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn res;\n}", "func_hash": 194329029953977312970767834657292140797, "file_name": "gd_interpolation.c", "file_hash": 48112947254685040097740151772508640024, "cwe": ["CWE-119"], "cve": "CVE-2016-6207", "cve_desc": "Integer overflow in the _gdContributionsAlloc function in gd_interpolation.c in GD Graphics Library (aka libgd) before 2.2.3 allows remote attackers to cause a denial of service (out-of-bounds memory write or memory consumption) via unspecified vectors.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-6207", "file_path": "ext/gd/libgd/gd_interpolation.c"}
{"idx": 333503, "project": "php-src", "commit_id": "8fa9d1ce28f3a894b104979df30d0b65e0f21107", "project_url": "https://github.com/php/php-src", "commit_url": "https://git.php.net/?p=php-src.git;a=commit;h=8fa9d1ce28f3a894b104979df30d0b65e0f21107", "commit_message": "improve fix #72558, while (u>=0) with unsigned int will always be true", "target": 0, "func": "static inline LineContribType * _gdContributionsAlloc(unsigned int line_length, unsigned int windows_size)\n{\n\tunsigned int u = 0;\n\tLineContribType *res;\n\tint overflow_error = 0;\n\n\tres = (LineContribType *) gdMalloc(sizeof(LineContribType));\n\tif (!res) {\n\t\treturn NULL;\n\t}\n\tres->WindowSize = windows_size;\n\tres->LineLength = line_length;\n\tif (overflow2(line_length, sizeof(ContributionType))) {\n\t\tgdFree(res);\n\t\treturn NULL;\n\t}\n\tres->ContribRow = (ContributionType *) gdMalloc(line_length * sizeof(ContributionType));\n\tif (res->ContribRow == NULL) {\n\t\tgdFree(res);\n\t\treturn NULL;\n\t}\n\tfor (u = 0 ; u < line_length ; u++) {\n\t\tif (overflow2(windows_size, sizeof(double))) {\n\t\t\toverflow_error = 1;\n\t\t} else {\n\t\t\tres->ContribRow[u].Weights = (double *) gdMalloc(windows_size * sizeof(double));\n\t\t}\n\t\tif (overflow_error == 1 || res->ContribRow[u].Weights == NULL) {\n\t\t\tunsigned int i;\n\t\t\tu--;\n\t\t\tfor (i=0;i<=u;i++) {\n\t\t\t\tgdFree(res->ContribRow[i].Weights);\n\t\t\t}\n\t\t\tgdFree(res);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn res;\n}", "func_hash": 144028133167446566795171831954194871613, "file_name": "gd_interpolation.c", "file_hash": 190827623618557315538392680975816018804, "cwe": ["CWE-119"], "cve": "CVE-2016-6207", "cve_desc": "Integer overflow in the _gdContributionsAlloc function in gd_interpolation.c in GD Graphics Library (aka libgd) before 2.2.3 allows remote attackers to cause a denial of service (out-of-bounds memory write or memory consumption) via unspecified vectors.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-6207", "file_path": "ext/gd/libgd/gd_interpolation.c"}
{"idx": 202688, "project": "ghostpdl", "commit_id": "450da26a76286a8342ec0864b3d113856709f8f6", "project_url": "https://github.com/ArtifexSoftware/ghostpdl", "commit_url": "https://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=450da26a76286a8342ec0864b3d113856709f8f6", "commit_message": "Bug 701785: fixed sanitizer heap-buffer-overflow in lprn_is_black().\n\nIn contrib/lips4/gdevlprn.c:lprn_is_black(), it seems that bpl is not\nnecessarily a multiple of lprn->nBw, so we need to explicitly avoid straying\ninto the next line's data.\n\nThis also avoids accessing beyond our buffer if we are already on the last\nline, and so fixes the sanitizer error.\n\nFixes:\n    ./sanbin/gs -sOutputFile=tmp -sDEVICE=lips2p ../bug-701785.pdf", "target": 1, "func": "lprn_is_black(gx_device_printer * pdev, int r, int h, int bx)\n{\n    gx_device_lprn *const lprn = (gx_device_lprn *) pdev;\n\n    int bh = lprn->nBh;\n    int bpl = gdev_mem_bytes_per_scan_line(pdev);\n    int x, y, y0;\n    byte *p;\n    int maxY = lprn->BlockLine / lprn->nBh * lprn->nBh;\n\n    y0 = (r + h - bh) % maxY;\n    for (y = 0; y < bh; y++) {\n        p = &lprn->ImageBuf[(y0 + y) * bpl + bx * lprn->nBw];\n        for (x = 0; x < lprn->nBw; x++)\n            if (p[x] != 0)\n                return 1;\n    }\n    return 0;\n}", "func_hash": 276235081077601818208956388725727672709, "file_name": "gdevlprn.c", "file_hash": 146789313062349427560159100335401323936, "cwe": ["CWE-787"], "cve": "CVE-2020-16287", "cve_desc": "A buffer overflow vulnerability in lprn_is_black() in contrib/lips4/gdevlprn.c of Artifex Software GhostScript v9.50 allows a remote attacker to cause a denial of service via a crafted PDF file. This is fixed in v9.51.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2020-16287", "file_path": "contrib/lips4/gdevlprn.c"}
{"idx": 336807, "project": "ghostpdl", "commit_id": "450da26a76286a8342ec0864b3d113856709f8f6", "project_url": "https://github.com/ArtifexSoftware/ghostpdl", "commit_url": "https://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=450da26a76286a8342ec0864b3d113856709f8f6", "commit_message": "Bug 701785: fixed sanitizer heap-buffer-overflow in lprn_is_black().\n\nIn contrib/lips4/gdevlprn.c:lprn_is_black(), it seems that bpl is not\nnecessarily a multiple of lprn->nBw, so we need to explicitly avoid straying\ninto the next line's data.\n\nThis also avoids accessing beyond our buffer if we are already on the last\nline, and so fixes the sanitizer error.\n\nFixes:\n    ./sanbin/gs -sOutputFile=tmp -sDEVICE=lips2p ../bug-701785.pdf", "target": 0, "func": "lprn_is_black(gx_device_printer * pdev, int r, int h, int bx)\n{\n    gx_device_lprn *const lprn = (gx_device_lprn *) pdev;\n\n    int bh = lprn->nBh;\n    int bpl = gdev_mem_bytes_per_scan_line(pdev);\n    int x, y, y0;\n    byte *p;\n    int maxY = lprn->BlockLine / lprn->nBh * lprn->nBh;\n\n    y0 = (r + h - bh) % maxY;\n    for (y = 0; y < bh; y++) {\n        p = &lprn->ImageBuf[(y0 + y) * bpl + bx * lprn->nBw];\n        for (x = 0; x < lprn->nBw; x++) {\n            /* bpl isn't necessarily a multiple of lprn->nBw, so\n            we need to explicitly stop after the last byte in this\n            line to avoid accessing either the next line's data or\n            going off the end of our buffer completely. This avoids\n            https://bugs.ghostscript.com/show_bug.cgi?id=701785. */\n            if (bx * lprn->nBw + x >= bpl)  break;\n            if (p[x] != 0)\n                return 1;\n        }\n    }\n    return 0;\n}", "func_hash": 150670636989365509549221893772046699987, "file_name": "gdevlprn.c", "file_hash": 90759681637200263840236208606383547324, "cwe": ["CWE-787"], "cve": "CVE-2020-16287", "cve_desc": "A buffer overflow vulnerability in lprn_is_black() in contrib/lips4/gdevlprn.c of Artifex Software GhostScript v9.50 allows a remote attacker to cause a denial of service via a crafted PDF file. This is fixed in v9.51.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2020-16287", "file_path": "contrib/lips4/gdevlprn.c"}
{"idx": 202708, "project": "vim", "commit_id": "8e4b76da1d7e987d43ca960dfbc372d1c617466f", "project_url": "https://github.com/vim/vim", "commit_url": "https://github.com/vim/vim/commit/8e4b76da1d7e987d43ca960dfbc372d1c617466f", "commit_message": "patch 8.2.4901: NULL pointer access when using invalid pattern\n\nProblem:    NULL pointer access when using invalid pattern.\nSolution:   Check for failed regexp program.", "target": 1, "func": "fname_match(\n    regmatch_T\t*rmp,\n    char_u\t*name,\n    int\t\tignore_case)  // when TRUE ignore case, when FALSE use 'fic'\n{\n    char_u\t*match = NULL;\n    char_u\t*p;\n\n    if (name != NULL)\n    {\n\t// Ignore case when 'fileignorecase' or the argument is set.\n\trmp->rm_ic = p_fic || ignore_case;\n\tif (vim_regexec(rmp, name, (colnr_T)0))\n\t    match = name;\n\telse\n\t{\n\t    // Replace $(HOME) with '~' and try matching again.\n\t    p = home_replace_save(NULL, name);\n\t    if (p != NULL && vim_regexec(rmp, p, (colnr_T)0))\n\t\tmatch = name;\n\t    vim_free(p);\n\t}\n    }\n\n    return match;\n}", "func_hash": 10065855190174385623233460326166538906, "file_name": "buffer.c", "file_hash": 293823123124136567259918164990957667329, "cwe": ["CWE-476"], "cve": "CVE-2022-1620", "cve_desc": "NULL Pointer Dereference in function vim_regexec_string at regexp.c:2729 in GitHub repository vim/vim prior to 8.2.4901. NULL Pointer Dereference in function vim_regexec_string at regexp.c:2729 allows attackers to cause a denial of service (application crash) via a crafted input.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-1620", "file_path": "src/buffer.c"}
{"idx": 337374, "project": "vim", "commit_id": "8e4b76da1d7e987d43ca960dfbc372d1c617466f", "project_url": "https://github.com/vim/vim", "commit_url": "https://github.com/vim/vim/commit/8e4b76da1d7e987d43ca960dfbc372d1c617466f", "commit_message": "patch 8.2.4901: NULL pointer access when using invalid pattern\n\nProblem:    NULL pointer access when using invalid pattern.\nSolution:   Check for failed regexp program.", "target": 0, "func": "fname_match(\n    regmatch_T\t*rmp,\n    char_u\t*name,\n    int\t\tignore_case)  // when TRUE ignore case, when FALSE use 'fic'\n{\n    char_u\t*match = NULL;\n    char_u\t*p;\n\n    if (name != NULL)\n    {\n\t// Ignore case when 'fileignorecase' or the argument is set.\n\trmp->rm_ic = p_fic || ignore_case;\n\tif (vim_regexec(rmp, name, (colnr_T)0))\n\t    match = name;\n\telse if (rmp->regprog != NULL)\n\t{\n\t    // Replace $(HOME) with '~' and try matching again.\n\t    p = home_replace_save(NULL, name);\n\t    if (p != NULL && vim_regexec(rmp, p, (colnr_T)0))\n\t\tmatch = name;\n\t    vim_free(p);\n\t}\n    }\n\n    return match;\n}", "func_hash": 197882423023027832397527147027813452758, "file_name": "buffer.c", "file_hash": 116246354520267882741601792511100691040, "cwe": ["CWE-476"], "cve": "CVE-2022-1620", "cve_desc": "NULL Pointer Dereference in function vim_regexec_string at regexp.c:2729 in GitHub repository vim/vim prior to 8.2.4901. NULL Pointer Dereference in function vim_regexec_string at regexp.c:2729 allows attackers to cause a denial of service (application crash) via a crafted input.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-1620", "file_path": "src/buffer.c"}
{"idx": 202719, "project": "linux", "commit_id": "a2d859e3fc97e79d907761550dbc03ff1b36479c", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=a2d859e3fc97e79d907761550dbc03ff1b36479c", "commit_message": "sctp: account stream padding length for reconf chunk\n\nsctp_make_strreset_req() makes repeated calls to sctp_addto_chunk()\nwhich will automatically account for padding on each call. inreq and\noutreq are already 4 bytes aligned, but the payload is not and doing\nSCTP_PAD4(a + b) (which _sctp_make_chunk() did implicitly here) is\ndifferent from SCTP_PAD4(a) + SCTP_PAD4(b) and not enough. It led to\npossible attempt to use more buffer than it was allocated and triggered\na BUG_ON.\n\nCc: Vlad Yasevich <vyasevich@gmail.com>\nCc: Neil Horman <nhorman@tuxdriver.com>\nCc: Greg KH <gregkh@linuxfoundation.org>\nFixes: cc16f00f6529 (\"sctp: add support for generating stream reconf ssn reset request chunk\")\nReported-by: Eiichi Tsukata <eiichi.tsukata@nutanix.com>\nSigned-off-by: Eiichi Tsukata <eiichi.tsukata@nutanix.com>\nSigned-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>\nSigned-off-by: Marcelo Ricardo Leitner <mleitner@redhat.com>\nReviewed-by: Xin Long <lucien.xin@gmail.com>\nLink: https://lore.kernel.org/r/b97c1f8b0c7ff79ac4ed206fc2c49d3612e0850c.1634156849.git.mleitner@redhat.com\nSigned-off-by: Jakub Kicinski <kuba@kernel.org>", "target": 1, "func": "struct sctp_chunk *sctp_make_strreset_req(\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\t__u16 stream_num, __be16 *stream_list,\n\t\t\t\t\tbool out, bool in)\n{\n\t__u16 stream_len = stream_num * sizeof(__u16);\n\tstruct sctp_strreset_outreq outreq;\n\tstruct sctp_strreset_inreq inreq;\n\tstruct sctp_chunk *retval;\n\t__u16 outlen, inlen;\n\n\toutlen = (sizeof(outreq) + stream_len) * out;\n\tinlen = (sizeof(inreq) + stream_len) * in;\n\n\tretval = sctp_make_reconf(asoc, outlen + inlen);\n\tif (!retval)\n\t\treturn NULL;\n\n\tif (outlen) {\n\t\toutreq.param_hdr.type = SCTP_PARAM_RESET_OUT_REQUEST;\n\t\toutreq.param_hdr.length = htons(outlen);\n\t\toutreq.request_seq = htonl(asoc->strreset_outseq);\n\t\toutreq.response_seq = htonl(asoc->strreset_inseq - 1);\n\t\toutreq.send_reset_at_tsn = htonl(asoc->next_tsn - 1);\n\n\t\tsctp_addto_chunk(retval, sizeof(outreq), &outreq);\n\n\t\tif (stream_len)\n\t\t\tsctp_addto_chunk(retval, stream_len, stream_list);\n\t}\n\n\tif (inlen) {\n\t\tinreq.param_hdr.type = SCTP_PARAM_RESET_IN_REQUEST;\n\t\tinreq.param_hdr.length = htons(inlen);\n\t\tinreq.request_seq = htonl(asoc->strreset_outseq + out);\n\n\t\tsctp_addto_chunk(retval, sizeof(inreq), &inreq);\n\n\t\tif (stream_len)\n\t\t\tsctp_addto_chunk(retval, stream_len, stream_list);\n\t}\n\n\treturn retval;\n}", "func_hash": 215335113411495657240056321729109595636, "file_name": "sm_make_chunk.c", "file_hash": 110519816461895113606911923370921219323, "cwe": ["CWE-704"], "cve": "CVE-2022-0322", "cve_desc": "A flaw was found in the sctp_make_strreset_req function in net/sctp/sm_make_chunk.c in the SCTP network protocol in the Linux kernel with a local user privilege access. In this flaw, an attempt to use more buffer than is allocated triggers a BUG_ON issue, leading to a denial of service (DOS).", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-0322", "file_path": "net/sctp/sm_make_chunk.c"}
{"idx": 337848, "project": "linux", "commit_id": "a2d859e3fc97e79d907761550dbc03ff1b36479c", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=a2d859e3fc97e79d907761550dbc03ff1b36479c", "commit_message": "sctp: account stream padding length for reconf chunk\n\nsctp_make_strreset_req() makes repeated calls to sctp_addto_chunk()\nwhich will automatically account for padding on each call. inreq and\noutreq are already 4 bytes aligned, but the payload is not and doing\nSCTP_PAD4(a + b) (which _sctp_make_chunk() did implicitly here) is\ndifferent from SCTP_PAD4(a) + SCTP_PAD4(b) and not enough. It led to\npossible attempt to use more buffer than it was allocated and triggered\na BUG_ON.\n\nCc: Vlad Yasevich <vyasevich@gmail.com>\nCc: Neil Horman <nhorman@tuxdriver.com>\nCc: Greg KH <gregkh@linuxfoundation.org>\nFixes: cc16f00f6529 (\"sctp: add support for generating stream reconf ssn reset request chunk\")\nReported-by: Eiichi Tsukata <eiichi.tsukata@nutanix.com>\nSigned-off-by: Eiichi Tsukata <eiichi.tsukata@nutanix.com>\nSigned-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>\nSigned-off-by: Marcelo Ricardo Leitner <mleitner@redhat.com>\nReviewed-by: Xin Long <lucien.xin@gmail.com>\nLink: https://lore.kernel.org/r/b97c1f8b0c7ff79ac4ed206fc2c49d3612e0850c.1634156849.git.mleitner@redhat.com\nSigned-off-by: Jakub Kicinski <kuba@kernel.org>", "target": 0, "func": "struct sctp_chunk *sctp_make_strreset_req(\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\t__u16 stream_num, __be16 *stream_list,\n\t\t\t\t\tbool out, bool in)\n{\n\t__u16 stream_len = stream_num * sizeof(__u16);\n\tstruct sctp_strreset_outreq outreq;\n\tstruct sctp_strreset_inreq inreq;\n\tstruct sctp_chunk *retval;\n\t__u16 outlen, inlen;\n\n\toutlen = (sizeof(outreq) + stream_len) * out;\n\tinlen = (sizeof(inreq) + stream_len) * in;\n\n\tretval = sctp_make_reconf(asoc, SCTP_PAD4(outlen) + SCTP_PAD4(inlen));\n\tif (!retval)\n\t\treturn NULL;\n\n\tif (outlen) {\n\t\toutreq.param_hdr.type = SCTP_PARAM_RESET_OUT_REQUEST;\n\t\toutreq.param_hdr.length = htons(outlen);\n\t\toutreq.request_seq = htonl(asoc->strreset_outseq);\n\t\toutreq.response_seq = htonl(asoc->strreset_inseq - 1);\n\t\toutreq.send_reset_at_tsn = htonl(asoc->next_tsn - 1);\n\n\t\tsctp_addto_chunk(retval, sizeof(outreq), &outreq);\n\n\t\tif (stream_len)\n\t\t\tsctp_addto_chunk(retval, stream_len, stream_list);\n\t}\n\n\tif (inlen) {\n\t\tinreq.param_hdr.type = SCTP_PARAM_RESET_IN_REQUEST;\n\t\tinreq.param_hdr.length = htons(inlen);\n\t\tinreq.request_seq = htonl(asoc->strreset_outseq + out);\n\n\t\tsctp_addto_chunk(retval, sizeof(inreq), &inreq);\n\n\t\tif (stream_len)\n\t\t\tsctp_addto_chunk(retval, stream_len, stream_list);\n\t}\n\n\treturn retval;\n}", "func_hash": 175020260748921031996578395052444557756, "file_name": "sm_make_chunk.c", "file_hash": 72489321105602052766082993841220689495, "cwe": ["CWE-704"], "cve": "CVE-2022-0322", "cve_desc": "A flaw was found in the sctp_make_strreset_req function in net/sctp/sm_make_chunk.c in the SCTP network protocol in the Linux kernel with a local user privilege access. In this flaw, an attempt to use more buffer than is allocated triggers a BUG_ON issue, leading to a denial of service (DOS).", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-0322", "file_path": "net/sctp/sm_make_chunk.c"}
{"idx": 202748, "project": "ImageMagick", "commit_id": "fbb5e1c8211c4e88ecc367e784b79d457c300d6d", "project_url": "https://github.com/ImageMagick/ImageMagick", "commit_url": "https://github.com/ImageMagick/ImageMagick/commit/fbb5e1c8211c4e88ecc367e784b79d457c300d6d", "commit_message": "...", "target": 1, "func": "static Image *ReadTGAImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  PixelInfo\n    pixel;\n\n  Quantum\n    index;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  size_t\n    base,\n    flag,\n    offset,\n    real,\n    skip;\n\n  ssize_t\n    count,\n    y;\n\n  TGAInfo\n    tga_info;\n\n  unsigned char\n    j,\n    k,\n    pixels[4],\n    runlength;\n\n  unsigned int\n    alpha_bits;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read TGA header information.\n  */\n  count=ReadBlob(image,1,&tga_info.id_length);\n  tga_info.colormap_type=(unsigned char) ReadBlobByte(image);\n  tga_info.image_type=(TGAImageType) ReadBlobByte(image);\n  if ((count != 1) ||\n      ((tga_info.image_type != TGAColormap) &&\n       (tga_info.image_type != TGARGB) &&\n       (tga_info.image_type != TGAMonochrome) &&\n       (tga_info.image_type != TGARLEColormap) &&\n       (tga_info.image_type != TGARLERGB) &&\n       (tga_info.image_type != TGARLEMonochrome)) ||\n      (((tga_info.image_type == TGAColormap) ||\n       (tga_info.image_type == TGARLEColormap)) &&\n       (tga_info.colormap_type == 0)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  tga_info.colormap_index=ReadBlobLSBShort(image);\n  tga_info.colormap_length=ReadBlobLSBShort(image);\n  tga_info.colormap_size=(unsigned char) ReadBlobByte(image);\n  tga_info.x_origin=ReadBlobLSBShort(image);\n  tga_info.y_origin=ReadBlobLSBShort(image);\n  tga_info.width=(unsigned short) ReadBlobLSBShort(image);\n  tga_info.height=(unsigned short) ReadBlobLSBShort(image);\n  tga_info.bits_per_pixel=(unsigned char) ReadBlobByte(image);\n  tga_info.attributes=(unsigned char) ReadBlobByte(image);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n  if ((((tga_info.bits_per_pixel <= 1) || (tga_info.bits_per_pixel >= 17)) &&\n       (tga_info.bits_per_pixel != 24) && (tga_info.bits_per_pixel != 32)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  /*\n    Initialize image structure.\n  */\n  image->columns=tga_info.width;\n  image->rows=tga_info.height;\n  alpha_bits=(tga_info.attributes & 0x0FU);\n  image->alpha_trait=(alpha_bits > 0) || (tga_info.bits_per_pixel == 32) ||\n    (tga_info.colormap_size == 32) ?  BlendPixelTrait : UndefinedPixelTrait;\n  if ((tga_info.image_type != TGAColormap) &&\n      (tga_info.image_type != TGARLEColormap))\n    image->depth=(size_t) ((tga_info.bits_per_pixel <= 8) ? 8 :\n      (tga_info.bits_per_pixel <= 16) ? 5 : 8);\n  else\n    image->depth=(size_t) ((tga_info.colormap_size <= 8) ? 8 :\n      (tga_info.colormap_size <= 16) ? 5 : 8);\n  if ((tga_info.image_type == TGAColormap) ||\n      (tga_info.image_type == TGAMonochrome) ||\n      (tga_info.image_type == TGARLEColormap) ||\n      (tga_info.image_type == TGARLEMonochrome))\n    image->storage_class=PseudoClass;\n  image->compression=NoCompression;\n  if ((tga_info.image_type == TGARLEColormap) ||\n      (tga_info.image_type == TGARLEMonochrome) ||\n      (tga_info.image_type == TGARLERGB))\n    image->compression=RLECompression;\n  if (image->storage_class == PseudoClass)\n    {\n      if (tga_info.colormap_type != 0)\n        image->colors=tga_info.colormap_index+tga_info.colormap_length;\n      else\n        {\n          size_t\n            one;\n\n          one=1;\n          image->colors=one << tga_info.bits_per_pixel;\n          if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n    }\n  if (tga_info.id_length != 0)\n    {\n      char\n        *comment;\n\n      size_t\n        length;\n\n      /*\n        TGA image comment.\n      */\n      length=(size_t) tga_info.id_length;\n      comment=(char *) NULL;\n      if (~length >= (MagickPathExtent-1))\n        comment=(char *) AcquireQuantumMemory(length+MagickPathExtent,\n          sizeof(*comment));\n      if (comment == (char *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      count=ReadBlob(image,tga_info.id_length,(unsigned char *) comment);\n      comment[tga_info.id_length]='\\0';\n      (void) SetImageProperty(image,\"comment\",comment,exception);\n      comment=DestroyString(comment);\n    }\n  if (tga_info.attributes & (1UL << 4))\n    {\n      if (tga_info.attributes & (1UL << 5))\n        SetImageArtifact(image,\"tga:image-origin\",\"TopRight\");\n      else\n        SetImageArtifact(image,\"tga:image-origin\",\"BottomRight\");\n    }\n  else\n    {\n      if (tga_info.attributes & (1UL << 5))\n        SetImageArtifact(image,\"tga:image-origin\",\"TopLeft\");\n      else\n        SetImageArtifact(image,\"tga:image-origin\",\"BottomLeft\");\n    }\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(image);\n    }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  (void) ResetMagickMemory(&pixel,0,sizeof(pixel));\n  pixel.alpha=(MagickRealType) OpaqueAlpha;\n  if (tga_info.colormap_type != 0)\n    {\n      /*\n        Read TGA raster colormap.\n      */\n      if (image->colors < tga_info.colormap_index)\n        image->colors=tga_info.colormap_index;\n      if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      for (i=0; i < (ssize_t) tga_info.colormap_index; i++)\n        image->colormap[i]=pixel;\n      for ( ; i < (ssize_t) image->colors; i++)\n      {\n        switch (tga_info.colormap_size)\n        {\n          case 8:\n          default:\n          {\n            /*\n              Gray scale.\n            */\n            pixel.red=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            pixel.green=pixel.red;\n            pixel.blue=pixel.red;\n            break;\n          }\n          case 15:\n          case 16:\n          {\n            QuantumAny\n              range;\n\n            /*\n              5 bits each of red green and blue.\n            */\n            j=(unsigned char) ReadBlobByte(image);\n            k=(unsigned char) ReadBlobByte(image);\n            range=GetQuantumRange(5UL);\n            pixel.red=(MagickRealType) ScaleAnyToQuantum(1UL*(k & 0x7c) >> 2,\n              range);\n            pixel.green=(MagickRealType) ScaleAnyToQuantum((1UL*(k & 0x03)\n              << 3)+(1UL*(j & 0xe0) >> 5),range);\n            pixel.blue=(MagickRealType) ScaleAnyToQuantum(1UL*(j & 0x1f),range);\n            break;\n          }\n          case 24:\n          {\n            /*\n              8 bits each of blue, green and red.\n            */\n            pixel.blue=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            pixel.green=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            pixel.red=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            break;\n          }\n          case 32:\n          {\n            /*\n              8 bits each of blue, green, red, and alpha.\n            */\n            pixel.blue=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            pixel.green=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            pixel.red=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            pixel.alpha=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            break;\n          }\n        }\n        image->colormap[i]=pixel;\n      }\n    }\n  /*\n    Convert TGA pixels to pixel packets.\n  */\n  base=0;\n  flag=0;\n  skip=MagickFalse;\n  real=0;\n  index=0;\n  runlength=0;\n  offset=0;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    real=offset;\n    if (((unsigned char) (tga_info.attributes & 0x20) >> 5) == 0)\n      real=image->rows-real-1;\n    q=QueueAuthenticPixels(image,0,(ssize_t) real,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if ((tga_info.image_type == TGARLEColormap) ||\n          (tga_info.image_type == TGARLERGB) ||\n          (tga_info.image_type == TGARLEMonochrome))\n        {\n          if (runlength != 0)\n            {\n              runlength--;\n              skip=flag != 0;\n            }\n          else\n            {\n              count=ReadBlob(image,1,&runlength);\n              if (count != 1)\n                ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n              flag=runlength & 0x80;\n              if (flag != 0)\n                runlength-=128;\n              skip=MagickFalse;\n            }\n        }\n      if (skip == MagickFalse)\n        switch (tga_info.bits_per_pixel)\n        {\n          case 8:\n          default:\n          {\n            /*\n              Gray scale.\n            */\n            index=(Quantum) ReadBlobByte(image);\n            if (tga_info.colormap_type != 0)\n              pixel=image->colormap[(ssize_t) ConstrainColormapIndex(image,\n                (ssize_t) index,exception)];\n            else\n              {\n                pixel.red=(MagickRealType) ScaleCharToQuantum((unsigned char)\n                  index);\n                pixel.green=(MagickRealType) ScaleCharToQuantum((unsigned char)\n                  index);\n                pixel.blue=(MagickRealType) ScaleCharToQuantum((unsigned char)\n                  index);\n              }\n            break;\n          }\n          case 15:\n          case 16:\n          {\n            QuantumAny\n              range;\n\n            /*\n              5 bits each of RGB.\n            */\n            if (ReadBlob(image,2,pixels) != 2)\n              ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n            j=pixels[0];\n            k=pixels[1];\n            range=GetQuantumRange(5UL);\n            pixel.red=(MagickRealType) ScaleAnyToQuantum(1UL*(k & 0x7c) >> 2,\n              range);\n            pixel.green=(MagickRealType) ScaleAnyToQuantum((1UL*\n              (k & 0x03) << 3)+(1UL*(j & 0xe0) >> 5),range);\n            pixel.blue=(MagickRealType) ScaleAnyToQuantum(1UL*(j & 0x1f),range);\n            if (image->alpha_trait != UndefinedPixelTrait)\n              pixel.alpha=(MagickRealType) ((k & 0x80) == 0 ? (Quantum)\n                TransparentAlpha : (Quantum) OpaqueAlpha);\n            if (image->storage_class == PseudoClass)\n              index=(Quantum) ConstrainColormapIndex(image,((ssize_t) (k << 8))+\n                j,exception);\n            break;\n          }\n          case 24:\n          {\n            /*\n              BGR pixels.\n            */\n            if (ReadBlob(image,3,pixels) != 3)\n              ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n            pixel.blue=(MagickRealType) ScaleCharToQuantum(pixels[0]);\n            pixel.green=(MagickRealType) ScaleCharToQuantum(pixels[1]);\n            pixel.red=(MagickRealType) ScaleCharToQuantum(pixels[2]);\n            break;\n          }\n          case 32:\n          {\n            /*\n              BGRA pixels.\n            */\n            if (ReadBlob(image,4,pixels) != 4)\n              ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n            pixel.blue=(MagickRealType) ScaleCharToQuantum(pixels[0]);\n            pixel.green=(MagickRealType) ScaleCharToQuantum(pixels[1]);\n            pixel.red=(MagickRealType) ScaleCharToQuantum(pixels[2]);\n            pixel.alpha=(MagickRealType) ScaleCharToQuantum(pixels[3]);\n            break;\n          }\n        }\n      if (status == MagickFalse)\n        ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n      if (image->storage_class == PseudoClass)\n        SetPixelIndex(image,index,q);\n      SetPixelRed(image,ClampToQuantum(pixel.red),q);\n      SetPixelGreen(image,ClampToQuantum(pixel.green),q);\n      SetPixelBlue(image,ClampToQuantum(pixel.blue),q);\n      if (image->alpha_trait != UndefinedPixelTrait)\n        SetPixelAlpha(image,ClampToQuantum(pixel.alpha),q);\n      q+=GetPixelChannels(image);\n    }\n    /*\n      if (((unsigned char) (tga_info.attributes & 0xc0) >> 6) == 4)\n        offset+=4;\n      else\n    */\n      if (((unsigned char) (tga_info.attributes & 0xc0) >> 6) == 2)\n        offset+=2;\n      else\n        offset++;\n    if (offset >= image->rows)\n      {\n        base++;\n        offset=base;\n      }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    if (image->previous == (Image *) NULL)\n      {\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}", "func_hash": 95115433929731884744054008378657506459, "file_name": "tga.c", "file_hash": 229955351147198147579545037524450823231, "cwe": ["CWE-772"], "cve": "CVE-2017-11170", "cve_desc": "The ReadTGAImage function in coders\\tga.c in ImageMagick 7.0.5-6 has a memory leak vulnerability that can cause memory exhaustion via invalid colors data in the header of a TGA or VST file.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-11170", "file_path": "coders/tga.c"}
{"idx": 338747, "project": "ImageMagick", "commit_id": "fbb5e1c8211c4e88ecc367e784b79d457c300d6d", "project_url": "https://github.com/ImageMagick/ImageMagick", "commit_url": "https://github.com/ImageMagick/ImageMagick/commit/fbb5e1c8211c4e88ecc367e784b79d457c300d6d", "commit_message": "...", "target": 0, "func": "static Image *ReadTGAImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  PixelInfo\n    pixel;\n\n  Quantum\n    index;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  size_t\n    base,\n    flag,\n    offset,\n    real,\n    skip;\n\n  ssize_t\n    count,\n    y;\n\n  TGAInfo\n    tga_info;\n\n  unsigned char\n    j,\n    k,\n    pixels[4],\n    runlength;\n\n  unsigned int\n    alpha_bits;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read TGA header information.\n  */\n  count=ReadBlob(image,1,&tga_info.id_length);\n  tga_info.colormap_type=(unsigned char) ReadBlobByte(image);\n  tga_info.image_type=(TGAImageType) ReadBlobByte(image);\n  if ((count != 1) ||\n      ((tga_info.image_type != TGAColormap) &&\n       (tga_info.image_type != TGARGB) &&\n       (tga_info.image_type != TGAMonochrome) &&\n       (tga_info.image_type != TGARLEColormap) &&\n       (tga_info.image_type != TGARLERGB) &&\n       (tga_info.image_type != TGARLEMonochrome)) ||\n      (((tga_info.image_type == TGAColormap) ||\n       (tga_info.image_type == TGARLEColormap)) &&\n       (tga_info.colormap_type == 0)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  tga_info.colormap_index=ReadBlobLSBShort(image);\n  tga_info.colormap_length=ReadBlobLSBShort(image);\n  tga_info.colormap_size=(unsigned char) ReadBlobByte(image);\n  tga_info.x_origin=ReadBlobLSBShort(image);\n  tga_info.y_origin=ReadBlobLSBShort(image);\n  tga_info.width=(unsigned short) ReadBlobLSBShort(image);\n  tga_info.height=(unsigned short) ReadBlobLSBShort(image);\n  tga_info.bits_per_pixel=(unsigned char) ReadBlobByte(image);\n  tga_info.attributes=(unsigned char) ReadBlobByte(image);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n  if ((((tga_info.bits_per_pixel <= 1) || (tga_info.bits_per_pixel >= 17)) &&\n       (tga_info.bits_per_pixel != 24) && (tga_info.bits_per_pixel != 32)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  /*\n    Initialize image structure.\n  */\n  image->columns=tga_info.width;\n  image->rows=tga_info.height;\n  alpha_bits=(tga_info.attributes & 0x0FU);\n  image->alpha_trait=(alpha_bits > 0) || (tga_info.bits_per_pixel == 32) ||\n    (tga_info.colormap_size == 32) ?  BlendPixelTrait : UndefinedPixelTrait;\n  if ((tga_info.image_type != TGAColormap) &&\n      (tga_info.image_type != TGARLEColormap))\n    image->depth=(size_t) ((tga_info.bits_per_pixel <= 8) ? 8 :\n      (tga_info.bits_per_pixel <= 16) ? 5 : 8);\n  else\n    image->depth=(size_t) ((tga_info.colormap_size <= 8) ? 8 :\n      (tga_info.colormap_size <= 16) ? 5 : 8);\n  if ((tga_info.image_type == TGAColormap) ||\n      (tga_info.image_type == TGAMonochrome) ||\n      (tga_info.image_type == TGARLEColormap) ||\n      (tga_info.image_type == TGARLEMonochrome))\n    image->storage_class=PseudoClass;\n  image->compression=NoCompression;\n  if ((tga_info.image_type == TGARLEColormap) ||\n      (tga_info.image_type == TGARLEMonochrome) ||\n      (tga_info.image_type == TGARLERGB))\n    image->compression=RLECompression;\n  if (image->storage_class == PseudoClass)\n    {\n      if (tga_info.colormap_type != 0)\n        image->colors=tga_info.colormap_index+tga_info.colormap_length;\n      else\n        {\n          size_t\n            one;\n\n          one=1;\n          image->colors=one << tga_info.bits_per_pixel;\n          if (image->colors > ((~0UL)/sizeof(*image->colormap)))\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n          if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n    }\n  if (tga_info.id_length != 0)\n    {\n      char\n        *comment;\n\n      size_t\n        length;\n\n      /*\n        TGA image comment.\n      */\n      length=(size_t) tga_info.id_length;\n      comment=(char *) NULL;\n      if (~length >= (MagickPathExtent-1))\n        comment=(char *) AcquireQuantumMemory(length+MagickPathExtent,\n          sizeof(*comment));\n      if (comment == (char *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      count=ReadBlob(image,tga_info.id_length,(unsigned char *) comment);\n      comment[tga_info.id_length]='\\0';\n      (void) SetImageProperty(image,\"comment\",comment,exception);\n      comment=DestroyString(comment);\n    }\n  if (tga_info.attributes & (1UL << 4))\n    {\n      if (tga_info.attributes & (1UL << 5))\n        SetImageArtifact(image,\"tga:image-origin\",\"TopRight\");\n      else\n        SetImageArtifact(image,\"tga:image-origin\",\"BottomRight\");\n    }\n  else\n    {\n      if (tga_info.attributes & (1UL << 5))\n        SetImageArtifact(image,\"tga:image-origin\",\"TopLeft\");\n      else\n        SetImageArtifact(image,\"tga:image-origin\",\"BottomLeft\");\n    }\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(image);\n    }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  (void) ResetMagickMemory(&pixel,0,sizeof(pixel));\n  pixel.alpha=(MagickRealType) OpaqueAlpha;\n  if (tga_info.colormap_type != 0)\n    {\n      /*\n        Read TGA raster colormap.\n      */\n      if (image->colors < tga_info.colormap_index)\n        image->colors=tga_info.colormap_index;\n      if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      for (i=0; i < (ssize_t) tga_info.colormap_index; i++)\n        image->colormap[i]=pixel;\n      for ( ; i < (ssize_t) image->colors; i++)\n      {\n        switch (tga_info.colormap_size)\n        {\n          case 8:\n          default:\n          {\n            /*\n              Gray scale.\n            */\n            pixel.red=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            pixel.green=pixel.red;\n            pixel.blue=pixel.red;\n            break;\n          }\n          case 15:\n          case 16:\n          {\n            QuantumAny\n              range;\n\n            /*\n              5 bits each of red green and blue.\n            */\n            j=(unsigned char) ReadBlobByte(image);\n            k=(unsigned char) ReadBlobByte(image);\n            range=GetQuantumRange(5UL);\n            pixel.red=(MagickRealType) ScaleAnyToQuantum(1UL*(k & 0x7c) >> 2,\n              range);\n            pixel.green=(MagickRealType) ScaleAnyToQuantum((1UL*(k & 0x03)\n              << 3)+(1UL*(j & 0xe0) >> 5),range);\n            pixel.blue=(MagickRealType) ScaleAnyToQuantum(1UL*(j & 0x1f),range);\n            break;\n          }\n          case 24:\n          {\n            /*\n              8 bits each of blue, green and red.\n            */\n            pixel.blue=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            pixel.green=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            pixel.red=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            break;\n          }\n          case 32:\n          {\n            /*\n              8 bits each of blue, green, red, and alpha.\n            */\n            pixel.blue=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            pixel.green=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            pixel.red=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            pixel.alpha=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            break;\n          }\n        }\n        image->colormap[i]=pixel;\n      }\n    }\n  /*\n    Convert TGA pixels to pixel packets.\n  */\n  base=0;\n  flag=0;\n  skip=MagickFalse;\n  real=0;\n  index=0;\n  runlength=0;\n  offset=0;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    real=offset;\n    if (((unsigned char) (tga_info.attributes & 0x20) >> 5) == 0)\n      real=image->rows-real-1;\n    q=QueueAuthenticPixels(image,0,(ssize_t) real,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if ((tga_info.image_type == TGARLEColormap) ||\n          (tga_info.image_type == TGARLERGB) ||\n          (tga_info.image_type == TGARLEMonochrome))\n        {\n          if (runlength != 0)\n            {\n              runlength--;\n              skip=flag != 0;\n            }\n          else\n            {\n              count=ReadBlob(image,1,&runlength);\n              if (count != 1)\n                ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n              flag=runlength & 0x80;\n              if (flag != 0)\n                runlength-=128;\n              skip=MagickFalse;\n            }\n        }\n      if (skip == MagickFalse)\n        switch (tga_info.bits_per_pixel)\n        {\n          case 8:\n          default:\n          {\n            /*\n              Gray scale.\n            */\n            index=(Quantum) ReadBlobByte(image);\n            if (tga_info.colormap_type != 0)\n              pixel=image->colormap[(ssize_t) ConstrainColormapIndex(image,\n                (ssize_t) index,exception)];\n            else\n              {\n                pixel.red=(MagickRealType) ScaleCharToQuantum((unsigned char)\n                  index);\n                pixel.green=(MagickRealType) ScaleCharToQuantum((unsigned char)\n                  index);\n                pixel.blue=(MagickRealType) ScaleCharToQuantum((unsigned char)\n                  index);\n              }\n            break;\n          }\n          case 15:\n          case 16:\n          {\n            QuantumAny\n              range;\n\n            /*\n              5 bits each of RGB.\n            */\n            if (ReadBlob(image,2,pixels) != 2)\n              ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n            j=pixels[0];\n            k=pixels[1];\n            range=GetQuantumRange(5UL);\n            pixel.red=(MagickRealType) ScaleAnyToQuantum(1UL*(k & 0x7c) >> 2,\n              range);\n            pixel.green=(MagickRealType) ScaleAnyToQuantum((1UL*\n              (k & 0x03) << 3)+(1UL*(j & 0xe0) >> 5),range);\n            pixel.blue=(MagickRealType) ScaleAnyToQuantum(1UL*(j & 0x1f),range);\n            if (image->alpha_trait != UndefinedPixelTrait)\n              pixel.alpha=(MagickRealType) ((k & 0x80) == 0 ? (Quantum)\n                TransparentAlpha : (Quantum) OpaqueAlpha);\n            if (image->storage_class == PseudoClass)\n              index=(Quantum) ConstrainColormapIndex(image,((ssize_t) (k << 8))+\n                j,exception);\n            break;\n          }\n          case 24:\n          {\n            /*\n              BGR pixels.\n            */\n            if (ReadBlob(image,3,pixels) != 3)\n              ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n            pixel.blue=(MagickRealType) ScaleCharToQuantum(pixels[0]);\n            pixel.green=(MagickRealType) ScaleCharToQuantum(pixels[1]);\n            pixel.red=(MagickRealType) ScaleCharToQuantum(pixels[2]);\n            break;\n          }\n          case 32:\n          {\n            /*\n              BGRA pixels.\n            */\n            if (ReadBlob(image,4,pixels) != 4)\n              ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n            pixel.blue=(MagickRealType) ScaleCharToQuantum(pixels[0]);\n            pixel.green=(MagickRealType) ScaleCharToQuantum(pixels[1]);\n            pixel.red=(MagickRealType) ScaleCharToQuantum(pixels[2]);\n            pixel.alpha=(MagickRealType) ScaleCharToQuantum(pixels[3]);\n            break;\n          }\n        }\n      if (status == MagickFalse)\n        ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n      if (image->storage_class == PseudoClass)\n        SetPixelIndex(image,index,q);\n      SetPixelRed(image,ClampToQuantum(pixel.red),q);\n      SetPixelGreen(image,ClampToQuantum(pixel.green),q);\n      SetPixelBlue(image,ClampToQuantum(pixel.blue),q);\n      if (image->alpha_trait != UndefinedPixelTrait)\n        SetPixelAlpha(image,ClampToQuantum(pixel.alpha),q);\n      q+=GetPixelChannels(image);\n    }\n    /*\n      if (((unsigned char) (tga_info.attributes & 0xc0) >> 6) == 4)\n        offset+=4;\n      else\n    */\n      if (((unsigned char) (tga_info.attributes & 0xc0) >> 6) == 2)\n        offset+=2;\n      else\n        offset++;\n    if (offset >= image->rows)\n      {\n        base++;\n        offset=base;\n      }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    if (image->previous == (Image *) NULL)\n      {\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}", "func_hash": 175791113381074585644433899536597352981, "file_name": "tga.c", "file_hash": 184535518978867885654371830775021710506, "cwe": ["CWE-772"], "cve": "CVE-2017-11170", "cve_desc": "The ReadTGAImage function in coders\\tga.c in ImageMagick 7.0.5-6 has a memory leak vulnerability that can cause memory exhaustion via invalid colors data in the header of a TGA or VST file.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-11170", "file_path": "coders/tga.c"}
{"idx": 202783, "project": "php-src", "commit_id": "37da90248deb2188e8ee50e4753ad6340679b425", "project_url": "https://github.com/php/php-src", "commit_url": "http://git.php.net/?p=php-src.git;a=commitdiff;h=37da90248deb2188e8ee50e4753ad6340679b425", "commit_message": "Added missing allocation checks", "target": 1, "func": "static Bigint * Balloc(int k)\n{\n\tint x;\n\tBigint *rv;\n\n\t_THREAD_PRIVATE_MUTEX_LOCK(dtoa_mutex);\n\tif ((rv = freelist[k])) {\n\t\tfreelist[k] = rv->next;\n\t} else {\n\t\tx = 1 << k;\n\t\trv = (Bigint *)MALLOC(sizeof(Bigint) + (x-1)*sizeof(Long));\n\t\trv->k = k;\n\t\trv->maxwds = x;\n\t}\n\t_THREAD_PRIVATE_MUTEX_UNLOCK(dtoa_mutex);\n\trv->sign = rv->wds = 0;\n\treturn rv;\n}", "func_hash": 233883423838019694196347564918158945680, "file_name": "zend_strtod.c", "file_hash": 162225586697792700551271623353891886066, "cwe": ["CWE-119"], "cve": "CVE-2009-0689", "cve_desc": "Array index error in the (1) dtoa implementation in dtoa.c (aka pdtoa.c) and the (2) gdtoa (aka new dtoa) implementation in gdtoa/misc.c in libc, as used in multiple operating systems and products including in FreeBSD 6.4 and 7.2, NetBSD 5.0, OpenBSD 4.5, Mozilla Firefox 3.0.x before 3.0.15 and 3.5.x before 3.5.4, K-Meleon 1.5.3, SeaMonkey 1.1.8, and other products, allows context-dependent attackers to cause a denial of service (application crash) and possibly execute arbitrary code via a large precision value in the format argument to a printf function, which triggers incorrect memory allocation and a heap-based buffer overflow during conversion to a floating-point number.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2009-0689", "file_path": "Zend/zend_strtod.c"}
{"idx": 339712, "project": "php-src", "commit_id": "37da90248deb2188e8ee50e4753ad6340679b425", "project_url": "https://github.com/php/php-src", "commit_url": "http://git.php.net/?p=php-src.git;a=commitdiff;h=37da90248deb2188e8ee50e4753ad6340679b425", "commit_message": "Added missing allocation checks", "target": 0, "func": "static Bigint * Balloc(int k)\n{\n\tint x;\n\tBigint *rv;\n\n\tif (k > Kmax) {\n\t\tzend_error(E_ERROR, \"Balloc() allocation exceeds list boundary\");\n\t}\n\n\t_THREAD_PRIVATE_MUTEX_LOCK(dtoa_mutex);\n\tif ((rv = freelist[k])) {\n\t\tfreelist[k] = rv->next;\n\t} else {\n\t\tx = 1 << k;\n\t\trv = (Bigint *)MALLOC(sizeof(Bigint) + (x-1)*sizeof(Long));\n\t\tif (!rv) {\n\t\t\t_THREAD_PRIVATE_MUTEX_UNLOCK(dtoa_mutex);\n\t\t\tzend_error(E_ERROR, \"Balloc() failed to allocate memory\");\n\t\t}\n\t\trv->k = k;\n\t\trv->maxwds = x;\n\t}\n\t_THREAD_PRIVATE_MUTEX_UNLOCK(dtoa_mutex);\n\trv->sign = rv->wds = 0;\n\treturn rv;\n}", "func_hash": 126877960775748554954774287335252576908, "file_name": "zend_strtod.c", "file_hash": 330178516637592595167149550690737234647, "cwe": ["CWE-119"], "cve": "CVE-2009-0689", "cve_desc": "Array index error in the (1) dtoa implementation in dtoa.c (aka pdtoa.c) and the (2) gdtoa (aka new dtoa) implementation in gdtoa/misc.c in libc, as used in multiple operating systems and products including in FreeBSD 6.4 and 7.2, NetBSD 5.0, OpenBSD 4.5, Mozilla Firefox 3.0.x before 3.0.15 and 3.5.x before 3.5.4, K-Meleon 1.5.3, SeaMonkey 1.1.8, and other products, allows context-dependent attackers to cause a denial of service (application crash) and possibly execute arbitrary code via a large precision value in the format argument to a printf function, which triggers incorrect memory allocation and a heap-based buffer overflow during conversion to a floating-point number.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2009-0689", "file_path": "Zend/zend_strtod.c"}
{"idx": 202822, "project": "ghostpdl", "commit_id": "5d499272b95a6b890a1397e11d20937de000d31b", "project_url": "https://github.com/ArtifexSoftware/ghostpdl", "commit_url": "https://github.com/ArtifexSoftware/ghostpdl/commit/5d499272b95a6b890a1397e11d20937de000d31b", "commit_message": "Bug 702582, CVE 2020-15900 Memory Corruption in Ghostscript 9.52\n\nFix the 'rsearch' calculation for the 'post' size to give the correct\nsize.  Previous calculation would result in a size that was too large,\nand could underflow to max uint32_t. Also fix 'rsearch' to return the\ncorrect 'pre' string with empty string match.\n\nA future change may 'undefine' this undocumented, non-standard operator\nduring initialization as we do with the many other non-standard internal\nPostScript operators and procedures.", "target": 1, "func": "search_impl(i_ctx_t *i_ctx_p, bool forward)\n{\n    os_ptr op = osp;\n    os_ptr op1 = op - 1;\n    uint size = r_size(op);\n    uint count;\n    byte *pat;\n    byte *ptr;\n    byte ch;\n    int incr = forward ? 1 : -1;\n\n    check_read_type(*op1, t_string);\n    check_read_type(*op, t_string);\n    if (size > r_size(op1)) {\t/* can't match */\n        make_false(op);\n        return 0;\n    }\n    count = r_size(op1) - size;\n    ptr = op1->value.bytes;\n    if (size == 0)\n        goto found;\n    if (!forward)\n        ptr += count;\n    pat = op->value.bytes;\n    ch = pat[0];\n    do {\n        if (*ptr == ch && (size == 1 || !memcmp(ptr, pat, size)))\n            goto found;\n        ptr += incr;\n    }\n    while (count--);\n    /* No match */\n    make_false(op);\n    return 0;\nfound:\n    op->tas.type_attrs = op1->tas.type_attrs;\n    op->value.bytes = ptr;\n    r_set_size(op, size);\n    push(2);\n    op[-1] = *op1;\n    r_set_size(op - 1, ptr - op[-1].value.bytes);\n    op1->value.bytes = ptr + size;\n    r_set_size(op1, count + (!forward ? (size - 1) : 0));\n    make_true(op);\n    return 0;\n}", "func_hash": 86939516891110967185620104740052162316, "file_name": "zstring.c", "file_hash": 72939855407215089106002168079796587202, "cwe": ["CWE-787"], "cve": "CVE-2020-15900", "cve_desc": "A memory corruption issue was found in Artifex Ghostscript 9.50 and 9.52. Use of a non-standard PostScript operator can allow overriding of file access controls. The 'rsearch' calculation for the 'post' size resulted in a size that was too large, and could underflow to max uint32_t. This was fixed in commit 5d499272b95a6b890a1397e11d20937de000d31b.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2020-15900", "file_path": "psi/zstring.c"}
{"idx": 341817, "project": "ghostpdl", "commit_id": "5d499272b95a6b890a1397e11d20937de000d31b", "project_url": "https://github.com/ArtifexSoftware/ghostpdl", "commit_url": "https://github.com/ArtifexSoftware/ghostpdl/commit/5d499272b95a6b890a1397e11d20937de000d31b", "commit_message": "Bug 702582, CVE 2020-15900 Memory Corruption in Ghostscript 9.52\n\nFix the 'rsearch' calculation for the 'post' size to give the correct\nsize.  Previous calculation would result in a size that was too large,\nand could underflow to max uint32_t. Also fix 'rsearch' to return the\ncorrect 'pre' string with empty string match.\n\nA future change may 'undefine' this undocumented, non-standard operator\nduring initialization as we do with the many other non-standard internal\nPostScript operators and procedures.", "target": 0, "func": "search_impl(i_ctx_t *i_ctx_p, bool forward)\n{\n    os_ptr op = osp;\n    os_ptr op1 = op - 1;\n    uint size = r_size(op);\n    uint count;\n    byte *pat;\n    byte *ptr;\n    byte ch;\n    int incr = forward ? 1 : -1;\n\n    check_read_type(*op1, t_string);\n    check_read_type(*op, t_string);\n    if (size > r_size(op1)) {\t/* can't match */\n        make_false(op);\n        return 0;\n    }\n    count = r_size(op1) - size;\n    ptr = op1->value.bytes;\n    if (size == 0)\n        goto found;\n    if (!forward)\n        ptr += count;\n    pat = op->value.bytes;\n    ch = pat[0];\n    do {\n        if (*ptr == ch && (size == 1 || !memcmp(ptr, pat, size)))\n            goto found;\n        ptr += incr;\n    }\n    while (count--);\n    /* No match */\n    make_false(op);\n    return 0;\nfound:\n    op->tas.type_attrs = op1->tas.type_attrs;\n    op->value.bytes = ptr;\t\t\t\t/* match */\n    op->tas.rsize = size;\t\t\t\t/* match */\n    push(2);\n    op[-1] = *op1;\t\t\t\t\t/* pre */\n    op[-3].value.bytes = ptr + size;\t\t\t/* post */\n    if (forward) {\n        op[-1].tas.rsize = ptr - op[-1].value.bytes;\t/* pre */\n        op[-3].tas.rsize = count;\t\t\t/* post */\n    } else {\n        op[-1].tas.rsize = count;\t\t\t/* pre */\n        op[-3].tas.rsize -= count + size;\t\t/* post */\n    }\n    make_true(op);\n    return 0;\n}", "func_hash": 122691468476432977214258761853397783174, "file_name": "zstring.c", "file_hash": 242560896359670915428991047058679210834, "cwe": ["CWE-787"], "cve": "CVE-2020-15900", "cve_desc": "A memory corruption issue was found in Artifex Ghostscript 9.50 and 9.52. Use of a non-standard PostScript operator can allow overriding of file access controls. The 'rsearch' calculation for the 'post' size resulted in a size that was too large, and could underflow to max uint32_t. This was fixed in commit 5d499272b95a6b890a1397e11d20937de000d31b.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2020-15900", "file_path": "psi/zstring.c"}
{"idx": 202888, "project": "linux", "commit_id": "ebe48d368e97d007bfeb76fcb065d6cfc4c96645", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/ebe48d368e97d007bfeb76fcb065d6cfc4c96645", "commit_message": "esp: Fix possible buffer overflow in ESP transformation\n\nThe maximum message size that can be send is bigger than\nthe  maximum site that skb_page_frag_refill can allocate.\nSo it is possible to write beyond the allocated buffer.\n\nFix this by doing a fallback to COW in that case.\n\nv2:\n\nAvoid get get_order() costs as suggested by Linus Torvalds.\n\nFixes: cac2661c53f3 (\"esp4: Avoid skb_cow_data whenever possible\")\nFixes: 03e2a30f6a27 (\"esp6: Avoid skb_cow_data whenever possible\")\nReported-by: valis <sec@valis.email>\nSigned-off-by: Steffen Klassert <steffen.klassert@secunet.com>", "target": 1, "func": "int esp_output_head(struct xfrm_state *x, struct sk_buff *skb, struct esp_info *esp)\n{\n\tu8 *tail;\n\tint nfrags;\n\tint esph_offset;\n\tstruct page *page;\n\tstruct sk_buff *trailer;\n\tint tailen = esp->tailen;\n\n\t/* this is non-NULL only with TCP/UDP Encapsulation */\n\tif (x->encap) {\n\t\tint err = esp_output_encap(x, skb, esp);\n\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (!skb_cloned(skb)) {\n\t\tif (tailen <= skb_tailroom(skb)) {\n\t\t\tnfrags = 1;\n\t\t\ttrailer = skb;\n\t\t\ttail = skb_tail_pointer(trailer);\n\n\t\t\tgoto skip_cow;\n\t\t} else if ((skb_shinfo(skb)->nr_frags < MAX_SKB_FRAGS)\n\t\t\t   && !skb_has_frag_list(skb)) {\n\t\t\tint allocsize;\n\t\t\tstruct sock *sk = skb->sk;\n\t\t\tstruct page_frag *pfrag = &x->xfrag;\n\n\t\t\tesp->inplace = false;\n\n\t\t\tallocsize = ALIGN(tailen, L1_CACHE_BYTES);\n\n\t\t\tspin_lock_bh(&x->lock);\n\n\t\t\tif (unlikely(!skb_page_frag_refill(allocsize, pfrag, GFP_ATOMIC))) {\n\t\t\t\tspin_unlock_bh(&x->lock);\n\t\t\t\tgoto cow;\n\t\t\t}\n\n\t\t\tpage = pfrag->page;\n\t\t\tget_page(page);\n\n\t\t\ttail = page_address(page) + pfrag->offset;\n\n\t\t\tesp_output_fill_trailer(tail, esp->tfclen, esp->plen, esp->proto);\n\n\t\t\tnfrags = skb_shinfo(skb)->nr_frags;\n\n\t\t\t__skb_fill_page_desc(skb, nfrags, page, pfrag->offset,\n\t\t\t\t\t     tailen);\n\t\t\tskb_shinfo(skb)->nr_frags = ++nfrags;\n\n\t\t\tpfrag->offset = pfrag->offset + allocsize;\n\n\t\t\tspin_unlock_bh(&x->lock);\n\n\t\t\tnfrags++;\n\n\t\t\tskb->len += tailen;\n\t\t\tskb->data_len += tailen;\n\t\t\tskb->truesize += tailen;\n\t\t\tif (sk && sk_fullsock(sk))\n\t\t\t\trefcount_add(tailen, &sk->sk_wmem_alloc);\n\n\t\t\tgoto out;\n\t\t}\n\t}\n\ncow:\n\tesph_offset = (unsigned char *)esp->esph - skb_transport_header(skb);\n\n\tnfrags = skb_cow_data(skb, tailen, &trailer);\n\tif (nfrags < 0)\n\t\tgoto out;\n\ttail = skb_tail_pointer(trailer);\n\tesp->esph = (struct ip_esp_hdr *)(skb_transport_header(skb) + esph_offset);\n\nskip_cow:\n\tesp_output_fill_trailer(tail, esp->tfclen, esp->plen, esp->proto);\n\tpskb_put(skb, trailer, tailen);\n\nout:\n\treturn nfrags;\n}", "func_hash": 111996591465481135953474754686135159337, "file_name": "esp4.c", "file_hash": 169926453254442983322582759592161291384, "cwe": ["CWE-787"], "cve": "CVE-2022-27666", "cve_desc": "A heap buffer overflow flaw was found in IPsec ESP transformation code in net/ipv4/esp4.c and net/ipv6/esp6.c. This flaw allows a local attacker with a normal user privilege to overwrite kernel heap objects and may cause a local privilege escalation threat.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-27666", "file_path": "net/ipv4/esp4.c"}
{"idx": 343175, "project": "linux", "commit_id": "ebe48d368e97d007bfeb76fcb065d6cfc4c96645", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/ebe48d368e97d007bfeb76fcb065d6cfc4c96645", "commit_message": "esp: Fix possible buffer overflow in ESP transformation\n\nThe maximum message size that can be send is bigger than\nthe  maximum site that skb_page_frag_refill can allocate.\nSo it is possible to write beyond the allocated buffer.\n\nFix this by doing a fallback to COW in that case.\n\nv2:\n\nAvoid get get_order() costs as suggested by Linus Torvalds.\n\nFixes: cac2661c53f3 (\"esp4: Avoid skb_cow_data whenever possible\")\nFixes: 03e2a30f6a27 (\"esp6: Avoid skb_cow_data whenever possible\")\nReported-by: valis <sec@valis.email>\nSigned-off-by: Steffen Klassert <steffen.klassert@secunet.com>", "target": 0, "func": "int esp_output_head(struct xfrm_state *x, struct sk_buff *skb, struct esp_info *esp)\n{\n\tu8 *tail;\n\tint nfrags;\n\tint esph_offset;\n\tstruct page *page;\n\tstruct sk_buff *trailer;\n\tint tailen = esp->tailen;\n\tunsigned int allocsz;\n\n\t/* this is non-NULL only with TCP/UDP Encapsulation */\n\tif (x->encap) {\n\t\tint err = esp_output_encap(x, skb, esp);\n\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tallocsz = ALIGN(skb->data_len + tailen, L1_CACHE_BYTES);\n\tif (allocsz > ESP_SKB_FRAG_MAXSIZE)\n\t\tgoto cow;\n\n\tif (!skb_cloned(skb)) {\n\t\tif (tailen <= skb_tailroom(skb)) {\n\t\t\tnfrags = 1;\n\t\t\ttrailer = skb;\n\t\t\ttail = skb_tail_pointer(trailer);\n\n\t\t\tgoto skip_cow;\n\t\t} else if ((skb_shinfo(skb)->nr_frags < MAX_SKB_FRAGS)\n\t\t\t   && !skb_has_frag_list(skb)) {\n\t\t\tint allocsize;\n\t\t\tstruct sock *sk = skb->sk;\n\t\t\tstruct page_frag *pfrag = &x->xfrag;\n\n\t\t\tesp->inplace = false;\n\n\t\t\tallocsize = ALIGN(tailen, L1_CACHE_BYTES);\n\n\t\t\tspin_lock_bh(&x->lock);\n\n\t\t\tif (unlikely(!skb_page_frag_refill(allocsize, pfrag, GFP_ATOMIC))) {\n\t\t\t\tspin_unlock_bh(&x->lock);\n\t\t\t\tgoto cow;\n\t\t\t}\n\n\t\t\tpage = pfrag->page;\n\t\t\tget_page(page);\n\n\t\t\ttail = page_address(page) + pfrag->offset;\n\n\t\t\tesp_output_fill_trailer(tail, esp->tfclen, esp->plen, esp->proto);\n\n\t\t\tnfrags = skb_shinfo(skb)->nr_frags;\n\n\t\t\t__skb_fill_page_desc(skb, nfrags, page, pfrag->offset,\n\t\t\t\t\t     tailen);\n\t\t\tskb_shinfo(skb)->nr_frags = ++nfrags;\n\n\t\t\tpfrag->offset = pfrag->offset + allocsize;\n\n\t\t\tspin_unlock_bh(&x->lock);\n\n\t\t\tnfrags++;\n\n\t\t\tskb->len += tailen;\n\t\t\tskb->data_len += tailen;\n\t\t\tskb->truesize += tailen;\n\t\t\tif (sk && sk_fullsock(sk))\n\t\t\t\trefcount_add(tailen, &sk->sk_wmem_alloc);\n\n\t\t\tgoto out;\n\t\t}\n\t}\n\ncow:\n\tesph_offset = (unsigned char *)esp->esph - skb_transport_header(skb);\n\n\tnfrags = skb_cow_data(skb, tailen, &trailer);\n\tif (nfrags < 0)\n\t\tgoto out;\n\ttail = skb_tail_pointer(trailer);\n\tesp->esph = (struct ip_esp_hdr *)(skb_transport_header(skb) + esph_offset);\n\nskip_cow:\n\tesp_output_fill_trailer(tail, esp->tfclen, esp->plen, esp->proto);\n\tpskb_put(skb, trailer, tailen);\n\nout:\n\treturn nfrags;\n}", "func_hash": 32635591870999159240037878048744247169, "file_name": "esp4.c", "file_hash": 243441935638352226599130061922041332693, "cwe": ["CWE-787"], "cve": "CVE-2022-27666", "cve_desc": "A heap buffer overflow flaw was found in IPsec ESP transformation code in net/ipv4/esp4.c and net/ipv6/esp6.c. This flaw allows a local attacker with a normal user privilege to overwrite kernel heap objects and may cause a local privilege escalation threat.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-27666", "file_path": "net/ipv4/esp4.c"}
