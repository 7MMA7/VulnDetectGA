{"idx": 212152, "project": "bash", "commit_id": "951bdaad7a18cc0dc1036bba86b18b90874d39ff", "project_url": "https://github.com/bminor/bash", "commit_url": "https://github.com/bminor/bash/commit/951bdaad7a18cc0dc1036bba86b18b90874d39ff", "commit_message": "commit bash-20190628 snapshot", "target": 1, "func": "disable_priv_mode ()\n{\n  int e;\n\n  if (setuid (current_user.uid) < 0)\n    {\n      e = errno;\n      sys_error (_(\"cannot set uid to %d: effective uid %d\"), current_user.uid, current_user.euid);\n#if defined (EXIT_ON_SETUID_FAILURE)\n      if (e == EAGAIN)\n\texit (e);\n#endif\n    }\n  if (setgid (current_user.gid) < 0)\n    sys_error (_(\"cannot set gid to %d: effective gid %d\"), current_user.gid, current_user.egid);\n\n  current_user.euid = current_user.uid;\n  current_user.egid = current_user.gid;\n}", "func_hash": 247622822404411128670815043239926864688, "file_name": "shell.c", "file_hash": 63031401309370215256197051387367703039, "cwe": ["CWE-787"], "cve": "CVE-2019-18276", "cve_desc": "An issue was discovered in disable_priv_mode in shell.c in GNU Bash through 5.0 patch 11. By default, if Bash is run with its effective UID not equal to its real UID, it will drop privileges by setting its effective UID to its real UID. However, it does so incorrectly. On Linux and other systems that support \"saved UID\" functionality, the saved UID is not dropped. An attacker with command execution in the shell can use \"enable -f\" for runtime loading of a new builtin, which can be a shared object that calls setuid() and therefore regains privileges. However, binaries running with an effective UID of 0 are unaffected.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2019-18276", "file_path": "shell.c"}
{"idx": 455356, "project": "bash", "commit_id": "951bdaad7a18cc0dc1036bba86b18b90874d39ff", "project_url": "https://github.com/bminor/bash", "commit_url": "https://github.com/bminor/bash/commit/951bdaad7a18cc0dc1036bba86b18b90874d39ff", "commit_message": "commit bash-20190628 snapshot", "target": 0, "func": "disable_priv_mode ()\n{\n  int e;\n\n#if HAVE_DECL_SETRESUID\n  if (setresuid (current_user.uid, current_user.uid, current_user.uid) < 0)\n#else\n  if (setuid (current_user.uid) < 0)\n#endif\n    {\n      e = errno;\n      sys_error (_(\"cannot set uid to %d: effective uid %d\"), current_user.uid, current_user.euid);\n#if defined (EXIT_ON_SETUID_FAILURE)\n      if (e == EAGAIN)\n\texit (e);\n#endif\n    }\n#if HAVE_DECL_SETRESGID\n  if (setresgid (current_user.gid, current_user.gid, current_user.gid) < 0)\n#else\n  if (setgid (current_user.gid) < 0)\n#endif\n    sys_error (_(\"cannot set gid to %d: effective gid %d\"), current_user.gid, current_user.egid);\n\n  current_user.euid = current_user.uid;\n  current_user.egid = current_user.gid;\n}", "func_hash": 129442006485124574074853062128903057999, "file_name": "shell.c", "file_hash": 275188902865294694619472408620496076656, "cwe": ["CWE-787"], "cve": "CVE-2019-18276", "cve_desc": "An issue was discovered in disable_priv_mode in shell.c in GNU Bash through 5.0 patch 11. By default, if Bash is run with its effective UID not equal to its real UID, it will drop privileges by setting its effective UID to its real UID. However, it does so incorrectly. On Linux and other systems that support \"saved UID\" functionality, the saved UID is not dropped. An attacker with command execution in the shell can use \"enable -f\" for runtime loading of a new builtin, which can be a shared object that calls setuid() and therefore regains privileges. However, binaries running with an effective UID of 0 are unaffected.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2019-18276", "file_path": "shell.c"}
{"idx": 212339, "project": "icecast-server", "commit_id": "03ea74c04a5966114c2fe66e4e6892d11a68181e", "project_url": "https://gitlab.xiph.org/xiph/icecast-server", "commit_url": "https://gitlab.xiph.org/xiph/icecast-server/commit/03ea74c04a5966114c2fe66e4e6892d11a68181e", "commit_message": "Fix: Worked around buffer overflows in URL auth's cURL interface\n\nThis is only a workaround that keeps compatibility with 2.4.x mainline.\nA real fix has been implemented in 2.5.x (master).", "target": 1, "func": "static size_t handle_returned_header (void *ptr, size_t size, size_t nmemb, void *stream)\n{\n    auth_client *auth_user = stream;\n    size_t bytes = size * nmemb;\n    client_t *client = auth_user->client;\n\n    if (client)\n    {\n        auth_t *auth = client->auth;\n        auth_url *url = auth->state;\n        if (strncasecmp (ptr, url->auth_header, url->auth_header_len) == 0)\n            client->authenticated = 1;\n        if (strncasecmp (ptr, url->timelimit_header, url->timelimit_header_len) == 0)\n        {\n            unsigned int limit = 0;\n            sscanf ((char *)ptr+url->timelimit_header_len, \"%u\\r\\n\", &limit);\n            client->con->discon_time = time(NULL) + limit;\n        }\n        if (strncasecmp (ptr, \"icecast-auth-message: \", 22) == 0)\n        {\n            char *eol;\n            snprintf (url->errormsg, sizeof (url->errormsg), \"%s\", (char*)ptr+22);\n            eol = strchr (url->errormsg, '\\r');\n            if (eol == NULL)\n                eol = strchr (url->errormsg, '\\n');\n            if (eol)\n                *eol = '\\0';\n        }\n    }\n\n    return bytes;\n}", "func_hash": 172813813159602330520810310060333400473, "file_name": "auth_url.c", "file_hash": 1122861942142437056113331349516615132, "cwe": ["CWE-119"], "cve": "CVE-2018-18820", "cve_desc": "A buffer overflow was discovered in the URL-authentication backend of the Icecast before 2.4.4. If the backend is enabled, then any malicious HTTP client can send a request for that specific resource including a crafted header, leading to denial of service and potentially remote code execution.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2018-18820", "file_path": "src/auth_url.c"}
{"idx": 457772, "project": "icecast-server", "commit_id": "03ea74c04a5966114c2fe66e4e6892d11a68181e", "project_url": "https://gitlab.xiph.org/xiph/icecast-server", "commit_url": "https://gitlab.xiph.org/xiph/icecast-server/commit/03ea74c04a5966114c2fe66e4e6892d11a68181e", "commit_message": "Fix: Worked around buffer overflows in URL auth's cURL interface\n\nThis is only a workaround that keeps compatibility with 2.4.x mainline.\nA real fix has been implemented in 2.5.x (master).", "target": 0, "func": "static size_t handle_returned_header (void *ptr, size_t size, size_t nmemb, void *stream)\n{\n    auth_client *auth_user = stream;\n    size_t len = size * nmemb;\n    client_t *client = auth_user->client;\n\n    if (client) {\n        auth_t *auth = client->auth;\n        auth_url *url = auth->state;\n\n        if (url->auth_header && len >= url->auth_header_len && strncasecmp(ptr, url->auth_header, url->auth_header_len) == 0)\n            client->authenticated = 1;\n\n        if (url->timelimit_header && len > url->timelimit_header_len && strncasecmp(ptr, url->timelimit_header, url->timelimit_header_len) == 0) {\n            const char *input = ptr;\n            unsigned int limit = 0;\n\n            if (len >= 2 && input[len - 2] == '\\r' && input[len - 1] == '\\n') {\n                input += url->timelimit_header_len;\n\n                if (sscanf(input, \"%u\\r\\n\", &limit) == 1) {\n                    client->con->discon_time = time(NULL) + limit;\n                } else {\n                    ICECAST_LOG_ERROR(\"Auth backend returned invalid timeline header: Can not parse limit\");\n                }\n            } else {\n                ICECAST_LOG_ERROR(\"Auth backend returned invalid timelimit header.\");\n            }\n        }\n\n        if (len > 24 && strncasecmp(ptr, \"icecast-auth-message: \", 22) == 0) {\n            const char *input = ptr;\n            size_t copy_len = len - 24 + 1; /* length of string plus \\0-termination */\n\n            if (copy_len > sizeof(url->errormsg)) {\n                copy_len = sizeof(url->errormsg);\n            }\n\n            if (len >= 2 && input[len - 2] == '\\r' && input[len - 1] == '\\n') {\n                input += 22;\n                memcpy(url->errormsg, input, copy_len);\n                url->errormsg[copy_len-1] = 0;\n            } else {\n                ICECAST_LOG_ERROR(\"Auth backend returned invalid message header.\");\n            }\n        }\n    }\n\n    return len;\n}", "func_hash": 325925920263284522777628774415448931953, "file_name": "auth_url.c", "file_hash": 331866999271559721275349792045163085611, "cwe": ["CWE-119"], "cve": "CVE-2018-18820", "cve_desc": "A buffer overflow was discovered in the URL-authentication backend of the Icecast before 2.4.4. If the backend is enabled, then any malicious HTTP client can send a request for that specific resource including a crafted header, leading to denial of service and potentially remote code execution.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2018-18820", "file_path": "src/auth_url.c"}
{"idx": 212407, "project": "varnish-cache", "commit_id": "c5fd097e5cce8b461c6443af02b3448baef2491d", "project_url": "https://github.com/varnishcache/varnish-cache", "commit_url": "https://github.com/varnishcache/varnish-cache/commit/c5fd097e5cce8b461c6443af02b3448baef2491d", "commit_message": "Do not call http_hdr_flags() on pseudo-headers\n\nIn http_EstimateWS(), all headers are passed to the http_isfiltered()\nfunction to calculate how many bytes is needed to serialize the entire\nstruct http. http_isfiltered() will check the headers for whether they are\ngoing to be filtered out later and if so skip them.\n\nHowever http_isfiltered() would attempt to treat all elements of struct\nhttp as regular headers with an implicit structure. That does not hold for\nthe first three pseudo-header entries, which would lead to asserts in\nlater steps.\n\nThis patch skips the filter step for pseudo-headers.\n\nFixes: #3830", "target": 1, "func": "http_isfiltered(const struct http *fm, unsigned u, unsigned how)\n{\n\tconst char *e;\n\tconst struct http_hdrflg *f;\n\n\tif (fm->hdf[u] & HDF_FILTER)\n\t\treturn (1);\n\te = strchr(fm->hd[u].b, ':');\n\tif (e == NULL)\n\t\treturn (0);\n\tf = http_hdr_flags(fm->hd[u].b, e);\n\treturn (f != NULL && f->flag & how);\n}", "func_hash": 811300647438513744666233377828733318, "file_name": "cache_http.c", "file_hash": 145239057408586301398711991484884532857, "cwe": ["CWE-703"], "cve": "CVE-2022-38150", "cve_desc": "In Varnish Cache 7.0.0, 7.0.1, 7.0.2, and 7.1.0, it is possible to cause the Varnish Server to assert and automatically restart through forged HTTP/1 backend responses. An attack uses a crafted reason phrase of the backend response status line. This is fixed in 7.0.3 and 7.1.1.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-38150", "file_path": "bin/varnishd/cache/cache_http.c"}
{"idx": 459029, "project": "varnish-cache", "commit_id": "c5fd097e5cce8b461c6443af02b3448baef2491d", "project_url": "https://github.com/varnishcache/varnish-cache", "commit_url": "https://github.com/varnishcache/varnish-cache/commit/c5fd097e5cce8b461c6443af02b3448baef2491d", "commit_message": "Do not call http_hdr_flags() on pseudo-headers\n\nIn http_EstimateWS(), all headers are passed to the http_isfiltered()\nfunction to calculate how many bytes is needed to serialize the entire\nstruct http. http_isfiltered() will check the headers for whether they are\ngoing to be filtered out later and if so skip them.\n\nHowever http_isfiltered() would attempt to treat all elements of struct\nhttp as regular headers with an implicit structure. That does not hold for\nthe first three pseudo-header entries, which would lead to asserts in\nlater steps.\n\nThis patch skips the filter step for pseudo-headers.\n\nFixes: #3830", "target": 0, "func": "http_isfiltered(const struct http *fm, unsigned u, unsigned how)\n{\n\tconst char *e;\n\tconst struct http_hdrflg *f;\n\n\tif (fm->hdf[u] & HDF_FILTER)\n\t\treturn (1);\n\tif (u < HTTP_HDR_FIRST)\n\t\treturn (0);\n\te = strchr(fm->hd[u].b, ':');\n\tif (e == NULL)\n\t\treturn (0);\n\tf = http_hdr_flags(fm->hd[u].b, e);\n\treturn (f != NULL && f->flag & how);\n}", "func_hash": 214500471714364858208416051205285025611, "file_name": "cache_http.c", "file_hash": 148461925742958572930249757440638720534, "cwe": ["CWE-703"], "cve": "CVE-2022-38150", "cve_desc": "In Varnish Cache 7.0.0, 7.0.1, 7.0.2, and 7.1.0, it is possible to cause the Varnish Server to assert and automatically restart through forged HTTP/1 backend responses. An attack uses a crafted reason phrase of the backend response status line. This is fixed in 7.0.3 and 7.1.1.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-38150", "file_path": "bin/varnishd/cache/cache_http.c"}
{"idx": 212414, "project": "linux", "commit_id": "04c2a47ffb13c29778e2a14e414ad4cb5a5db4b5", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/04c2a47ffb13c29778e2a14e414ad4cb5a5db4b5", "commit_message": "net: sched: fix use-after-free in tc_new_tfilter()\n\nWhenever tc_new_tfilter() jumps back to replay: label,\nwe need to make sure @q and @chain local variables are cleared again,\nor risk use-after-free as in [1]\n\nFor consistency, apply the same fix in tc_ctl_chain()\n\nBUG: KASAN: use-after-free in mini_qdisc_pair_swap+0x1b9/0x1f0 net/sched/sch_generic.c:1581\nWrite of size 8 at addr ffff8880985c4b08 by task syz-executor.4/1945\n\nCPU: 0 PID: 1945 Comm: syz-executor.4 Not tainted 5.17.0-rc1-syzkaller-00495-gff58831fa02d #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:88 [inline]\n dump_stack_lvl+0xcd/0x134 lib/dump_stack.c:106\n print_address_description.constprop.0.cold+0x8d/0x336 mm/kasan/report.c:255\n __kasan_report mm/kasan/report.c:442 [inline]\n kasan_report.cold+0x83/0xdf mm/kasan/report.c:459\n mini_qdisc_pair_swap+0x1b9/0x1f0 net/sched/sch_generic.c:1581\n tcf_chain_head_change_item net/sched/cls_api.c:372 [inline]\n tcf_chain0_head_change.isra.0+0xb9/0x120 net/sched/cls_api.c:386\n tcf_chain_tp_insert net/sched/cls_api.c:1657 [inline]\n tcf_chain_tp_insert_unique net/sched/cls_api.c:1707 [inline]\n tc_new_tfilter+0x1e67/0x2350 net/sched/cls_api.c:2086\n rtnetlink_rcv_msg+0x80d/0xb80 net/core/rtnetlink.c:5583\n netlink_rcv_skb+0x153/0x420 net/netlink/af_netlink.c:2494\n netlink_unicast_kernel net/netlink/af_netlink.c:1317 [inline]\n netlink_unicast+0x539/0x7e0 net/netlink/af_netlink.c:1343\n netlink_sendmsg+0x904/0xe00 net/netlink/af_netlink.c:1919\n sock_sendmsg_nosec net/socket.c:705 [inline]\n sock_sendmsg+0xcf/0x120 net/socket.c:725\n ____sys_sendmsg+0x331/0x810 net/socket.c:2413\n ___sys_sendmsg+0xf3/0x170 net/socket.c:2467\n __sys_sendmmsg+0x195/0x470 net/socket.c:2553\n __do_sys_sendmmsg net/socket.c:2582 [inline]\n __se_sys_sendmmsg net/socket.c:2579 [inline]\n __x64_sys_sendmmsg+0x99/0x100 net/socket.c:2579\n do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n do_syscall_64+0x35/0xb0 arch/x86/entry/common.c:80\n entry_SYSCALL_64_after_hwframe+0x44/0xae\nRIP: 0033:0x7f2647172059\nCode: ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b8 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007f2645aa5168 EFLAGS: 00000246 ORIG_RAX: 0000000000000133\nRAX: ffffffffffffffda RBX: 00007f2647285100 RCX: 00007f2647172059\nRDX: 040000000000009f RSI: 00000000200002c0 RDI: 0000000000000006\nRBP: 00007f26471cc08d R08: 0000000000000000 R09: 0000000000000000\nR10: 9e00000000000000 R11: 0000000000000246 R12: 0000000000000000\nR13: 00007fffb3f7f02f R14: 00007f2645aa5300 R15: 0000000000022000\n </TASK>\n\nAllocated by task 1944:\n kasan_save_stack+0x1e/0x40 mm/kasan/common.c:38\n kasan_set_track mm/kasan/common.c:45 [inline]\n set_alloc_info mm/kasan/common.c:436 [inline]\n ____kasan_kmalloc mm/kasan/common.c:515 [inline]\n ____kasan_kmalloc mm/kasan/common.c:474 [inline]\n __kasan_kmalloc+0xa9/0xd0 mm/kasan/common.c:524\n kmalloc_node include/linux/slab.h:604 [inline]\n kzalloc_node include/linux/slab.h:726 [inline]\n qdisc_alloc+0xac/0xa10 net/sched/sch_generic.c:941\n qdisc_create.constprop.0+0xce/0x10f0 net/sched/sch_api.c:1211\n tc_modify_qdisc+0x4c5/0x1980 net/sched/sch_api.c:1660\n rtnetlink_rcv_msg+0x413/0xb80 net/core/rtnetlink.c:5592\n netlink_rcv_skb+0x153/0x420 net/netlink/af_netlink.c:2494\n netlink_unicast_kernel net/netlink/af_netlink.c:1317 [inline]\n netlink_unicast+0x539/0x7e0 net/netlink/af_netlink.c:1343\n netlink_sendmsg+0x904/0xe00 net/netlink/af_netlink.c:1919\n sock_sendmsg_nosec net/socket.c:705 [inline]\n sock_sendmsg+0xcf/0x120 net/socket.c:725\n ____sys_sendmsg+0x331/0x810 net/socket.c:2413\n ___sys_sendmsg+0xf3/0x170 net/socket.c:2467\n __sys_sendmmsg+0x195/0x470 net/socket.c:2553\n __do_sys_sendmmsg net/socket.c:2582 [inline]\n __se_sys_sendmmsg net/socket.c:2579 [inline]\n __x64_sys_sendmmsg+0x99/0x100 net/socket.c:2579\n do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n do_syscall_64+0x35/0xb0 arch/x86/entry/common.c:80\n entry_SYSCALL_64_after_hwframe+0x44/0xae\n\nFreed by task 3609:\n kasan_save_stack+0x1e/0x40 mm/kasan/common.c:38\n kasan_set_track+0x21/0x30 mm/kasan/common.c:45\n kasan_set_free_info+0x20/0x30 mm/kasan/generic.c:370\n ____kasan_slab_free mm/kasan/common.c:366 [inline]\n ____kasan_slab_free+0x130/0x160 mm/kasan/common.c:328\n kasan_slab_free include/linux/kasan.h:236 [inline]\n slab_free_hook mm/slub.c:1728 [inline]\n slab_free_freelist_hook+0x8b/0x1c0 mm/slub.c:1754\n slab_free mm/slub.c:3509 [inline]\n kfree+0xcb/0x280 mm/slub.c:4562\n rcu_do_batch kernel/rcu/tree.c:2527 [inline]\n rcu_core+0x7b8/0x1540 kernel/rcu/tree.c:2778\n __do_softirq+0x29b/0x9c2 kernel/softirq.c:558\n\nLast potentially related work creation:\n kasan_save_stack+0x1e/0x40 mm/kasan/common.c:38\n __kasan_record_aux_stack+0xbe/0xd0 mm/kasan/generic.c:348\n __call_rcu kernel/rcu/tree.c:3026 [inline]\n call_rcu+0xb1/0x740 kernel/rcu/tree.c:3106\n qdisc_put_unlocked+0x6f/0x90 net/sched/sch_generic.c:1109\n tcf_block_release+0x86/0x90 net/sched/cls_api.c:1238\n tc_new_tfilter+0xc0d/0x2350 net/sched/cls_api.c:2148\n rtnetlink_rcv_msg+0x80d/0xb80 net/core/rtnetlink.c:5583\n netlink_rcv_skb+0x153/0x420 net/netlink/af_netlink.c:2494\n netlink_unicast_kernel net/netlink/af_netlink.c:1317 [inline]\n netlink_unicast+0x539/0x7e0 net/netlink/af_netlink.c:1343\n netlink_sendmsg+0x904/0xe00 net/netlink/af_netlink.c:1919\n sock_sendmsg_nosec net/socket.c:705 [inline]\n sock_sendmsg+0xcf/0x120 net/socket.c:725\n ____sys_sendmsg+0x331/0x810 net/socket.c:2413\n ___sys_sendmsg+0xf3/0x170 net/socket.c:2467\n __sys_sendmmsg+0x195/0x470 net/socket.c:2553\n __do_sys_sendmmsg net/socket.c:2582 [inline]\n __se_sys_sendmmsg net/socket.c:2579 [inline]\n __x64_sys_sendmmsg+0x99/0x100 net/socket.c:2579\n do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n do_syscall_64+0x35/0xb0 arch/x86/entry/common.c:80\n entry_SYSCALL_64_after_hwframe+0x44/0xae\n\nThe buggy address belongs to the object at ffff8880985c4800\n which belongs to the cache kmalloc-1k of size 1024\nThe buggy address is located 776 bytes inside of\n 1024-byte region [ffff8880985c4800, ffff8880985c4c00)\nThe buggy address belongs to the page:\npage:ffffea0002617000 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x985c0\nhead:ffffea0002617000 order:3 compound_mapcount:0 compound_pincount:0\nflags: 0xfff00000010200(slab|head|node=0|zone=1|lastcpupid=0x7ff)\nraw: 00fff00000010200 0000000000000000 dead000000000122 ffff888010c41dc0\nraw: 0000000000000000 0000000000100010 00000001ffffffff 0000000000000000\npage dumped because: kasan: bad access detected\npage_owner tracks the page as allocated\npage last allocated via order 3, migratetype Unmovable, gfp_mask 0x1d20c0(__GFP_IO|__GFP_FS|__GFP_NOWARN|__GFP_NORETRY|__GFP_COMP|__GFP_NOMEMALLOC|__GFP_HARDWALL), pid 1941, ts 1038999441284, free_ts 1033444432829\n prep_new_page mm/page_alloc.c:2434 [inline]\n get_page_from_freelist+0xa72/0x2f50 mm/page_alloc.c:4165\n __alloc_pages+0x1b2/0x500 mm/page_alloc.c:5389\n alloc_pages+0x1aa/0x310 mm/mempolicy.c:2271\n alloc_slab_page mm/slub.c:1799 [inline]\n allocate_slab mm/slub.c:1944 [inline]\n new_slab+0x28a/0x3b0 mm/slub.c:2004\n ___slab_alloc+0x87c/0xe90 mm/slub.c:3018\n __slab_alloc.constprop.0+0x4d/0xa0 mm/slub.c:3105\n slab_alloc_node mm/slub.c:3196 [inline]\n slab_alloc mm/slub.c:3238 [inline]\n __kmalloc+0x2fb/0x340 mm/slub.c:4420\n kmalloc include/linux/slab.h:586 [inline]\n kzalloc include/linux/slab.h:715 [inline]\n __register_sysctl_table+0x112/0x1090 fs/proc/proc_sysctl.c:1335\n neigh_sysctl_register+0x2c8/0x5e0 net/core/neighbour.c:3787\n devinet_sysctl_register+0xb1/0x230 net/ipv4/devinet.c:2618\n inetdev_init+0x286/0x580 net/ipv4/devinet.c:278\n inetdev_event+0xa8a/0x15d0 net/ipv4/devinet.c:1532\n notifier_call_chain+0xb5/0x200 kernel/notifier.c:84\n call_netdevice_notifiers_info+0xb5/0x130 net/core/dev.c:1919\n call_netdevice_notifiers_extack net/core/dev.c:1931 [inline]\n call_netdevice_notifiers net/core/dev.c:1945 [inline]\n register_netdevice+0x1073/0x1500 net/core/dev.c:9698\n veth_newlink+0x59c/0xa90 drivers/net/veth.c:1722\npage last free stack trace:\n reset_page_owner include/linux/page_owner.h:24 [inline]\n free_pages_prepare mm/page_alloc.c:1352 [inline]\n free_pcp_prepare+0x374/0x870 mm/page_alloc.c:1404\n free_unref_page_prepare mm/page_alloc.c:3325 [inline]\n free_unref_page+0x19/0x690 mm/page_alloc.c:3404\n release_pages+0x748/0x1220 mm/swap.c:956\n tlb_batch_pages_flush mm/mmu_gather.c:50 [inline]\n tlb_flush_mmu_free mm/mmu_gather.c:243 [inline]\n tlb_flush_mmu+0xe9/0x6b0 mm/mmu_gather.c:250\n zap_pte_range mm/memory.c:1441 [inline]\n zap_pmd_range mm/memory.c:1490 [inline]\n zap_pud_range mm/memory.c:1519 [inline]\n zap_p4d_range mm/memory.c:1540 [inline]\n unmap_page_range+0x1d1d/0x2a30 mm/memory.c:1561\n unmap_single_vma+0x198/0x310 mm/memory.c:1606\n unmap_vmas+0x16b/0x2f0 mm/memory.c:1638\n exit_mmap+0x201/0x670 mm/mmap.c:3178\n __mmput+0x122/0x4b0 kernel/fork.c:1114\n mmput+0x56/0x60 kernel/fork.c:1135\n exit_mm kernel/exit.c:507 [inline]\n do_exit+0xa3c/0x2a30 kernel/exit.c:793\n do_group_exit+0xd2/0x2f0 kernel/exit.c:935\n __do_sys_exit_group kernel/exit.c:946 [inline]\n __se_sys_exit_group kernel/exit.c:944 [inline]\n __x64_sys_exit_group+0x3a/0x50 kernel/exit.c:944\n do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n do_syscall_64+0x35/0xb0 arch/x86/entry/common.c:80\n entry_SYSCALL_64_after_hwframe+0x44/0xae\n\nMemory state around the buggy address:\n ffff8880985c4a00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n ffff8880985c4a80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n>ffff8880985c4b00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n                      ^\n ffff8880985c4b80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n ffff8880985c4c00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n\nFixes: 470502de5bdb (\"net: sched: unlock rules update API\")\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nCc: Vlad Buslov <vladbu@mellanox.com>\nCc: Jiri Pirko <jiri@mellanox.com>\nCc: Cong Wang <xiyou.wangcong@gmail.com>\nReported-by: syzbot <syzkaller@googlegroups.com>\nLink: https://lore.kernel.org/r/20220131172018.3704490-1-eric.dumazet@gmail.com\nSigned-off-by: Jakub Kicinski <kuba@kernel.org>", "target": 1, "func": "static int tc_new_tfilter(struct sk_buff *skb, struct nlmsghdr *n,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlattr *tca[TCA_MAX + 1];\n\tchar name[IFNAMSIZ];\n\tstruct tcmsg *t;\n\tu32 protocol;\n\tu32 prio;\n\tbool prio_allocate;\n\tu32 parent;\n\tu32 chain_index;\n\tstruct Qdisc *q = NULL;\n\tstruct tcf_chain_info chain_info;\n\tstruct tcf_chain *chain = NULL;\n\tstruct tcf_block *block;\n\tstruct tcf_proto *tp;\n\tunsigned long cl;\n\tvoid *fh;\n\tint err;\n\tint tp_created;\n\tbool rtnl_held = false;\n\tu32 flags;\n\n\tif (!netlink_ns_capable(skb, net->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\nreplay:\n\ttp_created = 0;\n\n\terr = nlmsg_parse_deprecated(n, sizeof(*t), tca, TCA_MAX,\n\t\t\t\t     rtm_tca_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tt = nlmsg_data(n);\n\tprotocol = TC_H_MIN(t->tcm_info);\n\tprio = TC_H_MAJ(t->tcm_info);\n\tprio_allocate = false;\n\tparent = t->tcm_parent;\n\ttp = NULL;\n\tcl = 0;\n\tblock = NULL;\n\tflags = 0;\n\n\tif (prio == 0) {\n\t\t/* If no priority is provided by the user,\n\t\t * we allocate one.\n\t\t */\n\t\tif (n->nlmsg_flags & NLM_F_CREATE) {\n\t\t\tprio = TC_H_MAKE(0x80000000U, 0U);\n\t\t\tprio_allocate = true;\n\t\t} else {\n\t\t\tNL_SET_ERR_MSG(extack, \"Invalid filter command with priority of zero\");\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\n\t/* Find head of filter chain. */\n\n\terr = __tcf_qdisc_find(net, &q, &parent, t->tcm_ifindex, false, extack);\n\tif (err)\n\t\treturn err;\n\n\tif (tcf_proto_check_kind(tca[TCA_KIND], name)) {\n\t\tNL_SET_ERR_MSG(extack, \"Specified TC filter name too long\");\n\t\terr = -EINVAL;\n\t\tgoto errout;\n\t}\n\n\t/* Take rtnl mutex if rtnl_held was set to true on previous iteration,\n\t * block is shared (no qdisc found), qdisc is not unlocked, classifier\n\t * type is not specified, classifier is not unlocked.\n\t */\n\tif (rtnl_held ||\n\t    (q && !(q->ops->cl_ops->flags & QDISC_CLASS_OPS_DOIT_UNLOCKED)) ||\n\t    !tcf_proto_is_unlocked(name)) {\n\t\trtnl_held = true;\n\t\trtnl_lock();\n\t}\n\n\terr = __tcf_qdisc_cl_find(q, parent, &cl, t->tcm_ifindex, extack);\n\tif (err)\n\t\tgoto errout;\n\n\tblock = __tcf_block_find(net, q, cl, t->tcm_ifindex, t->tcm_block_index,\n\t\t\t\t extack);\n\tif (IS_ERR(block)) {\n\t\terr = PTR_ERR(block);\n\t\tgoto errout;\n\t}\n\tblock->classid = parent;\n\n\tchain_index = tca[TCA_CHAIN] ? nla_get_u32(tca[TCA_CHAIN]) : 0;\n\tif (chain_index > TC_ACT_EXT_VAL_MASK) {\n\t\tNL_SET_ERR_MSG(extack, \"Specified chain index exceeds upper limit\");\n\t\terr = -EINVAL;\n\t\tgoto errout;\n\t}\n\tchain = tcf_chain_get(block, chain_index, true);\n\tif (!chain) {\n\t\tNL_SET_ERR_MSG(extack, \"Cannot create specified filter chain\");\n\t\terr = -ENOMEM;\n\t\tgoto errout;\n\t}\n\n\tmutex_lock(&chain->filter_chain_lock);\n\ttp = tcf_chain_tp_find(chain, &chain_info, protocol,\n\t\t\t       prio, prio_allocate);\n\tif (IS_ERR(tp)) {\n\t\tNL_SET_ERR_MSG(extack, \"Filter with specified priority/protocol not found\");\n\t\terr = PTR_ERR(tp);\n\t\tgoto errout_locked;\n\t}\n\n\tif (tp == NULL) {\n\t\tstruct tcf_proto *tp_new = NULL;\n\n\t\tif (chain->flushing) {\n\t\t\terr = -EAGAIN;\n\t\t\tgoto errout_locked;\n\t\t}\n\n\t\t/* Proto-tcf does not exist, create new one */\n\n\t\tif (tca[TCA_KIND] == NULL || !protocol) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Filter kind and protocol must be specified\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto errout_locked;\n\t\t}\n\n\t\tif (!(n->nlmsg_flags & NLM_F_CREATE)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Need both RTM_NEWTFILTER and NLM_F_CREATE to create a new filter\");\n\t\t\terr = -ENOENT;\n\t\t\tgoto errout_locked;\n\t\t}\n\n\t\tif (prio_allocate)\n\t\t\tprio = tcf_auto_prio(tcf_chain_tp_prev(chain,\n\t\t\t\t\t\t\t       &chain_info));\n\n\t\tmutex_unlock(&chain->filter_chain_lock);\n\t\ttp_new = tcf_proto_create(name, protocol, prio, chain,\n\t\t\t\t\t  rtnl_held, extack);\n\t\tif (IS_ERR(tp_new)) {\n\t\t\terr = PTR_ERR(tp_new);\n\t\t\tgoto errout_tp;\n\t\t}\n\n\t\ttp_created = 1;\n\t\ttp = tcf_chain_tp_insert_unique(chain, tp_new, protocol, prio,\n\t\t\t\t\t\trtnl_held);\n\t\tif (IS_ERR(tp)) {\n\t\t\terr = PTR_ERR(tp);\n\t\t\tgoto errout_tp;\n\t\t}\n\t} else {\n\t\tmutex_unlock(&chain->filter_chain_lock);\n\t}\n\n\tif (tca[TCA_KIND] && nla_strcmp(tca[TCA_KIND], tp->ops->kind)) {\n\t\tNL_SET_ERR_MSG(extack, \"Specified filter kind does not match existing one\");\n\t\terr = -EINVAL;\n\t\tgoto errout;\n\t}\n\n\tfh = tp->ops->get(tp, t->tcm_handle);\n\n\tif (!fh) {\n\t\tif (!(n->nlmsg_flags & NLM_F_CREATE)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Need both RTM_NEWTFILTER and NLM_F_CREATE to create a new filter\");\n\t\t\terr = -ENOENT;\n\t\t\tgoto errout;\n\t\t}\n\t} else if (n->nlmsg_flags & NLM_F_EXCL) {\n\t\ttfilter_put(tp, fh);\n\t\tNL_SET_ERR_MSG(extack, \"Filter already exists\");\n\t\terr = -EEXIST;\n\t\tgoto errout;\n\t}\n\n\tif (chain->tmplt_ops && chain->tmplt_ops != tp->ops) {\n\t\tNL_SET_ERR_MSG(extack, \"Chain template is set to a different filter kind\");\n\t\terr = -EINVAL;\n\t\tgoto errout;\n\t}\n\n\tif (!(n->nlmsg_flags & NLM_F_CREATE))\n\t\tflags |= TCA_ACT_FLAGS_REPLACE;\n\tif (!rtnl_held)\n\t\tflags |= TCA_ACT_FLAGS_NO_RTNL;\n\terr = tp->ops->change(net, skb, tp, cl, t->tcm_handle, tca, &fh,\n\t\t\t      flags, extack);\n\tif (err == 0) {\n\t\ttfilter_notify(net, skb, n, tp, block, q, parent, fh,\n\t\t\t       RTM_NEWTFILTER, false, rtnl_held);\n\t\ttfilter_put(tp, fh);\n\t\t/* q pointer is NULL for shared blocks */\n\t\tif (q)\n\t\t\tq->flags &= ~TCQ_F_CAN_BYPASS;\n\t}\n\nerrout:\n\tif (err && tp_created)\n\t\ttcf_chain_tp_delete_empty(chain, tp, rtnl_held, NULL);\nerrout_tp:\n\tif (chain) {\n\t\tif (tp && !IS_ERR(tp))\n\t\t\ttcf_proto_put(tp, rtnl_held, NULL);\n\t\tif (!tp_created)\n\t\t\ttcf_chain_put(chain);\n\t}\n\ttcf_block_release(q, block, rtnl_held);\n\n\tif (rtnl_held)\n\t\trtnl_unlock();\n\n\tif (err == -EAGAIN) {\n\t\t/* Take rtnl lock in case EAGAIN is caused by concurrent flush\n\t\t * of target chain.\n\t\t */\n\t\trtnl_held = true;\n\t\t/* Replay the request. */\n\t\tgoto replay;\n\t}\n\treturn err;\n\nerrout_locked:\n\tmutex_unlock(&chain->filter_chain_lock);\n\tgoto errout;\n}", "func_hash": 18151855959135734228627793679159459802, "file_name": "cls_api.c", "file_hash": 251903803472854915466369605008106287178, "cwe": ["CWE-416"], "cve": "CVE-2022-1055", "cve_desc": "A use-after-free exists in the Linux Kernel in tc_new_tfilter that could allow a local attacker to gain privilege escalation. The exploit requires unprivileged user namespaces. We recommend upgrading past commit 04c2a47ffb13c29778e2a14e414ad4cb5a5db4b5", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-1055", "file_path": "net/sched/cls_api.c"}
{"idx": 459107, "project": "linux", "commit_id": "04c2a47ffb13c29778e2a14e414ad4cb5a5db4b5", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/04c2a47ffb13c29778e2a14e414ad4cb5a5db4b5", "commit_message": "net: sched: fix use-after-free in tc_new_tfilter()\n\nWhenever tc_new_tfilter() jumps back to replay: label,\nwe need to make sure @q and @chain local variables are cleared again,\nor risk use-after-free as in [1]\n\nFor consistency, apply the same fix in tc_ctl_chain()\n\nBUG: KASAN: use-after-free in mini_qdisc_pair_swap+0x1b9/0x1f0 net/sched/sch_generic.c:1581\nWrite of size 8 at addr ffff8880985c4b08 by task syz-executor.4/1945\n\nCPU: 0 PID: 1945 Comm: syz-executor.4 Not tainted 5.17.0-rc1-syzkaller-00495-gff58831fa02d #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:88 [inline]\n dump_stack_lvl+0xcd/0x134 lib/dump_stack.c:106\n print_address_description.constprop.0.cold+0x8d/0x336 mm/kasan/report.c:255\n __kasan_report mm/kasan/report.c:442 [inline]\n kasan_report.cold+0x83/0xdf mm/kasan/report.c:459\n mini_qdisc_pair_swap+0x1b9/0x1f0 net/sched/sch_generic.c:1581\n tcf_chain_head_change_item net/sched/cls_api.c:372 [inline]\n tcf_chain0_head_change.isra.0+0xb9/0x120 net/sched/cls_api.c:386\n tcf_chain_tp_insert net/sched/cls_api.c:1657 [inline]\n tcf_chain_tp_insert_unique net/sched/cls_api.c:1707 [inline]\n tc_new_tfilter+0x1e67/0x2350 net/sched/cls_api.c:2086\n rtnetlink_rcv_msg+0x80d/0xb80 net/core/rtnetlink.c:5583\n netlink_rcv_skb+0x153/0x420 net/netlink/af_netlink.c:2494\n netlink_unicast_kernel net/netlink/af_netlink.c:1317 [inline]\n netlink_unicast+0x539/0x7e0 net/netlink/af_netlink.c:1343\n netlink_sendmsg+0x904/0xe00 net/netlink/af_netlink.c:1919\n sock_sendmsg_nosec net/socket.c:705 [inline]\n sock_sendmsg+0xcf/0x120 net/socket.c:725\n ____sys_sendmsg+0x331/0x810 net/socket.c:2413\n ___sys_sendmsg+0xf3/0x170 net/socket.c:2467\n __sys_sendmmsg+0x195/0x470 net/socket.c:2553\n __do_sys_sendmmsg net/socket.c:2582 [inline]\n __se_sys_sendmmsg net/socket.c:2579 [inline]\n __x64_sys_sendmmsg+0x99/0x100 net/socket.c:2579\n do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n do_syscall_64+0x35/0xb0 arch/x86/entry/common.c:80\n entry_SYSCALL_64_after_hwframe+0x44/0xae\nRIP: 0033:0x7f2647172059\nCode: ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b8 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007f2645aa5168 EFLAGS: 00000246 ORIG_RAX: 0000000000000133\nRAX: ffffffffffffffda RBX: 00007f2647285100 RCX: 00007f2647172059\nRDX: 040000000000009f RSI: 00000000200002c0 RDI: 0000000000000006\nRBP: 00007f26471cc08d R08: 0000000000000000 R09: 0000000000000000\nR10: 9e00000000000000 R11: 0000000000000246 R12: 0000000000000000\nR13: 00007fffb3f7f02f R14: 00007f2645aa5300 R15: 0000000000022000\n </TASK>\n\nAllocated by task 1944:\n kasan_save_stack+0x1e/0x40 mm/kasan/common.c:38\n kasan_set_track mm/kasan/common.c:45 [inline]\n set_alloc_info mm/kasan/common.c:436 [inline]\n ____kasan_kmalloc mm/kasan/common.c:515 [inline]\n ____kasan_kmalloc mm/kasan/common.c:474 [inline]\n __kasan_kmalloc+0xa9/0xd0 mm/kasan/common.c:524\n kmalloc_node include/linux/slab.h:604 [inline]\n kzalloc_node include/linux/slab.h:726 [inline]\n qdisc_alloc+0xac/0xa10 net/sched/sch_generic.c:941\n qdisc_create.constprop.0+0xce/0x10f0 net/sched/sch_api.c:1211\n tc_modify_qdisc+0x4c5/0x1980 net/sched/sch_api.c:1660\n rtnetlink_rcv_msg+0x413/0xb80 net/core/rtnetlink.c:5592\n netlink_rcv_skb+0x153/0x420 net/netlink/af_netlink.c:2494\n netlink_unicast_kernel net/netlink/af_netlink.c:1317 [inline]\n netlink_unicast+0x539/0x7e0 net/netlink/af_netlink.c:1343\n netlink_sendmsg+0x904/0xe00 net/netlink/af_netlink.c:1919\n sock_sendmsg_nosec net/socket.c:705 [inline]\n sock_sendmsg+0xcf/0x120 net/socket.c:725\n ____sys_sendmsg+0x331/0x810 net/socket.c:2413\n ___sys_sendmsg+0xf3/0x170 net/socket.c:2467\n __sys_sendmmsg+0x195/0x470 net/socket.c:2553\n __do_sys_sendmmsg net/socket.c:2582 [inline]\n __se_sys_sendmmsg net/socket.c:2579 [inline]\n __x64_sys_sendmmsg+0x99/0x100 net/socket.c:2579\n do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n do_syscall_64+0x35/0xb0 arch/x86/entry/common.c:80\n entry_SYSCALL_64_after_hwframe+0x44/0xae\n\nFreed by task 3609:\n kasan_save_stack+0x1e/0x40 mm/kasan/common.c:38\n kasan_set_track+0x21/0x30 mm/kasan/common.c:45\n kasan_set_free_info+0x20/0x30 mm/kasan/generic.c:370\n ____kasan_slab_free mm/kasan/common.c:366 [inline]\n ____kasan_slab_free+0x130/0x160 mm/kasan/common.c:328\n kasan_slab_free include/linux/kasan.h:236 [inline]\n slab_free_hook mm/slub.c:1728 [inline]\n slab_free_freelist_hook+0x8b/0x1c0 mm/slub.c:1754\n slab_free mm/slub.c:3509 [inline]\n kfree+0xcb/0x280 mm/slub.c:4562\n rcu_do_batch kernel/rcu/tree.c:2527 [inline]\n rcu_core+0x7b8/0x1540 kernel/rcu/tree.c:2778\n __do_softirq+0x29b/0x9c2 kernel/softirq.c:558\n\nLast potentially related work creation:\n kasan_save_stack+0x1e/0x40 mm/kasan/common.c:38\n __kasan_record_aux_stack+0xbe/0xd0 mm/kasan/generic.c:348\n __call_rcu kernel/rcu/tree.c:3026 [inline]\n call_rcu+0xb1/0x740 kernel/rcu/tree.c:3106\n qdisc_put_unlocked+0x6f/0x90 net/sched/sch_generic.c:1109\n tcf_block_release+0x86/0x90 net/sched/cls_api.c:1238\n tc_new_tfilter+0xc0d/0x2350 net/sched/cls_api.c:2148\n rtnetlink_rcv_msg+0x80d/0xb80 net/core/rtnetlink.c:5583\n netlink_rcv_skb+0x153/0x420 net/netlink/af_netlink.c:2494\n netlink_unicast_kernel net/netlink/af_netlink.c:1317 [inline]\n netlink_unicast+0x539/0x7e0 net/netlink/af_netlink.c:1343\n netlink_sendmsg+0x904/0xe00 net/netlink/af_netlink.c:1919\n sock_sendmsg_nosec net/socket.c:705 [inline]\n sock_sendmsg+0xcf/0x120 net/socket.c:725\n ____sys_sendmsg+0x331/0x810 net/socket.c:2413\n ___sys_sendmsg+0xf3/0x170 net/socket.c:2467\n __sys_sendmmsg+0x195/0x470 net/socket.c:2553\n __do_sys_sendmmsg net/socket.c:2582 [inline]\n __se_sys_sendmmsg net/socket.c:2579 [inline]\n __x64_sys_sendmmsg+0x99/0x100 net/socket.c:2579\n do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n do_syscall_64+0x35/0xb0 arch/x86/entry/common.c:80\n entry_SYSCALL_64_after_hwframe+0x44/0xae\n\nThe buggy address belongs to the object at ffff8880985c4800\n which belongs to the cache kmalloc-1k of size 1024\nThe buggy address is located 776 bytes inside of\n 1024-byte region [ffff8880985c4800, ffff8880985c4c00)\nThe buggy address belongs to the page:\npage:ffffea0002617000 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x985c0\nhead:ffffea0002617000 order:3 compound_mapcount:0 compound_pincount:0\nflags: 0xfff00000010200(slab|head|node=0|zone=1|lastcpupid=0x7ff)\nraw: 00fff00000010200 0000000000000000 dead000000000122 ffff888010c41dc0\nraw: 0000000000000000 0000000000100010 00000001ffffffff 0000000000000000\npage dumped because: kasan: bad access detected\npage_owner tracks the page as allocated\npage last allocated via order 3, migratetype Unmovable, gfp_mask 0x1d20c0(__GFP_IO|__GFP_FS|__GFP_NOWARN|__GFP_NORETRY|__GFP_COMP|__GFP_NOMEMALLOC|__GFP_HARDWALL), pid 1941, ts 1038999441284, free_ts 1033444432829\n prep_new_page mm/page_alloc.c:2434 [inline]\n get_page_from_freelist+0xa72/0x2f50 mm/page_alloc.c:4165\n __alloc_pages+0x1b2/0x500 mm/page_alloc.c:5389\n alloc_pages+0x1aa/0x310 mm/mempolicy.c:2271\n alloc_slab_page mm/slub.c:1799 [inline]\n allocate_slab mm/slub.c:1944 [inline]\n new_slab+0x28a/0x3b0 mm/slub.c:2004\n ___slab_alloc+0x87c/0xe90 mm/slub.c:3018\n __slab_alloc.constprop.0+0x4d/0xa0 mm/slub.c:3105\n slab_alloc_node mm/slub.c:3196 [inline]\n slab_alloc mm/slub.c:3238 [inline]\n __kmalloc+0x2fb/0x340 mm/slub.c:4420\n kmalloc include/linux/slab.h:586 [inline]\n kzalloc include/linux/slab.h:715 [inline]\n __register_sysctl_table+0x112/0x1090 fs/proc/proc_sysctl.c:1335\n neigh_sysctl_register+0x2c8/0x5e0 net/core/neighbour.c:3787\n devinet_sysctl_register+0xb1/0x230 net/ipv4/devinet.c:2618\n inetdev_init+0x286/0x580 net/ipv4/devinet.c:278\n inetdev_event+0xa8a/0x15d0 net/ipv4/devinet.c:1532\n notifier_call_chain+0xb5/0x200 kernel/notifier.c:84\n call_netdevice_notifiers_info+0xb5/0x130 net/core/dev.c:1919\n call_netdevice_notifiers_extack net/core/dev.c:1931 [inline]\n call_netdevice_notifiers net/core/dev.c:1945 [inline]\n register_netdevice+0x1073/0x1500 net/core/dev.c:9698\n veth_newlink+0x59c/0xa90 drivers/net/veth.c:1722\npage last free stack trace:\n reset_page_owner include/linux/page_owner.h:24 [inline]\n free_pages_prepare mm/page_alloc.c:1352 [inline]\n free_pcp_prepare+0x374/0x870 mm/page_alloc.c:1404\n free_unref_page_prepare mm/page_alloc.c:3325 [inline]\n free_unref_page+0x19/0x690 mm/page_alloc.c:3404\n release_pages+0x748/0x1220 mm/swap.c:956\n tlb_batch_pages_flush mm/mmu_gather.c:50 [inline]\n tlb_flush_mmu_free mm/mmu_gather.c:243 [inline]\n tlb_flush_mmu+0xe9/0x6b0 mm/mmu_gather.c:250\n zap_pte_range mm/memory.c:1441 [inline]\n zap_pmd_range mm/memory.c:1490 [inline]\n zap_pud_range mm/memory.c:1519 [inline]\n zap_p4d_range mm/memory.c:1540 [inline]\n unmap_page_range+0x1d1d/0x2a30 mm/memory.c:1561\n unmap_single_vma+0x198/0x310 mm/memory.c:1606\n unmap_vmas+0x16b/0x2f0 mm/memory.c:1638\n exit_mmap+0x201/0x670 mm/mmap.c:3178\n __mmput+0x122/0x4b0 kernel/fork.c:1114\n mmput+0x56/0x60 kernel/fork.c:1135\n exit_mm kernel/exit.c:507 [inline]\n do_exit+0xa3c/0x2a30 kernel/exit.c:793\n do_group_exit+0xd2/0x2f0 kernel/exit.c:935\n __do_sys_exit_group kernel/exit.c:946 [inline]\n __se_sys_exit_group kernel/exit.c:944 [inline]\n __x64_sys_exit_group+0x3a/0x50 kernel/exit.c:944\n do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n do_syscall_64+0x35/0xb0 arch/x86/entry/common.c:80\n entry_SYSCALL_64_after_hwframe+0x44/0xae\n\nMemory state around the buggy address:\n ffff8880985c4a00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n ffff8880985c4a80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n>ffff8880985c4b00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n                      ^\n ffff8880985c4b80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n ffff8880985c4c00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n\nFixes: 470502de5bdb (\"net: sched: unlock rules update API\")\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nCc: Vlad Buslov <vladbu@mellanox.com>\nCc: Jiri Pirko <jiri@mellanox.com>\nCc: Cong Wang <xiyou.wangcong@gmail.com>\nReported-by: syzbot <syzkaller@googlegroups.com>\nLink: https://lore.kernel.org/r/20220131172018.3704490-1-eric.dumazet@gmail.com\nSigned-off-by: Jakub Kicinski <kuba@kernel.org>", "target": 0, "func": "static int tc_new_tfilter(struct sk_buff *skb, struct nlmsghdr *n,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlattr *tca[TCA_MAX + 1];\n\tchar name[IFNAMSIZ];\n\tstruct tcmsg *t;\n\tu32 protocol;\n\tu32 prio;\n\tbool prio_allocate;\n\tu32 parent;\n\tu32 chain_index;\n\tstruct Qdisc *q;\n\tstruct tcf_chain_info chain_info;\n\tstruct tcf_chain *chain;\n\tstruct tcf_block *block;\n\tstruct tcf_proto *tp;\n\tunsigned long cl;\n\tvoid *fh;\n\tint err;\n\tint tp_created;\n\tbool rtnl_held = false;\n\tu32 flags;\n\n\tif (!netlink_ns_capable(skb, net->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\nreplay:\n\ttp_created = 0;\n\n\terr = nlmsg_parse_deprecated(n, sizeof(*t), tca, TCA_MAX,\n\t\t\t\t     rtm_tca_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tt = nlmsg_data(n);\n\tprotocol = TC_H_MIN(t->tcm_info);\n\tprio = TC_H_MAJ(t->tcm_info);\n\tprio_allocate = false;\n\tparent = t->tcm_parent;\n\ttp = NULL;\n\tcl = 0;\n\tblock = NULL;\n\tq = NULL;\n\tchain = NULL;\n\tflags = 0;\n\n\tif (prio == 0) {\n\t\t/* If no priority is provided by the user,\n\t\t * we allocate one.\n\t\t */\n\t\tif (n->nlmsg_flags & NLM_F_CREATE) {\n\t\t\tprio = TC_H_MAKE(0x80000000U, 0U);\n\t\t\tprio_allocate = true;\n\t\t} else {\n\t\t\tNL_SET_ERR_MSG(extack, \"Invalid filter command with priority of zero\");\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\n\t/* Find head of filter chain. */\n\n\terr = __tcf_qdisc_find(net, &q, &parent, t->tcm_ifindex, false, extack);\n\tif (err)\n\t\treturn err;\n\n\tif (tcf_proto_check_kind(tca[TCA_KIND], name)) {\n\t\tNL_SET_ERR_MSG(extack, \"Specified TC filter name too long\");\n\t\terr = -EINVAL;\n\t\tgoto errout;\n\t}\n\n\t/* Take rtnl mutex if rtnl_held was set to true on previous iteration,\n\t * block is shared (no qdisc found), qdisc is not unlocked, classifier\n\t * type is not specified, classifier is not unlocked.\n\t */\n\tif (rtnl_held ||\n\t    (q && !(q->ops->cl_ops->flags & QDISC_CLASS_OPS_DOIT_UNLOCKED)) ||\n\t    !tcf_proto_is_unlocked(name)) {\n\t\trtnl_held = true;\n\t\trtnl_lock();\n\t}\n\n\terr = __tcf_qdisc_cl_find(q, parent, &cl, t->tcm_ifindex, extack);\n\tif (err)\n\t\tgoto errout;\n\n\tblock = __tcf_block_find(net, q, cl, t->tcm_ifindex, t->tcm_block_index,\n\t\t\t\t extack);\n\tif (IS_ERR(block)) {\n\t\terr = PTR_ERR(block);\n\t\tgoto errout;\n\t}\n\tblock->classid = parent;\n\n\tchain_index = tca[TCA_CHAIN] ? nla_get_u32(tca[TCA_CHAIN]) : 0;\n\tif (chain_index > TC_ACT_EXT_VAL_MASK) {\n\t\tNL_SET_ERR_MSG(extack, \"Specified chain index exceeds upper limit\");\n\t\terr = -EINVAL;\n\t\tgoto errout;\n\t}\n\tchain = tcf_chain_get(block, chain_index, true);\n\tif (!chain) {\n\t\tNL_SET_ERR_MSG(extack, \"Cannot create specified filter chain\");\n\t\terr = -ENOMEM;\n\t\tgoto errout;\n\t}\n\n\tmutex_lock(&chain->filter_chain_lock);\n\ttp = tcf_chain_tp_find(chain, &chain_info, protocol,\n\t\t\t       prio, prio_allocate);\n\tif (IS_ERR(tp)) {\n\t\tNL_SET_ERR_MSG(extack, \"Filter with specified priority/protocol not found\");\n\t\terr = PTR_ERR(tp);\n\t\tgoto errout_locked;\n\t}\n\n\tif (tp == NULL) {\n\t\tstruct tcf_proto *tp_new = NULL;\n\n\t\tif (chain->flushing) {\n\t\t\terr = -EAGAIN;\n\t\t\tgoto errout_locked;\n\t\t}\n\n\t\t/* Proto-tcf does not exist, create new one */\n\n\t\tif (tca[TCA_KIND] == NULL || !protocol) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Filter kind and protocol must be specified\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto errout_locked;\n\t\t}\n\n\t\tif (!(n->nlmsg_flags & NLM_F_CREATE)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Need both RTM_NEWTFILTER and NLM_F_CREATE to create a new filter\");\n\t\t\terr = -ENOENT;\n\t\t\tgoto errout_locked;\n\t\t}\n\n\t\tif (prio_allocate)\n\t\t\tprio = tcf_auto_prio(tcf_chain_tp_prev(chain,\n\t\t\t\t\t\t\t       &chain_info));\n\n\t\tmutex_unlock(&chain->filter_chain_lock);\n\t\ttp_new = tcf_proto_create(name, protocol, prio, chain,\n\t\t\t\t\t  rtnl_held, extack);\n\t\tif (IS_ERR(tp_new)) {\n\t\t\terr = PTR_ERR(tp_new);\n\t\t\tgoto errout_tp;\n\t\t}\n\n\t\ttp_created = 1;\n\t\ttp = tcf_chain_tp_insert_unique(chain, tp_new, protocol, prio,\n\t\t\t\t\t\trtnl_held);\n\t\tif (IS_ERR(tp)) {\n\t\t\terr = PTR_ERR(tp);\n\t\t\tgoto errout_tp;\n\t\t}\n\t} else {\n\t\tmutex_unlock(&chain->filter_chain_lock);\n\t}\n\n\tif (tca[TCA_KIND] && nla_strcmp(tca[TCA_KIND], tp->ops->kind)) {\n\t\tNL_SET_ERR_MSG(extack, \"Specified filter kind does not match existing one\");\n\t\terr = -EINVAL;\n\t\tgoto errout;\n\t}\n\n\tfh = tp->ops->get(tp, t->tcm_handle);\n\n\tif (!fh) {\n\t\tif (!(n->nlmsg_flags & NLM_F_CREATE)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Need both RTM_NEWTFILTER and NLM_F_CREATE to create a new filter\");\n\t\t\terr = -ENOENT;\n\t\t\tgoto errout;\n\t\t}\n\t} else if (n->nlmsg_flags & NLM_F_EXCL) {\n\t\ttfilter_put(tp, fh);\n\t\tNL_SET_ERR_MSG(extack, \"Filter already exists\");\n\t\terr = -EEXIST;\n\t\tgoto errout;\n\t}\n\n\tif (chain->tmplt_ops && chain->tmplt_ops != tp->ops) {\n\t\tNL_SET_ERR_MSG(extack, \"Chain template is set to a different filter kind\");\n\t\terr = -EINVAL;\n\t\tgoto errout;\n\t}\n\n\tif (!(n->nlmsg_flags & NLM_F_CREATE))\n\t\tflags |= TCA_ACT_FLAGS_REPLACE;\n\tif (!rtnl_held)\n\t\tflags |= TCA_ACT_FLAGS_NO_RTNL;\n\terr = tp->ops->change(net, skb, tp, cl, t->tcm_handle, tca, &fh,\n\t\t\t      flags, extack);\n\tif (err == 0) {\n\t\ttfilter_notify(net, skb, n, tp, block, q, parent, fh,\n\t\t\t       RTM_NEWTFILTER, false, rtnl_held);\n\t\ttfilter_put(tp, fh);\n\t\t/* q pointer is NULL for shared blocks */\n\t\tif (q)\n\t\t\tq->flags &= ~TCQ_F_CAN_BYPASS;\n\t}\n\nerrout:\n\tif (err && tp_created)\n\t\ttcf_chain_tp_delete_empty(chain, tp, rtnl_held, NULL);\nerrout_tp:\n\tif (chain) {\n\t\tif (tp && !IS_ERR(tp))\n\t\t\ttcf_proto_put(tp, rtnl_held, NULL);\n\t\tif (!tp_created)\n\t\t\ttcf_chain_put(chain);\n\t}\n\ttcf_block_release(q, block, rtnl_held);\n\n\tif (rtnl_held)\n\t\trtnl_unlock();\n\n\tif (err == -EAGAIN) {\n\t\t/* Take rtnl lock in case EAGAIN is caused by concurrent flush\n\t\t * of target chain.\n\t\t */\n\t\trtnl_held = true;\n\t\t/* Replay the request. */\n\t\tgoto replay;\n\t}\n\treturn err;\n\nerrout_locked:\n\tmutex_unlock(&chain->filter_chain_lock);\n\tgoto errout;\n}", "func_hash": 249400845678093962479611801234831545975, "file_name": "cls_api.c", "file_hash": 31293344430191637657447401884064089853, "cwe": ["CWE-416"], "cve": "CVE-2022-1055", "cve_desc": "A use-after-free exists in the Linux Kernel in tc_new_tfilter that could allow a local attacker to gain privilege escalation. The exploit requires unprivileged user namespaces. We recommend upgrading past commit 04c2a47ffb13c29778e2a14e414ad4cb5a5db4b5", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-1055", "file_path": "net/sched/cls_api.c"}
{"idx": 212436, "project": "linux", "commit_id": "30e29a9a2bc6a4888335a6ede968b75cd329657a", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/30e29a9a2bc6a4888335a6ede968b75cd329657a", "commit_message": "bpf: Fix integer overflow in prealloc_elems_and_freelist()\n\nIn prealloc_elems_and_freelist(), the multiplication to calculate the\nsize passed to bpf_map_area_alloc() could lead to an integer overflow.\nAs a result, out-of-bounds write could occur in pcpu_freelist_populate()\nas reported by KASAN:\n\n[...]\n[   16.968613] BUG: KASAN: slab-out-of-bounds in pcpu_freelist_populate+0xd9/0x100\n[   16.969408] Write of size 8 at addr ffff888104fc6ea0 by task crash/78\n[   16.970038]\n[   16.970195] CPU: 0 PID: 78 Comm: crash Not tainted 5.15.0-rc2+ #1\n[   16.970878] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1.1 04/01/2014\n[   16.972026] Call Trace:\n[   16.972306]  dump_stack_lvl+0x34/0x44\n[   16.972687]  print_address_description.constprop.0+0x21/0x140\n[   16.973297]  ? pcpu_freelist_populate+0xd9/0x100\n[   16.973777]  ? pcpu_freelist_populate+0xd9/0x100\n[   16.974257]  kasan_report.cold+0x7f/0x11b\n[   16.974681]  ? pcpu_freelist_populate+0xd9/0x100\n[   16.975190]  pcpu_freelist_populate+0xd9/0x100\n[   16.975669]  stack_map_alloc+0x209/0x2a0\n[   16.976106]  __sys_bpf+0xd83/0x2ce0\n[...]\n\nThe possibility of this overflow was originally discussed in [0], but\nwas overlooked.\n\nFix the integer overflow by changing elem_size to u64 from u32.\n\n  [0] https://lore.kernel.org/bpf/728b238e-a481-eb50-98e9-b0f430ab01e7@gmail.com/\n\nFixes: 557c0c6e7df8 (\"bpf: convert stackmap to pre-allocation\")\nSigned-off-by: Tatsuhiko Yasumatsu <th.yasumatsu@gmail.com>\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>\nLink: https://lore.kernel.org/bpf/20210930135545.173698-1-th.yasumatsu@gmail.com", "target": 1, "func": "static int prealloc_elems_and_freelist(struct bpf_stack_map *smap)\n{\n\tu32 elem_size = sizeof(struct stack_map_bucket) + smap->map.value_size;\n\tint err;\n\n\tsmap->elems = bpf_map_area_alloc(elem_size * smap->map.max_entries,\n\t\t\t\t\t smap->map.numa_node);\n\tif (!smap->elems)\n\t\treturn -ENOMEM;\n\n\terr = pcpu_freelist_init(&smap->freelist);\n\tif (err)\n\t\tgoto free_elems;\n\n\tpcpu_freelist_populate(&smap->freelist, smap->elems, elem_size,\n\t\t\t       smap->map.max_entries);\n\treturn 0;\n\nfree_elems:\n\tbpf_map_area_free(smap->elems);\n\treturn err;\n}", "func_hash": 178134261771669129761013963339102987528, "file_name": "stackmap.c", "file_hash": 212947868785159241816012605096544782433, "cwe": ["CWE-787"], "cve": "CVE-2021-41864", "cve_desc": "prealloc_elems_and_freelist in kernel/bpf/stackmap.c in the Linux kernel before 5.14.12 allows unprivileged users to trigger an eBPF multiplication integer overflow with a resultant out-of-bounds write.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-41864", "file_path": "kernel/bpf/stackmap.c"}
{"idx": 459524, "project": "linux", "commit_id": "30e29a9a2bc6a4888335a6ede968b75cd329657a", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/30e29a9a2bc6a4888335a6ede968b75cd329657a", "commit_message": "bpf: Fix integer overflow in prealloc_elems_and_freelist()\n\nIn prealloc_elems_and_freelist(), the multiplication to calculate the\nsize passed to bpf_map_area_alloc() could lead to an integer overflow.\nAs a result, out-of-bounds write could occur in pcpu_freelist_populate()\nas reported by KASAN:\n\n[...]\n[   16.968613] BUG: KASAN: slab-out-of-bounds in pcpu_freelist_populate+0xd9/0x100\n[   16.969408] Write of size 8 at addr ffff888104fc6ea0 by task crash/78\n[   16.970038]\n[   16.970195] CPU: 0 PID: 78 Comm: crash Not tainted 5.15.0-rc2+ #1\n[   16.970878] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1.1 04/01/2014\n[   16.972026] Call Trace:\n[   16.972306]  dump_stack_lvl+0x34/0x44\n[   16.972687]  print_address_description.constprop.0+0x21/0x140\n[   16.973297]  ? pcpu_freelist_populate+0xd9/0x100\n[   16.973777]  ? pcpu_freelist_populate+0xd9/0x100\n[   16.974257]  kasan_report.cold+0x7f/0x11b\n[   16.974681]  ? pcpu_freelist_populate+0xd9/0x100\n[   16.975190]  pcpu_freelist_populate+0xd9/0x100\n[   16.975669]  stack_map_alloc+0x209/0x2a0\n[   16.976106]  __sys_bpf+0xd83/0x2ce0\n[...]\n\nThe possibility of this overflow was originally discussed in [0], but\nwas overlooked.\n\nFix the integer overflow by changing elem_size to u64 from u32.\n\n  [0] https://lore.kernel.org/bpf/728b238e-a481-eb50-98e9-b0f430ab01e7@gmail.com/\n\nFixes: 557c0c6e7df8 (\"bpf: convert stackmap to pre-allocation\")\nSigned-off-by: Tatsuhiko Yasumatsu <th.yasumatsu@gmail.com>\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>\nLink: https://lore.kernel.org/bpf/20210930135545.173698-1-th.yasumatsu@gmail.com", "target": 0, "func": "static int prealloc_elems_and_freelist(struct bpf_stack_map *smap)\n{\n\tu64 elem_size = sizeof(struct stack_map_bucket) +\n\t\t\t(u64)smap->map.value_size;\n\tint err;\n\n\tsmap->elems = bpf_map_area_alloc(elem_size * smap->map.max_entries,\n\t\t\t\t\t smap->map.numa_node);\n\tif (!smap->elems)\n\t\treturn -ENOMEM;\n\n\terr = pcpu_freelist_init(&smap->freelist);\n\tif (err)\n\t\tgoto free_elems;\n\n\tpcpu_freelist_populate(&smap->freelist, smap->elems, elem_size,\n\t\t\t       smap->map.max_entries);\n\treturn 0;\n\nfree_elems:\n\tbpf_map_area_free(smap->elems);\n\treturn err;\n}", "func_hash": 247842121005492107026661682297731302199, "file_name": "stackmap.c", "file_hash": 198452357082465344097055898312719400384, "cwe": ["CWE-787"], "cve": "CVE-2021-41864", "cve_desc": "prealloc_elems_and_freelist in kernel/bpf/stackmap.c in the Linux kernel before 5.14.12 allows unprivileged users to trigger an eBPF multiplication integer overflow with a resultant out-of-bounds write.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-41864", "file_path": "kernel/bpf/stackmap.c"}
{"idx": 212829, "project": "php-src", "commit_id": "698a691724c0a949295991e5df091ce16f899e02", "project_url": "https://github.com/php/php-src", "commit_url": "https://github.com/php/php-src/commit/698a691724c0a949295991e5df091ce16f899e02?w=1", "commit_message": "Fix bug #72750: wddx_deserialize null dereference", "target": 1, "func": " */\nstatic void php_wddx_pop_element(void *user_data, const XML_Char *name)\n{\n\tst_entry \t\t\t*ent1, *ent2;\n\twddx_stack \t\t\t*stack = (wddx_stack *)user_data;\n\tHashTable \t\t\t*target_hash;\n\tzend_class_entry \t**pce;\n\tzval\t\t\t\t*obj;\n\tzval\t\t\t\t*tmp;\n\tTSRMLS_FETCH();\n\n/* OBJECTS_FIXME */\n\tif (stack->top == 0) {\n\t\treturn;\n\t}\n\n\tif (!strcmp(name, EL_STRING) || !strcmp(name, EL_NUMBER) ||\n\t\t!strcmp(name, EL_BOOLEAN) || !strcmp(name, EL_NULL) ||\n\t  \t!strcmp(name, EL_ARRAY) || !strcmp(name, EL_STRUCT) ||\n\t\t!strcmp(name, EL_RECORDSET) || !strcmp(name, EL_BINARY) ||\n\t\t!strcmp(name, EL_DATETIME)) {\n\t\twddx_stack_top(stack, (void**)&ent1);\n\n\t\tif (!ent1->data) {\n\t\t\tif (stack->top > 1) {\n\t\t\t\tstack->top--;\n\t\t\t} else {\n\t\t\t\tstack->done = 1;\n\t\t\t}\n\t\t\tefree(ent1);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!strcmp(name, EL_BINARY)) {\n\t\t\tint new_len=0;\n\t\t\tunsigned char *new_str;\n\n\t\t\tnew_str = php_base64_decode(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data), &new_len);\n\t\t\tSTR_FREE(Z_STRVAL_P(ent1->data));\n\t\t\tZ_STRVAL_P(ent1->data) = new_str;\n\t\t\tZ_STRLEN_P(ent1->data) = new_len;\n\t\t}\n\n\t\t/* Call __wakeup() method on the object. */\n\t\tif (Z_TYPE_P(ent1->data) == IS_OBJECT) {\n\t\t\tzval *fname, *retval = NULL;\n\n\t\t\tMAKE_STD_ZVAL(fname);\n\t\t\tZVAL_STRING(fname, \"__wakeup\", 1);\n\n\t\t\tcall_user_function_ex(NULL, &ent1->data, fname, &retval, 0, 0, 0, NULL TSRMLS_CC);\n\n\t\t\tzval_dtor(fname);\n\t\t\tFREE_ZVAL(fname);\n\t\t\tif (retval) {\n\t\t\t\tzval_ptr_dtor(&retval);\n\t\t\t}\n\t\t}\n\n\t\tif (stack->top > 1) {\n\t\t\tstack->top--;\n\t\t\twddx_stack_top(stack, (void**)&ent2);\n\n\t\t\t/* if non-existent field */\n\t\t\tif (ent2->type == ST_FIELD && ent2->data == NULL) {\n\t\t\t\tzval_ptr_dtor(&ent1->data);\n\t\t\t\tefree(ent1);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (Z_TYPE_P(ent2->data) == IS_ARRAY || Z_TYPE_P(ent2->data) == IS_OBJECT) {\n\t\t\t\ttarget_hash = HASH_OF(ent2->data);\n\n\t\t\t\tif (ent1->varname) {\n\t\t\t\t\tif (!strcmp(ent1->varname, PHP_CLASS_NAME_VAR) &&\n\t\t\t\t\t\tZ_TYPE_P(ent1->data) == IS_STRING && Z_STRLEN_P(ent1->data) &&\n\t\t\t\t\t\tent2->type == ST_STRUCT && Z_TYPE_P(ent2->data) == IS_ARRAY) {\n\t\t\t\t\t\tzend_bool incomplete_class = 0;\n\n\t\t\t\t\t\tzend_str_tolower(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));\n\t\t\t\t\t\tif (zend_hash_find(EG(class_table), Z_STRVAL_P(ent1->data),\n\t\t\t\t\t\t\t\t\t\t   Z_STRLEN_P(ent1->data)+1, (void **) &pce)==FAILURE) {\n\t\t\t\t\t\t\tincomplete_class = 1;\n\t\t\t\t\t\t\tpce = &PHP_IC_ENTRY;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* Initialize target object */\n\t\t\t\t\t\tMAKE_STD_ZVAL(obj);\n\t\t\t\t\t\tobject_init_ex(obj, *pce);\n\n\t\t\t\t\t\t/* Merge current hashtable with object's default properties */\n\t\t\t\t\t\tzend_hash_merge(Z_OBJPROP_P(obj),\n\t\t\t\t\t\t\t\t\t\tZ_ARRVAL_P(ent2->data),\n\t\t\t\t\t\t\t\t\t\t(void (*)(void *)) zval_add_ref,\n\t\t\t\t\t\t\t\t\t\t(void *) &tmp, sizeof(zval *), 0);\n\n\t\t\t\t\t\tif (incomplete_class) {\n\t\t\t\t\t\t\tphp_store_class_name(obj, Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* Clean up old array entry */\n\t\t\t\t\t\tzval_ptr_dtor(&ent2->data);\n\n\t\t\t\t\t\t/* Set stack entry to point to the newly created object */\n\t\t\t\t\t\tent2->data = obj;\n\n\t\t\t\t\t\t/* Clean up class name var entry */\n\t\t\t\t\t\tzval_ptr_dtor(&ent1->data);\n\t\t\t\t\t} else if (Z_TYPE_P(ent2->data) == IS_OBJECT) {\n\t\t\t\t\t\tzend_class_entry *old_scope = EG(scope);\n\n\t\t\t\t\t\tEG(scope) = Z_OBJCE_P(ent2->data);\n\t\t\t\t\t\tZ_DELREF_P(ent1->data);\n\t\t\t\t\t\tadd_property_zval(ent2->data, ent1->varname, ent1->data);\n\t\t\t\t\t\tEG(scope) = old_scope;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tzend_symtable_update(target_hash, ent1->varname, strlen(ent1->varname)+1, &ent1->data, sizeof(zval *), NULL);\n\t\t\t\t\t}\n\t\t\t\t\tefree(ent1->varname);\n\t\t\t\t} else\t{\n\t\t\t\t\tzend_hash_next_index_insert(target_hash, &ent1->data, sizeof(zval *), NULL);\n\t\t\t\t}\n\t\t\t}\n\t\t\tefree(ent1);\n\t\t} else {\n\t\t\tstack->done = 1;\n\t\t}\n\t} else if (!strcmp(name, EL_VAR) && stack->varname) {\n\t\tefree(stack->varname);\n\t\tstack->varname = NULL;\n\t} else if (!strcmp(name, EL_FIELD)) {\n\t\tst_entry *ent;\n\t\twddx_stack_top(stack, (void **)&ent);\n\t\tefree(ent);\n\t\tstack->top--;\n\t}", "func_hash": 256847714577175382991355330020307438516, "file_name": "wddx.c", "file_hash": 145600633466725124063532436200225083004, "cwe": ["CWE-476"], "cve": "CVE-2016-7130", "cve_desc": "The php_wddx_pop_element function in ext/wddx/wddx.c in PHP before 5.6.25 and 7.x before 7.0.10 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) or possibly have unspecified other impact via an invalid base64 binary value, as demonstrated by a wddx_deserialize call that mishandles a binary element in a wddxPacket XML document.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-7130", "file_path": "ext/wddx/wddx.c"}
{"idx": 462395, "project": "php-src", "commit_id": "698a691724c0a949295991e5df091ce16f899e02", "project_url": "https://github.com/php/php-src", "commit_url": "https://github.com/php/php-src/commit/698a691724c0a949295991e5df091ce16f899e02?w=1", "commit_message": "Fix bug #72750: wddx_deserialize null dereference", "target": 0, "func": " */\nstatic void php_wddx_pop_element(void *user_data, const XML_Char *name)\n{\n\tst_entry \t\t\t*ent1, *ent2;\n\twddx_stack \t\t\t*stack = (wddx_stack *)user_data;\n\tHashTable \t\t\t*target_hash;\n\tzend_class_entry \t**pce;\n\tzval\t\t\t\t*obj;\n\tzval\t\t\t\t*tmp;\n\tTSRMLS_FETCH();\n\n/* OBJECTS_FIXME */\n\tif (stack->top == 0) {\n\t\treturn;\n\t}\n\n\tif (!strcmp(name, EL_STRING) || !strcmp(name, EL_NUMBER) ||\n\t\t!strcmp(name, EL_BOOLEAN) || !strcmp(name, EL_NULL) ||\n\t  \t!strcmp(name, EL_ARRAY) || !strcmp(name, EL_STRUCT) ||\n\t\t!strcmp(name, EL_RECORDSET) || !strcmp(name, EL_BINARY) ||\n\t\t!strcmp(name, EL_DATETIME)) {\n\t\twddx_stack_top(stack, (void**)&ent1);\n\n\t\tif (!ent1->data) {\n\t\t\tif (stack->top > 1) {\n\t\t\t\tstack->top--;\n\t\t\t} else {\n\t\t\t\tstack->done = 1;\n\t\t\t}\n\t\t\tefree(ent1);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!strcmp(name, EL_BINARY)) {\n\t\t\tint new_len=0;\n\t\t\tunsigned char *new_str;\n\n\t\t\tnew_str = php_base64_decode(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data), &new_len);\n\t\t\tSTR_FREE(Z_STRVAL_P(ent1->data));\n\t\t\tif (new_str) {\n\t\t\t\tZ_STRVAL_P(ent1->data) = new_str;\n\t\t\t\tZ_STRLEN_P(ent1->data) = new_len;\n\t\t\t} else {\n\t\t\t\tZVAL_EMPTY_STRING(ent1->data);\n\t\t\t}\n\t\t}\n\n\t\t/* Call __wakeup() method on the object. */\n\t\tif (Z_TYPE_P(ent1->data) == IS_OBJECT) {\n\t\t\tzval *fname, *retval = NULL;\n\n\t\t\tMAKE_STD_ZVAL(fname);\n\t\t\tZVAL_STRING(fname, \"__wakeup\", 1);\n\n\t\t\tcall_user_function_ex(NULL, &ent1->data, fname, &retval, 0, 0, 0, NULL TSRMLS_CC);\n\n\t\t\tzval_dtor(fname);\n\t\t\tFREE_ZVAL(fname);\n\t\t\tif (retval) {\n\t\t\t\tzval_ptr_dtor(&retval);\n\t\t\t}\n\t\t}\n\n\t\tif (stack->top > 1) {\n\t\t\tstack->top--;\n\t\t\twddx_stack_top(stack, (void**)&ent2);\n\n\t\t\t/* if non-existent field */\n\t\t\tif (ent2->type == ST_FIELD && ent2->data == NULL) {\n\t\t\t\tzval_ptr_dtor(&ent1->data);\n\t\t\t\tefree(ent1);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (Z_TYPE_P(ent2->data) == IS_ARRAY || Z_TYPE_P(ent2->data) == IS_OBJECT) {\n\t\t\t\ttarget_hash = HASH_OF(ent2->data);\n\n\t\t\t\tif (ent1->varname) {\n\t\t\t\t\tif (!strcmp(ent1->varname, PHP_CLASS_NAME_VAR) &&\n\t\t\t\t\t\tZ_TYPE_P(ent1->data) == IS_STRING && Z_STRLEN_P(ent1->data) &&\n\t\t\t\t\t\tent2->type == ST_STRUCT && Z_TYPE_P(ent2->data) == IS_ARRAY) {\n\t\t\t\t\t\tzend_bool incomplete_class = 0;\n\n\t\t\t\t\t\tzend_str_tolower(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));\n\t\t\t\t\t\tif (zend_hash_find(EG(class_table), Z_STRVAL_P(ent1->data),\n\t\t\t\t\t\t\t\t\t\t   Z_STRLEN_P(ent1->data)+1, (void **) &pce)==FAILURE) {\n\t\t\t\t\t\t\tincomplete_class = 1;\n\t\t\t\t\t\t\tpce = &PHP_IC_ENTRY;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* Initialize target object */\n\t\t\t\t\t\tMAKE_STD_ZVAL(obj);\n\t\t\t\t\t\tobject_init_ex(obj, *pce);\n\n\t\t\t\t\t\t/* Merge current hashtable with object's default properties */\n\t\t\t\t\t\tzend_hash_merge(Z_OBJPROP_P(obj),\n\t\t\t\t\t\t\t\t\t\tZ_ARRVAL_P(ent2->data),\n\t\t\t\t\t\t\t\t\t\t(void (*)(void *)) zval_add_ref,\n\t\t\t\t\t\t\t\t\t\t(void *) &tmp, sizeof(zval *), 0);\n\n\t\t\t\t\t\tif (incomplete_class) {\n\t\t\t\t\t\t\tphp_store_class_name(obj, Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* Clean up old array entry */\n\t\t\t\t\t\tzval_ptr_dtor(&ent2->data);\n\n\t\t\t\t\t\t/* Set stack entry to point to the newly created object */\n\t\t\t\t\t\tent2->data = obj;\n\n\t\t\t\t\t\t/* Clean up class name var entry */\n\t\t\t\t\t\tzval_ptr_dtor(&ent1->data);\n\t\t\t\t\t} else if (Z_TYPE_P(ent2->data) == IS_OBJECT) {\n\t\t\t\t\t\tzend_class_entry *old_scope = EG(scope);\n\n\t\t\t\t\t\tEG(scope) = Z_OBJCE_P(ent2->data);\n\t\t\t\t\t\tZ_DELREF_P(ent1->data);\n\t\t\t\t\t\tadd_property_zval(ent2->data, ent1->varname, ent1->data);\n\t\t\t\t\t\tEG(scope) = old_scope;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tzend_symtable_update(target_hash, ent1->varname, strlen(ent1->varname)+1, &ent1->data, sizeof(zval *), NULL);\n\t\t\t\t\t}\n\t\t\t\t\tefree(ent1->varname);\n\t\t\t\t} else\t{\n\t\t\t\t\tzend_hash_next_index_insert(target_hash, &ent1->data, sizeof(zval *), NULL);\n\t\t\t\t}\n\t\t\t}\n\t\t\tefree(ent1);\n\t\t} else {\n\t\t\tstack->done = 1;\n\t\t}\n\t} else if (!strcmp(name, EL_VAR) && stack->varname) {\n\t\tefree(stack->varname);\n\t\tstack->varname = NULL;\n\t} else if (!strcmp(name, EL_FIELD)) {\n\t\tst_entry *ent;\n\t\twddx_stack_top(stack, (void **)&ent);\n\t\tefree(ent);\n\t\tstack->top--;\n\t}", "func_hash": 281846366232469448026733489364664016551, "file_name": "wddx.c", "file_hash": 180653157857930473406661829830823818897, "cwe": ["CWE-476"], "cve": "CVE-2016-7130", "cve_desc": "The php_wddx_pop_element function in ext/wddx/wddx.c in PHP before 5.6.25 and 7.x before 7.0.10 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) or possibly have unspecified other impact via an invalid base64 binary value, as demonstrated by a wddx_deserialize call that mishandles a binary element in a wddxPacket XML document.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-7130", "file_path": "ext/wddx/wddx.c"}
{"idx": 212834, "project": "rsyslog", "commit_id": "0381a0de64a5a048c3d48b79055bd9848d0c7fc2", "project_url": "https://github.com/rsyslog/rsyslog", "commit_url": "https://github.com/rsyslog/rsyslog/commit/0381a0de64a5a048c3d48b79055bd9848d0c7fc2", "commit_message": "imptcp: fix Segmentation Fault when octet count is to high", "target": 1, "func": "processDataRcvd(ptcpsess_t *const __restrict__ pThis,\n\tchar **buff,\n\tconst int buffLen,\n\tstruct syslogTime *stTime,\n\tconst time_t ttGenTime,\n\tmulti_submit_t *pMultiSub,\n\tunsigned *const __restrict__ pnMsgs)\n{\n\tDEFiRet;\n\tchar c = **buff;\n\tint octatesToCopy, octatesToDiscard;\n\n\tif(pThis->inputState == eAtStrtFram) {\n\t\tif(pThis->bSuppOctetFram && isdigit((int) c)) {\n\t\t\tpThis->inputState = eInOctetCnt;\n\t\t\tpThis->iOctetsRemain = 0;\n\t\t\tpThis->eFraming = TCP_FRAMING_OCTET_COUNTING;\n\t\t} else if(pThis->bSPFramingFix && c == ' ') {\n\t\t\t/* Cisco very occasionally sends a SP after a LF, which\n\t\t\t * thrashes framing if not taken special care of. Here,\n\t\t\t * we permit space *in front of the next frame* and\n\t\t\t * ignore it.\n\t\t\t */\n\t\t\t FINALIZE;\n\t\t} else {\n\t\t\tpThis->inputState = eInMsg;\n\t\t\tpThis->eFraming = TCP_FRAMING_OCTET_STUFFING;\n\t\t}\n\t}\n\n\tif(pThis->inputState == eInOctetCnt) {\n\t\tif(isdigit(c)) {\n\t\t\tpThis->iOctetsRemain = pThis->iOctetsRemain * 10 + c - '0';\n\t\t} else { /* done with the octet count, so this must be the SP terminator */\n\t\t\tDBGPRINTF(\"TCP Message with octet-counter, size %d.\\n\", pThis->iOctetsRemain);\n\t\t\tif(c != ' ') {\n\t\t\t\terrmsg.LogError(0, NO_ERRCODE, \"Framing Error in received TCP message: \"\n\t\t\t\t\t    \"delimiter is not SP but has ASCII value %d.\", c);\n\t\t\t}\n\t\t\tif(pThis->iOctetsRemain < 1) {\n\t\t\t\t/* TODO: handle the case where the octet count is 0! */\n\t\t\t\tDBGPRINTF(\"Framing Error: invalid octet count\\n\");\n\t\t\t\terrmsg.LogError(0, NO_ERRCODE, \"Framing Error in received TCP message: \"\n\t\t\t\t\t    \"invalid octet count %d.\", pThis->iOctetsRemain);\n\t\t\t} else if(pThis->iOctetsRemain > iMaxLine) {\n\t\t\t\t/* while we can not do anything against it, we can at least log an indication\n\t\t\t\t * that something went wrong) -- rgerhards, 2008-03-14\n\t\t\t\t */\n\t\t\t\tDBGPRINTF(\"truncating message with %d octets - max msg size is %d\\n\",\n\t\t\t\t\t  pThis->iOctetsRemain, iMaxLine);\n\t\t\t\terrmsg.LogError(0, NO_ERRCODE, \"received oversize message: size is %d bytes, \"\n\t\t\t\t\t        \"max msg size is %d, truncating...\", pThis->iOctetsRemain, iMaxLine);\n\t\t\t}\n\t\t\tpThis->inputState = eInMsg;\n\t\t}\n\t} else {\n\t\tassert(pThis->inputState == eInMsg);\n\n\t\tif (pThis->eFraming == TCP_FRAMING_OCTET_STUFFING) {\n\t\t\tif(pThis->iMsg >= iMaxLine) {\n\t\t\t\t/* emergency, we now need to flush, no matter if we are at end of message or not... */\n\t\t\t\tint i = 1;\n\t\t\t\tchar currBuffChar;\n\t\t\t\twhile(i < buffLen && ((currBuffChar = (*buff)[i]) != '\\n'\n\t\t\t\t\t&& (pThis->pLstn->pSrv->iAddtlFrameDelim == TCPSRV_NO_ADDTL_DELIMITER\n\t\t\t\t\t\t|| currBuffChar != pThis->pLstn->pSrv->iAddtlFrameDelim))) {\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tLogError(0, NO_ERRCODE, \"error: message received is at least %d byte larger than max msg\"\n\t\t\t\t\t\" size; message will be split starting at: \\\"%.*s\\\"\\n\", i, (i < 32) ? i : 32, *buff);\n\t\t\t\tdoSubmitMsg(pThis, stTime, ttGenTime, pMultiSub);\n\t\t\t\t++(*pnMsgs);\n\t\t\t\t/* we might think if it is better to ignore the rest of the\n\t\t\t\t * message than to treat it as a new one. Maybe this is a good\n\t\t\t\t * candidate for a configuration parameter...\n\t\t\t\t * rgerhards, 2006-12-04\n\t\t\t\t */\n\t\t\t}\n\n\t\t\tif ((c == '\\n')\n\t\t\t\t   || ((pThis->pLstn->pSrv->iAddtlFrameDelim != TCPSRV_NO_ADDTL_DELIMITER)\n\t\t\t\t\t   && (c == pThis->pLstn->pSrv->iAddtlFrameDelim))\n\t\t\t\t   ) { /* record delimiter? */\n\t\t\t\tdoSubmitMsg(pThis, stTime, ttGenTime, pMultiSub);\n\t\t\t\t++(*pnMsgs);\n\t\t\t\tpThis->inputState = eAtStrtFram;\n\t\t\t} else {\n\t\t\t\t/* IMPORTANT: here we copy the actual frame content to the message - for BOTH framing modes!\n\t\t\t\t * If we have a message that is larger than the max msg size, we truncate it. This is the best\n\t\t\t\t * we can do in light of what the engine supports. -- rgerhards, 2008-03-14\n\t\t\t\t */\n\t\t\t\tif(pThis->iMsg < iMaxLine) {\n\t\t\t\t\t*(pThis->pMsg + pThis->iMsg++) = c;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tassert(pThis->eFraming == TCP_FRAMING_OCTET_COUNTING);\n\t\t\toctatesToCopy = pThis->iOctetsRemain;\n\t\t\toctatesToDiscard = 0;\n\t\t\tif (buffLen < octatesToCopy) {\n\t\t\t\toctatesToCopy = buffLen;\n\t\t\t}\n\t\t\tif (octatesToCopy + pThis->iMsg > iMaxLine) {\n\t\t\t\toctatesToDiscard = octatesToCopy - (iMaxLine - pThis->iMsg);\n\t\t\t\toctatesToCopy = iMaxLine - pThis->iMsg;\n\t\t\t}\n\n\t\t\tmemcpy(pThis->pMsg + pThis->iMsg, *buff, octatesToCopy);\n\t\t\tpThis->iMsg += octatesToCopy;\n\t\t\tpThis->iOctetsRemain -= (octatesToCopy + octatesToDiscard);\n\t\t\t*buff += (octatesToCopy + octatesToDiscard - 1);\n\t\t\tif (pThis->iOctetsRemain == 0) {\n\t\t\t\t/* we have end of frame! */\n\t\t\t\tdoSubmitMsg(pThis, stTime, ttGenTime, pMultiSub);\n\t\t\t\t++(*pnMsgs);\n\t\t\t\tpThis->inputState = eAtStrtFram;\n\t\t\t}\n\t\t}\n\n\t}\n\nfinalize_it:\n\tRETiRet;\n}", "func_hash": 175845780697344678841951403700990960175, "file_name": "imptcp.c", "file_hash": 66608949268386945207139768258979939814, "cwe": ["CWE-190"], "cve": "CVE-2018-16881", "cve_desc": "A denial of service vulnerability was found in rsyslog in the imptcp module. An attacker could send a specially crafted message to the imptcp socket, which would cause rsyslog to crash. Versions before 8.27.0 are vulnerable.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2018-16881", "file_path": "plugins/imptcp/imptcp.c"}
{"idx": 462409, "project": "rsyslog", "commit_id": "0381a0de64a5a048c3d48b79055bd9848d0c7fc2", "project_url": "https://github.com/rsyslog/rsyslog", "commit_url": "https://github.com/rsyslog/rsyslog/commit/0381a0de64a5a048c3d48b79055bd9848d0c7fc2", "commit_message": "imptcp: fix Segmentation Fault when octet count is to high", "target": 0, "func": "processDataRcvd(ptcpsess_t *const __restrict__ pThis,\n\tchar **buff,\n\tconst int buffLen,\n\tstruct syslogTime *stTime,\n\tconst time_t ttGenTime,\n\tmulti_submit_t *pMultiSub,\n\tunsigned *const __restrict__ pnMsgs)\n{\n\tDEFiRet;\n\tchar c = **buff;\n\tint octatesToCopy, octatesToDiscard;\n\n\tif(pThis->inputState == eAtStrtFram) {\n\t\tif(pThis->bSuppOctetFram && isdigit((int) c)) {\n\t\t\tpThis->inputState = eInOctetCnt;\n\t\t\tpThis->iOctetsRemain = 0;\n\t\t\tpThis->eFraming = TCP_FRAMING_OCTET_COUNTING;\n\t\t} else if(pThis->bSPFramingFix && c == ' ') {\n\t\t\t/* Cisco very occasionally sends a SP after a LF, which\n\t\t\t * thrashes framing if not taken special care of. Here,\n\t\t\t * we permit space *in front of the next frame* and\n\t\t\t * ignore it.\n\t\t\t */\n\t\t\t FINALIZE;\n\t\t} else {\n\t\t\tpThis->inputState = eInMsg;\n\t\t\tpThis->eFraming = TCP_FRAMING_OCTET_STUFFING;\n\t\t}\n\t}\n\n\tif(pThis->inputState == eInOctetCnt) {\n\t\tif(isdigit(c)) {\n\t\t\tif(pThis->iOctetsRemain <= 200000000) {\n\t\t\t\tpThis->iOctetsRemain = pThis->iOctetsRemain * 10 + c - '0';\n\t\t\t} else {\n\t\t\t\terrmsg.LogError(0, NO_ERRCODE, \"Framing Error in received TCP message: \"\n\t\t\t\t\t\t\"frame too large (at least %d%c), change to octet stuffing\",\n\t\t\t\t\t\tpThis->iOctetsRemain, c);\n\t\t\t\tpThis->eFraming = TCP_FRAMING_OCTET_STUFFING;\n\t\t\t\tpThis->inputState = eInMsg;\n\t\t\t}\n\t\t\t*(pThis->pMsg + pThis->iMsg++) = c;\n\t\t} else { /* done with the octet count, so this must be the SP terminator */\n\t\t\tDBGPRINTF(\"TCP Message with octet-counter, size %d.\\n\", pThis->iOctetsRemain);\n\t\t\tif(c != ' ') {\n\t\t\t\terrmsg.LogError(0, NO_ERRCODE, \"Framing Error in received TCP message: \"\n\t\t\t\t\t    \"delimiter is not SP but has ASCII value %d.\", c);\n\t\t\t}\n\t\t\tif(pThis->iOctetsRemain < 1) {\n\t\t\t\t/* TODO: handle the case where the octet count is 0! */\n\t\t\t\terrmsg.LogError(0, NO_ERRCODE, \"Framing Error in received TCP message: \"\n\t\t\t\t\t    \"invalid octet count %d.\", pThis->iOctetsRemain);\n\t\t\t\tpThis->eFraming = TCP_FRAMING_OCTET_STUFFING;\n\t\t\t} else if(pThis->iOctetsRemain > iMaxLine) {\n\t\t\t\t/* while we can not do anything against it, we can at least log an indication\n\t\t\t\t * that something went wrong) -- rgerhards, 2008-03-14\n\t\t\t\t */\n\t\t\t\tDBGPRINTF(\"truncating message with %d octets - max msg size is %d\\n\",\n\t\t\t\t\t  pThis->iOctetsRemain, iMaxLine);\n\t\t\t\terrmsg.LogError(0, NO_ERRCODE, \"received oversize message: size is %d bytes, \"\n\t\t\t\t\t        \"max msg size is %d, truncating...\", pThis->iOctetsRemain, iMaxLine);\n\t\t\t}\n\t\t\tpThis->inputState = eInMsg;\n\t\t\tpThis->iMsg = 0;\n\t\t}\n\t} else {\n\t\tassert(pThis->inputState == eInMsg);\n\n\t\tif (pThis->eFraming == TCP_FRAMING_OCTET_STUFFING) {\n\t\t\tif(pThis->iMsg >= iMaxLine) {\n\t\t\t\t/* emergency, we now need to flush, no matter if we are at end of message or not... */\n\t\t\t\tint i = 1;\n\t\t\t\tchar currBuffChar;\n\t\t\t\twhile(i < buffLen && ((currBuffChar = (*buff)[i]) != '\\n'\n\t\t\t\t\t&& (pThis->pLstn->pSrv->iAddtlFrameDelim == TCPSRV_NO_ADDTL_DELIMITER\n\t\t\t\t\t\t|| currBuffChar != pThis->pLstn->pSrv->iAddtlFrameDelim))) {\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tLogError(0, NO_ERRCODE, \"error: message received is at least %d byte larger than max msg\"\n\t\t\t\t\t\" size; message will be split starting at: \\\"%.*s\\\"\\n\", i, (i < 32) ? i : 32, *buff);\n\t\t\t\tdoSubmitMsg(pThis, stTime, ttGenTime, pMultiSub);\n\t\t\t\t++(*pnMsgs);\n\t\t\t\t/* we might think if it is better to ignore the rest of the\n\t\t\t\t * message than to treat it as a new one. Maybe this is a good\n\t\t\t\t * candidate for a configuration parameter...\n\t\t\t\t * rgerhards, 2006-12-04\n\t\t\t\t */\n\t\t\t}\n\n\t\t\tif ((c == '\\n')\n\t\t\t\t   || ((pThis->pLstn->pSrv->iAddtlFrameDelim != TCPSRV_NO_ADDTL_DELIMITER)\n\t\t\t\t\t   && (c == pThis->pLstn->pSrv->iAddtlFrameDelim))\n\t\t\t\t   ) { /* record delimiter? */\n\t\t\t\tdoSubmitMsg(pThis, stTime, ttGenTime, pMultiSub);\n\t\t\t\t++(*pnMsgs);\n\t\t\t\tpThis->inputState = eAtStrtFram;\n\t\t\t} else {\n\t\t\t\t/* IMPORTANT: here we copy the actual frame content to the message - for BOTH framing modes!\n\t\t\t\t * If we have a message that is larger than the max msg size, we truncate it. This is the best\n\t\t\t\t * we can do in light of what the engine supports. -- rgerhards, 2008-03-14\n\t\t\t\t */\n\t\t\t\tif(pThis->iMsg < iMaxLine) {\n\t\t\t\t\t*(pThis->pMsg + pThis->iMsg++) = c;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tassert(pThis->eFraming == TCP_FRAMING_OCTET_COUNTING);\n\t\t\toctatesToCopy = pThis->iOctetsRemain;\n\t\t\toctatesToDiscard = 0;\n\t\t\tif (buffLen < octatesToCopy) {\n\t\t\t\toctatesToCopy = buffLen;\n\t\t\t}\n\t\t\tif (octatesToCopy + pThis->iMsg > iMaxLine) {\n\t\t\t\toctatesToDiscard = octatesToCopy - (iMaxLine - pThis->iMsg);\n\t\t\t\toctatesToCopy = iMaxLine - pThis->iMsg;\n\t\t\t}\n\n\t\t\tmemcpy(pThis->pMsg + pThis->iMsg, *buff, octatesToCopy);\n\t\t\tpThis->iMsg += octatesToCopy;\n\t\t\tpThis->iOctetsRemain -= (octatesToCopy + octatesToDiscard);\n\t\t\t*buff += (octatesToCopy + octatesToDiscard - 1);\n\t\t\tif (pThis->iOctetsRemain == 0) {\n\t\t\t\t/* we have end of frame! */\n\t\t\t\tdoSubmitMsg(pThis, stTime, ttGenTime, pMultiSub);\n\t\t\t\t++(*pnMsgs);\n\t\t\t\tpThis->inputState = eAtStrtFram;\n\t\t\t}\n\t\t}\n\n\t}\n\nfinalize_it:\n\tRETiRet;\n}", "func_hash": 319180109338452321529530788318348241217, "file_name": "imptcp.c", "file_hash": 222511081390723120608536252618686301143, "cwe": ["CWE-190"], "cve": "CVE-2018-16881", "cve_desc": "A denial of service vulnerability was found in rsyslog in the imptcp module. An attacker could send a specially crafted message to the imptcp socket, which would cause rsyslog to crash. Versions before 8.27.0 are vulnerable.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2018-16881", "file_path": "plugins/imptcp/imptcp.c"}
{"idx": 212857, "project": "vim", "commit_id": "4f1b083be43f351bc107541e7b0c9655a5d2c0bb", "project_url": "https://github.com/vim/vim", "commit_url": "https://github.com/vim/vim/commit/4f1b083be43f351bc107541e7b0c9655a5d2c0bb", "commit_message": "patch 9.0.0322: crash when no errors and 'quickfixtextfunc' is set\n\nProblem:    Crash when no errors and 'quickfixtextfunc' is set.\nSolution:   Do not handle errors if there aren't any.", "target": 1, "func": "qf_fill_buffer(qf_list_T *qfl, buf_T *buf, qfline_T *old_last, int qf_winid)\n{\n    linenr_T\tlnum;\n    qfline_T\t*qfp;\n    int\t\told_KeyTyped = KeyTyped;\n    list_T\t*qftf_list = NULL;\n    listitem_T\t*qftf_li = NULL;\n\n    if (old_last == NULL)\n    {\n\tif (buf != curbuf)\n\t{\n\t    internal_error(\"qf_fill_buffer()\");\n\t    return;\n\t}\n\n\t// delete all existing lines\n\twhile ((curbuf->b_ml.ml_flags & ML_EMPTY) == 0)\n\t    (void)ml_delete((linenr_T)1);\n    }\n\n    // Check if there is anything to display\n    if (qfl != NULL)\n    {\n\tchar_u\t\tdirname[MAXPATHL];\n\tint\t\tinvalid_val = FALSE;\n\tint\t\tprev_bufnr = -1;\n\n\t*dirname = NUL;\n\n\t// Add one line for each error\n\tif (old_last == NULL)\n\t{\n\t    qfp = qfl->qf_start;\n\t    lnum = 0;\n\t}\n\telse\n\t{\n\t    if (old_last->qf_next != NULL)\n\t\tqfp = old_last->qf_next;\n\t    else\n\t\tqfp = old_last;\n\t    lnum = buf->b_ml.ml_line_count;\n\t}\n\n\tqftf_list = call_qftf_func(qfl, qf_winid, (long)(lnum + 1),\n\t\t\t\t\t\t\t(long)qfl->qf_count);\n\tif (qftf_list != NULL)\n\t    qftf_li = qftf_list->lv_first;\n\n\twhile (lnum < qfl->qf_count)\n\t{\n\t    char_u\t*qftf_str = NULL;\n\n\t    // Use the text supplied by the user defined function (if any).\n\t    // If the returned value is not string, then ignore the rest\n\t    // of the returned values and use the default.\n\t    if (qftf_li != NULL && !invalid_val)\n\t    {\n\t\tqftf_str = tv_get_string_chk(&qftf_li->li_tv);\n\t\tif (qftf_str == NULL)\n\t\t    invalid_val = TRUE;\n\t    }\n\n\t    if (qf_buf_add_line(buf, lnum, qfp, dirname,\n\t\t\tprev_bufnr != qfp->qf_fnum, qftf_str) == FAIL)\n\t\tbreak;\n\n\t    prev_bufnr = qfp->qf_fnum;\n\t    ++lnum;\n\t    qfp = qfp->qf_next;\n\t    if (qfp == NULL)\n\t\tbreak;\n\n\t    if (qftf_li != NULL)\n\t\tqftf_li = qftf_li->li_next;\n\t}\n\n\tif (old_last == NULL)\n\t    // Delete the empty line which is now at the end\n\t    (void)ml_delete(lnum + 1);\n    }\n\n    // correct cursor position\n    check_lnums(TRUE);\n\n    if (old_last == NULL)\n    {\n\t// Set the 'filetype' to \"qf\" each time after filling the buffer.\n\t// This resembles reading a file into a buffer, it's more logical when\n\t// using autocommands.\n\t++curbuf_lock;\n\tset_option_value_give_err((char_u *)\"ft\",\n\t\t\t\t\t\t0L, (char_u *)\"qf\", OPT_LOCAL);\n\tcurbuf->b_p_ma = FALSE;\n\n\tkeep_filetype = TRUE;\t\t// don't detect 'filetype'\n\tapply_autocmds(EVENT_BUFREADPOST, (char_u *)\"quickfix\", NULL,\n\t\t\t\t\t\t\t       FALSE, curbuf);\n\tapply_autocmds(EVENT_BUFWINENTER, (char_u *)\"quickfix\", NULL,\n\t\t\t\t\t\t\t       FALSE, curbuf);\n\tkeep_filetype = FALSE;\n\t--curbuf_lock;\n\n\t// make sure it will be redrawn\n\tredraw_curbuf_later(UPD_NOT_VALID);\n    }\n\n    // Restore KeyTyped, setting 'filetype' may reset it.\n    KeyTyped = old_KeyTyped;\n}", "func_hash": 19896236176049682773029755500370526703, "file_name": "quickfix.c", "file_hash": 67097038911895244025002740290880368768, "cwe": ["CWE-416"], "cve": "CVE-2022-3037", "cve_desc": "Use After Free in GitHub repository vim/vim prior to 9.0.0322.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-3037", "file_path": "src/quickfix.c"}
{"idx": 462511, "project": "vim", "commit_id": "4f1b083be43f351bc107541e7b0c9655a5d2c0bb", "project_url": "https://github.com/vim/vim", "commit_url": "https://github.com/vim/vim/commit/4f1b083be43f351bc107541e7b0c9655a5d2c0bb", "commit_message": "patch 9.0.0322: crash when no errors and 'quickfixtextfunc' is set\n\nProblem:    Crash when no errors and 'quickfixtextfunc' is set.\nSolution:   Do not handle errors if there aren't any.", "target": 0, "func": "qf_fill_buffer(qf_list_T *qfl, buf_T *buf, qfline_T *old_last, int qf_winid)\n{\n    linenr_T\tlnum;\n    qfline_T\t*qfp;\n    int\t\told_KeyTyped = KeyTyped;\n    list_T\t*qftf_list = NULL;\n    listitem_T\t*qftf_li = NULL;\n\n    if (old_last == NULL)\n    {\n\tif (buf != curbuf)\n\t{\n\t    internal_error(\"qf_fill_buffer()\");\n\t    return;\n\t}\n\n\t// delete all existing lines\n\twhile ((curbuf->b_ml.ml_flags & ML_EMPTY) == 0)\n\t    (void)ml_delete((linenr_T)1);\n    }\n\n    // Check if there is anything to display\n    if (qfl != NULL && qfl->qf_start != NULL)\n    {\n\tchar_u\t\tdirname[MAXPATHL];\n\tint\t\tinvalid_val = FALSE;\n\tint\t\tprev_bufnr = -1;\n\n\t*dirname = NUL;\n\n\t// Add one line for each error\n\tif (old_last == NULL)\n\t{\n\t    qfp = qfl->qf_start;\n\t    lnum = 0;\n\t}\n\telse\n\t{\n\t    if (old_last->qf_next != NULL)\n\t\tqfp = old_last->qf_next;\n\t    else\n\t\tqfp = old_last;\n\t    lnum = buf->b_ml.ml_line_count;\n\t}\n\n\tqftf_list = call_qftf_func(qfl, qf_winid, (long)(lnum + 1),\n\t\t\t\t\t\t\t(long)qfl->qf_count);\n\tif (qftf_list != NULL)\n\t    qftf_li = qftf_list->lv_first;\n\n\twhile (lnum < qfl->qf_count)\n\t{\n\t    char_u\t*qftf_str = NULL;\n\n\t    // Use the text supplied by the user defined function (if any).\n\t    // If the returned value is not string, then ignore the rest\n\t    // of the returned values and use the default.\n\t    if (qftf_li != NULL && !invalid_val)\n\t    {\n\t\tqftf_str = tv_get_string_chk(&qftf_li->li_tv);\n\t\tif (qftf_str == NULL)\n\t\t    invalid_val = TRUE;\n\t    }\n\n\t    if (qf_buf_add_line(buf, lnum, qfp, dirname,\n\t\t\tprev_bufnr != qfp->qf_fnum, qftf_str) == FAIL)\n\t\tbreak;\n\n\t    prev_bufnr = qfp->qf_fnum;\n\t    ++lnum;\n\t    qfp = qfp->qf_next;\n\t    if (qfp == NULL)\n\t\tbreak;\n\n\t    if (qftf_li != NULL)\n\t\tqftf_li = qftf_li->li_next;\n\t}\n\n\tif (old_last == NULL)\n\t    // Delete the empty line which is now at the end\n\t    (void)ml_delete(lnum + 1);\n    }\n\n    // correct cursor position\n    check_lnums(TRUE);\n\n    if (old_last == NULL)\n    {\n\t// Set the 'filetype' to \"qf\" each time after filling the buffer.\n\t// This resembles reading a file into a buffer, it's more logical when\n\t// using autocommands.\n\t++curbuf_lock;\n\tset_option_value_give_err((char_u *)\"ft\",\n\t\t\t\t\t\t0L, (char_u *)\"qf\", OPT_LOCAL);\n\tcurbuf->b_p_ma = FALSE;\n\n\tkeep_filetype = TRUE;\t\t// don't detect 'filetype'\n\tapply_autocmds(EVENT_BUFREADPOST, (char_u *)\"quickfix\", NULL,\n\t\t\t\t\t\t\t       FALSE, curbuf);\n\tapply_autocmds(EVENT_BUFWINENTER, (char_u *)\"quickfix\", NULL,\n\t\t\t\t\t\t\t       FALSE, curbuf);\n\tkeep_filetype = FALSE;\n\t--curbuf_lock;\n\n\t// make sure it will be redrawn\n\tredraw_curbuf_later(UPD_NOT_VALID);\n    }\n\n    // Restore KeyTyped, setting 'filetype' may reset it.\n    KeyTyped = old_KeyTyped;\n}", "func_hash": 333242954823260199301291407740047378845, "file_name": "quickfix.c", "file_hash": 221790887990910120742119728344121157301, "cwe": ["CWE-416"], "cve": "CVE-2022-3037", "cve_desc": "Use After Free in GitHub repository vim/vim prior to 9.0.0322.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-3037", "file_path": "src/quickfix.c"}
{"idx": 212871, "project": "newsbeuter", "commit_id": "96e9506ae9e252c548665152d1b8968297128307", "project_url": "https://github.com/akrennmair/newsbeuter", "commit_url": "https://github.com/akrennmair/newsbeuter/commit/96e9506ae9e252c548665152d1b8968297128307", "commit_message": "Sanitize inputs to bookmark-cmd (#591)\n\nNewsbeuter didn't properly shell-escape the arguments passed to\nbookmarking command, which allows a remote attacker to perform remote\ncode execution by crafting an RSS item whose title and/or URL contain\nsomething interpretable by the shell (most notably subshell\ninvocations.)\n\nThis has been reported by Jeriko One <jeriko.one@gmx.us>, complete with\nPoC and a patch.\n\nThis vulnerability was assigned CVE-2017-12904.", "target": 1, "func": "std::string controller::bookmark(\n\t\tconst std::string& url,\n\t\tconst std::string& title,\n\t\tconst std::string& description,\n\t\tconst std::string& feed_title)\n{\n\tstd::string bookmark_cmd = cfg.get_configvalue(\"bookmark-cmd\");\n\tbool is_interactive = cfg.get_configvalue_as_bool(\"bookmark-interactive\");\n\tif (bookmark_cmd.length() > 0) {\n\t\tstd::string cmdline = strprintf::fmt(\"%s '%s' %s %s %s\",\n\t\t                                       bookmark_cmd,\n\t\t                                       utils::replace_all(url,\"'\", \"%27\"),\n\t\t                                       quote_empty(stfl::quote(title)),\n\t\t                                       quote_empty(stfl::quote(description)),\n\t\t                                       quote_empty(stfl::quote(feed_title)));\n\n\t\tLOG(level::DEBUG, \"controller::bookmark: cmd = %s\", cmdline);\n\n\t\tif (is_interactive) {\n\t\t\tv->push_empty_formaction();\n\t\t\tstfl::reset();\n\t\t\tutils::run_interactively(cmdline, \"controller::bookmark\");\n\t\t\tv->pop_current_formaction();\n\t\t\treturn \"\";\n\t\t} else {\n\t\t\tchar * my_argv[4];\n\t\t\tmy_argv[0] = const_cast<char *>(\"/bin/sh\");\n\t\t\tmy_argv[1] = const_cast<char *>(\"-c\");\n\t\t\tmy_argv[2] = const_cast<char *>(cmdline.c_str());\n\t\t\tmy_argv[3] = nullptr;\n\t\t\treturn utils::run_program(my_argv, \"\");\n\t\t}\n\t} else {\n\t\treturn _(\"bookmarking support is not configured. Please set the configuration variable `bookmark-cmd' accordingly.\");\n\t}\n}", "func_hash": 264539000779301749255245601679907359223, "file_name": "controller.cpp", "file_hash": 304698252897756630266738619508328009845, "cwe": ["CWE-787"], "cve": "CVE-2017-12904", "cve_desc": "Improper Neutralization of Special Elements used in an OS Command in bookmarking function of Newsbeuter versions 0.7 through 2.9 allows remote attackers to perform user-assisted code execution by crafting an RSS item that includes shell code in its title and/or URL.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-12904", "file_path": "src/controller.cpp"}
{"idx": 462566, "project": "newsbeuter", "commit_id": "96e9506ae9e252c548665152d1b8968297128307", "project_url": "https://github.com/akrennmair/newsbeuter", "commit_url": "https://github.com/akrennmair/newsbeuter/commit/96e9506ae9e252c548665152d1b8968297128307", "commit_message": "Sanitize inputs to bookmark-cmd (#591)\n\nNewsbeuter didn't properly shell-escape the arguments passed to\nbookmarking command, which allows a remote attacker to perform remote\ncode execution by crafting an RSS item whose title and/or URL contain\nsomething interpretable by the shell (most notably subshell\ninvocations.)\n\nThis has been reported by Jeriko One <jeriko.one@gmx.us>, complete with\nPoC and a patch.\n\nThis vulnerability was assigned CVE-2017-12904.", "target": 0, "func": "std::string controller::bookmark(\n\t\tconst std::string& url,\n\t\tconst std::string& title,\n\t\tconst std::string& description,\n\t\tconst std::string& feed_title)\n{\n\tstd::string bookmark_cmd = cfg.get_configvalue(\"bookmark-cmd\");\n\tbool is_interactive = cfg.get_configvalue_as_bool(\"bookmark-interactive\");\n\tif (bookmark_cmd.length() > 0) {\n\t\tstd::string cmdline = strprintf::fmt(\"%s '%s' '%s' '%s' '%s'\",\n\t\t                                       bookmark_cmd,\n\t\t                                       utils::replace_all(url,\"'\", \"%27\"),\n\t\t                                       utils::replace_all(title,\"'\", \"%27\"),\n\t\t                                       utils::replace_all(description,\"'\", \"%27\"),\n\t\t                                       utils::replace_all(feed_title,\"'\", \"%27\"));\n\n\t\tLOG(level::DEBUG, \"controller::bookmark: cmd = %s\", cmdline);\n\n\t\tif (is_interactive) {\n\t\t\tv->push_empty_formaction();\n\t\t\tstfl::reset();\n\t\t\tutils::run_interactively(cmdline, \"controller::bookmark\");\n\t\t\tv->pop_current_formaction();\n\t\t\treturn \"\";\n\t\t} else {\n\t\t\tchar * my_argv[4];\n\t\t\tmy_argv[0] = const_cast<char *>(\"/bin/sh\");\n\t\t\tmy_argv[1] = const_cast<char *>(\"-c\");\n\t\t\tmy_argv[2] = const_cast<char *>(cmdline.c_str());\n\t\t\tmy_argv[3] = nullptr;\n\t\t\treturn utils::run_program(my_argv, \"\");\n\t\t}\n\t} else {\n\t\treturn _(\"bookmarking support is not configured. Please set the configuration variable `bookmark-cmd' accordingly.\");\n\t}\n}", "func_hash": 79271714330892808671163251460832419876, "file_name": "controller.cpp", "file_hash": 323926139485782731853395949715316223577, "cwe": ["CWE-787"], "cve": "CVE-2017-12904", "cve_desc": "Improper Neutralization of Special Elements used in an OS Command in bookmarking function of Newsbeuter versions 0.7 through 2.9 allows remote attackers to perform user-assisted code execution by crafting an RSS item that includes shell code in its title and/or URL.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-12904", "file_path": "src/controller.cpp"}
{"idx": 212927, "project": "qemu", "commit_id": "8c92060d3c0248bd4d515719a35922cd2391b9b4", "project_url": "https://github.com/bonzini/qemu", "commit_url": "https://git.qemu.org/?p=qemu.git;a=commit;h=8c92060d3c0248bd4d515719a35922cd2391b9b4", "commit_message": "sungem: switch to use qemu_receive_packet() for loopback\n\nThis patch switches to use qemu_receive_packet() which can detect\nreentrancy and return early.\n\nThis is intended to address CVE-2021-3416.\n\nCc: Prasad J Pandit <ppandit@redhat.com>\nCc: qemu-stable@nongnu.org\nReviewed-by: Mark Cave-Ayland <mark.cave-ayland@ilande.co.uk>\nReviewed-by: Philippe Mathieu-Daud\u00e9 <philmd@redhat.com>\nReviewed-by: Alistair Francis <alistair.francis@wdc.com>\nSigned-off-by: Jason Wang <jasowang@redhat.com>", "target": 1, "func": "static void sungem_send_packet(SunGEMState *s, const uint8_t *buf,\n                               int size)\n{\n    NetClientState *nc = qemu_get_queue(s->nic);\n\n    if (s->macregs[MAC_XIFCFG >> 2] & MAC_XIFCFG_LBCK) {\n        nc->info->receive(nc, buf, size);\n    } else {\n        qemu_send_packet(nc, buf, size);\n    }\n}", "func_hash": 112948077964204681005351426202657971698, "file_name": "sungem.c", "file_hash": 256783431250079747313896805247705613463, "cwe": ["CWE-835"], "cve": "CVE-2021-3416", "cve_desc": "A potential stack overflow via infinite loop issue was found in various NIC emulators of QEMU in versions up to and including 5.2.0. The issue occurs in loopback mode of a NIC wherein reentrant DMA checks get bypassed. A guest user/process may use this flaw to consume CPU cycles or crash the QEMU process on the host resulting in DoS scenario.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-3416", "file_path": "hw/net/sungem.c"}
{"idx": 463051, "project": "qemu", "commit_id": "8c92060d3c0248bd4d515719a35922cd2391b9b4", "project_url": "https://github.com/bonzini/qemu", "commit_url": "https://git.qemu.org/?p=qemu.git;a=commit;h=8c92060d3c0248bd4d515719a35922cd2391b9b4", "commit_message": "sungem: switch to use qemu_receive_packet() for loopback\n\nThis patch switches to use qemu_receive_packet() which can detect\nreentrancy and return early.\n\nThis is intended to address CVE-2021-3416.\n\nCc: Prasad J Pandit <ppandit@redhat.com>\nCc: qemu-stable@nongnu.org\nReviewed-by: Mark Cave-Ayland <mark.cave-ayland@ilande.co.uk>\nReviewed-by: Philippe Mathieu-Daud\u00e9 <philmd@redhat.com>\nReviewed-by: Alistair Francis <alistair.francis@wdc.com>\nSigned-off-by: Jason Wang <jasowang@redhat.com>", "target": 0, "func": "static void sungem_send_packet(SunGEMState *s, const uint8_t *buf,\n                               int size)\n{\n    NetClientState *nc = qemu_get_queue(s->nic);\n\n    if (s->macregs[MAC_XIFCFG >> 2] & MAC_XIFCFG_LBCK) {\n        qemu_receive_packet(nc, buf, size);\n    } else {\n        qemu_send_packet(nc, buf, size);\n    }\n}", "func_hash": 84544313584680412999632571366119869555, "file_name": "sungem.c", "file_hash": 289260737548619033998236290754655826819, "cwe": ["CWE-835"], "cve": "CVE-2021-3416", "cve_desc": "A potential stack overflow via infinite loop issue was found in various NIC emulators of QEMU in versions up to and including 5.2.0. The issue occurs in loopback mode of a NIC wherein reentrant DMA checks get bypassed. A guest user/process may use this flaw to consume CPU cycles or crash the QEMU process on the host resulting in DoS scenario.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-3416", "file_path": "hw/net/sungem.c"}
