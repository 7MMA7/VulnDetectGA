{"idx": 308163, "project": "linux", "commit_id": "fc739a058d99c9297ef6bfd923b809d85855b9a9", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/fc739a058d99c9297ef6bfd923b809d85855b9a9", "commit_message": "misc: fastrpc: prevent memory leak in fastrpc_dma_buf_attach\n\nIn fastrpc_dma_buf_attach if dma_get_sgtable fails the allocated memory\nfor a should be released.\n\nSigned-off-by: Navid Emamdoost <navid.emamdoost@gmail.com>\nLink: https://lore.kernel.org/r/20190925152742.16258-1-navid.emamdoost@gmail.com\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>", "target": 0, "func": "static int fastrpc_dma_buf_attach(struct dma_buf *dmabuf,\n\t\t\t\t  struct dma_buf_attachment *attachment)\n{\n\tstruct fastrpc_dma_buf_attachment *a;\n\tstruct fastrpc_buf *buffer = dmabuf->priv;\n\tint ret;\n\n\ta = kzalloc(sizeof(*a), GFP_KERNEL);\n\tif (!a)\n\t\treturn -ENOMEM;\n\n\tret = dma_get_sgtable(buffer->dev, &a->sgt, buffer->virt,\n\t\t\t      FASTRPC_PHYS(buffer->phys), buffer->size);\n\tif (ret < 0) {\n\t\tdev_err(buffer->dev, \"failed to get scatterlist from DMA API\\n\");\n\t\tkfree(a);\n\t\treturn -EINVAL;\n\t}\n\n\ta->dev = attachment->dev;\n\tINIT_LIST_HEAD(&a->node);\n\tattachment->priv = a;\n\n\tmutex_lock(&buffer->lock);\n\tlist_add(&a->node, &buffer->attachments);\n\tmutex_unlock(&buffer->lock);\n\n\treturn 0;\n}", "func_hash": 207220312586035988811790061557628451284, "file_name": "fastrpc.c", "file_hash": 163997548888586618383929907046515889539, "cwe": ["CWE-401"], "cve": "CVE-2019-19069", "cve_desc": "A memory leak in the fastrpc_dma_buf_attach() function in drivers/misc/fastrpc.c in the Linux kernel before 5.3.9 allows attackers to cause a denial of service (memory consumption) by triggering dma_get_sgtable() failures, aka CID-fc739a058d99.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2019-19069", "file_path": "drivers/misc/fastrpc.c"}
{"idx": 200934, "project": "libvirt", "commit_id": "524de6cc35d3b222f0e940bb0fd027f5482572c5", "project_url": "https://github.com/libvirt/libvirt", "commit_url": "https://github.com/libvirt/libvirt/commit/524de6cc35d3b222f0e940bb0fd027f5482572c5", "commit_message": "virstoragetest: testBackingParse: Use VIR_DOMAIN_DEF_FORMAT_SECURE when formatting xml\n\nWe want to format even the secure information in tests.\n\nSigned-off-by: Peter Krempa <pkrempa@redhat.com>\nReviewed-by: Erik Skultety <eskultet@redhat.com>", "target": 1, "func": "testBackingParse(const void *args)\n{\n    const struct testBackingParseData *data = args;\n    g_auto(virBuffer) buf = VIR_BUFFER_INITIALIZER;\n    g_autofree char *xml = NULL;\n    g_autoptr(virStorageSource) src = NULL;\n    int rc;\n    int erc = data->rv;\n\n    /* expect failure return code with NULL expected data */\n    if (!data->expect)\n        erc = -1;\n\n    if ((rc = virStorageSourceNewFromBackingAbsolute(data->backing, &src)) != erc) {\n        fprintf(stderr, \"expected return value '%d' actual '%d'\\n\", erc, rc);\n        return -1;\n    }\n\n    if (!src)\n        return 0;\n\n    if (src && !data->expect) {\n        fprintf(stderr, \"parsing of backing store string '%s' should \"\n                        \"have failed\\n\", data->backing);\n        return -1;\n    }\n\n    if (virDomainDiskSourceFormat(&buf, src, \"source\", 0, false, 0, true, NULL) < 0 ||\n        !(xml = virBufferContentAndReset(&buf))) {\n        fprintf(stderr, \"failed to format disk source xml\\n\");\n        return -1;\n    }\n\n    if (STRNEQ(xml, data->expect)) {\n        fprintf(stderr, \"\\n backing store string '%s'\\n\"\n                        \"expected storage source xml:\\n%s\\n\"\n                        \"actual storage source xml:\\n%s\\n\",\n                        data->backing, data->expect, xml);\n        return -1;\n    }\n\n    return 0;\n}", "func_hash": 11097234962036893945341293376039418410, "file_name": "virstoragetest.c", "file_hash": 229136922246575533938843249875631381172, "cwe": ["CWE-212"], "cve": "CVE-2020-14301", "cve_desc": "An information disclosure vulnerability was found in libvirt in versions before 6.3.0. HTTP cookies used to access network-based disks were saved in the XML dump of the guest domain. This flaw allows an attacker to access potentially sensitive information in the domain configuration via the `dumpxml` command.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2020-14301", "file_path": "tests/virstoragetest.c"}
{"idx": 313134, "project": "libvirt", "commit_id": "524de6cc35d3b222f0e940bb0fd027f5482572c5", "project_url": "https://github.com/libvirt/libvirt", "commit_url": "https://github.com/libvirt/libvirt/commit/524de6cc35d3b222f0e940bb0fd027f5482572c5", "commit_message": "virstoragetest: testBackingParse: Use VIR_DOMAIN_DEF_FORMAT_SECURE when formatting xml\n\nWe want to format even the secure information in tests.\n\nSigned-off-by: Peter Krempa <pkrempa@redhat.com>\nReviewed-by: Erik Skultety <eskultet@redhat.com>", "target": 0, "func": "testBackingParse(const void *args)\n{\n    const struct testBackingParseData *data = args;\n    g_auto(virBuffer) buf = VIR_BUFFER_INITIALIZER;\n    g_autofree char *xml = NULL;\n    g_autoptr(virStorageSource) src = NULL;\n    int rc;\n    int erc = data->rv;\n    unsigned int xmlformatflags = VIR_DOMAIN_DEF_FORMAT_SECURE;\n\n    /* expect failure return code with NULL expected data */\n    if (!data->expect)\n        erc = -1;\n\n    if ((rc = virStorageSourceNewFromBackingAbsolute(data->backing, &src)) != erc) {\n        fprintf(stderr, \"expected return value '%d' actual '%d'\\n\", erc, rc);\n        return -1;\n    }\n\n    if (!src)\n        return 0;\n\n    if (src && !data->expect) {\n        fprintf(stderr, \"parsing of backing store string '%s' should \"\n                        \"have failed\\n\", data->backing);\n        return -1;\n    }\n\n    if (virDomainDiskSourceFormat(&buf, src, \"source\", 0, false, xmlformatflags, true, NULL) < 0 ||\n        !(xml = virBufferContentAndReset(&buf))) {\n        fprintf(stderr, \"failed to format disk source xml\\n\");\n        return -1;\n    }\n\n    if (STRNEQ(xml, data->expect)) {\n        fprintf(stderr, \"\\n backing store string '%s'\\n\"\n                        \"expected storage source xml:\\n%s\\n\"\n                        \"actual storage source xml:\\n%s\\n\",\n                        data->backing, data->expect, xml);\n        return -1;\n    }\n\n    return 0;\n}", "func_hash": 323157311431778658152105206238946839547, "file_name": "virstoragetest.c", "file_hash": 268394034841003390499099830389942989362, "cwe": ["CWE-212"], "cve": "CVE-2020-14301", "cve_desc": "An information disclosure vulnerability was found in libvirt in versions before 6.3.0. HTTP cookies used to access network-based disks were saved in the XML dump of the guest domain. This flaw allows an attacker to access potentially sensitive information in the domain configuration via the `dumpxml` command.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2020-14301", "file_path": "tests/virstoragetest.c"}
{"idx": 201007, "project": "pjproject", "commit_id": "560a1346f87aabe126509bb24930106dea292b00", "project_url": "https://github.com/pjsip/pjproject", "commit_url": "https://github.com/pjsip/pjproject/commit/560a1346f87aabe126509bb24930106dea292b00", "commit_message": "Merge pull request from GHSA-f5qg-pqcg-765m", "target": 1, "func": "static int print_media_desc(const pjmedia_sdp_media *m, char *buf, pj_size_t len)\n{\n    char *p = buf;\n    char *end = buf+len;\n    unsigned i;\n    int printed;\n\n    /* check length for the \"m=\" line. */\n    if (len < (pj_size_t)m->desc.media.slen+m->desc.transport.slen+12+24) {\n\treturn -1;\n    }\n    *p++ = 'm';\t    /* m= */\n    *p++ = '=';\n    pj_memcpy(p, m->desc.media.ptr, m->desc.media.slen);\n    p += m->desc.media.slen;\n    *p++ = ' ';\n    printed = pj_utoa(m->desc.port, p);\n    p += printed;\n    if (m->desc.port_count > 1) {\n\t*p++ = '/';\n\tprinted = pj_utoa(m->desc.port_count, p);\n\tp += printed;\n    }\n    *p++ = ' ';\n    pj_memcpy(p, m->desc.transport.ptr, m->desc.transport.slen);\n    p += m->desc.transport.slen;\n    for (i=0; i<m->desc.fmt_count; ++i) {\n\t*p++ = ' ';\n\tpj_memcpy(p, m->desc.fmt[i].ptr, m->desc.fmt[i].slen);\n\tp += m->desc.fmt[i].slen;\n    }\n    *p++ = '\\r';\n    *p++ = '\\n';\n\n    /* print connection info, if present. */\n    if (m->conn) {\n\tprinted = print_connection_info(m->conn, p, (int)(end-p));\n\tif (printed < 0) {\n\t    return -1;\n\t}\n\tp += printed;\n    }\n    \n    /* print optional bandwidth info. */\n    for (i=0; i<m->bandw_count; ++i) {\n\tprinted = (int)print_bandw(m->bandw[i], p, end-p);\n\tif (printed < 0) {\n\t    return -1;\n\t}\n\tp += printed;\n    }\n\n    /* print attributes. */\n    for (i=0; i<m->attr_count; ++i) {\n\tprinted = (int)print_attr(m->attr[i], p, end-p);\n\tif (printed < 0) {\n\t    return -1;\n\t}\n\tp += printed;\n    }\n\n    return (int)(p-buf);\n}", "func_hash": 243109353869436532488614405590479215364, "file_name": "sdp.c", "file_hash": 204440288713003047579803744169338279171, "cwe": ["CWE-787"], "cve": "CVE-2022-24764", "cve_desc": "PJSIP is a free and open source multimedia communication library written in C. Versions 2.12 and prior contain a stack buffer overflow vulnerability that affects PJSUA2 users or users that call the API `pjmedia_sdp_print(), pjmedia_sdp_media_print()`. Applications that do not use PJSUA2 and do not directly call `pjmedia_sdp_print()` or `pjmedia_sdp_media_print()` should not be affected. A patch is available on the `master` branch of the `pjsip/pjproject` GitHub repository. There are currently no known workarounds.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-24764", "file_path": "pjmedia/src/pjmedia/sdp.c"}
{"idx": 314536, "project": "pjproject", "commit_id": "560a1346f87aabe126509bb24930106dea292b00", "project_url": "https://github.com/pjsip/pjproject", "commit_url": "https://github.com/pjsip/pjproject/commit/560a1346f87aabe126509bb24930106dea292b00", "commit_message": "Merge pull request from GHSA-f5qg-pqcg-765m", "target": 0, "func": "static int print_media_desc(const pjmedia_sdp_media *m, char *buf, pj_size_t len)\n{\n    char *p = buf;\n    char *end = buf+len;\n    unsigned i;\n    int printed;\n\n    /* check length for the \"m=\" line. */\n    if (len < (pj_size_t)m->desc.media.slen+m->desc.transport.slen+12+24) {\n\treturn -1;\n    }\n    *p++ = 'm';\t    /* m= */\n    *p++ = '=';\n    pj_memcpy(p, m->desc.media.ptr, m->desc.media.slen);\n    p += m->desc.media.slen;\n    *p++ = ' ';\n    printed = pj_utoa(m->desc.port, p);\n    p += printed;\n    if (m->desc.port_count > 1) {\n\t*p++ = '/';\n\tprinted = pj_utoa(m->desc.port_count, p);\n\tp += printed;\n    }\n    *p++ = ' ';\n    pj_memcpy(p, m->desc.transport.ptr, m->desc.transport.slen);\n    p += m->desc.transport.slen;\n    for (i=0; i<m->desc.fmt_count; ++i) {\n\tif (end-p > m->desc.fmt[i].slen) {\n\t    *p++ = ' ';\n\t    pj_memcpy(p, m->desc.fmt[i].ptr, m->desc.fmt[i].slen);\n\t    p += m->desc.fmt[i].slen;\n\t} else {\n\t    return -1;\n\t}\n    }\n\n    if (end-p >= 2) {\n\t*p++ = '\\r';\n\t*p++ = '\\n';\n    } else {\n\treturn -1;\n    }\n\n    /* print connection info, if present. */\n    if (m->conn) {\n\tprinted = print_connection_info(m->conn, p, (int)(end-p));\n\tif (printed < 0) {\n\t    return -1;\n\t}\n\tp += printed;\n    }\n    \n    /* print optional bandwidth info. */\n    for (i=0; i<m->bandw_count; ++i) {\n\tprinted = (int)print_bandw(m->bandw[i], p, end-p);\n\tif (printed < 0) {\n\t    return -1;\n\t}\n\tp += printed;\n    }\n\n    /* print attributes. */\n    for (i=0; i<m->attr_count; ++i) {\n\tprinted = (int)print_attr(m->attr[i], p, end-p);\n\tif (printed < 0) {\n\t    return -1;\n\t}\n\tp += printed;\n    }\n\n    return (int)(p-buf);\n}", "func_hash": 281187495727100348867210742014490000849, "file_name": "sdp.c", "file_hash": 260444738794842919556316298921063524881, "cwe": ["CWE-787"], "cve": "CVE-2022-24764", "cve_desc": "PJSIP is a free and open source multimedia communication library written in C. Versions 2.12 and prior contain a stack buffer overflow vulnerability that affects PJSUA2 users or users that call the API `pjmedia_sdp_print(), pjmedia_sdp_media_print()`. Applications that do not use PJSUA2 and do not directly call `pjmedia_sdp_print()` or `pjmedia_sdp_media_print()` should not be affected. A patch is available on the `master` branch of the `pjsip/pjproject` GitHub repository. There are currently no known workarounds.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-24764", "file_path": "pjmedia/src/pjmedia/sdp.c"}
