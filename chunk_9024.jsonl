{"idx": 207804, "project": "linux", "commit_id": "f227e3ec3b5cad859ad15666874405e8c1bbc1d4", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/f227e3ec3b5cad859ad15666874405e8c1bbc1d4", "commit_message": "random32: update the net random state on interrupt and activity\n\nThis modifies the first 32 bits out of the 128 bits of a random CPU's\nnet_rand_state on interrupt or CPU activity to complicate remote\nobservations that could lead to guessing the network RNG's internal\nstate.\n\nNote that depending on some network devices' interrupt rate moderation\nor binding, this re-seeding might happen on every packet or even almost\nnever.\n\nIn addition, with NOHZ some CPUs might not even get timer interrupts,\nleaving their local state rarely updated, while they are running\nnetworked processes making use of the random state.  For this reason, we\nalso perform this update in update_process_times() in order to at least\nupdate the state when there is user or system activity, since it's the\nonly case we care about.\n\nReported-by: Amit Klein <aksecurity@gmail.com>\nSuggested-by: Linus Torvalds <torvalds@linux-foundation.org>\nCc: Eric Dumazet <edumazet@google.com>\nCc: \"Jason A. Donenfeld\" <Jason@zx2c4.com>\nCc: Andy Lutomirski <luto@kernel.org>\nCc: Kees Cook <keescook@chromium.org>\nCc: Thomas Gleixner <tglx@linutronix.de>\nCc: Peter Zijlstra <peterz@infradead.org>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Willy Tarreau <w@1wt.eu>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "target": 1, "func": "void update_process_times(int user_tick)\n{\n\tstruct task_struct *p = current;\n\n\t/* Note: this timer irq context must be accounted for as well. */\n\taccount_process_tick(p, user_tick);\n\trun_local_timers();\n\trcu_sched_clock_irq(user_tick);\n#ifdef CONFIG_IRQ_WORK\n\tif (in_irq())\n\t\tirq_work_tick();\n#endif\n\tscheduler_tick();\n\tif (IS_ENABLED(CONFIG_POSIX_TIMERS))\n\t\trun_posix_cpu_timers();\n}", "func_hash": 82612237012862358865324786376664956349, "file_name": "timer.c", "file_hash": 271218236065045560355591111071365801019, "cwe": ["CWE-200"], "cve": "CVE-2020-16166", "cve_desc": "The Linux kernel through 5.7.11 allows remote attackers to make observations that help to obtain sensitive information about the internal state of the network RNG, aka CID-f227e3ec3b5c. This is related to drivers/char/random.c and kernel/time/timer.c.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2020-16166", "file_path": "kernel/time/timer.c"}
{"idx": 401525, "project": "linux", "commit_id": "f227e3ec3b5cad859ad15666874405e8c1bbc1d4", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/f227e3ec3b5cad859ad15666874405e8c1bbc1d4", "commit_message": "random32: update the net random state on interrupt and activity\n\nThis modifies the first 32 bits out of the 128 bits of a random CPU's\nnet_rand_state on interrupt or CPU activity to complicate remote\nobservations that could lead to guessing the network RNG's internal\nstate.\n\nNote that depending on some network devices' interrupt rate moderation\nor binding, this re-seeding might happen on every packet or even almost\nnever.\n\nIn addition, with NOHZ some CPUs might not even get timer interrupts,\nleaving their local state rarely updated, while they are running\nnetworked processes making use of the random state.  For this reason, we\nalso perform this update in update_process_times() in order to at least\nupdate the state when there is user or system activity, since it's the\nonly case we care about.\n\nReported-by: Amit Klein <aksecurity@gmail.com>\nSuggested-by: Linus Torvalds <torvalds@linux-foundation.org>\nCc: Eric Dumazet <edumazet@google.com>\nCc: \"Jason A. Donenfeld\" <Jason@zx2c4.com>\nCc: Andy Lutomirski <luto@kernel.org>\nCc: Kees Cook <keescook@chromium.org>\nCc: Thomas Gleixner <tglx@linutronix.de>\nCc: Peter Zijlstra <peterz@infradead.org>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Willy Tarreau <w@1wt.eu>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "target": 0, "func": "void update_process_times(int user_tick)\n{\n\tstruct task_struct *p = current;\n\n\t/* Note: this timer irq context must be accounted for as well. */\n\taccount_process_tick(p, user_tick);\n\trun_local_timers();\n\trcu_sched_clock_irq(user_tick);\n#ifdef CONFIG_IRQ_WORK\n\tif (in_irq())\n\t\tirq_work_tick();\n#endif\n\tscheduler_tick();\n\tif (IS_ENABLED(CONFIG_POSIX_TIMERS))\n\t\trun_posix_cpu_timers();\n\n\t/* The current CPU might make use of net randoms without receiving IRQs\n\t * to renew them often enough. Let's update the net_rand_state from a\n\t * non-constant value that's not affine to the number of calls to make\n\t * sure it's updated when there's some activity (we don't care in idle).\n\t */\n\tthis_cpu_add(net_rand_state.s1, rol32(jiffies, 24) + user_tick);\n}", "func_hash": 311686403025993845778050249928014943417, "file_name": "timer.c", "file_hash": 222103336435375278106670191376448375228, "cwe": ["CWE-200"], "cve": "CVE-2020-16166", "cve_desc": "The Linux kernel through 5.7.11 allows remote attackers to make observations that help to obtain sensitive information about the internal state of the network RNG, aka CID-f227e3ec3b5c. This is related to drivers/char/random.c and kernel/time/timer.c.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2020-16166", "file_path": "kernel/time/timer.c"}
{"idx": 207990, "project": "pcre2", "commit_id": "03654e751e7f0700693526b67dfcadda6b42c9d0", "project_url": "https://github.com/PCRE2Project/pcre2", "commit_url": "https://github.com/PCRE2Project/pcre2/commit/03654e751e7f0700693526b67dfcadda6b42c9d0", "commit_message": "Fixed an issue affecting recursions in JIT", "target": 1, "func": "static int get_recurse_data_length(compiler_common *common, PCRE2_SPTR cc, PCRE2_SPTR ccend,\n  BOOL *needs_control_head, BOOL *has_quit, BOOL *has_accept)\n{\nint length = 1;\nint size;\nPCRE2_SPTR alternative;\nBOOL quit_found = FALSE;\nBOOL accept_found = FALSE;\nBOOL setsom_found = FALSE;\nBOOL setmark_found = FALSE;\nBOOL capture_last_found = FALSE;\nBOOL control_head_found = FALSE;\n\n#if defined DEBUG_FORCE_CONTROL_HEAD && DEBUG_FORCE_CONTROL_HEAD\nSLJIT_ASSERT(common->control_head_ptr != 0);\ncontrol_head_found = TRUE;\n#endif\n\n/* Calculate the sum of the private machine words. */\nwhile (cc < ccend)\n  {\n  size = 0;\n  switch(*cc)\n    {\n    case OP_SET_SOM:\n    SLJIT_ASSERT(common->has_set_som);\n    setsom_found = TRUE;\n    cc += 1;\n    break;\n\n    case OP_RECURSE:\n    if (common->has_set_som)\n      setsom_found = TRUE;\n    if (common->mark_ptr != 0)\n      setmark_found = TRUE;\n    if (common->capture_last_ptr != 0)\n      capture_last_found = TRUE;\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_KET:\n    if (PRIVATE_DATA(cc) != 0)\n      {\n      length++;\n      SLJIT_ASSERT(PRIVATE_DATA(cc + 1) != 0);\n      cc += PRIVATE_DATA(cc + 1);\n      }\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_ASSERT:\n    case OP_ASSERT_NOT:\n    case OP_ASSERTBACK:\n    case OP_ASSERTBACK_NOT:\n    case OP_ASSERT_NA:\n    case OP_ASSERTBACK_NA:\n    case OP_ONCE:\n    case OP_SCRIPT_RUN:\n    case OP_BRAPOS:\n    case OP_SBRA:\n    case OP_SBRAPOS:\n    case OP_SCOND:\n    length++;\n    SLJIT_ASSERT(PRIVATE_DATA(cc) != 0);\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_CBRA:\n    case OP_SCBRA:\n    length += 2;\n    if (common->capture_last_ptr != 0)\n      capture_last_found = TRUE;\n    if (common->optimized_cbracket[GET2(cc, 1 + LINK_SIZE)] == 0)\n      length++;\n    cc += 1 + LINK_SIZE + IMM2_SIZE;\n    break;\n\n    case OP_CBRAPOS:\n    case OP_SCBRAPOS:\n    length += 2 + 2;\n    if (common->capture_last_ptr != 0)\n      capture_last_found = TRUE;\n    cc += 1 + LINK_SIZE + IMM2_SIZE;\n    break;\n\n    case OP_COND:\n    /* Might be a hidden SCOND. */\n    alternative = cc + GET(cc, 1);\n    if (*alternative == OP_KETRMAX || *alternative == OP_KETRMIN)\n      length++;\n    cc += 1 + LINK_SIZE;\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_1\n    if (PRIVATE_DATA(cc) != 0)\n      length++;\n    cc += 2;\n#ifdef SUPPORT_UNICODE\n    if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_2A\n    if (PRIVATE_DATA(cc) != 0)\n      length += 2;\n    cc += 2;\n#ifdef SUPPORT_UNICODE\n    if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_2B\n    if (PRIVATE_DATA(cc) != 0)\n      length += 2;\n    cc += 2 + IMM2_SIZE;\n#ifdef SUPPORT_UNICODE\n    if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n    break;\n\n    CASE_ITERATOR_TYPE_PRIVATE_DATA_1\n    if (PRIVATE_DATA(cc) != 0)\n      length++;\n    cc += 1;\n    break;\n\n    CASE_ITERATOR_TYPE_PRIVATE_DATA_2A\n    if (PRIVATE_DATA(cc) != 0)\n      length += 2;\n    cc += 1;\n    break;\n\n    CASE_ITERATOR_TYPE_PRIVATE_DATA_2B\n    if (PRIVATE_DATA(cc) != 0)\n      length += 2;\n    cc += 1 + IMM2_SIZE;\n    break;\n\n    case OP_CLASS:\n    case OP_NCLASS:\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8\n    case OP_XCLASS:\n    size = (*cc == OP_XCLASS) ? GET(cc, 1) : 1 + 32 / (int)sizeof(PCRE2_UCHAR);\n#else\n    size = 1 + 32 / (int)sizeof(PCRE2_UCHAR);\n#endif\n    if (PRIVATE_DATA(cc) != 0)\n      length += get_class_iterator_size(cc + size);\n    cc += size;\n    break;\n\n    case OP_MARK:\n    case OP_COMMIT_ARG:\n    case OP_PRUNE_ARG:\n    case OP_THEN_ARG:\n    SLJIT_ASSERT(common->mark_ptr != 0);\n    if (!setmark_found)\n      setmark_found = TRUE;\n    if (common->control_head_ptr != 0)\n      control_head_found = TRUE;\n    if (*cc != OP_MARK)\n      quit_found = TRUE;\n\n    cc += 1 + 2 + cc[1];\n    break;\n\n    case OP_PRUNE:\n    case OP_SKIP:\n    case OP_COMMIT:\n    quit_found = TRUE;\n    cc++;\n    break;\n\n    case OP_SKIP_ARG:\n    quit_found = TRUE;\n    cc += 1 + 2 + cc[1];\n    break;\n\n    case OP_THEN:\n    SLJIT_ASSERT(common->control_head_ptr != 0);\n    quit_found = TRUE;\n    if (!control_head_found)\n      control_head_found = TRUE;\n    cc++;\n    break;\n\n    case OP_ACCEPT:\n    case OP_ASSERT_ACCEPT:\n    accept_found = TRUE;\n    cc++;\n    break;\n\n    default:\n    cc = next_opcode(common, cc);\n    SLJIT_ASSERT(cc != NULL);\n    break;\n    }\n  }\nSLJIT_ASSERT(cc == ccend);\n\nif (control_head_found)\n  length++;\nif (capture_last_found)\n  length++;\nif (quit_found)\n  {\n  if (setsom_found)\n    length++;\n  if (setmark_found)\n    length++;\n  }\n\n*needs_control_head = control_head_found;\n*has_quit = quit_found;\n*has_accept = accept_found;\nreturn length;\n}", "func_hash": 240126232931244050288328890875640372325, "file_name": "pcre2_jit_compile.c", "file_hash": 105541590302198799083513857874765354258, "cwe": ["CWE-703"], "cve": "CVE-2022-1587", "cve_desc": "An out-of-bounds read vulnerability was discovered in the PCRE2 library in the get_recurse_data_length() function of the pcre2_jit_compile.c file. This issue affects recursions in JIT-compiled regular expressions caused by duplicate data transfers.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-1587", "file_path": "src/pcre2_jit_compile.c"}
{"idx": 404192, "project": "pcre2", "commit_id": "03654e751e7f0700693526b67dfcadda6b42c9d0", "project_url": "https://github.com/PCRE2Project/pcre2", "commit_url": "https://github.com/PCRE2Project/pcre2/commit/03654e751e7f0700693526b67dfcadda6b42c9d0", "commit_message": "Fixed an issue affecting recursions in JIT", "target": 0, "func": "static int get_recurse_data_length(compiler_common *common, PCRE2_SPTR cc, PCRE2_SPTR ccend,\n  BOOL *needs_control_head, BOOL *has_quit, BOOL *has_accept)\n{\nint length = 1;\nint size, offset;\nPCRE2_SPTR alternative;\nBOOL quit_found = FALSE;\nBOOL accept_found = FALSE;\nBOOL setsom_found = FALSE;\nBOOL setmark_found = FALSE;\nBOOL control_head_found = FALSE;\n\nmemset(common->recurse_bitset, 0, common->recurse_bitset_size);\n\n#if defined DEBUG_FORCE_CONTROL_HEAD && DEBUG_FORCE_CONTROL_HEAD\nSLJIT_ASSERT(common->control_head_ptr != 0);\ncontrol_head_found = TRUE;\n#endif\n\n/* Calculate the sum of the private machine words. */\nwhile (cc < ccend)\n  {\n  size = 0;\n  switch(*cc)\n    {\n    case OP_SET_SOM:\n    SLJIT_ASSERT(common->has_set_som);\n    setsom_found = TRUE;\n    cc += 1;\n    break;\n\n    case OP_RECURSE:\n    if (common->has_set_som)\n      setsom_found = TRUE;\n    if (common->mark_ptr != 0)\n      setmark_found = TRUE;\n    if (common->capture_last_ptr != 0 && recurse_check_bit(common, common->capture_last_ptr))\n      length++;\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_KET:\n    offset = PRIVATE_DATA(cc);\n    if (offset != 0)\n      {\n      if (recurse_check_bit(common, offset))\n        length++;\n      SLJIT_ASSERT(PRIVATE_DATA(cc + 1) != 0);\n      cc += PRIVATE_DATA(cc + 1);\n      }\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_ASSERT:\n    case OP_ASSERT_NOT:\n    case OP_ASSERTBACK:\n    case OP_ASSERTBACK_NOT:\n    case OP_ASSERT_NA:\n    case OP_ASSERTBACK_NA:\n    case OP_ONCE:\n    case OP_SCRIPT_RUN:\n    case OP_BRAPOS:\n    case OP_SBRA:\n    case OP_SBRAPOS:\n    case OP_SCOND:\n    SLJIT_ASSERT(PRIVATE_DATA(cc) != 0);\n    if (recurse_check_bit(common, PRIVATE_DATA(cc)))\n      length++;\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_CBRA:\n    case OP_SCBRA:\n    offset = GET2(cc, 1 + LINK_SIZE);\n    if (recurse_check_bit(common, OVECTOR(offset << 1)))\n      {\n      SLJIT_ASSERT(recurse_check_bit(common, OVECTOR((offset << 1) + 1)));\n      length += 2;\n      }\n    if (common->optimized_cbracket[offset] == 0 && recurse_check_bit(common, OVECTOR_PRIV(offset)))\n      length++;\n    if (common->capture_last_ptr != 0 && recurse_check_bit(common, common->capture_last_ptr))\n      length++;\n    cc += 1 + LINK_SIZE + IMM2_SIZE;\n    break;\n\n    case OP_CBRAPOS:\n    case OP_SCBRAPOS:\n    offset = GET2(cc, 1 + LINK_SIZE);\n    if (recurse_check_bit(common, OVECTOR(offset << 1)))\n      {\n      SLJIT_ASSERT(recurse_check_bit(common, OVECTOR((offset << 1) + 1)));\n      length += 2;\n      }\n    if (recurse_check_bit(common, OVECTOR_PRIV(offset)))\n      length++;\n    if (recurse_check_bit(common, PRIVATE_DATA(cc)))\n      length++;\n    if (common->capture_last_ptr != 0 && recurse_check_bit(common, common->capture_last_ptr))\n      length++;\n    cc += 1 + LINK_SIZE + IMM2_SIZE;\n    break;\n\n    case OP_COND:\n    /* Might be a hidden SCOND. */\n    alternative = cc + GET(cc, 1);\n    if ((*alternative == OP_KETRMAX || *alternative == OP_KETRMIN) && recurse_check_bit(common, PRIVATE_DATA(cc)))\n      length++;\n    cc += 1 + LINK_SIZE;\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_1\n    offset = PRIVATE_DATA(cc);\n    if (offset != 0 && recurse_check_bit(common, offset))\n      length++;\n    cc += 2;\n#ifdef SUPPORT_UNICODE\n    if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_2A\n    offset = PRIVATE_DATA(cc);\n    if (offset != 0 && recurse_check_bit(common, offset))\n      {\n      SLJIT_ASSERT(recurse_check_bit(common, offset + sizeof(sljit_sw)));\n      length += 2;\n      }\n    cc += 2;\n#ifdef SUPPORT_UNICODE\n    if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_2B\n    offset = PRIVATE_DATA(cc);\n    if (offset != 0 && recurse_check_bit(common, offset))\n      {\n      SLJIT_ASSERT(recurse_check_bit(common, offset + sizeof(sljit_sw)));\n      length += 2;\n      }\n    cc += 2 + IMM2_SIZE;\n#ifdef SUPPORT_UNICODE\n    if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n    break;\n\n    CASE_ITERATOR_TYPE_PRIVATE_DATA_1\n    offset = PRIVATE_DATA(cc);\n    if (offset != 0 && recurse_check_bit(common, offset))\n      length++;\n    cc += 1;\n    break;\n\n    CASE_ITERATOR_TYPE_PRIVATE_DATA_2A\n    offset = PRIVATE_DATA(cc);\n    if (offset != 0 && recurse_check_bit(common, offset))\n      {\n      SLJIT_ASSERT(recurse_check_bit(common, offset + sizeof(sljit_sw)));\n      length += 2;\n      }\n    cc += 1;\n    break;\n\n    CASE_ITERATOR_TYPE_PRIVATE_DATA_2B\n    offset = PRIVATE_DATA(cc);\n    if (offset != 0 && recurse_check_bit(common, offset))\n      {\n      SLJIT_ASSERT(recurse_check_bit(common, offset + sizeof(sljit_sw)));\n      length += 2;\n      }\n    cc += 1 + IMM2_SIZE;\n    break;\n\n    case OP_CLASS:\n    case OP_NCLASS:\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8\n    case OP_XCLASS:\n    size = (*cc == OP_XCLASS) ? GET(cc, 1) : 1 + 32 / (int)sizeof(PCRE2_UCHAR);\n#else\n    size = 1 + 32 / (int)sizeof(PCRE2_UCHAR);\n#endif\n\n    offset = PRIVATE_DATA(cc);\n    if (offset != 0 && recurse_check_bit(common, offset))\n      length += get_class_iterator_size(cc + size);\n    cc += size;\n    break;\n\n    case OP_MARK:\n    case OP_COMMIT_ARG:\n    case OP_PRUNE_ARG:\n    case OP_THEN_ARG:\n    SLJIT_ASSERT(common->mark_ptr != 0);\n    if (!setmark_found)\n      setmark_found = TRUE;\n    if (common->control_head_ptr != 0)\n      control_head_found = TRUE;\n    if (*cc != OP_MARK)\n      quit_found = TRUE;\n\n    cc += 1 + 2 + cc[1];\n    break;\n\n    case OP_PRUNE:\n    case OP_SKIP:\n    case OP_COMMIT:\n    quit_found = TRUE;\n    cc++;\n    break;\n\n    case OP_SKIP_ARG:\n    quit_found = TRUE;\n    cc += 1 + 2 + cc[1];\n    break;\n\n    case OP_THEN:\n    SLJIT_ASSERT(common->control_head_ptr != 0);\n    quit_found = TRUE;\n    control_head_found = TRUE;\n    cc++;\n    break;\n\n    case OP_ACCEPT:\n    case OP_ASSERT_ACCEPT:\n    accept_found = TRUE;\n    cc++;\n    break;\n\n    default:\n    cc = next_opcode(common, cc);\n    SLJIT_ASSERT(cc != NULL);\n    break;\n    }\n  }\nSLJIT_ASSERT(cc == ccend);\n\nif (control_head_found)\n  length++;\nif (quit_found)\n  {\n  if (setsom_found)\n    length++;\n  if (setmark_found)\n    length++;\n  }\n\n*needs_control_head = control_head_found;\n*has_quit = quit_found;\n*has_accept = accept_found;\nreturn length;\n}", "func_hash": 173942933444712771516446324481674462692, "file_name": "pcre2_jit_compile.c", "file_hash": 52374969195278947710795935639555031915, "cwe": ["CWE-703"], "cve": "CVE-2022-1587", "cve_desc": "An out-of-bounds read vulnerability was discovered in the PCRE2 library in the get_recurse_data_length() function of the pcre2_jit_compile.c file. This issue affects recursions in JIT-compiled regular expressions caused by duplicate data transfers.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-1587", "file_path": "src/pcre2_jit_compile.c"}
