{"idx": 202889, "project": "linux", "commit_id": "ebe48d368e97d007bfeb76fcb065d6cfc4c96645", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/ebe48d368e97d007bfeb76fcb065d6cfc4c96645", "commit_message": "esp: Fix possible buffer overflow in ESP transformation\n\nThe maximum message size that can be send is bigger than\nthe  maximum site that skb_page_frag_refill can allocate.\nSo it is possible to write beyond the allocated buffer.\n\nFix this by doing a fallback to COW in that case.\n\nv2:\n\nAvoid get get_order() costs as suggested by Linus Torvalds.\n\nFixes: cac2661c53f3 (\"esp4: Avoid skb_cow_data whenever possible\")\nFixes: 03e2a30f6a27 (\"esp6: Avoid skb_cow_data whenever possible\")\nReported-by: valis <sec@valis.email>\nSigned-off-by: Steffen Klassert <steffen.klassert@secunet.com>", "target": 1, "func": "int esp6_output_head(struct xfrm_state *x, struct sk_buff *skb, struct esp_info *esp)\n{\n\tu8 *tail;\n\tint nfrags;\n\tint esph_offset;\n\tstruct page *page;\n\tstruct sk_buff *trailer;\n\tint tailen = esp->tailen;\n\n\tif (x->encap) {\n\t\tint err = esp6_output_encap(x, skb, esp);\n\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (!skb_cloned(skb)) {\n\t\tif (tailen <= skb_tailroom(skb)) {\n\t\t\tnfrags = 1;\n\t\t\ttrailer = skb;\n\t\t\ttail = skb_tail_pointer(trailer);\n\n\t\t\tgoto skip_cow;\n\t\t} else if ((skb_shinfo(skb)->nr_frags < MAX_SKB_FRAGS)\n\t\t\t   && !skb_has_frag_list(skb)) {\n\t\t\tint allocsize;\n\t\t\tstruct sock *sk = skb->sk;\n\t\t\tstruct page_frag *pfrag = &x->xfrag;\n\n\t\t\tesp->inplace = false;\n\n\t\t\tallocsize = ALIGN(tailen, L1_CACHE_BYTES);\n\n\t\t\tspin_lock_bh(&x->lock);\n\n\t\t\tif (unlikely(!skb_page_frag_refill(allocsize, pfrag, GFP_ATOMIC))) {\n\t\t\t\tspin_unlock_bh(&x->lock);\n\t\t\t\tgoto cow;\n\t\t\t}\n\n\t\t\tpage = pfrag->page;\n\t\t\tget_page(page);\n\n\t\t\ttail = page_address(page) + pfrag->offset;\n\n\t\t\tesp_output_fill_trailer(tail, esp->tfclen, esp->plen, esp->proto);\n\n\t\t\tnfrags = skb_shinfo(skb)->nr_frags;\n\n\t\t\t__skb_fill_page_desc(skb, nfrags, page, pfrag->offset,\n\t\t\t\t\t     tailen);\n\t\t\tskb_shinfo(skb)->nr_frags = ++nfrags;\n\n\t\t\tpfrag->offset = pfrag->offset + allocsize;\n\n\t\t\tspin_unlock_bh(&x->lock);\n\n\t\t\tnfrags++;\n\n\t\t\tskb->len += tailen;\n\t\t\tskb->data_len += tailen;\n\t\t\tskb->truesize += tailen;\n\t\t\tif (sk && sk_fullsock(sk))\n\t\t\t\trefcount_add(tailen, &sk->sk_wmem_alloc);\n\n\t\t\tgoto out;\n\t\t}\n\t}\n\ncow:\n\tesph_offset = (unsigned char *)esp->esph - skb_transport_header(skb);\n\n\tnfrags = skb_cow_data(skb, tailen, &trailer);\n\tif (nfrags < 0)\n\t\tgoto out;\n\ttail = skb_tail_pointer(trailer);\n\tesp->esph = (struct ip_esp_hdr *)(skb_transport_header(skb) + esph_offset);\n\nskip_cow:\n\tesp_output_fill_trailer(tail, esp->tfclen, esp->plen, esp->proto);\n\tpskb_put(skb, trailer, tailen);\n\nout:\n\treturn nfrags;\n}", "func_hash": 288301041182247062764395753908590668676, "file_name": "esp6.c", "file_hash": 297879342136766332467148715516497305667, "cwe": ["CWE-787"], "cve": "CVE-2022-27666", "cve_desc": "A heap buffer overflow flaw was found in IPsec ESP transformation code in net/ipv4/esp4.c and net/ipv6/esp6.c. This flaw allows a local attacker with a normal user privilege to overwrite kernel heap objects and may cause a local privilege escalation threat.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-27666", "file_path": "net/ipv6/esp6.c"}
{"idx": 343158, "project": "linux", "commit_id": "ebe48d368e97d007bfeb76fcb065d6cfc4c96645", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/ebe48d368e97d007bfeb76fcb065d6cfc4c96645", "commit_message": "esp: Fix possible buffer overflow in ESP transformation\n\nThe maximum message size that can be send is bigger than\nthe  maximum site that skb_page_frag_refill can allocate.\nSo it is possible to write beyond the allocated buffer.\n\nFix this by doing a fallback to COW in that case.\n\nv2:\n\nAvoid get get_order() costs as suggested by Linus Torvalds.\n\nFixes: cac2661c53f3 (\"esp4: Avoid skb_cow_data whenever possible\")\nFixes: 03e2a30f6a27 (\"esp6: Avoid skb_cow_data whenever possible\")\nReported-by: valis <sec@valis.email>\nSigned-off-by: Steffen Klassert <steffen.klassert@secunet.com>", "target": 0, "func": "int esp6_output_head(struct xfrm_state *x, struct sk_buff *skb, struct esp_info *esp)\n{\n\tu8 *tail;\n\tint nfrags;\n\tint esph_offset;\n\tstruct page *page;\n\tstruct sk_buff *trailer;\n\tint tailen = esp->tailen;\n\tunsigned int allocsz;\n\n\tif (x->encap) {\n\t\tint err = esp6_output_encap(x, skb, esp);\n\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tallocsz = ALIGN(skb->data_len + tailen, L1_CACHE_BYTES);\n\tif (allocsz > ESP_SKB_FRAG_MAXSIZE)\n\t\tgoto cow;\n\n\tif (!skb_cloned(skb)) {\n\t\tif (tailen <= skb_tailroom(skb)) {\n\t\t\tnfrags = 1;\n\t\t\ttrailer = skb;\n\t\t\ttail = skb_tail_pointer(trailer);\n\n\t\t\tgoto skip_cow;\n\t\t} else if ((skb_shinfo(skb)->nr_frags < MAX_SKB_FRAGS)\n\t\t\t   && !skb_has_frag_list(skb)) {\n\t\t\tint allocsize;\n\t\t\tstruct sock *sk = skb->sk;\n\t\t\tstruct page_frag *pfrag = &x->xfrag;\n\n\t\t\tesp->inplace = false;\n\n\t\t\tallocsize = ALIGN(tailen, L1_CACHE_BYTES);\n\n\t\t\tspin_lock_bh(&x->lock);\n\n\t\t\tif (unlikely(!skb_page_frag_refill(allocsize, pfrag, GFP_ATOMIC))) {\n\t\t\t\tspin_unlock_bh(&x->lock);\n\t\t\t\tgoto cow;\n\t\t\t}\n\n\t\t\tpage = pfrag->page;\n\t\t\tget_page(page);\n\n\t\t\ttail = page_address(page) + pfrag->offset;\n\n\t\t\tesp_output_fill_trailer(tail, esp->tfclen, esp->plen, esp->proto);\n\n\t\t\tnfrags = skb_shinfo(skb)->nr_frags;\n\n\t\t\t__skb_fill_page_desc(skb, nfrags, page, pfrag->offset,\n\t\t\t\t\t     tailen);\n\t\t\tskb_shinfo(skb)->nr_frags = ++nfrags;\n\n\t\t\tpfrag->offset = pfrag->offset + allocsize;\n\n\t\t\tspin_unlock_bh(&x->lock);\n\n\t\t\tnfrags++;\n\n\t\t\tskb->len += tailen;\n\t\t\tskb->data_len += tailen;\n\t\t\tskb->truesize += tailen;\n\t\t\tif (sk && sk_fullsock(sk))\n\t\t\t\trefcount_add(tailen, &sk->sk_wmem_alloc);\n\n\t\t\tgoto out;\n\t\t}\n\t}\n\ncow:\n\tesph_offset = (unsigned char *)esp->esph - skb_transport_header(skb);\n\n\tnfrags = skb_cow_data(skb, tailen, &trailer);\n\tif (nfrags < 0)\n\t\tgoto out;\n\ttail = skb_tail_pointer(trailer);\n\tesp->esph = (struct ip_esp_hdr *)(skb_transport_header(skb) + esph_offset);\n\nskip_cow:\n\tesp_output_fill_trailer(tail, esp->tfclen, esp->plen, esp->proto);\n\tpskb_put(skb, trailer, tailen);\n\nout:\n\treturn nfrags;\n}", "func_hash": 5299017131743026733431501074283607591, "file_name": "esp6.c", "file_hash": 272053559916260151312940536238291966334, "cwe": ["CWE-787"], "cve": "CVE-2022-27666", "cve_desc": "A heap buffer overflow flaw was found in IPsec ESP transformation code in net/ipv4/esp4.c and net/ipv6/esp6.c. This flaw allows a local attacker with a normal user privilege to overwrite kernel heap objects and may cause a local privilege escalation threat.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-27666", "file_path": "net/ipv6/esp6.c"}
{"idx": 202892, "project": "pure-ftpd", "commit_id": "37ad222868e52271905b94afea4fc780d83294b4", "project_url": "https://github.com/jedisct1/pure-ftpd", "commit_url": "https://github.com/jedisct1/pure-ftpd/commit/37ad222868e52271905b94afea4fc780d83294b4", "commit_message": "Initialize the max upload file size when quotas are enabled\n\nDue to an unwanted check, files causing the quota to be exceeded\nwere deleted after the upload, but not during the upload.\n\nThe bug was introduced in 2009 in version 1.0.23\n\nSpotted by @DroidTest, thanks!", "target": 1, "func": "void dostor(char *name, const int append, const int autorename)\n{\n    ULHandler ulhandler;\n    int f;\n    const char *ul_name = NULL;\n    const char *atomic_file = NULL;\n    off_t filesize = (off_t) 0U;\n    struct stat st;\n    double started = 0.0;\n    signed char overwrite = 0;\n    int overflow = 0;\n    int ret = -1;\n    off_t max_filesize = (off_t) -1;\n#ifdef QUOTAS\n    Quota quota;\n#endif\n    const char *name2 = NULL;\n\n    if (type < 1 || (type == 1 && restartat > (off_t) 1)) {\n        addreply_noformat(503, MSG_NO_ASCII_RESUME);\n        goto end;\n    }\n#ifndef ANON_CAN_RESUME\n    if (guest != 0 && anon_noupload != 0) {\n        addreply_noformat(550, MSG_ANON_CANT_OVERWRITE);\n        goto end;\n    }\n#endif\n    if (ul_check_free_space(name, -1.0) == 0) {\n        addreply_noformat(552, MSG_NO_DISK_SPACE);\n        goto end;\n    }\n    if (checknamesanity(name, dot_write_ok) != 0) {\n        addreply(553, MSG_SANITY_FILE_FAILURE, name);\n        goto end;\n    }\n    if (autorename != 0) {\n        no_truncate = 1;\n    }\n    if (restartat > (off_t) 0 || no_truncate != 0) {\n        if ((atomic_file = get_atomic_file(name)) == NULL) {\n            addreply(553, MSG_SANITY_FILE_FAILURE, name);\n            goto end;\n        }\n        if (restartat > (off_t) 0 &&\n            rename(name, atomic_file) != 0 && errno != ENOENT) {\n            error(553, MSG_RENAME_FAILURE);\n            atomic_file = NULL;\n            goto end;\n        }\n    }\n    if (atomic_file != NULL) {\n        ul_name = atomic_file;\n    } else {\n        ul_name = name;\n    }\n    if (atomic_file == NULL &&\n        (f = open(ul_name, O_WRONLY | O_NOFOLLOW)) != -1) {\n        overwrite++;\n    } else if ((f = open(ul_name, O_CREAT | O_WRONLY | O_NOFOLLOW,\n                         (mode_t) 0777 & ~u_mask)) == -1) {\n        error(553, MSG_OPEN_FAILURE2);\n        goto end;\n    }\n    if (fstat(f, &st) < 0) {\n        (void) close(f);\n        error(553, MSG_STAT_FAILURE2);\n        goto end;\n    }\n    if (!S_ISREG(st.st_mode)) {\n        (void) close(f);\n        addreply_noformat(550, MSG_NOT_REGULAR_FILE);\n        goto end;\n    }\n    alarm(MAX_SESSION_XFER_IDLE);\n\n    /* Anonymous users *CAN* overwrite 0-bytes files - This is the right behavior */\n    if (st.st_size > (off_t) 0) {\n#ifndef ANON_CAN_RESUME\n        if (guest != 0) {\n            addreply_noformat(550, MSG_ANON_CANT_OVERWRITE);\n            (void) close(f);\n            goto end;\n        }\n#endif\n        if (append != 0) {\n            restartat = st.st_size;\n        }\n    } else {\n        restartat = (off_t) 0;\n    }\n    if (restartat > st.st_size) {\n        restartat = st.st_size;\n    }\n    if (restartat > (off_t) 0 && lseek(f, restartat, SEEK_SET) < (off_t) 0) {\n        (void) close(f);\n        error(451, \"seek\");\n        goto end;\n    }\n    if (restartat < st.st_size) {\n        if (ftruncate(f, restartat) < 0) {\n            (void) close(f);\n            error(451, \"ftruncate\");\n            goto end;\n        }\n#ifdef QUOTAS\n        if (restartat != st.st_size) {\n            (void) quota_update(NULL, 0LL,\n                                (long long) (restartat - st.st_size),\n                                &overflow);\n        }\n#endif\n    }\n#ifdef QUOTAS\n    if (quota_update(&quota, 0LL, 0LL, &overflow) == 0 &&\n        (overflow > 0 || quota.files >= user_quota_files ||\n         quota.size > user_quota_size ||\n         (max_filesize >= (off_t) 0 &&\n          (max_filesize = user_quota_size - quota.size) < (off_t) 0))) {\n        overflow = 1;\n        (void) close(f);\n        goto afterquota;\n    }\n#endif\n    opendata();\n    if (xferfd == -1) {\n        (void) close(f);\n        goto end;\n    }\n    doreply();\n# ifdef WITH_TLS\n    if (data_protection_level == CPL_PRIVATE) {\n        tls_init_data_session(xferfd, passive);\n    }\n# endif\n    state_needs_update = 1;\n    setprocessname(\"pure-ftpd (UPLOAD)\");\n    filesize = restartat;\n\n#ifdef FTPWHO\n    if (shm_data_cur != NULL) {\n        const size_t sl = strlen(name);\n\n        ftpwho_lock();\n        shm_data_cur->state = FTPWHO_STATE_UPLOAD;\n        shm_data_cur->download_total_size = (off_t) 0U;\n        shm_data_cur->download_current_size = (off_t) filesize;\n        shm_data_cur->restartat = restartat;\n        (void) time(&shm_data_cur->xfer_date);\n        if (sl < sizeof shm_data_cur->filename) {\n            memcpy(shm_data_cur->filename, name, sl);\n            shm_data_cur->filename[sl] = 0;\n        } else {\n            memcpy(shm_data_cur->filename,\n                   &name[sl - sizeof shm_data_cur->filename - 1U],\n                   sizeof shm_data_cur->filename);\n        }\n        ftpwho_unlock();\n    }\n#endif\n\n    /* Here starts the real upload code */\n\n    started = get_usec_time();\n\n    if (ul_init(&ulhandler, clientfd, tls_cnx, xferfd, name, f, tls_data_cnx,\n                restartat, type == 1, throttling_bandwidth_ul,\n                max_filesize) == 0) {\n        ret = ul_send(&ulhandler);\n        ul_exit(&ulhandler);\n    } else {\n        ret = -1;\n    }\n    (void) close(f);\n    closedata();\n\n    /* Here ends the real upload code */\n\n#ifdef SHOW_REAL_DISK_SPACE\n    if (FSTATFS(f, &statfsbuf) == 0) {\n        double space;\n\n        space = (double) STATFS_BAVAIL(statfsbuf) *\n            (double) STATFS_FRSIZE(statfsbuf);\n        if (space > 524288.0) {\n            addreply(0, MSG_SPACE_FREE_M, space / 1048576.0);\n        } else {\n            addreply(0, MSG_SPACE_FREE_K, space / 1024.0);\n        }\n    }\n#endif\n\n    uploaded += (unsigned long long) ulhandler.total_uploaded;\n    {\n        off_t atomic_file_size;\n        off_t original_file_size;\n        int files_count;\n\n        if (overwrite == 0) {\n            files_count = 1;\n        } else {\n            files_count = 0;\n        }\n        if (autorename != 0 && restartat == (off_t) 0) {\n            if ((atomic_file_size = get_file_size(atomic_file)) < (off_t) 0) {\n                goto afterquota;\n            }\n            if (tryautorename(atomic_file, name, &name2) != 0) {\n                error(553, MSG_RENAME_FAILURE);\n                goto afterquota;\n            } else {\n#ifdef QUOTAS\n                ul_quota_update(name2 ? name2 : name, 1, atomic_file_size);\n#endif\n                atomic_file = NULL;\n            }\n        } else if (atomic_file != NULL) {\n            if ((atomic_file_size = get_file_size(atomic_file)) < (off_t) 0) {\n                goto afterquota;\n            }\n            if ((original_file_size = get_file_size(name)) < (off_t) 0 ||\n                restartat > original_file_size) {\n                original_file_size = restartat;\n            }\n            if (rename(atomic_file, name) != 0) {\n                error(553, MSG_RENAME_FAILURE);\n                goto afterquota;\n            } else {\n#ifdef QUOTAS\n                overflow = ul_quota_update\n                    (name, files_count, atomic_file_size - original_file_size);\n#endif\n                atomic_file = NULL;\n            }\n        } else {\n#ifdef QUOTAS\n            overflow = ul_quota_update\n                (name, files_count, ulhandler.total_uploaded);\n#endif\n        }\n    }\n    afterquota:\n    if (overflow > 0) {\n        addreply(552, MSG_QUOTA_EXCEEDED, name);\n    } else {\n        if (ret == 0) {\n            addreply_noformat(226, MSG_TRANSFER_SUCCESSFUL);\n        } else {\n            addreply_noformat(451, MSG_ABORTED);\n        }\n        displayrate(MSG_UPLOADED, ulhandler.total_uploaded, started,\n                    name2 ? name2 : name, 1);\n    }\n    end:\n    restartat = (off_t) 0;\n    if (atomic_file != NULL) {\n        unlink(atomic_file);\n        atomic_file = NULL;\n    }\n}", "func_hash": 206214968854253605299556693579818029977, "file_name": "ftpd.c", "file_hash": 235084351397611292950237183012549023004, "cwe": ["CWE-434"], "cve": "CVE-2021-40524", "cve_desc": "In Pure-FTPd before 1.0.50, an incorrect max_filesize quota mechanism in the server allows attackers to upload files of unbounded size, which may lead to denial of service or a server hang. This occurs because a certain greater-than-zero test does not anticipate an initial -1 value. (Versions 1.0.23 through 1.0.49 are affected.)", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-40524", "file_path": "src/ftpd.c"}
{"idx": 343298, "project": "pure-ftpd", "commit_id": "37ad222868e52271905b94afea4fc780d83294b4", "project_url": "https://github.com/jedisct1/pure-ftpd", "commit_url": "https://github.com/jedisct1/pure-ftpd/commit/37ad222868e52271905b94afea4fc780d83294b4", "commit_message": "Initialize the max upload file size when quotas are enabled\n\nDue to an unwanted check, files causing the quota to be exceeded\nwere deleted after the upload, but not during the upload.\n\nThe bug was introduced in 2009 in version 1.0.23\n\nSpotted by @DroidTest, thanks!", "target": 0, "func": "void dostor(char *name, const int append, const int autorename)\n{\n    ULHandler ulhandler;\n    int f;\n    const char *ul_name = NULL;\n    const char *atomic_file = NULL;\n    off_t filesize = (off_t) 0U;\n    struct stat st;\n    double started = 0.0;\n    signed char overwrite = 0;\n    int overflow = 0;\n    int ret = -1;\n    off_t max_filesize = (off_t) -1;\n#ifdef QUOTAS\n    Quota quota;\n#endif\n    const char *name2 = NULL;\n\n    if (type < 1 || (type == 1 && restartat > (off_t) 1)) {\n        addreply_noformat(503, MSG_NO_ASCII_RESUME);\n        goto end;\n    }\n#ifndef ANON_CAN_RESUME\n    if (guest != 0 && anon_noupload != 0) {\n        addreply_noformat(550, MSG_ANON_CANT_OVERWRITE);\n        goto end;\n    }\n#endif\n    if (ul_check_free_space(name, -1.0) == 0) {\n        addreply_noformat(552, MSG_NO_DISK_SPACE);\n        goto end;\n    }\n    if (checknamesanity(name, dot_write_ok) != 0) {\n        addreply(553, MSG_SANITY_FILE_FAILURE, name);\n        goto end;\n    }\n    if (autorename != 0) {\n        no_truncate = 1;\n    }\n    if (restartat > (off_t) 0 || no_truncate != 0) {\n        if ((atomic_file = get_atomic_file(name)) == NULL) {\n            addreply(553, MSG_SANITY_FILE_FAILURE, name);\n            goto end;\n        }\n        if (restartat > (off_t) 0 &&\n            rename(name, atomic_file) != 0 && errno != ENOENT) {\n            error(553, MSG_RENAME_FAILURE);\n            atomic_file = NULL;\n            goto end;\n        }\n    }\n    if (atomic_file != NULL) {\n        ul_name = atomic_file;\n    } else {\n        ul_name = name;\n    }\n    if (atomic_file == NULL &&\n        (f = open(ul_name, O_WRONLY | O_NOFOLLOW)) != -1) {\n        overwrite++;\n    } else if ((f = open(ul_name, O_CREAT | O_WRONLY | O_NOFOLLOW,\n                         (mode_t) 0777 & ~u_mask)) == -1) {\n        error(553, MSG_OPEN_FAILURE2);\n        goto end;\n    }\n    if (fstat(f, &st) < 0) {\n        (void) close(f);\n        error(553, MSG_STAT_FAILURE2);\n        goto end;\n    }\n    if (!S_ISREG(st.st_mode)) {\n        (void) close(f);\n        addreply_noformat(550, MSG_NOT_REGULAR_FILE);\n        goto end;\n    }\n    alarm(MAX_SESSION_XFER_IDLE);\n\n    /* Anonymous users *CAN* overwrite 0-bytes files - This is the right behavior */\n    if (st.st_size > (off_t) 0) {\n#ifndef ANON_CAN_RESUME\n        if (guest != 0) {\n            addreply_noformat(550, MSG_ANON_CANT_OVERWRITE);\n            (void) close(f);\n            goto end;\n        }\n#endif\n        if (append != 0) {\n            restartat = st.st_size;\n        }\n    } else {\n        restartat = (off_t) 0;\n    }\n    if (restartat > st.st_size) {\n        restartat = st.st_size;\n    }\n    if (restartat > (off_t) 0 && lseek(f, restartat, SEEK_SET) < (off_t) 0) {\n        (void) close(f);\n        error(451, \"seek\");\n        goto end;\n    }\n    if (restartat < st.st_size) {\n        if (ftruncate(f, restartat) < 0) {\n            (void) close(f);\n            error(451, \"ftruncate\");\n            goto end;\n        }\n#ifdef QUOTAS\n        if (restartat != st.st_size) {\n            (void) quota_update(NULL, 0LL,\n                                (long long) (restartat - st.st_size),\n                                &overflow);\n        }\n#endif\n    }\n#ifdef QUOTAS\n    if (quota_update(&quota, 0LL, 0LL, &overflow) == 0 &&\n        (overflow > 0 || quota.files >= user_quota_files ||\n         quota.size > user_quota_size ||\n         (max_filesize = user_quota_size - quota.size) < (off_t) 0)) {\n        overflow = 1;\n        (void) close(f);\n        goto afterquota;\n    }\n#endif\n    opendata();\n    if (xferfd == -1) {\n        (void) close(f);\n        goto end;\n    }\n    doreply();\n# ifdef WITH_TLS\n    if (data_protection_level == CPL_PRIVATE) {\n        tls_init_data_session(xferfd, passive);\n    }\n# endif\n    state_needs_update = 1;\n    setprocessname(\"pure-ftpd (UPLOAD)\");\n    filesize = restartat;\n\n#ifdef FTPWHO\n    if (shm_data_cur != NULL) {\n        const size_t sl = strlen(name);\n\n        ftpwho_lock();\n        shm_data_cur->state = FTPWHO_STATE_UPLOAD;\n        shm_data_cur->download_total_size = (off_t) 0U;\n        shm_data_cur->download_current_size = (off_t) filesize;\n        shm_data_cur->restartat = restartat;\n        (void) time(&shm_data_cur->xfer_date);\n        if (sl < sizeof shm_data_cur->filename) {\n            memcpy(shm_data_cur->filename, name, sl);\n            shm_data_cur->filename[sl] = 0;\n        } else {\n            memcpy(shm_data_cur->filename,\n                   &name[sl - sizeof shm_data_cur->filename - 1U],\n                   sizeof shm_data_cur->filename);\n        }\n        ftpwho_unlock();\n    }\n#endif\n\n    /* Here starts the real upload code */\n\n    started = get_usec_time();\n\n    if (ul_init(&ulhandler, clientfd, tls_cnx, xferfd, name, f, tls_data_cnx,\n                restartat, type == 1, throttling_bandwidth_ul,\n                max_filesize) == 0) {\n        ret = ul_send(&ulhandler);\n        ul_exit(&ulhandler);\n    } else {\n        ret = -1;\n    }\n    (void) close(f);\n    closedata();\n\n    /* Here ends the real upload code */\n\n#ifdef SHOW_REAL_DISK_SPACE\n    if (FSTATFS(f, &statfsbuf) == 0) {\n        double space;\n\n        space = (double) STATFS_BAVAIL(statfsbuf) *\n            (double) STATFS_FRSIZE(statfsbuf);\n        if (space > 524288.0) {\n            addreply(0, MSG_SPACE_FREE_M, space / 1048576.0);\n        } else {\n            addreply(0, MSG_SPACE_FREE_K, space / 1024.0);\n        }\n    }\n#endif\n\n    uploaded += (unsigned long long) ulhandler.total_uploaded;\n    {\n        off_t atomic_file_size;\n        off_t original_file_size;\n        int files_count;\n\n        if (overwrite == 0) {\n            files_count = 1;\n        } else {\n            files_count = 0;\n        }\n        if (autorename != 0 && restartat == (off_t) 0) {\n            if ((atomic_file_size = get_file_size(atomic_file)) < (off_t) 0) {\n                goto afterquota;\n            }\n            if (tryautorename(atomic_file, name, &name2) != 0) {\n                error(553, MSG_RENAME_FAILURE);\n                goto afterquota;\n            } else {\n#ifdef QUOTAS\n                ul_quota_update(name2 ? name2 : name, 1, atomic_file_size);\n#endif\n                atomic_file = NULL;\n            }\n        } else if (atomic_file != NULL) {\n            if ((atomic_file_size = get_file_size(atomic_file)) < (off_t) 0) {\n                goto afterquota;\n            }\n            if ((original_file_size = get_file_size(name)) < (off_t) 0 ||\n                restartat > original_file_size) {\n                original_file_size = restartat;\n            }\n            if (rename(atomic_file, name) != 0) {\n                error(553, MSG_RENAME_FAILURE);\n                goto afterquota;\n            } else {\n#ifdef QUOTAS\n                overflow = ul_quota_update\n                    (name, files_count, atomic_file_size - original_file_size);\n#endif\n                atomic_file = NULL;\n            }\n        } else {\n#ifdef QUOTAS\n            overflow = ul_quota_update\n                (name, files_count, ulhandler.total_uploaded);\n#endif\n        }\n    }\n    afterquota:\n    if (overflow > 0) {\n        addreply(552, MSG_QUOTA_EXCEEDED, name);\n    } else {\n        if (ret == 0) {\n            addreply_noformat(226, MSG_TRANSFER_SUCCESSFUL);\n        } else {\n            addreply_noformat(451, MSG_ABORTED);\n        }\n        displayrate(MSG_UPLOADED, ulhandler.total_uploaded, started,\n                    name2 ? name2 : name, 1);\n    }\n    end:\n    restartat = (off_t) 0;\n    if (atomic_file != NULL) {\n        unlink(atomic_file);\n        atomic_file = NULL;\n    }\n}", "func_hash": 189507601171684383524883387321805614234, "file_name": "ftpd.c", "file_hash": 102895278505023286855651896148239525136, "cwe": ["CWE-434"], "cve": "CVE-2021-40524", "cve_desc": "In Pure-FTPd before 1.0.50, an incorrect max_filesize quota mechanism in the server allows attackers to upload files of unbounded size, which may lead to denial of service or a server hang. This occurs because a certain greater-than-zero test does not anticipate an initial -1 value. (Versions 1.0.23 through 1.0.49 are affected.)", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-40524", "file_path": "src/ftpd.c"}
{"idx": 203614, "project": "linux", "commit_id": "a09d2d00af53b43c6f11e6ab3cb58443c2cac8a7", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/a09d2d00af53b43c6f11e6ab3cb58443c2cac8a7", "commit_message": "video: fbdev: pxa3xx-gcu: Fix integer overflow in pxa3xx_gcu_write\n\nIn pxa3xx_gcu_write, a count parameter of type size_t is passed to words of\ntype int.  Then, copy_from_user() may cause a heap overflow because it is used\nas the third argument of copy_from_user().\n\nSigned-off-by: Hyunwoo Kim <imv4bel@gmail.com>\nSigned-off-by: Helge Deller <deller@gmx.de>", "target": 1, "func": "pxa3xx_gcu_write(struct file *file, const char *buff,\n\t\t size_t count, loff_t *offp)\n{\n\tint ret;\n\tunsigned long flags;\n\tstruct pxa3xx_gcu_batch\t*buffer;\n\tstruct pxa3xx_gcu_priv *priv = to_pxa3xx_gcu_priv(file);\n\n\tint words = count / 4;\n\n\t/* Does not need to be atomic. There's a lock in user space,\n\t * but anyhow, this is just for statistics. */\n\tpriv->shared->num_writes++;\n\tpriv->shared->num_words += words;\n\n\t/* Last word reserved for batch buffer end command */\n\tif (words >= PXA3XX_GCU_BATCH_WORDS)\n\t\treturn -E2BIG;\n\n\t/* Wait for a free buffer */\n\tif (!priv->free) {\n\t\tret = pxa3xx_gcu_wait_free(priv);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * Get buffer from free list\n\t */\n\tspin_lock_irqsave(&priv->spinlock, flags);\n\tbuffer = priv->free;\n\tpriv->free = buffer->next;\n\tspin_unlock_irqrestore(&priv->spinlock, flags);\n\n\n\t/* Copy data from user into buffer */\n\tret = copy_from_user(buffer->ptr, buff, words * 4);\n\tif (ret) {\n\t\tspin_lock_irqsave(&priv->spinlock, flags);\n\t\tbuffer->next = priv->free;\n\t\tpriv->free = buffer;\n\t\tspin_unlock_irqrestore(&priv->spinlock, flags);\n\t\treturn -EFAULT;\n\t}\n\n\tbuffer->length = words;\n\n\t/* Append batch buffer end command */\n\tbuffer->ptr[words] = 0x01000000;\n\n\t/*\n\t * Add buffer to ready list\n\t */\n\tspin_lock_irqsave(&priv->spinlock, flags);\n\n\tbuffer->next = NULL;\n\n\tif (priv->ready) {\n\t\tBUG_ON(priv->ready_last == NULL);\n\n\t\tpriv->ready_last->next = buffer;\n\t} else\n\t\tpriv->ready = buffer;\n\n\tpriv->ready_last = buffer;\n\n\tif (!priv->shared->hw_running)\n\t\trun_ready(priv);\n\n\tspin_unlock_irqrestore(&priv->spinlock, flags);\n\n\treturn words * 4;\n}", "func_hash": 295091935056220827099180820590433673308, "file_name": "pxa3xx-gcu.c", "file_hash": 328263488920768374085149640831046958332, "cwe": ["CWE-703"], "cve": "CVE-2022-39842", "cve_desc": "An issue was discovered in the Linux kernel before 5.19. In pxa3xx_gcu_write in drivers/video/fbdev/pxa3xx-gcu.c, the count parameter has a type conflict of size_t versus int, causing an integer overflow and bypassing the size check. After that, because it is used as the third argument to copy_from_user(), a heap overflow may occur. NOTE: the original discoverer disputes that the overflow can actually happen.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-39842", "file_path": "drivers/video/fbdev/pxa3xx-gcu.c"}
