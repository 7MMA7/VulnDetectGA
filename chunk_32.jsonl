{"idx": 214160, "project": "linux", "commit_id": "75e5b4849b81e19e9efe1654b30d7f3151c33c2c", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/75e5b4849b81e19e9efe1654b30d7f3151c33c2c", "commit_message": "USB: gadget: validate interface OS descriptor requests\n\nStall the control endpoint in case provided index exceeds array size of\nMAX_CONFIG_INTERFACES or when the retrieved function pointer is null.\n\nSigned-off-by: Szymon Heidrich <szymon.heidrich@gmail.com>\nCc: stable@kernel.org\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>", "target": 1, "func": "composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)\n{\n\tstruct usb_composite_dev\t*cdev = get_gadget_data(gadget);\n\tstruct usb_request\t\t*req = cdev->req;\n\tint\t\t\t\tvalue = -EOPNOTSUPP;\n\tint\t\t\t\tstatus = 0;\n\tu16\t\t\t\tw_index = le16_to_cpu(ctrl->wIndex);\n\tu8\t\t\t\tintf = w_index & 0xFF;\n\tu16\t\t\t\tw_value = le16_to_cpu(ctrl->wValue);\n\tu16\t\t\t\tw_length = le16_to_cpu(ctrl->wLength);\n\tstruct usb_function\t\t*f = NULL;\n\tu8\t\t\t\tendp;\n\n\tif (w_length > USB_COMP_EP0_BUFSIZ) {\n\t\tif (ctrl->bRequestType & USB_DIR_IN) {\n\t\t\t/* Cast away the const, we are going to overwrite on purpose. */\n\t\t\t__le16 *temp = (__le16 *)&ctrl->wLength;\n\n\t\t\t*temp = cpu_to_le16(USB_COMP_EP0_BUFSIZ);\n\t\t\tw_length = USB_COMP_EP0_BUFSIZ;\n\t\t} else {\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* partial re-init of the response message; the function or the\n\t * gadget might need to intercept e.g. a control-OUT completion\n\t * when we delegate to it.\n\t */\n\treq->zero = 0;\n\treq->context = cdev;\n\treq->complete = composite_setup_complete;\n\treq->length = 0;\n\tgadget->ep0->driver_data = cdev;\n\n\t/*\n\t * Don't let non-standard requests match any of the cases below\n\t * by accident.\n\t */\n\tif ((ctrl->bRequestType & USB_TYPE_MASK) != USB_TYPE_STANDARD)\n\t\tgoto unknown;\n\n\tswitch (ctrl->bRequest) {\n\n\t/* we handle all standard USB descriptors */\n\tcase USB_REQ_GET_DESCRIPTOR:\n\t\tif (ctrl->bRequestType != USB_DIR_IN)\n\t\t\tgoto unknown;\n\t\tswitch (w_value >> 8) {\n\n\t\tcase USB_DT_DEVICE:\n\t\t\tcdev->desc.bNumConfigurations =\n\t\t\t\tcount_configs(cdev, USB_DT_DEVICE);\n\t\t\tcdev->desc.bMaxPacketSize0 =\n\t\t\t\tcdev->gadget->ep0->maxpacket;\n\t\t\tif (gadget_is_superspeed(gadget)) {\n\t\t\t\tif (gadget->speed >= USB_SPEED_SUPER) {\n\t\t\t\t\tcdev->desc.bcdUSB = cpu_to_le16(0x0320);\n\t\t\t\t\tcdev->desc.bMaxPacketSize0 = 9;\n\t\t\t\t} else {\n\t\t\t\t\tcdev->desc.bcdUSB = cpu_to_le16(0x0210);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (gadget->lpm_capable)\n\t\t\t\t\tcdev->desc.bcdUSB = cpu_to_le16(0x0201);\n\t\t\t\telse\n\t\t\t\t\tcdev->desc.bcdUSB = cpu_to_le16(0x0200);\n\t\t\t}\n\n\t\t\tvalue = min(w_length, (u16) sizeof cdev->desc);\n\t\t\tmemcpy(req->buf, &cdev->desc, value);\n\t\t\tbreak;\n\t\tcase USB_DT_DEVICE_QUALIFIER:\n\t\t\tif (!gadget_is_dualspeed(gadget) ||\n\t\t\t    gadget->speed >= USB_SPEED_SUPER)\n\t\t\t\tbreak;\n\t\t\tdevice_qual(cdev);\n\t\t\tvalue = min_t(int, w_length,\n\t\t\t\tsizeof(struct usb_qualifier_descriptor));\n\t\t\tbreak;\n\t\tcase USB_DT_OTHER_SPEED_CONFIG:\n\t\t\tif (!gadget_is_dualspeed(gadget) ||\n\t\t\t    gadget->speed >= USB_SPEED_SUPER)\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\tcase USB_DT_CONFIG:\n\t\t\tvalue = config_desc(cdev, w_value);\n\t\t\tif (value >= 0)\n\t\t\t\tvalue = min(w_length, (u16) value);\n\t\t\tbreak;\n\t\tcase USB_DT_STRING:\n\t\t\tvalue = get_string(cdev, req->buf,\n\t\t\t\t\tw_index, w_value & 0xff);\n\t\t\tif (value >= 0)\n\t\t\t\tvalue = min(w_length, (u16) value);\n\t\t\tbreak;\n\t\tcase USB_DT_BOS:\n\t\t\tif (gadget_is_superspeed(gadget) ||\n\t\t\t    gadget->lpm_capable) {\n\t\t\t\tvalue = bos_desc(cdev);\n\t\t\t\tvalue = min(w_length, (u16) value);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase USB_DT_OTG:\n\t\t\tif (gadget_is_otg(gadget)) {\n\t\t\t\tstruct usb_configuration *config;\n\t\t\t\tint otg_desc_len = 0;\n\n\t\t\t\tif (cdev->config)\n\t\t\t\t\tconfig = cdev->config;\n\t\t\t\telse\n\t\t\t\t\tconfig = list_first_entry(\n\t\t\t\t\t\t\t&cdev->configs,\n\t\t\t\t\t\tstruct usb_configuration, list);\n\t\t\t\tif (!config)\n\t\t\t\t\tgoto done;\n\n\t\t\t\tif (gadget->otg_caps &&\n\t\t\t\t\t(gadget->otg_caps->otg_rev >= 0x0200))\n\t\t\t\t\totg_desc_len += sizeof(\n\t\t\t\t\t\tstruct usb_otg20_descriptor);\n\t\t\t\telse\n\t\t\t\t\totg_desc_len += sizeof(\n\t\t\t\t\t\tstruct usb_otg_descriptor);\n\n\t\t\t\tvalue = min_t(int, w_length, otg_desc_len);\n\t\t\t\tmemcpy(req->buf, config->descriptors[0], value);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\t/* any number of configs can work */\n\tcase USB_REQ_SET_CONFIGURATION:\n\t\tif (ctrl->bRequestType != 0)\n\t\t\tgoto unknown;\n\t\tif (gadget_is_otg(gadget)) {\n\t\t\tif (gadget->a_hnp_support)\n\t\t\t\tDBG(cdev, \"HNP available\\n\");\n\t\t\telse if (gadget->a_alt_hnp_support)\n\t\t\t\tDBG(cdev, \"HNP on another port\\n\");\n\t\t\telse\n\t\t\t\tVDBG(cdev, \"HNP inactive\\n\");\n\t\t}\n\t\tspin_lock(&cdev->lock);\n\t\tvalue = set_config(cdev, ctrl, w_value);\n\t\tspin_unlock(&cdev->lock);\n\t\tbreak;\n\tcase USB_REQ_GET_CONFIGURATION:\n\t\tif (ctrl->bRequestType != USB_DIR_IN)\n\t\t\tgoto unknown;\n\t\tif (cdev->config)\n\t\t\t*(u8 *)req->buf = cdev->config->bConfigurationValue;\n\t\telse\n\t\t\t*(u8 *)req->buf = 0;\n\t\tvalue = min(w_length, (u16) 1);\n\t\tbreak;\n\n\t/* function drivers must handle get/set altsetting */\n\tcase USB_REQ_SET_INTERFACE:\n\t\tif (ctrl->bRequestType != USB_RECIP_INTERFACE)\n\t\t\tgoto unknown;\n\t\tif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\n\t\t\tbreak;\n\t\tf = cdev->config->interface[intf];\n\t\tif (!f)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * If there's no get_alt() method, we know only altsetting zero\n\t\t * works. There is no need to check if set_alt() is not NULL\n\t\t * as we check this in usb_add_function().\n\t\t */\n\t\tif (w_value && !f->get_alt)\n\t\t\tbreak;\n\n\t\tspin_lock(&cdev->lock);\n\t\tvalue = f->set_alt(f, w_index, w_value);\n\t\tif (value == USB_GADGET_DELAYED_STATUS) {\n\t\t\tDBG(cdev,\n\t\t\t \"%s: interface %d (%s) requested delayed status\\n\",\n\t\t\t\t\t__func__, intf, f->name);\n\t\t\tcdev->delayed_status++;\n\t\t\tDBG(cdev, \"delayed_status count %d\\n\",\n\t\t\t\t\tcdev->delayed_status);\n\t\t}\n\t\tspin_unlock(&cdev->lock);\n\t\tbreak;\n\tcase USB_REQ_GET_INTERFACE:\n\t\tif (ctrl->bRequestType != (USB_DIR_IN|USB_RECIP_INTERFACE))\n\t\t\tgoto unknown;\n\t\tif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\n\t\t\tbreak;\n\t\tf = cdev->config->interface[intf];\n\t\tif (!f)\n\t\t\tbreak;\n\t\t/* lots of interfaces only need altsetting zero... */\n\t\tvalue = f->get_alt ? f->get_alt(f, w_index) : 0;\n\t\tif (value < 0)\n\t\t\tbreak;\n\t\t*((u8 *)req->buf) = value;\n\t\tvalue = min(w_length, (u16) 1);\n\t\tbreak;\n\tcase USB_REQ_GET_STATUS:\n\t\tif (gadget_is_otg(gadget) && gadget->hnp_polling_support &&\n\t\t\t\t\t\t(w_index == OTG_STS_SELECTOR)) {\n\t\t\tif (ctrl->bRequestType != (USB_DIR_IN |\n\t\t\t\t\t\t\tUSB_RECIP_DEVICE))\n\t\t\t\tgoto unknown;\n\t\t\t*((u8 *)req->buf) = gadget->host_request_flag;\n\t\t\tvalue = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * USB 3.0 additions:\n\t\t * Function driver should handle get_status request. If such cb\n\t\t * wasn't supplied we respond with default value = 0\n\t\t * Note: function driver should supply such cb only for the\n\t\t * first interface of the function\n\t\t */\n\t\tif (!gadget_is_superspeed(gadget))\n\t\t\tgoto unknown;\n\t\tif (ctrl->bRequestType != (USB_DIR_IN | USB_RECIP_INTERFACE))\n\t\t\tgoto unknown;\n\t\tvalue = 2;\t/* This is the length of the get_status reply */\n\t\tput_unaligned_le16(0, req->buf);\n\t\tif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\n\t\t\tbreak;\n\t\tf = cdev->config->interface[intf];\n\t\tif (!f)\n\t\t\tbreak;\n\t\tstatus = f->get_status ? f->get_status(f) : 0;\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tput_unaligned_le16(status & 0x0000ffff, req->buf);\n\t\tbreak;\n\t/*\n\t * Function drivers should handle SetFeature/ClearFeature\n\t * (FUNCTION_SUSPEND) request. function_suspend cb should be supplied\n\t * only for the first interface of the function\n\t */\n\tcase USB_REQ_CLEAR_FEATURE:\n\tcase USB_REQ_SET_FEATURE:\n\t\tif (!gadget_is_superspeed(gadget))\n\t\t\tgoto unknown;\n\t\tif (ctrl->bRequestType != (USB_DIR_OUT | USB_RECIP_INTERFACE))\n\t\t\tgoto unknown;\n\t\tswitch (w_value) {\n\t\tcase USB_INTRF_FUNC_SUSPEND:\n\t\t\tif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\n\t\t\t\tbreak;\n\t\t\tf = cdev->config->interface[intf];\n\t\t\tif (!f)\n\t\t\t\tbreak;\n\t\t\tvalue = 0;\n\t\t\tif (f->func_suspend)\n\t\t\t\tvalue = f->func_suspend(f, w_index >> 8);\n\t\t\tif (value < 0) {\n\t\t\t\tERROR(cdev,\n\t\t\t\t      \"func_suspend() returned error %d\\n\",\n\t\t\t\t      value);\n\t\t\t\tvalue = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\nunknown:\n\t\t/*\n\t\t * OS descriptors handling\n\t\t */\n\t\tif (cdev->use_os_string && cdev->os_desc_config &&\n\t\t    (ctrl->bRequestType & USB_TYPE_VENDOR) &&\n\t\t    ctrl->bRequest == cdev->b_vendor_code) {\n\t\t\tstruct usb_configuration\t*os_desc_cfg;\n\t\t\tu8\t\t\t\t*buf;\n\t\t\tint\t\t\t\tinterface;\n\t\t\tint\t\t\t\tcount = 0;\n\n\t\t\treq = cdev->os_desc_req;\n\t\t\treq->context = cdev;\n\t\t\treq->complete = composite_setup_complete;\n\t\t\tbuf = req->buf;\n\t\t\tos_desc_cfg = cdev->os_desc_config;\n\t\t\tw_length = min_t(u16, w_length, USB_COMP_EP0_OS_DESC_BUFSIZ);\n\t\t\tmemset(buf, 0, w_length);\n\t\t\tbuf[5] = 0x01;\n\t\t\tswitch (ctrl->bRequestType & USB_RECIP_MASK) {\n\t\t\tcase USB_RECIP_DEVICE:\n\t\t\t\tif (w_index != 0x4 || (w_value >> 8))\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[6] = w_index;\n\t\t\t\t/* Number of ext compat interfaces */\n\t\t\t\tcount = count_ext_compat(os_desc_cfg);\n\t\t\t\tbuf[8] = count;\n\t\t\t\tcount *= 24; /* 24 B/ext compat desc */\n\t\t\t\tcount += 16; /* header */\n\t\t\t\tput_unaligned_le32(count, buf);\n\t\t\t\tvalue = w_length;\n\t\t\t\tif (w_length > 0x10) {\n\t\t\t\t\tvalue = fill_ext_compat(os_desc_cfg, buf);\n\t\t\t\t\tvalue = min_t(u16, w_length, value);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase USB_RECIP_INTERFACE:\n\t\t\t\tif (w_index != 0x5 || (w_value >> 8))\n\t\t\t\t\tbreak;\n\t\t\t\tinterface = w_value & 0xFF;\n\t\t\t\tbuf[6] = w_index;\n\t\t\t\tcount = count_ext_prop(os_desc_cfg,\n\t\t\t\t\tinterface);\n\t\t\t\tput_unaligned_le16(count, buf + 8);\n\t\t\t\tcount = len_ext_prop(os_desc_cfg,\n\t\t\t\t\tinterface);\n\t\t\t\tput_unaligned_le32(count, buf);\n\t\t\t\tvalue = w_length;\n\t\t\t\tif (w_length > 0x0A) {\n\t\t\t\t\tvalue = fill_ext_prop(os_desc_cfg,\n\t\t\t\t\t\t\t      interface, buf);\n\t\t\t\t\tif (value >= 0)\n\t\t\t\t\t\tvalue = min_t(u16, w_length, value);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tgoto check_value;\n\t\t}\n\n\t\tVDBG(cdev,\n\t\t\t\"non-core control req%02x.%02x v%04x i%04x l%d\\n\",\n\t\t\tctrl->bRequestType, ctrl->bRequest,\n\t\t\tw_value, w_index, w_length);\n\n\t\t/* functions always handle their interfaces and endpoints...\n\t\t * punt other recipients (other, WUSB, ...) to the current\n\t\t * configuration code.\n\t\t */\n\t\tif (cdev->config) {\n\t\t\tlist_for_each_entry(f, &cdev->config->functions, list)\n\t\t\t\tif (f->req_match &&\n\t\t\t\t    f->req_match(f, ctrl, false))\n\t\t\t\t\tgoto try_fun_setup;\n\t\t} else {\n\t\t\tstruct usb_configuration *c;\n\t\t\tlist_for_each_entry(c, &cdev->configs, list)\n\t\t\t\tlist_for_each_entry(f, &c->functions, list)\n\t\t\t\t\tif (f->req_match &&\n\t\t\t\t\t    f->req_match(f, ctrl, true))\n\t\t\t\t\t\tgoto try_fun_setup;\n\t\t}\n\t\tf = NULL;\n\n\t\tswitch (ctrl->bRequestType & USB_RECIP_MASK) {\n\t\tcase USB_RECIP_INTERFACE:\n\t\t\tif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\n\t\t\t\tbreak;\n\t\t\tf = cdev->config->interface[intf];\n\t\t\tbreak;\n\n\t\tcase USB_RECIP_ENDPOINT:\n\t\t\tif (!cdev->config)\n\t\t\t\tbreak;\n\t\t\tendp = ((w_index & 0x80) >> 3) | (w_index & 0x0f);\n\t\t\tlist_for_each_entry(f, &cdev->config->functions, list) {\n\t\t\t\tif (test_bit(endp, f->endpoints))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (&f->list == &cdev->config->functions)\n\t\t\t\tf = NULL;\n\t\t\tbreak;\n\t\t}\ntry_fun_setup:\n\t\tif (f && f->setup)\n\t\t\tvalue = f->setup(f, ctrl);\n\t\telse {\n\t\t\tstruct usb_configuration\t*c;\n\n\t\t\tc = cdev->config;\n\t\t\tif (!c)\n\t\t\t\tgoto done;\n\n\t\t\t/* try current config's setup */\n\t\t\tif (c->setup) {\n\t\t\t\tvalue = c->setup(c, ctrl);\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\t/* try the only function in the current config */\n\t\t\tif (!list_is_singular(&c->functions))\n\t\t\t\tgoto done;\n\t\t\tf = list_first_entry(&c->functions, struct usb_function,\n\t\t\t\t\t     list);\n\t\t\tif (f->setup)\n\t\t\t\tvalue = f->setup(f, ctrl);\n\t\t}\n\n\t\tgoto done;\n\t}\n\ncheck_value:\n\t/* respond with data transfer before status phase? */\n\tif (value >= 0 && value != USB_GADGET_DELAYED_STATUS) {\n\t\treq->length = value;\n\t\treq->context = cdev;\n\t\treq->zero = value < w_length;\n\t\tvalue = composite_ep0_queue(cdev, req, GFP_ATOMIC);\n\t\tif (value < 0) {\n\t\t\tDBG(cdev, \"ep_queue --> %d\\n\", value);\n\t\t\treq->status = 0;\n\t\t\tcomposite_setup_complete(gadget->ep0, req);\n\t\t}\n\t} else if (value == USB_GADGET_DELAYED_STATUS && w_length != 0) {\n\t\tWARN(cdev,\n\t\t\t\"%s: Delayed status not supported for w_length != 0\",\n\t\t\t__func__);\n\t}\n\ndone:\n\t/* device either stalls (value < 0) or reports success */\n\treturn value;\n}", "func_hash": 303126640832251617876878392273862526744, "file_name": "composite.c", "file_hash": 18887355761308803276229129312051135602, "cwe": ["CWE-476"], "cve": "CVE-2022-25258", "cve_desc": "An issue was discovered in drivers/usb/gadget/composite.c in the Linux kernel before 5.16.10. The USB Gadget subsystem lacks certain validation of interface OS descriptor requests (ones with a large array index and ones associated with NULL function pointer retrieval). Memory corruption might occur.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-25258", "file_path": "drivers/usb/gadget/composite.c"}
{"idx": 476103, "project": "linux", "commit_id": "75e5b4849b81e19e9efe1654b30d7f3151c33c2c", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/75e5b4849b81e19e9efe1654b30d7f3151c33c2c", "commit_message": "USB: gadget: validate interface OS descriptor requests\n\nStall the control endpoint in case provided index exceeds array size of\nMAX_CONFIG_INTERFACES or when the retrieved function pointer is null.\n\nSigned-off-by: Szymon Heidrich <szymon.heidrich@gmail.com>\nCc: stable@kernel.org\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>", "target": 0, "func": "composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)\n{\n\tstruct usb_composite_dev\t*cdev = get_gadget_data(gadget);\n\tstruct usb_request\t\t*req = cdev->req;\n\tint\t\t\t\tvalue = -EOPNOTSUPP;\n\tint\t\t\t\tstatus = 0;\n\tu16\t\t\t\tw_index = le16_to_cpu(ctrl->wIndex);\n\tu8\t\t\t\tintf = w_index & 0xFF;\n\tu16\t\t\t\tw_value = le16_to_cpu(ctrl->wValue);\n\tu16\t\t\t\tw_length = le16_to_cpu(ctrl->wLength);\n\tstruct usb_function\t\t*f = NULL;\n\tu8\t\t\t\tendp;\n\n\tif (w_length > USB_COMP_EP0_BUFSIZ) {\n\t\tif (ctrl->bRequestType & USB_DIR_IN) {\n\t\t\t/* Cast away the const, we are going to overwrite on purpose. */\n\t\t\t__le16 *temp = (__le16 *)&ctrl->wLength;\n\n\t\t\t*temp = cpu_to_le16(USB_COMP_EP0_BUFSIZ);\n\t\t\tw_length = USB_COMP_EP0_BUFSIZ;\n\t\t} else {\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* partial re-init of the response message; the function or the\n\t * gadget might need to intercept e.g. a control-OUT completion\n\t * when we delegate to it.\n\t */\n\treq->zero = 0;\n\treq->context = cdev;\n\treq->complete = composite_setup_complete;\n\treq->length = 0;\n\tgadget->ep0->driver_data = cdev;\n\n\t/*\n\t * Don't let non-standard requests match any of the cases below\n\t * by accident.\n\t */\n\tif ((ctrl->bRequestType & USB_TYPE_MASK) != USB_TYPE_STANDARD)\n\t\tgoto unknown;\n\n\tswitch (ctrl->bRequest) {\n\n\t/* we handle all standard USB descriptors */\n\tcase USB_REQ_GET_DESCRIPTOR:\n\t\tif (ctrl->bRequestType != USB_DIR_IN)\n\t\t\tgoto unknown;\n\t\tswitch (w_value >> 8) {\n\n\t\tcase USB_DT_DEVICE:\n\t\t\tcdev->desc.bNumConfigurations =\n\t\t\t\tcount_configs(cdev, USB_DT_DEVICE);\n\t\t\tcdev->desc.bMaxPacketSize0 =\n\t\t\t\tcdev->gadget->ep0->maxpacket;\n\t\t\tif (gadget_is_superspeed(gadget)) {\n\t\t\t\tif (gadget->speed >= USB_SPEED_SUPER) {\n\t\t\t\t\tcdev->desc.bcdUSB = cpu_to_le16(0x0320);\n\t\t\t\t\tcdev->desc.bMaxPacketSize0 = 9;\n\t\t\t\t} else {\n\t\t\t\t\tcdev->desc.bcdUSB = cpu_to_le16(0x0210);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (gadget->lpm_capable)\n\t\t\t\t\tcdev->desc.bcdUSB = cpu_to_le16(0x0201);\n\t\t\t\telse\n\t\t\t\t\tcdev->desc.bcdUSB = cpu_to_le16(0x0200);\n\t\t\t}\n\n\t\t\tvalue = min(w_length, (u16) sizeof cdev->desc);\n\t\t\tmemcpy(req->buf, &cdev->desc, value);\n\t\t\tbreak;\n\t\tcase USB_DT_DEVICE_QUALIFIER:\n\t\t\tif (!gadget_is_dualspeed(gadget) ||\n\t\t\t    gadget->speed >= USB_SPEED_SUPER)\n\t\t\t\tbreak;\n\t\t\tdevice_qual(cdev);\n\t\t\tvalue = min_t(int, w_length,\n\t\t\t\tsizeof(struct usb_qualifier_descriptor));\n\t\t\tbreak;\n\t\tcase USB_DT_OTHER_SPEED_CONFIG:\n\t\t\tif (!gadget_is_dualspeed(gadget) ||\n\t\t\t    gadget->speed >= USB_SPEED_SUPER)\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\tcase USB_DT_CONFIG:\n\t\t\tvalue = config_desc(cdev, w_value);\n\t\t\tif (value >= 0)\n\t\t\t\tvalue = min(w_length, (u16) value);\n\t\t\tbreak;\n\t\tcase USB_DT_STRING:\n\t\t\tvalue = get_string(cdev, req->buf,\n\t\t\t\t\tw_index, w_value & 0xff);\n\t\t\tif (value >= 0)\n\t\t\t\tvalue = min(w_length, (u16) value);\n\t\t\tbreak;\n\t\tcase USB_DT_BOS:\n\t\t\tif (gadget_is_superspeed(gadget) ||\n\t\t\t    gadget->lpm_capable) {\n\t\t\t\tvalue = bos_desc(cdev);\n\t\t\t\tvalue = min(w_length, (u16) value);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase USB_DT_OTG:\n\t\t\tif (gadget_is_otg(gadget)) {\n\t\t\t\tstruct usb_configuration *config;\n\t\t\t\tint otg_desc_len = 0;\n\n\t\t\t\tif (cdev->config)\n\t\t\t\t\tconfig = cdev->config;\n\t\t\t\telse\n\t\t\t\t\tconfig = list_first_entry(\n\t\t\t\t\t\t\t&cdev->configs,\n\t\t\t\t\t\tstruct usb_configuration, list);\n\t\t\t\tif (!config)\n\t\t\t\t\tgoto done;\n\n\t\t\t\tif (gadget->otg_caps &&\n\t\t\t\t\t(gadget->otg_caps->otg_rev >= 0x0200))\n\t\t\t\t\totg_desc_len += sizeof(\n\t\t\t\t\t\tstruct usb_otg20_descriptor);\n\t\t\t\telse\n\t\t\t\t\totg_desc_len += sizeof(\n\t\t\t\t\t\tstruct usb_otg_descriptor);\n\n\t\t\t\tvalue = min_t(int, w_length, otg_desc_len);\n\t\t\t\tmemcpy(req->buf, config->descriptors[0], value);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\t/* any number of configs can work */\n\tcase USB_REQ_SET_CONFIGURATION:\n\t\tif (ctrl->bRequestType != 0)\n\t\t\tgoto unknown;\n\t\tif (gadget_is_otg(gadget)) {\n\t\t\tif (gadget->a_hnp_support)\n\t\t\t\tDBG(cdev, \"HNP available\\n\");\n\t\t\telse if (gadget->a_alt_hnp_support)\n\t\t\t\tDBG(cdev, \"HNP on another port\\n\");\n\t\t\telse\n\t\t\t\tVDBG(cdev, \"HNP inactive\\n\");\n\t\t}\n\t\tspin_lock(&cdev->lock);\n\t\tvalue = set_config(cdev, ctrl, w_value);\n\t\tspin_unlock(&cdev->lock);\n\t\tbreak;\n\tcase USB_REQ_GET_CONFIGURATION:\n\t\tif (ctrl->bRequestType != USB_DIR_IN)\n\t\t\tgoto unknown;\n\t\tif (cdev->config)\n\t\t\t*(u8 *)req->buf = cdev->config->bConfigurationValue;\n\t\telse\n\t\t\t*(u8 *)req->buf = 0;\n\t\tvalue = min(w_length, (u16) 1);\n\t\tbreak;\n\n\t/* function drivers must handle get/set altsetting */\n\tcase USB_REQ_SET_INTERFACE:\n\t\tif (ctrl->bRequestType != USB_RECIP_INTERFACE)\n\t\t\tgoto unknown;\n\t\tif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\n\t\t\tbreak;\n\t\tf = cdev->config->interface[intf];\n\t\tif (!f)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * If there's no get_alt() method, we know only altsetting zero\n\t\t * works. There is no need to check if set_alt() is not NULL\n\t\t * as we check this in usb_add_function().\n\t\t */\n\t\tif (w_value && !f->get_alt)\n\t\t\tbreak;\n\n\t\tspin_lock(&cdev->lock);\n\t\tvalue = f->set_alt(f, w_index, w_value);\n\t\tif (value == USB_GADGET_DELAYED_STATUS) {\n\t\t\tDBG(cdev,\n\t\t\t \"%s: interface %d (%s) requested delayed status\\n\",\n\t\t\t\t\t__func__, intf, f->name);\n\t\t\tcdev->delayed_status++;\n\t\t\tDBG(cdev, \"delayed_status count %d\\n\",\n\t\t\t\t\tcdev->delayed_status);\n\t\t}\n\t\tspin_unlock(&cdev->lock);\n\t\tbreak;\n\tcase USB_REQ_GET_INTERFACE:\n\t\tif (ctrl->bRequestType != (USB_DIR_IN|USB_RECIP_INTERFACE))\n\t\t\tgoto unknown;\n\t\tif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\n\t\t\tbreak;\n\t\tf = cdev->config->interface[intf];\n\t\tif (!f)\n\t\t\tbreak;\n\t\t/* lots of interfaces only need altsetting zero... */\n\t\tvalue = f->get_alt ? f->get_alt(f, w_index) : 0;\n\t\tif (value < 0)\n\t\t\tbreak;\n\t\t*((u8 *)req->buf) = value;\n\t\tvalue = min(w_length, (u16) 1);\n\t\tbreak;\n\tcase USB_REQ_GET_STATUS:\n\t\tif (gadget_is_otg(gadget) && gadget->hnp_polling_support &&\n\t\t\t\t\t\t(w_index == OTG_STS_SELECTOR)) {\n\t\t\tif (ctrl->bRequestType != (USB_DIR_IN |\n\t\t\t\t\t\t\tUSB_RECIP_DEVICE))\n\t\t\t\tgoto unknown;\n\t\t\t*((u8 *)req->buf) = gadget->host_request_flag;\n\t\t\tvalue = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * USB 3.0 additions:\n\t\t * Function driver should handle get_status request. If such cb\n\t\t * wasn't supplied we respond with default value = 0\n\t\t * Note: function driver should supply such cb only for the\n\t\t * first interface of the function\n\t\t */\n\t\tif (!gadget_is_superspeed(gadget))\n\t\t\tgoto unknown;\n\t\tif (ctrl->bRequestType != (USB_DIR_IN | USB_RECIP_INTERFACE))\n\t\t\tgoto unknown;\n\t\tvalue = 2;\t/* This is the length of the get_status reply */\n\t\tput_unaligned_le16(0, req->buf);\n\t\tif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\n\t\t\tbreak;\n\t\tf = cdev->config->interface[intf];\n\t\tif (!f)\n\t\t\tbreak;\n\t\tstatus = f->get_status ? f->get_status(f) : 0;\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tput_unaligned_le16(status & 0x0000ffff, req->buf);\n\t\tbreak;\n\t/*\n\t * Function drivers should handle SetFeature/ClearFeature\n\t * (FUNCTION_SUSPEND) request. function_suspend cb should be supplied\n\t * only for the first interface of the function\n\t */\n\tcase USB_REQ_CLEAR_FEATURE:\n\tcase USB_REQ_SET_FEATURE:\n\t\tif (!gadget_is_superspeed(gadget))\n\t\t\tgoto unknown;\n\t\tif (ctrl->bRequestType != (USB_DIR_OUT | USB_RECIP_INTERFACE))\n\t\t\tgoto unknown;\n\t\tswitch (w_value) {\n\t\tcase USB_INTRF_FUNC_SUSPEND:\n\t\t\tif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\n\t\t\t\tbreak;\n\t\t\tf = cdev->config->interface[intf];\n\t\t\tif (!f)\n\t\t\t\tbreak;\n\t\t\tvalue = 0;\n\t\t\tif (f->func_suspend)\n\t\t\t\tvalue = f->func_suspend(f, w_index >> 8);\n\t\t\tif (value < 0) {\n\t\t\t\tERROR(cdev,\n\t\t\t\t      \"func_suspend() returned error %d\\n\",\n\t\t\t\t      value);\n\t\t\t\tvalue = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\nunknown:\n\t\t/*\n\t\t * OS descriptors handling\n\t\t */\n\t\tif (cdev->use_os_string && cdev->os_desc_config &&\n\t\t    (ctrl->bRequestType & USB_TYPE_VENDOR) &&\n\t\t    ctrl->bRequest == cdev->b_vendor_code) {\n\t\t\tstruct usb_configuration\t*os_desc_cfg;\n\t\t\tu8\t\t\t\t*buf;\n\t\t\tint\t\t\t\tinterface;\n\t\t\tint\t\t\t\tcount = 0;\n\n\t\t\treq = cdev->os_desc_req;\n\t\t\treq->context = cdev;\n\t\t\treq->complete = composite_setup_complete;\n\t\t\tbuf = req->buf;\n\t\t\tos_desc_cfg = cdev->os_desc_config;\n\t\t\tw_length = min_t(u16, w_length, USB_COMP_EP0_OS_DESC_BUFSIZ);\n\t\t\tmemset(buf, 0, w_length);\n\t\t\tbuf[5] = 0x01;\n\t\t\tswitch (ctrl->bRequestType & USB_RECIP_MASK) {\n\t\t\tcase USB_RECIP_DEVICE:\n\t\t\t\tif (w_index != 0x4 || (w_value >> 8))\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[6] = w_index;\n\t\t\t\t/* Number of ext compat interfaces */\n\t\t\t\tcount = count_ext_compat(os_desc_cfg);\n\t\t\t\tbuf[8] = count;\n\t\t\t\tcount *= 24; /* 24 B/ext compat desc */\n\t\t\t\tcount += 16; /* header */\n\t\t\t\tput_unaligned_le32(count, buf);\n\t\t\t\tvalue = w_length;\n\t\t\t\tif (w_length > 0x10) {\n\t\t\t\t\tvalue = fill_ext_compat(os_desc_cfg, buf);\n\t\t\t\t\tvalue = min_t(u16, w_length, value);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase USB_RECIP_INTERFACE:\n\t\t\t\tif (w_index != 0x5 || (w_value >> 8))\n\t\t\t\t\tbreak;\n\t\t\t\tinterface = w_value & 0xFF;\n\t\t\t\tif (interface >= MAX_CONFIG_INTERFACES ||\n\t\t\t\t    !os_desc_cfg->interface[interface])\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[6] = w_index;\n\t\t\t\tcount = count_ext_prop(os_desc_cfg,\n\t\t\t\t\tinterface);\n\t\t\t\tput_unaligned_le16(count, buf + 8);\n\t\t\t\tcount = len_ext_prop(os_desc_cfg,\n\t\t\t\t\tinterface);\n\t\t\t\tput_unaligned_le32(count, buf);\n\t\t\t\tvalue = w_length;\n\t\t\t\tif (w_length > 0x0A) {\n\t\t\t\t\tvalue = fill_ext_prop(os_desc_cfg,\n\t\t\t\t\t\t\t      interface, buf);\n\t\t\t\t\tif (value >= 0)\n\t\t\t\t\t\tvalue = min_t(u16, w_length, value);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tgoto check_value;\n\t\t}\n\n\t\tVDBG(cdev,\n\t\t\t\"non-core control req%02x.%02x v%04x i%04x l%d\\n\",\n\t\t\tctrl->bRequestType, ctrl->bRequest,\n\t\t\tw_value, w_index, w_length);\n\n\t\t/* functions always handle their interfaces and endpoints...\n\t\t * punt other recipients (other, WUSB, ...) to the current\n\t\t * configuration code.\n\t\t */\n\t\tif (cdev->config) {\n\t\t\tlist_for_each_entry(f, &cdev->config->functions, list)\n\t\t\t\tif (f->req_match &&\n\t\t\t\t    f->req_match(f, ctrl, false))\n\t\t\t\t\tgoto try_fun_setup;\n\t\t} else {\n\t\t\tstruct usb_configuration *c;\n\t\t\tlist_for_each_entry(c, &cdev->configs, list)\n\t\t\t\tlist_for_each_entry(f, &c->functions, list)\n\t\t\t\t\tif (f->req_match &&\n\t\t\t\t\t    f->req_match(f, ctrl, true))\n\t\t\t\t\t\tgoto try_fun_setup;\n\t\t}\n\t\tf = NULL;\n\n\t\tswitch (ctrl->bRequestType & USB_RECIP_MASK) {\n\t\tcase USB_RECIP_INTERFACE:\n\t\t\tif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\n\t\t\t\tbreak;\n\t\t\tf = cdev->config->interface[intf];\n\t\t\tbreak;\n\n\t\tcase USB_RECIP_ENDPOINT:\n\t\t\tif (!cdev->config)\n\t\t\t\tbreak;\n\t\t\tendp = ((w_index & 0x80) >> 3) | (w_index & 0x0f);\n\t\t\tlist_for_each_entry(f, &cdev->config->functions, list) {\n\t\t\t\tif (test_bit(endp, f->endpoints))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (&f->list == &cdev->config->functions)\n\t\t\t\tf = NULL;\n\t\t\tbreak;\n\t\t}\ntry_fun_setup:\n\t\tif (f && f->setup)\n\t\t\tvalue = f->setup(f, ctrl);\n\t\telse {\n\t\t\tstruct usb_configuration\t*c;\n\n\t\t\tc = cdev->config;\n\t\t\tif (!c)\n\t\t\t\tgoto done;\n\n\t\t\t/* try current config's setup */\n\t\t\tif (c->setup) {\n\t\t\t\tvalue = c->setup(c, ctrl);\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\t/* try the only function in the current config */\n\t\t\tif (!list_is_singular(&c->functions))\n\t\t\t\tgoto done;\n\t\t\tf = list_first_entry(&c->functions, struct usb_function,\n\t\t\t\t\t     list);\n\t\t\tif (f->setup)\n\t\t\t\tvalue = f->setup(f, ctrl);\n\t\t}\n\n\t\tgoto done;\n\t}\n\ncheck_value:\n\t/* respond with data transfer before status phase? */\n\tif (value >= 0 && value != USB_GADGET_DELAYED_STATUS) {\n\t\treq->length = value;\n\t\treq->context = cdev;\n\t\treq->zero = value < w_length;\n\t\tvalue = composite_ep0_queue(cdev, req, GFP_ATOMIC);\n\t\tif (value < 0) {\n\t\t\tDBG(cdev, \"ep_queue --> %d\\n\", value);\n\t\t\treq->status = 0;\n\t\t\tcomposite_setup_complete(gadget->ep0, req);\n\t\t}\n\t} else if (value == USB_GADGET_DELAYED_STATUS && w_length != 0) {\n\t\tWARN(cdev,\n\t\t\t\"%s: Delayed status not supported for w_length != 0\",\n\t\t\t__func__);\n\t}\n\ndone:\n\t/* device either stalls (value < 0) or reports success */\n\treturn value;\n}", "func_hash": 150169819708721543824384188358095206836, "file_name": "composite.c", "file_hash": 106311505474453071070186160185104780414, "cwe": ["CWE-476"], "cve": "CVE-2022-25258", "cve_desc": "An issue was discovered in drivers/usb/gadget/composite.c in the Linux kernel before 5.16.10. The USB Gadget subsystem lacks certain validation of interface OS descriptor requests (ones with a large array index and ones associated with NULL function pointer retrieval). Memory corruption might occur.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-25258", "file_path": "drivers/usb/gadget/composite.c"}
{"idx": 214276, "project": "linux", "commit_id": "fa40d9734a57bcbfa79a280189799f76c88f7bb0", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/fa40d9734a57bcbfa79a280189799f76c88f7bb0", "commit_message": "tipc: fix size validations for the MSG_CRYPTO type\n\nThe function tipc_crypto_key_rcv is used to parse MSG_CRYPTO messages\nto receive keys from other nodes in the cluster in order to decrypt any\nfurther messages from them.\nThis patch verifies that any supplied sizes in the message body are\nvalid for the received message.\n\nFixes: 1ef6f7c9390f (\"tipc: add automatic session key exchange\")\nSigned-off-by: Max VA <maxv@sentinelone.com>\nAcked-by: Ying Xue <ying.xue@windriver.com>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\nAcked-by: Jon Maloy <jmaloy@redhat.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "target": 1, "func": "static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)\n{\n\tstruct tipc_crypto *tx = tipc_net(rx->net)->crypto_tx;\n\tstruct tipc_aead_key *skey = NULL;\n\tu16 key_gen = msg_key_gen(hdr);\n\tu16 size = msg_data_sz(hdr);\n\tu8 *data = msg_data(hdr);\n\n\tspin_lock(&rx->lock);\n\tif (unlikely(rx->skey || (key_gen == rx->key_gen && rx->key.keys))) {\n\t\tpr_err(\"%s: key existed <%p>, gen %d vs %d\\n\", rx->name,\n\t\t       rx->skey, key_gen, rx->key_gen);\n\t\tgoto exit;\n\t}\n\n\t/* Allocate memory for the key */\n\tskey = kmalloc(size, GFP_ATOMIC);\n\tif (unlikely(!skey)) {\n\t\tpr_err(\"%s: unable to allocate memory for skey\\n\", rx->name);\n\t\tgoto exit;\n\t}\n\n\t/* Copy key from msg data */\n\tskey->keylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME)));\n\tmemcpy(skey->alg_name, data, TIPC_AEAD_ALG_NAME);\n\tmemcpy(skey->key, data + TIPC_AEAD_ALG_NAME + sizeof(__be32),\n\t       skey->keylen);\n\n\t/* Sanity check */\n\tif (unlikely(size != tipc_aead_key_size(skey))) {\n\t\tkfree(skey);\n\t\tskey = NULL;\n\t\tgoto exit;\n\t}\n\n\trx->key_gen = key_gen;\n\trx->skey_mode = msg_key_mode(hdr);\n\trx->skey = skey;\n\trx->nokey = 0;\n\tmb(); /* for nokey flag */\n\nexit:\n\tspin_unlock(&rx->lock);\n\n\t/* Schedule the key attaching on this crypto */\n\tif (likely(skey && queue_delayed_work(tx->wq, &rx->work, 0)))\n\t\treturn true;\n\n\treturn false;\n}", "func_hash": 150450145750082729683403565650901445106, "file_name": "crypto.c", "file_hash": 58733917967082493268842355411939930161, "cwe": ["CWE-20"], "cve": "CVE-2021-43267", "cve_desc": "An issue was discovered in net/tipc/crypto.c in the Linux kernel before 5.14.16. The Transparent Inter-Process Communication (TIPC) functionality allows remote attackers to exploit insufficient validation of user-supplied sizes for the MSG_CRYPTO message type.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-43267", "file_path": "drivers/mmc/core/crypto.c"}
{"idx": 477273, "project": "linux", "commit_id": "fa40d9734a57bcbfa79a280189799f76c88f7bb0", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/fa40d9734a57bcbfa79a280189799f76c88f7bb0", "commit_message": "tipc: fix size validations for the MSG_CRYPTO type\n\nThe function tipc_crypto_key_rcv is used to parse MSG_CRYPTO messages\nto receive keys from other nodes in the cluster in order to decrypt any\nfurther messages from them.\nThis patch verifies that any supplied sizes in the message body are\nvalid for the received message.\n\nFixes: 1ef6f7c9390f (\"tipc: add automatic session key exchange\")\nSigned-off-by: Max VA <maxv@sentinelone.com>\nAcked-by: Ying Xue <ying.xue@windriver.com>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\nAcked-by: Jon Maloy <jmaloy@redhat.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "target": 0, "func": "static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)\n{\n\tstruct tipc_crypto *tx = tipc_net(rx->net)->crypto_tx;\n\tstruct tipc_aead_key *skey = NULL;\n\tu16 key_gen = msg_key_gen(hdr);\n\tu16 size = msg_data_sz(hdr);\n\tu8 *data = msg_data(hdr);\n\tunsigned int keylen;\n\n\t/* Verify whether the size can exist in the packet */\n\tif (unlikely(size < sizeof(struct tipc_aead_key) + TIPC_AEAD_KEYLEN_MIN)) {\n\t\tpr_debug(\"%s: message data size is too small\\n\", rx->name);\n\t\tgoto exit;\n\t}\n\n\tkeylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME)));\n\n\t/* Verify the supplied size values */\n\tif (unlikely(size != keylen + sizeof(struct tipc_aead_key) ||\n\t\t     keylen > TIPC_AEAD_KEY_SIZE_MAX)) {\n\t\tpr_debug(\"%s: invalid MSG_CRYPTO key size\\n\", rx->name);\n\t\tgoto exit;\n\t}\n\n\tspin_lock(&rx->lock);\n\tif (unlikely(rx->skey || (key_gen == rx->key_gen && rx->key.keys))) {\n\t\tpr_err(\"%s: key existed <%p>, gen %d vs %d\\n\", rx->name,\n\t\t       rx->skey, key_gen, rx->key_gen);\n\t\tgoto exit_unlock;\n\t}\n\n\t/* Allocate memory for the key */\n\tskey = kmalloc(size, GFP_ATOMIC);\n\tif (unlikely(!skey)) {\n\t\tpr_err(\"%s: unable to allocate memory for skey\\n\", rx->name);\n\t\tgoto exit_unlock;\n\t}\n\n\t/* Copy key from msg data */\n\tskey->keylen = keylen;\n\tmemcpy(skey->alg_name, data, TIPC_AEAD_ALG_NAME);\n\tmemcpy(skey->key, data + TIPC_AEAD_ALG_NAME + sizeof(__be32),\n\t       skey->keylen);\n\n\trx->key_gen = key_gen;\n\trx->skey_mode = msg_key_mode(hdr);\n\trx->skey = skey;\n\trx->nokey = 0;\n\tmb(); /* for nokey flag */\n\nexit_unlock:\n\tspin_unlock(&rx->lock);\n\nexit:\n\t/* Schedule the key attaching on this crypto */\n\tif (likely(skey && queue_delayed_work(tx->wq, &rx->work, 0)))\n\t\treturn true;\n\n\treturn false;\n}", "func_hash": 21444025468428283247999063273803236471, "file_name": "crypto.c", "file_hash": 97644738698722030133364122587095840919, "cwe": ["CWE-20"], "cve": "CVE-2021-43267", "cve_desc": "An issue was discovered in net/tipc/crypto.c in the Linux kernel before 5.14.16. The Transparent Inter-Process Communication (TIPC) functionality allows remote attackers to exploit insufficient validation of user-supplied sizes for the MSG_CRYPTO message type.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-43267", "file_path": "drivers/mmc/core/crypto.c"}
{"idx": 214335, "project": "ceph", "commit_id": "be7679007c3dfab3e19c22c38c36ccac91828e3b", "project_url": "https://github.com/ceph/ceph", "commit_url": "https://github.com/ceph/ceph/commit/be7679007c3dfab3e19c22c38c36ccac91828e3b", "commit_message": "rgw: reject control characters in response-header actions\n\nS3 GetObject permits overriding response header values, but those inputs\nneed to be validated to insure only characters that are valid in an HTTP\nheader value are present.\n\nCredit: Initial vulnerability discovery by William Bowling (@wcbowling)\nCredit: Further vulnerability discovery by Robin H. Johnson <rjohnson@digitalocean.com>\nSigned-off-by: Robin H. Johnson <rjohnson@digitalocean.com>", "target": 1, "func": "int RGWGetObj_ObjStore_S3::send_response_data(bufferlist& bl, off_t bl_ofs,\n\t\t\t\t\t      off_t bl_len)\n{\n  const char *content_type = NULL;\n  string content_type_str;\n  map<string, string> response_attrs;\n  map<string, string>::iterator riter;\n  bufferlist metadata_bl;\n\n  string expires = get_s3_expiration_header(s, lastmod);\n\n  if (sent_header)\n    goto send_data;\n\n  if (custom_http_ret) {\n    set_req_state_err(s, 0);\n    dump_errno(s, custom_http_ret);\n  } else {\n    set_req_state_err(s, (partial_content && !op_ret) ? STATUS_PARTIAL_CONTENT\n                  : op_ret);\n    dump_errno(s);\n  }\n\n  if (op_ret)\n    goto done;\n\n  if (range_str)\n    dump_range(s, start, end, s->obj_size);\n\n  if (s->system_request &&\n      s->info.args.exists(RGW_SYS_PARAM_PREFIX \"prepend-metadata\")) {\n\n    dump_header(s, \"Rgwx-Object-Size\", (long long)total_len);\n\n    if (rgwx_stat) {\n      /*\n       * in this case, we're not returning the object's content, only the prepended\n       * extra metadata\n       */\n      total_len = 0;\n    }\n\n    /* JSON encode object metadata */\n    JSONFormatter jf;\n    jf.open_object_section(\"obj_metadata\");\n    encode_json(\"attrs\", attrs, &jf);\n    utime_t ut(lastmod);\n    encode_json(\"mtime\", ut, &jf);\n    jf.close_section();\n    stringstream ss;\n    jf.flush(ss);\n    metadata_bl.append(ss.str());\n    dump_header(s, \"Rgwx-Embedded-Metadata-Len\", metadata_bl.length());\n    total_len += metadata_bl.length();\n  }\n\n  if (s->system_request && !real_clock::is_zero(lastmod)) {\n    /* we end up dumping mtime in two different methods, a bit redundant */\n    dump_epoch_header(s, \"Rgwx-Mtime\", lastmod);\n    uint64_t pg_ver = 0;\n    int r = decode_attr_bl_single_value(attrs, RGW_ATTR_PG_VER, &pg_ver, (uint64_t)0);\n    if (r < 0) {\n      ldpp_dout(this, 0) << \"ERROR: failed to decode pg ver attr, ignoring\" << dendl;\n    }\n    dump_header(s, \"Rgwx-Obj-PG-Ver\", pg_ver);\n\n    uint32_t source_zone_short_id = 0;\n    r = decode_attr_bl_single_value(attrs, RGW_ATTR_SOURCE_ZONE, &source_zone_short_id, (uint32_t)0);\n    if (r < 0) {\n      ldpp_dout(this, 0) << \"ERROR: failed to decode pg ver attr, ignoring\" << dendl;\n    }\n    if (source_zone_short_id != 0) {\n      dump_header(s, \"Rgwx-Source-Zone-Short-Id\", source_zone_short_id);\n    }\n  }\n\n  for (auto &it : crypt_http_responses)\n    dump_header(s, it.first, it.second);\n\n  dump_content_length(s, total_len);\n  dump_last_modified(s, lastmod);\n  dump_header_if_nonempty(s, \"x-amz-version-id\", version_id);\n  dump_header_if_nonempty(s, \"x-amz-expiration\", expires);\n\n  if (attrs.find(RGW_ATTR_APPEND_PART_NUM) != attrs.end()) {\n    dump_header(s, \"x-rgw-object-type\", \"Appendable\");\n    dump_header(s, \"x-rgw-next-append-position\", s->obj_size);\n  } else {\n    dump_header(s, \"x-rgw-object-type\", \"Normal\");\n  }\n\n  if (! op_ret) {\n    if (! lo_etag.empty()) {\n      /* Handle etag of Swift API's large objects (DLO/SLO). It's entirerly\n       * legit to perform GET on them through S3 API. In such situation,\n       * a client should receive the composited content with corresponding\n       * etag value. */\n      dump_etag(s, lo_etag);\n    } else {\n      auto iter = attrs.find(RGW_ATTR_ETAG);\n      if (iter != attrs.end()) {\n        dump_etag(s, iter->second.to_str());\n      }\n    }\n\n    for (struct response_attr_param *p = resp_attr_params; p->param; p++) {\n      bool exists;\n      string val = s->info.args.get(p->param, &exists);\n      if (exists) {\n\t/* reject unauthenticated response header manipulation, see\n\t * https://docs.aws.amazon.com/AmazonS3/latest/API/API_GetObject.html */\n\tif (s->auth.identity->is_anonymous()) {\n\t  return -ERR_INVALID_REQUEST;\n\t}\n\tif (strcmp(p->param, \"response-content-type\") != 0) {\n\t  response_attrs[p->http_attr] = val;\n\t} else {\n\t  content_type_str = val;\n\t  content_type = content_type_str.c_str();\n\t}\n      }\n    }\n\n    for (auto iter = attrs.begin(); iter != attrs.end(); ++iter) {\n      const char *name = iter->first.c_str();\n      map<string, string>::iterator aiter = rgw_to_http_attrs.find(name);\n      if (aiter != rgw_to_http_attrs.end()) {\n        if (response_attrs.count(aiter->second) == 0) {\n          /* Was not already overridden by a response param. */\n\n          size_t len = iter->second.length();\n          string s(iter->second.c_str(), len);\n          while (len && !s[len - 1]) {\n            --len;\n            s.resize(len);\n          }\n          response_attrs[aiter->second] = s;\n        }\n      } else if (iter->first.compare(RGW_ATTR_CONTENT_TYPE) == 0) {\n        /* Special handling for content_type. */\n        if (!content_type) {\n          content_type_str = rgw_bl_str(iter->second);\n          content_type = content_type_str.c_str();\n        }\n      } else if (strcmp(name, RGW_ATTR_SLO_UINDICATOR) == 0) {\n        // this attr has an extra length prefix from encode() in prior versions\n        dump_header(s, \"X-Object-Meta-Static-Large-Object\", \"True\");\n      } else if (strncmp(name, RGW_ATTR_META_PREFIX,\n\t\t\t sizeof(RGW_ATTR_META_PREFIX)-1) == 0) {\n        /* User custom metadata. */\n        name += sizeof(RGW_ATTR_PREFIX) - 1;\n        dump_header(s, name, iter->second);\n      } else if (iter->first.compare(RGW_ATTR_TAGS) == 0) {\n        RGWObjTags obj_tags;\n        try{\n          auto it = iter->second.cbegin();\n          obj_tags.decode(it);\n        } catch (buffer::error &err) {\n          ldpp_dout(this,0) << \"Error caught buffer::error couldn't decode TagSet \" << dendl;\n        }\n        dump_header(s, RGW_AMZ_TAG_COUNT, obj_tags.count());\n      } else if (iter->first.compare(RGW_ATTR_OBJECT_RETENTION) == 0 && get_retention){\n        RGWObjectRetention retention;\n        try {\n          decode(retention, iter->second);\n          dump_header(s, \"x-amz-object-lock-mode\", retention.get_mode());\n          dump_time_header(s, \"x-amz-object-lock-retain-until-date\", retention.get_retain_until_date());\n        } catch (buffer::error& err) {\n          ldpp_dout(this, 0) << \"ERROR: failed to decode RGWObjectRetention\" << dendl;\n        }\n      } else if (iter->first.compare(RGW_ATTR_OBJECT_LEGAL_HOLD) == 0 && get_legal_hold) {\n        RGWObjectLegalHold legal_hold;\n        try {\n          decode(legal_hold, iter->second);\n          dump_header(s, \"x-amz-object-lock-legal-hold\",legal_hold.get_status());\n        } catch (buffer::error& err) {\n          ldpp_dout(this, 0) << \"ERROR: failed to decode RGWObjectLegalHold\" << dendl;\n        }\n      }\n    }\n  }\n\ndone:\n  for (riter = response_attrs.begin(); riter != response_attrs.end();\n       ++riter) {\n    dump_header(s, riter->first, riter->second);\n  }\n\n  if (op_ret == -ERR_NOT_MODIFIED) {\n      end_header(s, this);\n  } else {\n      if (!content_type)\n          content_type = \"binary/octet-stream\";\n\n      end_header(s, this, content_type);\n  }\n\n  if (metadata_bl.length()) {\n    dump_body(s, metadata_bl);\n  }\n  sent_header = true;\n\nsend_data:\n  if (get_data && !op_ret) {\n    int r = dump_body(s, bl.c_str() + bl_ofs, bl_len);\n    if (r < 0)\n      return r;\n  }\n\n  return 0;\n}", "func_hash": 252320959275346519647300715417843120718, "file_name": "rgw_rest_s3.cc", "file_hash": 121704064633287557349192949015382644860, "cwe": ["CWE-79"], "cve": "CVE-2020-1760", "cve_desc": "A flaw was found in the Ceph Object Gateway, where it supports request sent by an anonymous user in Amazon S3. This flaw could lead to potential XSS attacks due to the lack of proper neutralization of untrusted input.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2020-1760", "file_path": "src/rgw/rgw_rest_s3.cc"}
{"idx": 477800, "project": "ceph", "commit_id": "be7679007c3dfab3e19c22c38c36ccac91828e3b", "project_url": "https://github.com/ceph/ceph", "commit_url": "https://github.com/ceph/ceph/commit/be7679007c3dfab3e19c22c38c36ccac91828e3b", "commit_message": "rgw: reject control characters in response-header actions\n\nS3 GetObject permits overriding response header values, but those inputs\nneed to be validated to insure only characters that are valid in an HTTP\nheader value are present.\n\nCredit: Initial vulnerability discovery by William Bowling (@wcbowling)\nCredit: Further vulnerability discovery by Robin H. Johnson <rjohnson@digitalocean.com>\nSigned-off-by: Robin H. Johnson <rjohnson@digitalocean.com>", "target": 0, "func": "int RGWGetObj_ObjStore_S3::send_response_data(bufferlist& bl, off_t bl_ofs,\n\t\t\t\t\t      off_t bl_len)\n{\n  const char *content_type = NULL;\n  string content_type_str;\n  map<string, string> response_attrs;\n  map<string, string>::iterator riter;\n  bufferlist metadata_bl;\n\n  string expires = get_s3_expiration_header(s, lastmod);\n\n  if (sent_header)\n    goto send_data;\n\n  if (custom_http_ret) {\n    set_req_state_err(s, 0);\n    dump_errno(s, custom_http_ret);\n  } else {\n    set_req_state_err(s, (partial_content && !op_ret) ? STATUS_PARTIAL_CONTENT\n                  : op_ret);\n    dump_errno(s);\n  }\n\n  if (op_ret)\n    goto done;\n\n  if (range_str)\n    dump_range(s, start, end, s->obj_size);\n\n  if (s->system_request &&\n      s->info.args.exists(RGW_SYS_PARAM_PREFIX \"prepend-metadata\")) {\n\n    dump_header(s, \"Rgwx-Object-Size\", (long long)total_len);\n\n    if (rgwx_stat) {\n      /*\n       * in this case, we're not returning the object's content, only the prepended\n       * extra metadata\n       */\n      total_len = 0;\n    }\n\n    /* JSON encode object metadata */\n    JSONFormatter jf;\n    jf.open_object_section(\"obj_metadata\");\n    encode_json(\"attrs\", attrs, &jf);\n    utime_t ut(lastmod);\n    encode_json(\"mtime\", ut, &jf);\n    jf.close_section();\n    stringstream ss;\n    jf.flush(ss);\n    metadata_bl.append(ss.str());\n    dump_header(s, \"Rgwx-Embedded-Metadata-Len\", metadata_bl.length());\n    total_len += metadata_bl.length();\n  }\n\n  if (s->system_request && !real_clock::is_zero(lastmod)) {\n    /* we end up dumping mtime in two different methods, a bit redundant */\n    dump_epoch_header(s, \"Rgwx-Mtime\", lastmod);\n    uint64_t pg_ver = 0;\n    int r = decode_attr_bl_single_value(attrs, RGW_ATTR_PG_VER, &pg_ver, (uint64_t)0);\n    if (r < 0) {\n      ldpp_dout(this, 0) << \"ERROR: failed to decode pg ver attr, ignoring\" << dendl;\n    }\n    dump_header(s, \"Rgwx-Obj-PG-Ver\", pg_ver);\n\n    uint32_t source_zone_short_id = 0;\n    r = decode_attr_bl_single_value(attrs, RGW_ATTR_SOURCE_ZONE, &source_zone_short_id, (uint32_t)0);\n    if (r < 0) {\n      ldpp_dout(this, 0) << \"ERROR: failed to decode pg ver attr, ignoring\" << dendl;\n    }\n    if (source_zone_short_id != 0) {\n      dump_header(s, \"Rgwx-Source-Zone-Short-Id\", source_zone_short_id);\n    }\n  }\n\n  for (auto &it : crypt_http_responses)\n    dump_header(s, it.first, it.second);\n\n  dump_content_length(s, total_len);\n  dump_last_modified(s, lastmod);\n  dump_header_if_nonempty(s, \"x-amz-version-id\", version_id);\n  dump_header_if_nonempty(s, \"x-amz-expiration\", expires);\n\n  if (attrs.find(RGW_ATTR_APPEND_PART_NUM) != attrs.end()) {\n    dump_header(s, \"x-rgw-object-type\", \"Appendable\");\n    dump_header(s, \"x-rgw-next-append-position\", s->obj_size);\n  } else {\n    dump_header(s, \"x-rgw-object-type\", \"Normal\");\n  }\n\n  if (! op_ret) {\n    if (! lo_etag.empty()) {\n      /* Handle etag of Swift API's large objects (DLO/SLO). It's entirerly\n       * legit to perform GET on them through S3 API. In such situation,\n       * a client should receive the composited content with corresponding\n       * etag value. */\n      dump_etag(s, lo_etag);\n    } else {\n      auto iter = attrs.find(RGW_ATTR_ETAG);\n      if (iter != attrs.end()) {\n        dump_etag(s, iter->second.to_str());\n      }\n    }\n\n    for (struct response_attr_param *p = resp_attr_params; p->param; p++) {\n      bool exists;\n      string val = s->info.args.get(p->param, &exists);\n      if (exists) {\n\t/* reject unauthenticated response header manipulation, see\n\t * https://docs.aws.amazon.com/AmazonS3/latest/API/API_GetObject.html */\n\tif (s->auth.identity->is_anonymous()) {\n\t  return -ERR_INVALID_REQUEST;\n\t}\n        /* HTTP specification says no control characters should be present in\n         * header values: https://tools.ietf.org/html/rfc7230#section-3.2\n         *      field-vchar    = VCHAR / obs-text\n         *\n         * Failure to validate this permits a CRLF injection in HTTP headers,\n         * whereas S3 GetObject only permits specific headers.\n         */\n        if(str_has_cntrl(val)) {\n          /* TODO: return a more distinct error in future;\n           * stating what the problem is */\n          return -ERR_INVALID_REQUEST;\n        }\n\n\tif (strcmp(p->param, \"response-content-type\") != 0) {\n\t  response_attrs[p->http_attr] = val;\n\t} else {\n\t  content_type_str = val;\n\t  content_type = content_type_str.c_str();\n\t}\n      }\n    }\n\n    for (auto iter = attrs.begin(); iter != attrs.end(); ++iter) {\n      const char *name = iter->first.c_str();\n      map<string, string>::iterator aiter = rgw_to_http_attrs.find(name);\n      if (aiter != rgw_to_http_attrs.end()) {\n        if (response_attrs.count(aiter->second) == 0) {\n          /* Was not already overridden by a response param. */\n\n          size_t len = iter->second.length();\n          string s(iter->second.c_str(), len);\n          while (len && !s[len - 1]) {\n            --len;\n            s.resize(len);\n          }\n          response_attrs[aiter->second] = s;\n        }\n      } else if (iter->first.compare(RGW_ATTR_CONTENT_TYPE) == 0) {\n        /* Special handling for content_type. */\n        if (!content_type) {\n          content_type_str = rgw_bl_str(iter->second);\n          content_type = content_type_str.c_str();\n        }\n      } else if (strcmp(name, RGW_ATTR_SLO_UINDICATOR) == 0) {\n        // this attr has an extra length prefix from encode() in prior versions\n        dump_header(s, \"X-Object-Meta-Static-Large-Object\", \"True\");\n      } else if (strncmp(name, RGW_ATTR_META_PREFIX,\n\t\t\t sizeof(RGW_ATTR_META_PREFIX)-1) == 0) {\n        /* User custom metadata. */\n        name += sizeof(RGW_ATTR_PREFIX) - 1;\n        dump_header(s, name, iter->second);\n      } else if (iter->first.compare(RGW_ATTR_TAGS) == 0) {\n        RGWObjTags obj_tags;\n        try{\n          auto it = iter->second.cbegin();\n          obj_tags.decode(it);\n        } catch (buffer::error &err) {\n          ldpp_dout(this,0) << \"Error caught buffer::error couldn't decode TagSet \" << dendl;\n        }\n        dump_header(s, RGW_AMZ_TAG_COUNT, obj_tags.count());\n      } else if (iter->first.compare(RGW_ATTR_OBJECT_RETENTION) == 0 && get_retention){\n        RGWObjectRetention retention;\n        try {\n          decode(retention, iter->second);\n          dump_header(s, \"x-amz-object-lock-mode\", retention.get_mode());\n          dump_time_header(s, \"x-amz-object-lock-retain-until-date\", retention.get_retain_until_date());\n        } catch (buffer::error& err) {\n          ldpp_dout(this, 0) << \"ERROR: failed to decode RGWObjectRetention\" << dendl;\n        }\n      } else if (iter->first.compare(RGW_ATTR_OBJECT_LEGAL_HOLD) == 0 && get_legal_hold) {\n        RGWObjectLegalHold legal_hold;\n        try {\n          decode(legal_hold, iter->second);\n          dump_header(s, \"x-amz-object-lock-legal-hold\",legal_hold.get_status());\n        } catch (buffer::error& err) {\n          ldpp_dout(this, 0) << \"ERROR: failed to decode RGWObjectLegalHold\" << dendl;\n        }\n      }\n    }\n  }\n\ndone:\n  for (riter = response_attrs.begin(); riter != response_attrs.end();\n       ++riter) {\n    dump_header(s, riter->first, riter->second);\n  }\n\n  if (op_ret == -ERR_NOT_MODIFIED) {\n      end_header(s, this);\n  } else {\n      if (!content_type)\n          content_type = \"binary/octet-stream\";\n\n      end_header(s, this, content_type);\n  }\n\n  if (metadata_bl.length()) {\n    dump_body(s, metadata_bl);\n  }\n  sent_header = true;\n\nsend_data:\n  if (get_data && !op_ret) {\n    int r = dump_body(s, bl.c_str() + bl_ofs, bl_len);\n    if (r < 0)\n      return r;\n  }\n\n  return 0;\n}", "func_hash": 262581748288231212684344001949485433363, "file_name": "rgw_rest_s3.cc", "file_hash": 18601801279536370570230302891439737230, "cwe": ["CWE-79"], "cve": "CVE-2020-1760", "cve_desc": "A flaw was found in the Ceph Object Gateway, where it supports request sent by an anonymous user in Amazon S3. This flaw could lead to potential XSS attacks due to the lack of proper neutralization of untrusted input.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2020-1760", "file_path": "src/rgw/rgw_rest_s3.cc"}
{"idx": 214336, "project": "linux", "commit_id": "ba953a9d89a00c078b85f4b190bc1dde66fe16b5", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/ba953a9d89a00c078b85f4b190bc1dde66fe16b5", "commit_message": "af_key: Do not call xfrm_probe_algs in parallel\n\nWhen namespace support was added to xfrm/afkey, it caused the\npreviously single-threaded call to xfrm_probe_algs to become\nmulti-threaded.  This is buggy and needs to be fixed with a mutex.\n\nReported-by: Abhishek Shah <abhishek.shah@columbia.edu>\nFixes: 283bc9f35bbb (\"xfrm: Namespacify xfrm state/policy locks\")\nSigned-off-by: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: Steffen Klassert <steffen.klassert@secunet.com>", "target": 1, "func": "static int pfkey_register(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\tstruct sk_buff *supp_skb;\n\n\tif (hdr->sadb_msg_satype > SADB_SATYPE_MAX)\n\t\treturn -EINVAL;\n\n\tif (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC) {\n\t\tif (pfk->registered&(1<<hdr->sadb_msg_satype))\n\t\t\treturn -EEXIST;\n\t\tpfk->registered |= (1<<hdr->sadb_msg_satype);\n\t}\n\n\txfrm_probe_algs();\n\n\tsupp_skb = compose_sadb_supported(hdr, GFP_KERNEL | __GFP_ZERO);\n\tif (!supp_skb) {\n\t\tif (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC)\n\t\t\tpfk->registered &= ~(1<<hdr->sadb_msg_satype);\n\n\t\treturn -ENOBUFS;\n\t}\n\n\tpfkey_broadcast(supp_skb, GFP_KERNEL, BROADCAST_REGISTERED, sk,\n\t\t\tsock_net(sk));\n\treturn 0;\n}", "func_hash": 31330987608984194197058225349266288841, "file_name": "af_key.c", "file_hash": 41141499114881598479952301810943667867, "cwe": ["CWE-362"], "cve": "CVE-2022-3028", "cve_desc": "A race condition was found in the Linux kernel's IP framework for transforming packets (XFRM subsystem) when multiple calls to xfrm_probe_algs occurred simultaneously. This flaw could allow a local attacker to potentially trigger an out-of-bounds write or leak kernel heap memory by performing an out-of-bounds read and copying it into a socket.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-3028", "file_path": "net/key/af_key.c"}
{"idx": 477803, "project": "linux", "commit_id": "ba953a9d89a00c078b85f4b190bc1dde66fe16b5", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/ba953a9d89a00c078b85f4b190bc1dde66fe16b5", "commit_message": "af_key: Do not call xfrm_probe_algs in parallel\n\nWhen namespace support was added to xfrm/afkey, it caused the\npreviously single-threaded call to xfrm_probe_algs to become\nmulti-threaded.  This is buggy and needs to be fixed with a mutex.\n\nReported-by: Abhishek Shah <abhishek.shah@columbia.edu>\nFixes: 283bc9f35bbb (\"xfrm: Namespacify xfrm state/policy locks\")\nSigned-off-by: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: Steffen Klassert <steffen.klassert@secunet.com>", "target": 0, "func": "static int pfkey_register(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\tstruct sk_buff *supp_skb;\n\n\tif (hdr->sadb_msg_satype > SADB_SATYPE_MAX)\n\t\treturn -EINVAL;\n\n\tif (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC) {\n\t\tif (pfk->registered&(1<<hdr->sadb_msg_satype))\n\t\t\treturn -EEXIST;\n\t\tpfk->registered |= (1<<hdr->sadb_msg_satype);\n\t}\n\n\tmutex_lock(&pfkey_mutex);\n\txfrm_probe_algs();\n\n\tsupp_skb = compose_sadb_supported(hdr, GFP_KERNEL | __GFP_ZERO);\n\tmutex_unlock(&pfkey_mutex);\n\n\tif (!supp_skb) {\n\t\tif (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC)\n\t\t\tpfk->registered &= ~(1<<hdr->sadb_msg_satype);\n\n\t\treturn -ENOBUFS;\n\t}\n\n\tpfkey_broadcast(supp_skb, GFP_KERNEL, BROADCAST_REGISTERED, sk,\n\t\t\tsock_net(sk));\n\treturn 0;\n}", "func_hash": 267484480773860224509939208990668486476, "file_name": "af_key.c", "file_hash": 320308785060277331715018929148947306218, "cwe": ["CWE-362"], "cve": "CVE-2022-3028", "cve_desc": "A race condition was found in the Linux kernel's IP framework for transforming packets (XFRM subsystem) when multiple calls to xfrm_probe_algs occurred simultaneously. This flaw could allow a local attacker to potentially trigger an out-of-bounds write or leak kernel heap memory by performing an out-of-bounds read and copying it into a socket.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-3028", "file_path": "net/key/af_key.c"}
{"idx": 214339, "project": "linux", "commit_id": "f62f3c20647ebd5fb6ecb8f0b477b9281c44c10a", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=f62f3c20647ebd5fb6ecb8f0b477b9281c44c10a", "commit_message": "KVM: PPC: Book3S: Fix H_RTAS rets buffer overflow\n\nThe kvmppc_rtas_hcall() sets the host rtas_args.rets pointer based on\nthe rtas_args.nargs that was provided by the guest. That guest nargs\nvalue is not range checked, so the guest can cause the host rets pointer\nto be pointed outside the args array. The individual rtas function\nhandlers check the nargs and nrets values to ensure they are correct,\nbut if they are not, the handlers store a -3 (0xfffffffd) failure\nindication in rets[0] which corrupts host memory.\n\nFix this by testing up front whether the guest supplied nargs and nret\nwould exceed the array size, and fail the hcall directly without storing\na failure indication to rets[0].\n\nAlso expand on a comment about why we kill the guest and try not to\nreturn errors directly if we have a valid rets[0] pointer.\n\nFixes: 8e591cb72047 (\"KVM: PPC: Book3S: Add infrastructure to implement kernel-side RTAS calls\")\nCc: stable@vger.kernel.org # v3.10+\nReported-by: Alexey Kardashevskiy <aik@ozlabs.ru>\nSigned-off-by: Nicholas Piggin <npiggin@gmail.com>\nSigned-off-by: Michael Ellerman <mpe@ellerman.id.au>", "target": 1, "func": "int kvmppc_rtas_hcall(struct kvm_vcpu *vcpu)\n{\n\tstruct rtas_token_definition *d;\n\tstruct rtas_args args;\n\trtas_arg_t *orig_rets;\n\tgpa_t args_phys;\n\tint rc;\n\n\t/*\n\t * r4 contains the guest physical address of the RTAS args\n\t * Mask off the top 4 bits since this is a guest real address\n\t */\n\targs_phys = kvmppc_get_gpr(vcpu, 4) & KVM_PAM;\n\n\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n\trc = kvm_read_guest(vcpu->kvm, args_phys, &args, sizeof(args));\n\tsrcu_read_unlock(&vcpu->kvm->srcu, vcpu->srcu_idx);\n\tif (rc)\n\t\tgoto fail;\n\n\t/*\n\t * args->rets is a pointer into args->args. Now that we've\n\t * copied args we need to fix it up to point into our copy,\n\t * not the guest args. We also need to save the original\n\t * value so we can restore it on the way out.\n\t */\n\torig_rets = args.rets;\n\targs.rets = &args.args[be32_to_cpu(args.nargs)];\n\n\tmutex_lock(&vcpu->kvm->arch.rtas_token_lock);\n\n\trc = -ENOENT;\n\tlist_for_each_entry(d, &vcpu->kvm->arch.rtas_tokens, list) {\n\t\tif (d->token == be32_to_cpu(args.token)) {\n\t\t\td->handler->handler(vcpu, &args);\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&vcpu->kvm->arch.rtas_token_lock);\n\n\tif (rc == 0) {\n\t\targs.rets = orig_rets;\n\t\trc = kvm_write_guest(vcpu->kvm, args_phys, &args, sizeof(args));\n\t\tif (rc)\n\t\t\tgoto fail;\n\t}\n\n\treturn rc;\n\nfail:\n\t/*\n\t * We only get here if the guest has called RTAS with a bogus\n\t * args pointer. That means we can't get to the args, and so we\n\t * can't fail the RTAS call. So fail right out to userspace,\n\t * which should kill the guest.\n\t */\n\treturn rc;\n}", "func_hash": 66579788869283176691450230454774242085, "file_name": "book3s_rtas.c", "file_hash": 244969410022637408362665450874858593503, "cwe": ["CWE-787"], "cve": "CVE-2021-37576", "cve_desc": "arch/powerpc/kvm/book3s_rtas.c in the Linux kernel through 5.13.5 on the powerpc platform allows KVM guest OS users to cause host OS memory corruption via rtas_args.nargs, aka CID-f62f3c20647e.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-37576", "file_path": "arch/powerpc/kvm/book3s_rtas.c"}
{"idx": 477811, "project": "linux", "commit_id": "f62f3c20647ebd5fb6ecb8f0b477b9281c44c10a", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=f62f3c20647ebd5fb6ecb8f0b477b9281c44c10a", "commit_message": "KVM: PPC: Book3S: Fix H_RTAS rets buffer overflow\n\nThe kvmppc_rtas_hcall() sets the host rtas_args.rets pointer based on\nthe rtas_args.nargs that was provided by the guest. That guest nargs\nvalue is not range checked, so the guest can cause the host rets pointer\nto be pointed outside the args array. The individual rtas function\nhandlers check the nargs and nrets values to ensure they are correct,\nbut if they are not, the handlers store a -3 (0xfffffffd) failure\nindication in rets[0] which corrupts host memory.\n\nFix this by testing up front whether the guest supplied nargs and nret\nwould exceed the array size, and fail the hcall directly without storing\na failure indication to rets[0].\n\nAlso expand on a comment about why we kill the guest and try not to\nreturn errors directly if we have a valid rets[0] pointer.\n\nFixes: 8e591cb72047 (\"KVM: PPC: Book3S: Add infrastructure to implement kernel-side RTAS calls\")\nCc: stable@vger.kernel.org # v3.10+\nReported-by: Alexey Kardashevskiy <aik@ozlabs.ru>\nSigned-off-by: Nicholas Piggin <npiggin@gmail.com>\nSigned-off-by: Michael Ellerman <mpe@ellerman.id.au>", "target": 0, "func": "int kvmppc_rtas_hcall(struct kvm_vcpu *vcpu)\n{\n\tstruct rtas_token_definition *d;\n\tstruct rtas_args args;\n\trtas_arg_t *orig_rets;\n\tgpa_t args_phys;\n\tint rc;\n\n\t/*\n\t * r4 contains the guest physical address of the RTAS args\n\t * Mask off the top 4 bits since this is a guest real address\n\t */\n\targs_phys = kvmppc_get_gpr(vcpu, 4) & KVM_PAM;\n\n\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n\trc = kvm_read_guest(vcpu->kvm, args_phys, &args, sizeof(args));\n\tsrcu_read_unlock(&vcpu->kvm->srcu, vcpu->srcu_idx);\n\tif (rc)\n\t\tgoto fail;\n\n\t/*\n\t * args->rets is a pointer into args->args. Now that we've\n\t * copied args we need to fix it up to point into our copy,\n\t * not the guest args. We also need to save the original\n\t * value so we can restore it on the way out.\n\t */\n\torig_rets = args.rets;\n\tif (be32_to_cpu(args.nargs) >= ARRAY_SIZE(args.args)) {\n\t\t/*\n\t\t * Don't overflow our args array: ensure there is room for\n\t\t * at least rets[0] (even if the call specifies 0 nret).\n\t\t *\n\t\t * Each handler must then check for the correct nargs and nret\n\t\t * values, but they may always return failure in rets[0].\n\t\t */\n\t\trc = -EINVAL;\n\t\tgoto fail;\n\t}\n\targs.rets = &args.args[be32_to_cpu(args.nargs)];\n\n\tmutex_lock(&vcpu->kvm->arch.rtas_token_lock);\n\n\trc = -ENOENT;\n\tlist_for_each_entry(d, &vcpu->kvm->arch.rtas_tokens, list) {\n\t\tif (d->token == be32_to_cpu(args.token)) {\n\t\t\td->handler->handler(vcpu, &args);\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&vcpu->kvm->arch.rtas_token_lock);\n\n\tif (rc == 0) {\n\t\targs.rets = orig_rets;\n\t\trc = kvm_write_guest(vcpu->kvm, args_phys, &args, sizeof(args));\n\t\tif (rc)\n\t\t\tgoto fail;\n\t}\n\n\treturn rc;\n\nfail:\n\t/*\n\t * We only get here if the guest has called RTAS with a bogus\n\t * args pointer or nargs/nret values that would overflow the\n\t * array. That means we can't get to the args, and so we can't\n\t * fail the RTAS call. So fail right out to userspace, which\n\t * should kill the guest.\n\t *\n\t * SLOF should actually pass the hcall return value from the\n\t * rtas handler call in r3, so enter_rtas could be modified to\n\t * return a failure indication in r3 and we could return such\n\t * errors to the guest rather than failing to host userspace.\n\t * However old guests that don't test for failure could then\n\t * continue silently after errors, so for now we won't do this.\n\t */\n\treturn rc;\n}", "func_hash": 270253933279643819807414798855847113264, "file_name": "book3s_rtas.c", "file_hash": 244634684304024017969354424959522055540, "cwe": ["CWE-787"], "cve": "CVE-2021-37576", "cve_desc": "arch/powerpc/kvm/book3s_rtas.c in the Linux kernel through 5.13.5 on the powerpc platform allows KVM guest OS users to cause host OS memory corruption via rtas_args.nargs, aka CID-f62f3c20647e.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-37576", "file_path": "arch/powerpc/kvm/book3s_rtas.c"}
{"idx": 214358, "project": "clamav-devel", "commit_id": "224fee54dd6cd8933d7007331ec2bfca0398d4b4", "project_url": "https://github.com/vrtadmin/clamav-devel", "commit_url": "http://git.clamav.net/gitweb?p=clamav-devel.git;a=commit;h=224fee54dd6cd8933d7007331ec2bfca0398d4b4", "commit_message": "libclamav/mspack.c: fix Quantum decompressor (bb#1771)", "target": 1, "func": "int qtm_decompress(struct qtm_stream *qtm, off_t out_bytes) {\n  unsigned int frame_start, frame_end, window_posn, match_offset, range;\n  unsigned char *window, *i_ptr, *i_end, *runsrc, *rundest;\n  int i, j, selector, extra, sym, match_length, ret;\n  unsigned short H, L, C, symf;\n\n  register unsigned int bit_buffer;\n  register unsigned char bits_left;\n  unsigned char bits_needed, bit_run;\n\n  /* easy answers */\n  if (!qtm || (out_bytes < 0)) return CL_ENULLARG;\n  if (qtm->error) return qtm->error;\n\n  /* flush out any stored-up bytes before we begin */\n  i = qtm->o_end - qtm->o_ptr;\n  if ((off_t) i > out_bytes) i = (int) out_bytes;\n  if (i) {\n    if (qtm->wflag && (ret = mspack_write(qtm->ofd, qtm->o_ptr, i, qtm->file)) != CL_SUCCESS) {\n      return qtm->error = ret;\n    }\n    qtm->o_ptr  += i;\n    out_bytes   -= i;\n  }\n  if (out_bytes == 0) return CL_SUCCESS;\n\n  /* restore local state */\n  QTM_RESTORE_BITS;\n  window = qtm->window;\n  window_posn = qtm->window_posn;\n  frame_start = qtm->frame_start;\n  H = qtm->H;\n  L = qtm->L;\n  C = qtm->C;\n\n  /* while we do not have enough decoded bytes in reserve: */\n  while ((qtm->o_end - qtm->o_ptr) < out_bytes) {\n\n    /* read header if necessary. Initialises H, L and C */\n    if (!qtm->header_read) {\n      H = 0xFFFF; L = 0; QTM_READ_BITS(C, 16);\n      qtm->header_read = 1;\n    }\n\n    /* decode more, at most up to to frame boundary */\n    frame_end = window_posn + (out_bytes - (qtm->o_end - qtm->o_ptr));\n    if ((frame_start + QTM_FRAME_SIZE) < frame_end) {\n      frame_end = frame_start + QTM_FRAME_SIZE;\n    }\n\n    while (window_posn < frame_end) {\n      QTM_GET_SYMBOL(qtm->model7, selector);\n      if (selector < 4) {\n\tstruct qtm_model *mdl = (selector == 0) ? &qtm->model0 :\n\t                        ((selector == 1) ? &qtm->model1 :\n\t\t\t\t((selector == 2) ? &qtm->model2 :\n                                                   &qtm->model3));\n\tQTM_GET_SYMBOL((*mdl), sym);\n\twindow[window_posn++] = sym;\n      }\n      else {\n\tswitch (selector) {\n\tcase 4: /* selector 4 = fixed length match (3 bytes) */\n\t  QTM_GET_SYMBOL(qtm->model4, sym);\n\t  QTM_READ_BITS(extra, qtm->extra_bits[sym]);\n\t  match_offset = qtm->position_base[sym] + extra + 1;\n\t  match_length = 3;\n\t  break;\n\n\tcase 5: /* selector 5 = fixed length match (4 bytes) */\n\t  QTM_GET_SYMBOL(qtm->model5, sym);\n\t  QTM_READ_BITS(extra, qtm->extra_bits[sym]);\n\t  match_offset = qtm->position_base[sym] + extra + 1;\n\t  match_length = 4;\n\t  break;\n\n\tcase 6: /* selector 6 = variable length match */\n\t  QTM_GET_SYMBOL(qtm->model6len, sym);\n\t  QTM_READ_BITS(extra, qtm->length_extra[sym]);\n\t  match_length = qtm->length_base[sym] + extra + 5;\n\n\t  QTM_GET_SYMBOL(qtm->model6, sym);\n\t  QTM_READ_BITS(extra, qtm->extra_bits[sym]);\n\t  match_offset = qtm->position_base[sym] + extra + 1;\n\t  break;\n\n\tdefault:\n\t  /* should be impossible, model7 can only return 0-6 */\n\t  return qtm->error = CL_EFORMAT;\n\t}\n\n\trundest = &window[window_posn];\n\ti = match_length;\n\t/* does match offset wrap the window? */\n\tif (match_offset > window_posn) {\n\t  /* j = length from match offset to end of window */\n\t  j = match_offset - window_posn;\n\t  if (j > (int) qtm->window_size) {\n\t    cli_dbgmsg(\"qtm_decompress: match offset beyond window boundaries\\n\");\n\t    return qtm->error = CL_EFORMAT;\n\t  }\n\t  runsrc = &window[qtm->window_size - j];\n\t  if (j < i) {\n\t    /* if match goes over the window edge, do two copy runs */\n\t    i -= j; while (j-- > 0) *rundest++ = *runsrc++;\n\t    runsrc = window;\n\t  }\n\t  while (i-- > 0) *rundest++ = *runsrc++;\n\t}\n\telse {\n\t  runsrc = rundest - match_offset;\n\t  if(i > (int) (qtm->window_size - window_posn))\n\t    i = qtm->window_size - window_posn;\n\t  while (i-- > 0) *rundest++ = *runsrc++;\n\t}\n\twindow_posn += match_length;\n      }\n    } /* while (window_posn < frame_end) */\n\n    qtm->o_end = &window[window_posn];\n\n    /* another frame completed? */\n    if ((window_posn - frame_start) >= QTM_FRAME_SIZE) {\n      if ((window_posn - frame_start) != QTM_FRAME_SIZE) {\n\tcli_dbgmsg(\"qtm_decompress: overshot frame alignment\\n\");\n\treturn qtm->error = CL_EFORMAT;\n      }\n\n      /* re-align input */\n      if (bits_left & 7) QTM_REMOVE_BITS(bits_left & 7);\n      do { QTM_READ_BITS(i, 8); } while (i != 0xFF);\n      qtm->header_read = 0;\n\n      /* window wrap? */\n      if (window_posn == qtm->window_size) {\n\t/* flush all currently stored data */\n\ti = (qtm->o_end - qtm->o_ptr);\n\tif (qtm->wflag && (ret = mspack_write(qtm->ofd, qtm->o_ptr, i, qtm->file)) != CL_SUCCESS) {\n\t  return qtm->error = ret;\n\t}\n\tout_bytes -= i;\n\tqtm->o_ptr = &window[0];\n\tqtm->o_end = &window[0];\n\twindow_posn = 0;\n      }\n\n      frame_start = window_posn;\n    }\n\n  } /* while (more bytes needed) */\n\n  if (out_bytes) {\n    i = (int) out_bytes;\n    if (qtm->wflag && (ret = mspack_write(qtm->ofd, qtm->o_ptr, i, qtm->file)) != CL_SUCCESS) {\n      return qtm->error = ret;\n    }\n    qtm->o_ptr += i;\n  }\n\n  /* store local state */\n  QTM_STORE_BITS;\n  qtm->window_posn = window_posn;\n  qtm->frame_start = frame_start;\n  qtm->H = H;\n  qtm->L = L;\n  qtm->C = C;\n\n  return CL_SUCCESS;\n}", "func_hash": 291050376752284006088755347145639053650, "file_name": "mspack.c", "file_hash": 137114659534783781079186144852150621076, "cwe": ["CWE-20"], "cve": "CVE-2010-1311", "cve_desc": "The qtm_decompress function in libclamav/mspack.c in ClamAV before 0.96 allows remote attackers to cause a denial of service (memory corruption and application crash) via a crafted CAB archive that uses the Quantum (aka .Q) compression format.  NOTE: some of these details are obtained from third party information.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2010-1311", "file_path": "libclamav/mspack.c"}
{"idx": 477946, "project": "clamav-devel", "commit_id": "224fee54dd6cd8933d7007331ec2bfca0398d4b4", "project_url": "https://github.com/vrtadmin/clamav-devel", "commit_url": "http://git.clamav.net/gitweb?p=clamav-devel.git;a=commit;h=224fee54dd6cd8933d7007331ec2bfca0398d4b4", "commit_message": "libclamav/mspack.c: fix Quantum decompressor (bb#1771)", "target": 0, "func": "int qtm_decompress(struct qtm_stream *qtm, off_t out_bytes) {\n  unsigned int frame_start, frame_end, window_posn, match_offset, range;\n  unsigned char *window, *i_ptr, *i_end, *runsrc, *rundest;\n  int i, j, selector, extra, sym, match_length, ret;\n  unsigned short H, L, C, symf;\n\n  register unsigned int bit_buffer;\n  register unsigned char bits_left;\n  unsigned char bits_needed, bit_run;\n\n  /* easy answers */\n  if (!qtm || (out_bytes < 0)) return CL_ENULLARG;\n  if (qtm->error) return qtm->error;\n\n  /* flush out any stored-up bytes before we begin */\n  i = qtm->o_end - qtm->o_ptr;\n  if ((off_t) i > out_bytes) i = (int) out_bytes;\n  if (i) {\n    if (qtm->wflag && (ret = mspack_write(qtm->ofd, qtm->o_ptr, i, qtm->file)) != CL_SUCCESS) {\n      return qtm->error = ret;\n    }\n    qtm->o_ptr  += i;\n    out_bytes   -= i;\n  }\n  if (out_bytes == 0) return CL_SUCCESS;\n\n  /* restore local state */\n  QTM_RESTORE_BITS;\n  window = qtm->window;\n  window_posn = qtm->window_posn;\n  frame_start = qtm->frame_start;\n  H = qtm->H;\n  L = qtm->L;\n  C = qtm->C;\n\n  /* while we do not have enough decoded bytes in reserve: */\n  while ((qtm->o_end - qtm->o_ptr) < out_bytes) {\n\n    /* read header if necessary. Initialises H, L and C */\n    if (!qtm->header_read) {\n      H = 0xFFFF; L = 0; QTM_READ_BITS(C, 16);\n      qtm->header_read = 1;\n    }\n\n    /* decode more, at most up to to frame boundary */\n    frame_end = window_posn + (out_bytes - (qtm->o_end - qtm->o_ptr));\n    if ((frame_start + QTM_FRAME_SIZE) < frame_end) {\n      frame_end = frame_start + QTM_FRAME_SIZE;\n    }\n\n    while (window_posn < frame_end) {\n      QTM_GET_SYMBOL(qtm->model7, selector);\n      if (selector < 4) {\n\tstruct qtm_model *mdl = (selector == 0) ? &qtm->model0 :\n\t                        ((selector == 1) ? &qtm->model1 :\n\t\t\t\t((selector == 2) ? &qtm->model2 :\n                                                   &qtm->model3));\n\tQTM_GET_SYMBOL((*mdl), sym);\n\twindow[window_posn++] = sym;\n      }\n      else {\n\tswitch (selector) {\n\tcase 4: /* selector 4 = fixed length match (3 bytes) */\n\t  QTM_GET_SYMBOL(qtm->model4, sym);\n\t  QTM_READ_BITS(extra, qtm->extra_bits[sym]);\n\t  match_offset = qtm->position_base[sym] + extra + 1;\n\t  match_length = 3;\n\t  break;\n\n\tcase 5: /* selector 5 = fixed length match (4 bytes) */\n\t  QTM_GET_SYMBOL(qtm->model5, sym);\n\t  QTM_READ_BITS(extra, qtm->extra_bits[sym]);\n\t  match_offset = qtm->position_base[sym] + extra + 1;\n\t  match_length = 4;\n\t  break;\n\n\tcase 6: /* selector 6 = variable length match */\n\t  QTM_GET_SYMBOL(qtm->model6len, sym);\n\t  QTM_READ_BITS(extra, qtm->length_extra[sym]);\n\t  match_length = qtm->length_base[sym] + extra + 5;\n\n\t  QTM_GET_SYMBOL(qtm->model6, sym);\n\t  QTM_READ_BITS(extra, qtm->extra_bits[sym]);\n\t  match_offset = qtm->position_base[sym] + extra + 1;\n\t  break;\n\n\tdefault:\n\t  /* should be impossible, model7 can only return 0-6 */\n\t  return qtm->error = CL_EFORMAT;\n\t}\n\n\tif (window_posn + match_length > qtm->window_size) {\n\t  cli_dbgmsg(\"qtm_decompress: match ran over window wrap\\n\");\n\t  return qtm->error = CL_EFORMAT;\n\t}\n\n\trundest = &window[window_posn];\n\ti = match_length;\n\t/* does match offset wrap the window? */\n\tif (match_offset > window_posn) {\n\t  /* j = length from match offset to end of window */\n\t  j = match_offset - window_posn;\n\t  if (j > (int) qtm->window_size) {\n\t    cli_dbgmsg(\"qtm_decompress: match offset beyond window boundaries\\n\");\n\t    return qtm->error = CL_EFORMAT;\n\t  }\n\t  runsrc = &window[qtm->window_size - j];\n\t  if (j < i) {\n\t    /* if match goes over the window edge, do two copy runs */\n\t    i -= j; while (j-- > 0) *rundest++ = *runsrc++;\n\t    runsrc = window;\n\t  }\n\t  while (i-- > 0) *rundest++ = *runsrc++;\n\t}\n\telse {\n\t  runsrc = rundest - match_offset;\n\t  if(i > (int) (qtm->window_size - window_posn))\n\t    i = qtm->window_size - window_posn;\n\t  while (i-- > 0) *rundest++ = *runsrc++;\n\t}\n\twindow_posn += match_length;\n      }\n    } /* while (window_posn < frame_end) */\n\n    qtm->o_end = &window[window_posn];\n\n    /* another frame completed? */\n    if ((window_posn - frame_start) >= QTM_FRAME_SIZE) {\n      if ((window_posn - frame_start) != QTM_FRAME_SIZE) {\n\tcli_dbgmsg(\"qtm_decompress: overshot frame alignment\\n\");\n\treturn qtm->error = CL_EFORMAT;\n      }\n\n      /* re-align input */\n      if (bits_left & 7) QTM_REMOVE_BITS(bits_left & 7);\n      do { QTM_READ_BITS(i, 8); } while (i != 0xFF);\n      qtm->header_read = 0;\n\n      /* window wrap? */\n      if (window_posn == qtm->window_size) {\n\t/* flush all currently stored data */\n\ti = (qtm->o_end - qtm->o_ptr);\n\tif (qtm->wflag && (ret = mspack_write(qtm->ofd, qtm->o_ptr, i, qtm->file)) != CL_SUCCESS) {\n\t  return qtm->error = ret;\n\t}\n\tout_bytes -= i;\n\tqtm->o_ptr = &window[0];\n\tqtm->o_end = &window[0];\n\twindow_posn = 0;\n      }\n\n      frame_start = window_posn;\n    }\n\n  } /* while (more bytes needed) */\n\n  if (out_bytes) {\n    i = (int) out_bytes;\n    if (qtm->wflag && (ret = mspack_write(qtm->ofd, qtm->o_ptr, i, qtm->file)) != CL_SUCCESS) {\n      return qtm->error = ret;\n    }\n    qtm->o_ptr += i;\n  }\n\n  /* store local state */\n  QTM_STORE_BITS;\n  qtm->window_posn = window_posn;\n  qtm->frame_start = frame_start;\n  qtm->H = H;\n  qtm->L = L;\n  qtm->C = C;\n\n  return CL_SUCCESS;\n}", "func_hash": 309561544522405112370599990059884786931, "file_name": "mspack.c", "file_hash": 294647704290965311324683497678599566631, "cwe": ["CWE-20"], "cve": "CVE-2010-1311", "cve_desc": "The qtm_decompress function in libclamav/mspack.c in ClamAV before 0.96 allows remote attackers to cause a denial of service (memory corruption and application crash) via a crafted CAB archive that uses the Quantum (aka .Q) compression format.  NOTE: some of these details are obtained from third party information.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2010-1311", "file_path": "libclamav/mspack.c"}
{"idx": 214364, "project": "php-src", "commit_id": "e6c48213c22ed50b2b987b479fcc1ac709394caa", "project_url": "https://github.com/php/php-src", "commit_url": "http://git.php.net/?p=php-src.git;a=commit;h=e6c48213c22ed50b2b987b479fcc1ac709394caa", "commit_message": "Fix bug #72606: heap-buffer-overflow (write) simplestring_addn simplestring.c", "target": 1, "func": "void simplestring_addn(simplestring* target, const char* source, int add_len) {\n   if(target && source) {\n      if(!target->str) {\n         simplestring_init_str(target);\n      }\n      if(target->len + add_len + 1 > target->size) {\n         /* newsize is current length + new length */\n         int newsize = target->len + add_len + 1;\n         int incr = target->size * 2;\n\n         /* align to SIMPLESTRING_INCR increments */\n         newsize = newsize - (newsize % incr) + incr;\n         target->str = (char*)realloc(target->str, newsize);\n\n         target->size = target->str ? newsize : 0;\n      }\n\n      if(target->str) {\n         if(add_len) {\n            memcpy(target->str + target->len, source, add_len);\n         }\n         target->len += add_len;\n         target->str[target->len] = 0; /* null terminate */\n      }\n   }\n}", "func_hash": 48339101902926135808878707654868204878, "file_name": "simplestring.c", "file_hash": 338610095237188637437183530843859723766, "cwe": ["CWE-119"], "cve": "CVE-2016-6296", "cve_desc": "Integer signedness error in the simplestring_addn function in simplestring.c in xmlrpc-epi through 0.54.2, as used in PHP before 5.5.38, 5.6.x before 5.6.24, and 7.x before 7.0.9, allows remote attackers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact via a long first argument to the PHP xmlrpc_encode_request function.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-6296", "file_path": "ext/xmlrpc/libxmlrpc/simplestring.c"}
{"idx": 477975, "project": "php-src", "commit_id": "e6c48213c22ed50b2b987b479fcc1ac709394caa", "project_url": "https://github.com/php/php-src", "commit_url": "http://git.php.net/?p=php-src.git;a=commit;h=e6c48213c22ed50b2b987b479fcc1ac709394caa", "commit_message": "Fix bug #72606: heap-buffer-overflow (write) simplestring_addn simplestring.c", "target": 0, "func": "void simplestring_addn(simplestring* target, const char* source, size_t add_len) {\n   size_t newsize = target->size, incr = 0;\n   if(target && source) {\n      if(!target->str) {\n         simplestring_init_str(target);\n      }\n\n      if((SIZE_MAX - add_len) < target->len || (SIZE_MAX - add_len - 1) < target->len) {\n    \t  /* check for overflows, if there's a potential overflow do nothing */\n    \t  return;\n      }\n\n      if(target->len + add_len + 1 > target->size) {\n         /* newsize is current length + new length */\n         newsize = target->len + add_len + 1;\n         incr = target->size * 2;\n\n         /* align to SIMPLESTRING_INCR increments */\n         if (incr) {\n            newsize = newsize - (newsize % incr) + incr;\n         }\n         if(newsize < (target->len + add_len + 1)) {\n        \t /* some kind of overflow happened */\n        \t return;\n         }\n         target->str = (char*)realloc(target->str, newsize);\n\n         target->size = target->str ? newsize : 0;\n      }\n\n      if(target->str) {\n         if(add_len) {\n            memcpy(target->str + target->len, source, add_len);\n         }\n         target->len += add_len;\n         target->str[target->len] = 0; /* null terminate */\n      }\n   }\n}", "func_hash": 17303339734462956863208308798642286429, "file_name": "simplestring.c", "file_hash": 335043387623274482983135088926291395510, "cwe": ["CWE-119"], "cve": "CVE-2016-6296", "cve_desc": "Integer signedness error in the simplestring_addn function in simplestring.c in xmlrpc-epi through 0.54.2, as used in PHP before 5.5.38, 5.6.x before 5.6.24, and 7.x before 7.0.9, allows remote attackers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact via a long first argument to the PHP xmlrpc_encode_request function.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-6296", "file_path": "ext/xmlrpc/libxmlrpc/simplestring.c"}
{"idx": 214909, "project": "linux", "commit_id": "c8c2a057fdc7de1cd16f4baa51425b932a42eb39", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/c8c2a057fdc7de1cd16f4baa51425b932a42eb39", "commit_message": "net/mlx5: prevent memory leak in mlx5_fpga_conn_create_cq\n\nIn mlx5_fpga_conn_create_cq if mlx5_vector2eqn fails the allocated\nmemory should be released.\n\nFixes: 537a50574175 (\"net/mlx5: FPGA, Add high-speed connection routines\")\nSigned-off-by: Navid Emamdoost <navid.emamdoost@gmail.com>\nSigned-off-by: Saeed Mahameed <saeedm@mellanox.com>", "target": 1, "func": "static int mlx5_fpga_conn_create_cq(struct mlx5_fpga_conn *conn, int cq_size)\n{\n\tstruct mlx5_fpga_device *fdev = conn->fdev;\n\tstruct mlx5_core_dev *mdev = fdev->mdev;\n\tu32 temp_cqc[MLX5_ST_SZ_DW(cqc)] = {0};\n\tu32 out[MLX5_ST_SZ_DW(create_cq_out)];\n\tstruct mlx5_wq_param wqp;\n\tstruct mlx5_cqe64 *cqe;\n\tint inlen, err, eqn;\n\tunsigned int irqn;\n\tvoid *cqc, *in;\n\t__be64 *pas;\n\tu32 i;\n\n\tcq_size = roundup_pow_of_two(cq_size);\n\tMLX5_SET(cqc, temp_cqc, log_cq_size, ilog2(cq_size));\n\n\twqp.buf_numa_node = mdev->priv.numa_node;\n\twqp.db_numa_node  = mdev->priv.numa_node;\n\n\terr = mlx5_cqwq_create(mdev, &wqp, temp_cqc, &conn->cq.wq,\n\t\t\t       &conn->cq.wq_ctrl);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < mlx5_cqwq_get_size(&conn->cq.wq); i++) {\n\t\tcqe = mlx5_cqwq_get_wqe(&conn->cq.wq, i);\n\t\tcqe->op_own = MLX5_CQE_INVALID << 4 | MLX5_CQE_OWNER_MASK;\n\t}\n\n\tinlen = MLX5_ST_SZ_BYTES(create_cq_in) +\n\t\tsizeof(u64) * conn->cq.wq_ctrl.buf.npages;\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in) {\n\t\terr = -ENOMEM;\n\t\tgoto err_cqwq;\n\t}\n\n\terr = mlx5_vector2eqn(mdev, smp_processor_id(), &eqn, &irqn);\n\tif (err)\n\t\tgoto err_cqwq;\n\n\tcqc = MLX5_ADDR_OF(create_cq_in, in, cq_context);\n\tMLX5_SET(cqc, cqc, log_cq_size, ilog2(cq_size));\n\tMLX5_SET(cqc, cqc, c_eqn, eqn);\n\tMLX5_SET(cqc, cqc, uar_page, fdev->conn_res.uar->index);\n\tMLX5_SET(cqc, cqc, log_page_size, conn->cq.wq_ctrl.buf.page_shift -\n\t\t\t   MLX5_ADAPTER_PAGE_SHIFT);\n\tMLX5_SET64(cqc, cqc, dbr_addr, conn->cq.wq_ctrl.db.dma);\n\n\tpas = (__be64 *)MLX5_ADDR_OF(create_cq_in, in, pas);\n\tmlx5_fill_page_frag_array(&conn->cq.wq_ctrl.buf, pas);\n\n\terr = mlx5_core_create_cq(mdev, &conn->cq.mcq, in, inlen, out, sizeof(out));\n\tkvfree(in);\n\n\tif (err)\n\t\tgoto err_cqwq;\n\n\tconn->cq.mcq.cqe_sz     = 64;\n\tconn->cq.mcq.set_ci_db  = conn->cq.wq_ctrl.db.db;\n\tconn->cq.mcq.arm_db     = conn->cq.wq_ctrl.db.db + 1;\n\t*conn->cq.mcq.set_ci_db = 0;\n\t*conn->cq.mcq.arm_db    = 0;\n\tconn->cq.mcq.vector     = 0;\n\tconn->cq.mcq.comp       = mlx5_fpga_conn_cq_complete;\n\tconn->cq.mcq.event      = mlx5_fpga_conn_cq_event;\n\tconn->cq.mcq.irqn       = irqn;\n\tconn->cq.mcq.uar        = fdev->conn_res.uar;\n\ttasklet_init(&conn->cq.tasklet, mlx5_fpga_conn_cq_tasklet,\n\t\t     (unsigned long)conn);\n\n\tmlx5_fpga_dbg(fdev, \"Created CQ #0x%x\\n\", conn->cq.mcq.cqn);\n\n\tgoto out;\n\nerr_cqwq:\n\tmlx5_wq_destroy(&conn->cq.wq_ctrl);\nout:\n\treturn err;\n}", "func_hash": 49458891717982371333799410023640328338, "file_name": "conn.c", "file_hash": 180696471421094307893886411619232621599, "cwe": ["CWE-401"], "cve": "CVE-2019-19045", "cve_desc": "A memory leak in the mlx5_fpga_conn_create_cq() function in drivers/net/ethernet/mellanox/mlx5/core/fpga/conn.c in the Linux kernel before 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering mlx5_vector2eqn() failures, aka CID-c8c2a057fdc7.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2019-19045", "file_path": "drivers/net/ethernet/mellanox/mlx5/core/fpga/conn.c"}
{"idx": 481267, "project": "linux", "commit_id": "c8c2a057fdc7de1cd16f4baa51425b932a42eb39", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/c8c2a057fdc7de1cd16f4baa51425b932a42eb39", "commit_message": "net/mlx5: prevent memory leak in mlx5_fpga_conn_create_cq\n\nIn mlx5_fpga_conn_create_cq if mlx5_vector2eqn fails the allocated\nmemory should be released.\n\nFixes: 537a50574175 (\"net/mlx5: FPGA, Add high-speed connection routines\")\nSigned-off-by: Navid Emamdoost <navid.emamdoost@gmail.com>\nSigned-off-by: Saeed Mahameed <saeedm@mellanox.com>", "target": 0, "func": "static int mlx5_fpga_conn_create_cq(struct mlx5_fpga_conn *conn, int cq_size)\n{\n\tstruct mlx5_fpga_device *fdev = conn->fdev;\n\tstruct mlx5_core_dev *mdev = fdev->mdev;\n\tu32 temp_cqc[MLX5_ST_SZ_DW(cqc)] = {0};\n\tu32 out[MLX5_ST_SZ_DW(create_cq_out)];\n\tstruct mlx5_wq_param wqp;\n\tstruct mlx5_cqe64 *cqe;\n\tint inlen, err, eqn;\n\tunsigned int irqn;\n\tvoid *cqc, *in;\n\t__be64 *pas;\n\tu32 i;\n\n\tcq_size = roundup_pow_of_two(cq_size);\n\tMLX5_SET(cqc, temp_cqc, log_cq_size, ilog2(cq_size));\n\n\twqp.buf_numa_node = mdev->priv.numa_node;\n\twqp.db_numa_node  = mdev->priv.numa_node;\n\n\terr = mlx5_cqwq_create(mdev, &wqp, temp_cqc, &conn->cq.wq,\n\t\t\t       &conn->cq.wq_ctrl);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < mlx5_cqwq_get_size(&conn->cq.wq); i++) {\n\t\tcqe = mlx5_cqwq_get_wqe(&conn->cq.wq, i);\n\t\tcqe->op_own = MLX5_CQE_INVALID << 4 | MLX5_CQE_OWNER_MASK;\n\t}\n\n\tinlen = MLX5_ST_SZ_BYTES(create_cq_in) +\n\t\tsizeof(u64) * conn->cq.wq_ctrl.buf.npages;\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in) {\n\t\terr = -ENOMEM;\n\t\tgoto err_cqwq;\n\t}\n\n\terr = mlx5_vector2eqn(mdev, smp_processor_id(), &eqn, &irqn);\n\tif (err) {\n\t\tkvfree(in);\n\t\tgoto err_cqwq;\n\t}\n\n\tcqc = MLX5_ADDR_OF(create_cq_in, in, cq_context);\n\tMLX5_SET(cqc, cqc, log_cq_size, ilog2(cq_size));\n\tMLX5_SET(cqc, cqc, c_eqn, eqn);\n\tMLX5_SET(cqc, cqc, uar_page, fdev->conn_res.uar->index);\n\tMLX5_SET(cqc, cqc, log_page_size, conn->cq.wq_ctrl.buf.page_shift -\n\t\t\t   MLX5_ADAPTER_PAGE_SHIFT);\n\tMLX5_SET64(cqc, cqc, dbr_addr, conn->cq.wq_ctrl.db.dma);\n\n\tpas = (__be64 *)MLX5_ADDR_OF(create_cq_in, in, pas);\n\tmlx5_fill_page_frag_array(&conn->cq.wq_ctrl.buf, pas);\n\n\terr = mlx5_core_create_cq(mdev, &conn->cq.mcq, in, inlen, out, sizeof(out));\n\tkvfree(in);\n\n\tif (err)\n\t\tgoto err_cqwq;\n\n\tconn->cq.mcq.cqe_sz     = 64;\n\tconn->cq.mcq.set_ci_db  = conn->cq.wq_ctrl.db.db;\n\tconn->cq.mcq.arm_db     = conn->cq.wq_ctrl.db.db + 1;\n\t*conn->cq.mcq.set_ci_db = 0;\n\t*conn->cq.mcq.arm_db    = 0;\n\tconn->cq.mcq.vector     = 0;\n\tconn->cq.mcq.comp       = mlx5_fpga_conn_cq_complete;\n\tconn->cq.mcq.event      = mlx5_fpga_conn_cq_event;\n\tconn->cq.mcq.irqn       = irqn;\n\tconn->cq.mcq.uar        = fdev->conn_res.uar;\n\ttasklet_init(&conn->cq.tasklet, mlx5_fpga_conn_cq_tasklet,\n\t\t     (unsigned long)conn);\n\n\tmlx5_fpga_dbg(fdev, \"Created CQ #0x%x\\n\", conn->cq.mcq.cqn);\n\n\tgoto out;\n\nerr_cqwq:\n\tmlx5_wq_destroy(&conn->cq.wq_ctrl);\nout:\n\treturn err;\n}", "func_hash": 166786309951983227645990078525765970677, "file_name": "conn.c", "file_hash": 179201474190149214779616550859114985162, "cwe": ["CWE-401"], "cve": "CVE-2019-19045", "cve_desc": "A memory leak in the mlx5_fpga_conn_create_cq() function in drivers/net/ethernet/mellanox/mlx5/core/fpga/conn.c in the Linux kernel before 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering mlx5_vector2eqn() failures, aka CID-c8c2a057fdc7.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2019-19045", "file_path": "drivers/net/ethernet/mellanox/mlx5/core/fpga/conn.c"}
{"idx": 214948, "project": "nagioscore", "commit_id": "b1a92a3b52d292ccb601e77a0b29cb1e67ac9d76", "project_url": "https://github.com/NagiosEnterprises/nagioscore", "commit_url": "https://github.com/NagiosEnterprises/nagioscore/commit/b1a92a3b52d292ccb601e77a0b29cb1e67ac9d76", "commit_message": "merge accidental master PR (#553) into maint and fix changelog\nmerge conflict", "target": 1, "func": "static int qh_help(int sd, char *buf, unsigned int len)\n{\n\tstruct query_handler *qh = NULL;\n\n\tif (!*buf || !strcmp(buf, \"help\")) {\n\t\tnsock_printf_nul(sd,\n\t\t\t\"  help <name>   show help for handler <name>\\n\"\n\t\t\t\"  help list     list registered handlers\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(buf, \"list\")) {\n\n\t\tfor (qh = qhandlers; qh != NULL; qh = qh->next_qh) {\n\t\t\tnsock_printf(sd, \"%-10s %s\\n\", qh->name, qh->description ? qh->description : \"(No description available)\");\n\t\t}\n\n\t\tnsock_printf(sd, \"%c\", 0);\n\t\treturn 0;\n\t}\n\n\tqh = qh_find_handler(buf);\n\tif (qh == NULL) {\n\n\t\tnsock_printf_nul(sd, \"No handler named '%s' is registered\\n\", buf);\n\n\t} else if (qh->handler(sd, \"help\", 4) > 200) {\n\n\t\tnsock_printf_nul(sd, \"The handler %s doesn't have any help yet.\", buf);\n\t}\n\n\treturn 0;\n}", "func_hash": 94205848469413247134990431510795041073, "file_name": "query-handler.c", "file_hash": 69411467652185615530893490033539842403, "cwe": ["CWE-476"], "cve": "CVE-2018-13441", "cve_desc": "qh_help in Nagios Core version 4.4.1 and earlier is prone to a NULL pointer dereference vulnerability, which allows attacker to cause a local denial-of-service condition by sending a crafted payload to the listening UNIX socket.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2018-13441", "file_path": "base/query-handler.c"}
{"idx": 481787, "project": "nagioscore", "commit_id": "b1a92a3b52d292ccb601e77a0b29cb1e67ac9d76", "project_url": "https://github.com/NagiosEnterprises/nagioscore", "commit_url": "https://github.com/NagiosEnterprises/nagioscore/commit/b1a92a3b52d292ccb601e77a0b29cb1e67ac9d76", "commit_message": "merge accidental master PR (#553) into maint and fix changelog\nmerge conflict", "target": 0, "func": "static int qh_help(int sd, char *buf, unsigned int len)\n{\n\tstruct query_handler *qh = NULL;\n\n\tif (buf == NULL || !strcmp(buf, \"help\")) {\n\t\tnsock_printf_nul(sd,\n\t\t\t\"  help <name>   show help for handler <name>\\n\"\n\t\t\t\"  help list     list registered handlers\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(buf, \"list\")) {\n\n\t\tfor (qh = qhandlers; qh != NULL; qh = qh->next_qh) {\n\t\t\tnsock_printf(sd, \"%-10s %s\\n\", qh->name, qh->description ? qh->description : \"(No description available)\");\n\t\t}\n\n\t\tnsock_printf(sd, \"%c\", 0);\n\t\treturn 0;\n\t}\n\n\tqh = qh_find_handler(buf);\n\tif (qh == NULL) {\n\n\t\tnsock_printf_nul(sd, \"No handler named '%s' is registered\\n\", buf);\n\n\t} else if (qh->handler(sd, \"help\", 4) > 200) {\n\n\t\tnsock_printf_nul(sd, \"The handler %s doesn't have any help yet.\", buf);\n\t}\n\n\treturn 0;\n}", "func_hash": 205155132129673453942496407625358391443, "file_name": "query-handler.c", "file_hash": 275184931270866221094094086326042798019, "cwe": ["CWE-476"], "cve": "CVE-2018-13441", "cve_desc": "qh_help in Nagios Core version 4.4.1 and earlier is prone to a NULL pointer dereference vulnerability, which allows attacker to cause a local denial-of-service condition by sending a crafted payload to the listening UNIX socket.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2018-13441", "file_path": "base/query-handler.c"}
{"idx": 214997, "project": "liblouis", "commit_id": "2e4772befb2b1c37cb4b9d6572945115ee28630a", "project_url": "https://github.com/liblouis/liblouis", "commit_url": "https://github.com/liblouis/liblouis/commit/2e4772befb2b1c37cb4b9d6572945115ee28630a", "commit_message": "Prevent an invalid memory writes in compileRule\n\nThanks to Han Zheng for reporting it\n\nFixes #1214", "target": 1, "func": "compileRule(FileInfo *file, TranslationTableHeader **table,\n\t\tDisplayTableHeader **displayTable, const MacroList **inScopeMacros) {\n\tCharsString token;\n\tTranslationTableOpcode opcode;\n\tCharsString ruleChars;\n\tCharsString ruleDots;\n\tCharsString cells;\n\tCharsString scratchPad;\n\tCharsString emphClass;\n\tTranslationTableCharacterAttributes after = 0;\n\tTranslationTableCharacterAttributes before = 0;\n\tint noback, nofor, nocross;\n\tnoback = nofor = nocross = 0;\ndoOpcode:\n\tif (!getToken(file, &token, NULL)) return 1;\t\t\t\t  /* blank line */\n\tif (token.chars[0] == '#' || token.chars[0] == '<') return 1; /* comment */\n\tif (file->lineNumber == 1 &&\n\t\t\t(eqasc2uni((unsigned char *)\"ISO\", token.chars, 3) ||\n\t\t\t\t\teqasc2uni((unsigned char *)\"UTF-8\", token.chars, 5))) {\n\t\tif (table)\n\t\t\tcompileHyphenation(file, &token, table);\n\t\telse\n\t\t\t/* ignore the whole file */\n\t\t\twhile (_lou_getALine(file))\n\t\t\t\t;\n\t\treturn 1;\n\t}\n\topcode = getOpcode(file, &token);\n\tswitch (opcode) {\n\tcase CTO_Macro: {\n\t\tconst Macro *macro;\n#ifdef ENABLE_MACROS\n\t\tif (!inScopeMacros) {\n\t\t\tcompileError(file, \"Defining macros only allowed in table files.\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (compileMacro(file, &macro)) {\n\t\t\t*inScopeMacros = cons_macro(macro, *inScopeMacros);\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n#else\n\t\tcompileError(file, \"Macro feature is disabled.\");\n\t\treturn 0;\n#endif\n\t}\n\tcase CTO_IncludeFile: {\n\t\tCharsString includedFile;\n\t\tif (!getToken(file, &token, \"include file name\")) return 0;\n\t\tif (!parseChars(file, &includedFile, &token)) return 0;\n\t\treturn includeFile(file, &includedFile, table, displayTable);\n\t}\n\tcase CTO_NoBack:\n\t\tif (nofor) {\n\t\t\tcompileError(file, \"%s already specified.\", _lou_findOpcodeName(CTO_NoFor));\n\t\t\treturn 0;\n\t\t}\n\t\tnoback = 1;\n\t\tgoto doOpcode;\n\tcase CTO_NoFor:\n\t\tif (noback) {\n\t\t\tcompileError(file, \"%s already specified.\", _lou_findOpcodeName(CTO_NoBack));\n\t\t\treturn 0;\n\t\t}\n\t\tnofor = 1;\n\t\tgoto doOpcode;\n\tcase CTO_Space:\n\t\treturn compileCharDef(\n\t\t\t\tfile, opcode, CTC_Space, noback, nofor, table, displayTable);\n\tcase CTO_Digit:\n\t\treturn compileCharDef(\n\t\t\t\tfile, opcode, CTC_Digit, noback, nofor, table, displayTable);\n\tcase CTO_LitDigit:\n\t\treturn compileCharDef(\n\t\t\t\tfile, opcode, CTC_LitDigit, noback, nofor, table, displayTable);\n\tcase CTO_Punctuation:\n\t\treturn compileCharDef(\n\t\t\t\tfile, opcode, CTC_Punctuation, noback, nofor, table, displayTable);\n\tcase CTO_Math:\n\t\treturn compileCharDef(file, opcode, CTC_Math, noback, nofor, table, displayTable);\n\tcase CTO_Sign:\n\t\treturn compileCharDef(file, opcode, CTC_Sign, noback, nofor, table, displayTable);\n\tcase CTO_Letter:\n\t\treturn compileCharDef(\n\t\t\t\tfile, opcode, CTC_Letter, noback, nofor, table, displayTable);\n\tcase CTO_UpperCase:\n\t\treturn compileCharDef(\n\t\t\t\tfile, opcode, CTC_UpperCase, noback, nofor, table, displayTable);\n\tcase CTO_LowerCase:\n\t\treturn compileCharDef(\n\t\t\t\tfile, opcode, CTC_LowerCase, noback, nofor, table, displayTable);\n\tcase CTO_Grouping:\n\t\treturn compileGrouping(file, noback, nofor, table, displayTable);\n\tcase CTO_Display:\n\t\tif (!displayTable) return 1;  // ignore\n\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\tif (!getRuleDotsPattern(file, &ruleDots)) return 0;\n\t\tif (ruleChars.length != 1 || ruleDots.length != 1) {\n\t\t\tcompileError(file, \"Exactly one character and one cell are required.\");\n\t\t\treturn 0;\n\t\t}\n\t\treturn putCharDotsMapping(\n\t\t\t\tfile, ruleChars.chars[0], ruleDots.chars[0], displayTable);\n\tcase CTO_UpLow:\n\tcase CTO_None: {\n\t\t// check if token is a macro name\n\t\tif (inScopeMacros) {\n\t\t\tconst MacroList *macros = *inScopeMacros;\n\t\t\twhile (macros) {\n\t\t\t\tconst Macro *m = macros->head;\n\t\t\t\tif (token.length == strlen(m->name) &&\n\t\t\t\t\t\teqasc2uni((unsigned char *)m->name, token.chars, token.length)) {\n\t\t\t\t\tif (!inScopeMacros) {\n\t\t\t\t\t\tcompileError(file, \"Calling macros only allowed in table files.\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tFileInfo tmpFile;\n\t\t\t\t\tmemset(&tmpFile, 0, sizeof(tmpFile));\n\t\t\t\t\ttmpFile.fileName = file->fileName;\n\t\t\t\t\ttmpFile.sourceFile = file->sourceFile;\n\t\t\t\t\ttmpFile.lineNumber = file->lineNumber;\n\t\t\t\t\ttmpFile.encoding = noEncoding;\n\t\t\t\t\ttmpFile.status = 0;\n\t\t\t\t\ttmpFile.linepos = 0;\n\t\t\t\t\ttmpFile.linelen = 0;\n\t\t\t\t\tint argument_count = 0;\n\t\t\t\t\tCharsString *arguments =\n\t\t\t\t\t\t\tmalloc(m->argument_count * sizeof(CharsString));\n\t\t\t\t\twhile (argument_count < m->argument_count) {\n\t\t\t\t\t\tif (getToken(file, &token, \"macro argument\"))\n\t\t\t\t\t\t\targuments[argument_count++] = token;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (argument_count < m->argument_count) {\n\t\t\t\t\t\tcompileError(file, \"Expected %d arguments\", m->argument_count);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tint i = 0;\n\t\t\t\t\tint subst = 0;\n\t\t\t\t\tint next = subst < m->substitution_count ? m->substitutions[2 * subst]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t : m->definition_length;\n\t\t\t\t\tfor (;;) {\n\t\t\t\t\t\twhile (i < next) {\n\t\t\t\t\t\t\twidechar c = m->definition[i++];\n\t\t\t\t\t\t\tif (c == '\\n') {\n\t\t\t\t\t\t\t\tif (!compileRule(&tmpFile, table, displayTable,\n\t\t\t\t\t\t\t\t\t\t\tinScopeMacros)) {\n\t\t\t\t\t\t\t\t\t_lou_logMessage(LOU_LOG_ERROR,\n\t\t\t\t\t\t\t\t\t\t\t\"result of macro expansion was: %s\",\n\t\t\t\t\t\t\t\t\t\t\t_lou_showString(\n\t\t\t\t\t\t\t\t\t\t\t\t\ttmpFile.line, tmpFile.linelen, 0));\n\t\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttmpFile.linepos = 0;\n\t\t\t\t\t\t\t\ttmpFile.linelen = 0;\n\t\t\t\t\t\t\t} else if (tmpFile.linelen >= MAXSTRING) {\n\t\t\t\t\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\t\t\t\t\"Line exceeds %d characters (post macro \"\n\t\t\t\t\t\t\t\t\t\t\"expansion)\",\n\t\t\t\t\t\t\t\t\t\tMAXSTRING);\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\ttmpFile.line[tmpFile.linelen++] = c;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (subst < m->substitution_count) {\n\t\t\t\t\t\t\tCharsString arg =\n\t\t\t\t\t\t\t\t\targuments[m->substitutions[2 * subst + 1] - 1];\n\t\t\t\t\t\t\tfor (int j = 0; j < arg.length; j++)\n\t\t\t\t\t\t\t\ttmpFile.line[tmpFile.linelen++] = arg.chars[j];\n\t\t\t\t\t\t\tsubst++;\n\t\t\t\t\t\t\tnext = subst < m->substitution_count\n\t\t\t\t\t\t\t\t\t? m->substitutions[2 * subst]\n\t\t\t\t\t\t\t\t\t: m->definition_length;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (!compileRule(\n\t\t\t\t\t\t\t\t\t\t&tmpFile, table, displayTable, inScopeMacros)) {\n\t\t\t\t\t\t\t\t_lou_logMessage(LOU_LOG_ERROR,\n\t\t\t\t\t\t\t\t\t\t\"result of macro expansion was: %s\",\n\t\t\t\t\t\t\t\t\t\t_lou_showString(\n\t\t\t\t\t\t\t\t\t\t\t\ttmpFile.line, tmpFile.linelen, 0));\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tmacros = macros->tail;\n\t\t\t}\n\t\t}\n\t\tif (opcode == CTO_UpLow) {\n\t\t\tcompileError(file, \"The uplow opcode is deprecated.\");\n\t\t\treturn 0;\n\t\t}\n\t\tcompileError(file, \"opcode %s not defined.\",\n\t\t\t\t_lou_showString(token.chars, token.length, 0));\n\t\treturn 0;\n\t}\n\n\t/* now only opcodes follow that don't modify the display table */\n\tdefault:\n\t\tif (!table) return 1;\n\t\tswitch (opcode) {\n\t\tcase CTO_Locale:\n\t\t\tcompileWarning(file,\n\t\t\t\t\t\"The locale opcode is not implemented. Use the locale meta data \"\n\t\t\t\t\t\"instead.\");\n\t\t\treturn 1;\n\t\tcase CTO_Undefined: {\n\t\t\t// not passing pointer because compileBrailleIndicator may reallocate table\n\t\t\tTranslationTableOffset ruleOffset = (*table)->undefined;\n\t\t\tif (!compileBrailleIndicator(file, \"undefined character opcode\",\n\t\t\t\t\t\tCTO_Undefined, &ruleOffset, noback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\t(*table)->undefined = ruleOffset;\n\t\t\treturn 1;\n\t\t}\n\t\tcase CTO_Match: {\n\t\t\tint ok = 0;\n\t\t\twidechar *patterns = NULL;\n\t\t\tTranslationTableRule *rule;\n\t\t\tTranslationTableOffset ruleOffset;\n\t\t\tCharsString ptn_before, ptn_after;\n\t\t\tTranslationTableOffset patternsOffset;\n\t\t\tint len, mrk;\n\t\t\tsize_t patternsByteSize = sizeof(*patterns) * 27720;\n\t\t\tpatterns = (widechar *)malloc(patternsByteSize);\n\t\t\tif (!patterns) _lou_outOfMemory();\n\t\t\tmemset(patterns, 0xffff, patternsByteSize);\n\t\t\tnoback = 1;\n\t\t\tgetCharacters(file, &ptn_before);\n\t\t\tgetRuleCharsText(file, &ruleChars);\n\t\t\tgetCharacters(file, &ptn_after);\n\t\t\tgetRuleDotsPattern(file, &ruleDots);\n\t\t\tif (!addRule(file, opcode, &ruleChars, &ruleDots, after, before, &ruleOffset,\n\t\t\t\t\t\t&rule, noback, nofor, table))\n\t\t\t\tgoto CTO_Match_cleanup;\n\t\t\tif (ptn_before.chars[0] == '-' && ptn_before.length == 1)\n\t\t\t\tlen = _lou_pattern_compile(\n\t\t\t\t\t\t&ptn_before.chars[0], 0, &patterns[1], 13841, *table, file);\n\t\t\telse\n\t\t\t\tlen = _lou_pattern_compile(&ptn_before.chars[0], ptn_before.length,\n\t\t\t\t\t\t&patterns[1], 13841, *table, file);\n\t\t\tif (!len) goto CTO_Match_cleanup;\n\t\t\tmrk = patterns[0] = len + 1;\n\t\t\t_lou_pattern_reverse(&patterns[1]);\n\t\t\tif (ptn_after.chars[0] == '-' && ptn_after.length == 1)\n\t\t\t\tlen = _lou_pattern_compile(\n\t\t\t\t\t\t&ptn_after.chars[0], 0, &patterns[mrk], 13841, *table, file);\n\t\t\telse\n\t\t\t\tlen = _lou_pattern_compile(&ptn_after.chars[0], ptn_after.length,\n\t\t\t\t\t\t&patterns[mrk], 13841, *table, file);\n\t\t\tif (!len) goto CTO_Match_cleanup;\n\t\t\tlen += mrk;\n\t\t\tif (!allocateSpaceInTranslationTable(\n\t\t\t\t\t\tfile, &patternsOffset, len * sizeof(widechar), table))\n\t\t\t\tgoto CTO_Match_cleanup;\n\t\t\t// allocateSpaceInTranslationTable may have moved table, so make sure rule is\n\t\t\t// still valid\n\t\t\trule = (TranslationTableRule *)&(*table)->ruleArea[ruleOffset];\n\t\t\tmemcpy(&(*table)->ruleArea[patternsOffset], patterns, len * sizeof(widechar));\n\t\t\trule->patterns = patternsOffset;\n\t\t\tok = 1;\n\t\tCTO_Match_cleanup:\n\t\t\tfree(patterns);\n\t\t\treturn ok;\n\t\t}\n\n\t\tcase CTO_BackMatch: {\n\t\t\tint ok = 0;\n\t\t\twidechar *patterns = NULL;\n\t\t\tTranslationTableRule *rule;\n\t\t\tTranslationTableOffset ruleOffset;\n\t\t\tCharsString ptn_before, ptn_after;\n\t\t\tTranslationTableOffset patternOffset;\n\t\t\tint len, mrk;\n\t\t\tsize_t patternsByteSize = sizeof(*patterns) * 27720;\n\t\t\tpatterns = (widechar *)malloc(patternsByteSize);\n\t\t\tif (!patterns) _lou_outOfMemory();\n\t\t\tmemset(patterns, 0xffff, patternsByteSize);\n\t\t\tnofor = 1;\n\t\t\tgetCharacters(file, &ptn_before);\n\t\t\tgetRuleCharsText(file, &ruleChars);\n\t\t\tgetCharacters(file, &ptn_after);\n\t\t\tgetRuleDotsPattern(file, &ruleDots);\n\t\t\tif (!addRule(file, opcode, &ruleChars, &ruleDots, 0, 0, &ruleOffset, &rule,\n\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\tgoto CTO_BackMatch_cleanup;\n\t\t\tif (ptn_before.chars[0] == '-' && ptn_before.length == 1)\n\t\t\t\tlen = _lou_pattern_compile(\n\t\t\t\t\t\t&ptn_before.chars[0], 0, &patterns[1], 13841, *table, file);\n\t\t\telse\n\t\t\t\tlen = _lou_pattern_compile(&ptn_before.chars[0], ptn_before.length,\n\t\t\t\t\t\t&patterns[1], 13841, *table, file);\n\t\t\tif (!len) goto CTO_BackMatch_cleanup;\n\t\t\tmrk = patterns[0] = len + 1;\n\t\t\t_lou_pattern_reverse(&patterns[1]);\n\t\t\tif (ptn_after.chars[0] == '-' && ptn_after.length == 1)\n\t\t\t\tlen = _lou_pattern_compile(\n\t\t\t\t\t\t&ptn_after.chars[0], 0, &patterns[mrk], 13841, *table, file);\n\t\t\telse\n\t\t\t\tlen = _lou_pattern_compile(&ptn_after.chars[0], ptn_after.length,\n\t\t\t\t\t\t&patterns[mrk], 13841, *table, file);\n\t\t\tif (!len) goto CTO_BackMatch_cleanup;\n\t\t\tlen += mrk;\n\t\t\tif (!allocateSpaceInTranslationTable(\n\t\t\t\t\t\tfile, &patternOffset, len * sizeof(widechar), table))\n\t\t\t\tgoto CTO_BackMatch_cleanup;\n\t\t\t// allocateSpaceInTranslationTable may have moved table, so make sure rule is\n\t\t\t// still valid\n\t\t\trule = (TranslationTableRule *)&(*table)->ruleArea[ruleOffset];\n\t\t\tmemcpy(&(*table)->ruleArea[patternOffset], patterns, len * sizeof(widechar));\n\t\t\trule->patterns = patternOffset;\n\t\t\tok = 1;\n\t\tCTO_BackMatch_cleanup:\n\t\t\tfree(patterns);\n\t\t\treturn ok;\n\t\t}\n\n\t\tcase CTO_CapsLetter:\n\t\tcase CTO_BegCapsWord:\n\t\tcase CTO_EndCapsWord:\n\t\tcase CTO_BegCaps:\n\t\tcase CTO_EndCaps:\n\t\tcase CTO_BegCapsPhrase:\n\t\tcase CTO_EndCapsPhrase:\n\t\tcase CTO_LenCapsPhrase:\n\t\t/* these 8 general purpose opcodes are compiled further down to more specific\n\t\t * internal opcodes:\n\t\t * - modeletter\n\t\t * - begmodeword\n\t\t * - endmodeword\n\t\t * - begmode\n\t\t * - endmode\n\t\t * - begmodephrase\n\t\t * - endmodephrase\n\t\t * - lenmodephrase\n\t\t */\n\t\tcase CTO_ModeLetter:\n\t\tcase CTO_BegModeWord:\n\t\tcase CTO_EndModeWord:\n\t\tcase CTO_BegMode:\n\t\tcase CTO_EndMode:\n\t\tcase CTO_BegModePhrase:\n\t\tcase CTO_EndModePhrase:\n\t\tcase CTO_LenModePhrase: {\n\t\t\tTranslationTableCharacterAttributes mode;\n\t\t\tint i;\n\t\t\tswitch (opcode) {\n\t\t\tcase CTO_CapsLetter:\n\t\t\tcase CTO_BegCapsWord:\n\t\t\tcase CTO_EndCapsWord:\n\t\t\tcase CTO_BegCaps:\n\t\t\tcase CTO_EndCaps:\n\t\t\tcase CTO_BegCapsPhrase:\n\t\t\tcase CTO_EndCapsPhrase:\n\t\t\tcase CTO_LenCapsPhrase:\n\t\t\t\tmode = CTC_UpperCase;\n\t\t\t\ti = 0;\n\t\t\t\topcode += (CTO_ModeLetter - CTO_CapsLetter);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (!getToken(file, &token, \"attribute name\")) return 0;\n\t\t\t\tif (!(*table)->characterClasses && !allocateCharacterClasses(*table)) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tconst CharacterClass *characterClass = findCharacterClass(&token, *table);\n\t\t\t\tif (!characterClass) {\n\t\t\t\t\tcharacterClass =\n\t\t\t\t\t\t\taddCharacterClass(file, token.chars, token.length, *table, 1);\n\t\t\t\t\tif (!characterClass) return 0;\n\t\t\t\t}\n\t\t\t\tmode = characterClass->attribute;\n\t\t\t\tif (!(mode == CTC_UpperCase || mode == CTC_Digit) && mode >= CTC_Space &&\n\t\t\t\t\t\tmode <= CTC_LitDigit) {\n\t\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\t\"mode must be \\\"uppercase\\\", \\\"digit\\\", or a custom \"\n\t\t\t\t\t\t\t\"attribute name.\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t/* check if this mode is already defined and if the number of modes does\n\t\t\t\t * not exceed the maximal number */\n\t\t\t\tif (mode == CTC_UpperCase)\n\t\t\t\t\ti = 0;\n\t\t\t\telse {\n\t\t\t\t\tfor (i = 1; i < MAX_MODES && (*table)->modes[i].value; i++) {\n\t\t\t\t\t\tif ((*table)->modes[i].mode == mode) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (i == MAX_MODES) {\n\t\t\t\t\t\tcompileError(file, \"Max number of modes (%i) reached\", MAX_MODES);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!(*table)->modes[i].value)\n\t\t\t\t(*table)->modes[i] = (EmphasisClass){ plain_text, mode,\n\t\t\t\t\t0x1 << (MAX_EMPH_CLASSES + i), MAX_EMPH_CLASSES + i };\n\t\t\tswitch (opcode) {\n\t\t\tcase CTO_BegModePhrase: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][begPhraseOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"first word capital sign\",\n\t\t\t\t\t\t\tCTO_BegCapsPhraseRule + (8 * i), &ruleOffset, noback, nofor,\n\t\t\t\t\t\t\ttable))\n\t\t\t\t\treturn 0;\n\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][begPhraseOffset] = ruleOffset;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcase CTO_EndModePhrase: {\n\t\t\t\tTranslationTableOffset ruleOffset;\n\t\t\t\tswitch (compileBeforeAfter(file)) {\n\t\t\t\tcase 1:\t // before\n\t\t\t\t\tif ((*table)->emphRules[MAX_EMPH_CLASSES + i][endPhraseAfterOffset]) {\n\t\t\t\t\t\tcompileError(\n\t\t\t\t\t\t\t\tfile, \"Capital sign after last word already defined.\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t\t// table\n\t\t\t\t\truleOffset = (*table)->emphRules[MAX_EMPH_CLASSES + i]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[endPhraseBeforeOffset];\n\t\t\t\t\tif (!compileBrailleIndicator(file, \"capital sign before last word\",\n\t\t\t\t\t\t\t\tCTO_EndCapsPhraseBeforeRule + (8 * i), &ruleOffset,\n\t\t\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][endPhraseBeforeOffset] =\n\t\t\t\t\t\t\truleOffset;\n\t\t\t\t\treturn 1;\n\t\t\t\tcase 2:\t // after\n\t\t\t\t\tif ((*table)->emphRules[MAX_EMPH_CLASSES + i]\n\t\t\t\t\t\t\t\t\t\t   [endPhraseBeforeOffset]) {\n\t\t\t\t\t\tcompileError(\n\t\t\t\t\t\t\t\tfile, \"Capital sign before last word already defined.\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t\t// table\n\t\t\t\t\truleOffset = (*table)->emphRules[MAX_EMPH_CLASSES + i]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[endPhraseAfterOffset];\n\t\t\t\t\tif (!compileBrailleIndicator(file, \"capital sign after last word\",\n\t\t\t\t\t\t\t\tCTO_EndCapsPhraseAfterRule + (8 * i), &ruleOffset, noback,\n\t\t\t\t\t\t\t\tnofor, table))\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][endPhraseAfterOffset] =\n\t\t\t\t\t\t\truleOffset;\n\t\t\t\t\treturn 1;\n\t\t\t\tdefault:  // error\n\t\t\t\t\tcompileError(file, \"Invalid lastword indicator location.\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcase CTO_BegMode: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][begOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"first letter capital sign\",\n\t\t\t\t\t\t\tCTO_BegCapsRule + (8 * i), &ruleOffset, noback, nofor, table))\n\t\t\t\t\treturn 0;\n\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][begOffset] = ruleOffset;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcase CTO_EndMode: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][endOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"last letter capital sign\",\n\t\t\t\t\t\t\tCTO_EndCapsRule + (8 * i), &ruleOffset, noback, nofor, table))\n\t\t\t\t\treturn 0;\n\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][endOffset] = ruleOffset;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcase CTO_ModeLetter: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][letterOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"single letter capital sign\",\n\t\t\t\t\t\t\tCTO_CapsLetterRule + (8 * i), &ruleOffset, noback, nofor,\n\t\t\t\t\t\t\ttable))\n\t\t\t\t\treturn 0;\n\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][letterOffset] = ruleOffset;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcase CTO_BegModeWord: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][begWordOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"capital word\",\n\t\t\t\t\t\t\tCTO_BegCapsWordRule + (8 * i), &ruleOffset, noback, nofor,\n\t\t\t\t\t\t\ttable))\n\t\t\t\t\treturn 0;\n\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][begWordOffset] = ruleOffset;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcase CTO_EndModeWord: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][endWordOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"capital word stop\",\n\t\t\t\t\t\t\tCTO_EndCapsWordRule + (8 * i), &ruleOffset, noback, nofor,\n\t\t\t\t\t\t\ttable))\n\t\t\t\t\treturn 0;\n\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][endWordOffset] = ruleOffset;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcase CTO_LenModePhrase:\n\t\t\t\treturn (*table)->emphRules[MAX_EMPH_CLASSES + i][lenPhraseOffset] =\n\t\t\t\t\t\t\t   compileNumber(file);\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/* these 8 general purpose emphasis opcodes are compiled further down to more\n\t\t * specific internal opcodes:\n\t\t * - emphletter\n\t\t * - begemphword\n\t\t * - endemphword\n\t\t * - begemph\n\t\t * - endemph\n\t\t * - begemphphrase\n\t\t * - endemphphrase\n\t\t * - lenemphphrase\n\t\t */\n\t\tcase CTO_EmphClass:\n\t\t\tif (!getToken(file, &emphClass, \"emphasis class\")) {\n\t\t\t\tcompileError(file, \"emphclass must be followed by a valid class name.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tint k, i;\n\t\t\tchar *s = malloc(sizeof(char) * (emphClass.length + 1));\n\t\t\tfor (k = 0; k < emphClass.length; k++) s[k] = (char)emphClass.chars[k];\n\t\t\ts[k++] = '\\0';\n\t\t\tfor (i = 0; i < MAX_EMPH_CLASSES && (*table)->emphClassNames[i]; i++)\n\t\t\t\tif (strcmp(s, (*table)->emphClassNames[i]) == 0) {\n\t\t\t\t\t_lou_logMessage(LOU_LOG_WARN, \"Duplicate emphasis class: %s\", s);\n\t\t\t\t\twarningCount++;\n\t\t\t\t\tfree(s);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\tif (i == MAX_EMPH_CLASSES) {\n\t\t\t\t_lou_logMessage(LOU_LOG_ERROR,\n\t\t\t\t\t\t\"Max number of emphasis classes (%i) reached\", MAX_EMPH_CLASSES);\n\t\t\t\terrorCount++;\n\t\t\t\tfree(s);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tswitch (i) {\n\t\t\t/* For backwards compatibility (i.e. because programs will assume\n\t\t\t * the first 3 typeform bits are `italic', `underline' and `bold')\n\t\t\t * we require that the first 3 emphclass definitions are (in that\n\t\t\t * order):\n\t\t\t *\n\t\t\t *   emphclass italic\n\t\t\t *   emphclass underline\n\t\t\t *   emphclass bold\n\t\t\t *\n\t\t\t * While it would be possible to use the emphclass opcode only for\n\t\t\t * defining _additional_ classes (not allowing for them to be called\n\t\t\t * italic, underline or bold), thereby reducing the amount of\n\t\t\t * boilerplate, we deliberately choose not to do that in order to\n\t\t\t * not give italic, underline and bold any special status. The\n\t\t\t * hope is that eventually all programs will use liblouis for\n\t\t\t * emphasis the recommended way (i.e. by looking up the supported\n\t\t\t * typeforms in the documentation or API) so that we can drop this\n\t\t\t * restriction.\n\t\t\t */\n\t\t\tcase 0:\n\t\t\t\tif (strcmp(s, \"italic\") != 0) {\n\t\t\t\t\t_lou_logMessage(LOU_LOG_ERROR,\n\t\t\t\t\t\t\t\"First emphasis class must be \\\"italic\\\" but got \"\n\t\t\t\t\t\t\t\"%s\",\n\t\t\t\t\t\t\ts);\n\t\t\t\t\terrorCount++;\n\t\t\t\t\tfree(s);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tif (strcmp(s, \"underline\") != 0) {\n\t\t\t\t\t_lou_logMessage(LOU_LOG_ERROR,\n\t\t\t\t\t\t\t\"Second emphasis class must be \\\"underline\\\" but \"\n\t\t\t\t\t\t\t\"got \"\n\t\t\t\t\t\t\t\"%s\",\n\t\t\t\t\t\t\ts);\n\t\t\t\t\terrorCount++;\n\t\t\t\t\tfree(s);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tif (strcmp(s, \"bold\") != 0) {\n\t\t\t\t\t_lou_logMessage(LOU_LOG_ERROR,\n\t\t\t\t\t\t\t\"Third emphasis class must be \\\"bold\\\" but got \"\n\t\t\t\t\t\t\t\"%s\",\n\t\t\t\t\t\t\ts);\n\t\t\t\t\terrorCount++;\n\t\t\t\t\tfree(s);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t(*table)->emphClassNames[i] = s;\n\t\t\t(*table)->emphClasses[i] = (EmphasisClass){ emph_1\n\t\t\t\t\t\t<< i, /* relies on the order of typeforms emph_1..emph_10 */\n\t\t\t\t0, 0x1 << i, i };\n\t\t\treturn 1;\n\t\tcase CTO_EmphLetter:\n\t\tcase CTO_BegEmphWord:\n\t\tcase CTO_EndEmphWord:\n\t\tcase CTO_BegEmph:\n\t\tcase CTO_EndEmph:\n\t\tcase CTO_BegEmphPhrase:\n\t\tcase CTO_EndEmphPhrase:\n\t\tcase CTO_LenEmphPhrase:\n\t\tcase CTO_EmphModeChars:\n\t\tcase CTO_NoEmphChars: {\n\t\t\tif (!getToken(file, &token, \"emphasis class\")) return 0;\n\t\t\tif (!parseChars(file, &emphClass, &token)) return 0;\n\t\t\tchar *s = malloc(sizeof(char) * (emphClass.length + 1));\n\t\t\tint k, i;\n\t\t\tfor (k = 0; k < emphClass.length; k++) s[k] = (char)emphClass.chars[k];\n\t\t\ts[k++] = '\\0';\n\t\t\tfor (i = 0; i < MAX_EMPH_CLASSES && (*table)->emphClassNames[i]; i++)\n\t\t\t\tif (strcmp(s, (*table)->emphClassNames[i]) == 0) break;\n\t\t\tif (i == MAX_EMPH_CLASSES || !(*table)->emphClassNames[i]) {\n\t\t\t\t_lou_logMessage(LOU_LOG_ERROR, \"Emphasis class %s not declared\", s);\n\t\t\t\terrorCount++;\n\t\t\t\tfree(s);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tint ok = 0;\n\t\t\tswitch (opcode) {\n\t\t\tcase CTO_EmphLetter: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset = (*table)->emphRules[i][letterOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"single letter\",\n\t\t\t\t\t\t\tCTO_Emph1LetterRule + letterOffset + (8 * i), &ruleOffset,\n\t\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\t\tbreak;\n\t\t\t\t(*table)->emphRules[i][letterOffset] = ruleOffset;\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CTO_BegEmphWord: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset = (*table)->emphRules[i][begWordOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"word\",\n\t\t\t\t\t\t\tCTO_Emph1LetterRule + begWordOffset + (8 * i), &ruleOffset,\n\t\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\t\tbreak;\n\t\t\t\t(*table)->emphRules[i][begWordOffset] = ruleOffset;\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CTO_EndEmphWord: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset = (*table)->emphRules[i][endWordOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"word stop\",\n\t\t\t\t\t\t\tCTO_Emph1LetterRule + endWordOffset + (8 * i), &ruleOffset,\n\t\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\t\tbreak;\n\t\t\t\t(*table)->emphRules[i][endWordOffset] = ruleOffset;\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CTO_BegEmph: {\n\t\t\t\t/* fail if both begemph and any of begemphphrase or begemphword are\n\t\t\t\t * defined */\n\t\t\t\tif ((*table)->emphRules[i][begWordOffset] ||\n\t\t\t\t\t\t(*table)->emphRules[i][begPhraseOffset]) {\n\t\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\t\"Cannot define emphasis for both no context and word or \"\n\t\t\t\t\t\t\t\"phrase context, i.e. cannot have both begemph and \"\n\t\t\t\t\t\t\t\"begemphword or begemphphrase.\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset = (*table)->emphRules[i][begOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"first letter\",\n\t\t\t\t\t\t\tCTO_Emph1LetterRule + begOffset + (8 * i), &ruleOffset,\n\t\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\t\tbreak;\n\t\t\t\t(*table)->emphRules[i][begOffset] = ruleOffset;\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CTO_EndEmph: {\n\t\t\t\tif ((*table)->emphRules[i][endWordOffset] ||\n\t\t\t\t\t\t(*table)->emphRules[i][endPhraseBeforeOffset] ||\n\t\t\t\t\t\t(*table)->emphRules[i][endPhraseAfterOffset]) {\n\t\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\t\"Cannot define emphasis for both no context and word or \"\n\t\t\t\t\t\t\t\"phrase context, i.e. cannot have both endemph and \"\n\t\t\t\t\t\t\t\"endemphword or endemphphrase.\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset = (*table)->emphRules[i][endOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"last letter\",\n\t\t\t\t\t\t\tCTO_Emph1LetterRule + endOffset + (8 * i), &ruleOffset,\n\t\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\t\tbreak;\n\t\t\t\t(*table)->emphRules[i][endOffset] = ruleOffset;\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CTO_BegEmphPhrase: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t(*table)->emphRules[i][begPhraseOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"first word\",\n\t\t\t\t\t\t\tCTO_Emph1LetterRule + begPhraseOffset + (8 * i), &ruleOffset,\n\t\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\t\tbreak;\n\t\t\t\t(*table)->emphRules[i][begPhraseOffset] = ruleOffset;\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CTO_EndEmphPhrase:\n\t\t\t\tswitch (compileBeforeAfter(file)) {\n\t\t\t\tcase 1: {  // before\n\t\t\t\t\tif ((*table)->emphRules[i][endPhraseAfterOffset]) {\n\t\t\t\t\t\tcompileError(file, \"last word after already defined.\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t\t// table\n\t\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t\t(*table)->emphRules[i][endPhraseBeforeOffset];\n\t\t\t\t\tif (!compileBrailleIndicator(file, \"last word before\",\n\t\t\t\t\t\t\t\tCTO_Emph1LetterRule + endPhraseBeforeOffset + (8 * i),\n\t\t\t\t\t\t\t\t&ruleOffset, noback, nofor, table))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t(*table)->emphRules[i][endPhraseBeforeOffset] = ruleOffset;\n\t\t\t\t\tok = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 2: {  // after\n\t\t\t\t\tif ((*table)->emphRules[i][endPhraseBeforeOffset]) {\n\t\t\t\t\t\tcompileError(file, \"last word before already defined.\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t\t// table\n\t\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t\t(*table)->emphRules[i][endPhraseAfterOffset];\n\t\t\t\t\tif (!compileBrailleIndicator(file, \"last word after\",\n\t\t\t\t\t\t\t\tCTO_Emph1LetterRule + endPhraseAfterOffset + (8 * i),\n\t\t\t\t\t\t\t\t&ruleOffset, noback, nofor, table))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t(*table)->emphRules[i][endPhraseAfterOffset] = ruleOffset;\n\t\t\t\t\tok = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdefault:  // error\n\t\t\t\t\tcompileError(file, \"Invalid lastword indicator location.\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CTO_LenEmphPhrase:\n\t\t\t\tif (((*table)->emphRules[i][lenPhraseOffset] = compileNumber(file)))\n\t\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\tcase CTO_EmphModeChars: {\n\t\t\t\tif (!getRuleCharsText(file, &ruleChars)) break;\n\t\t\t\twidechar *emphmodechars = (*table)->emphModeChars[i];\n\t\t\t\tint len;\n\t\t\t\tfor (len = 0; len < EMPHMODECHARSSIZE && emphmodechars[len]; len++)\n\t\t\t\t\t;\n\t\t\t\tif (len + ruleChars.length > EMPHMODECHARSSIZE) {\n\t\t\t\t\tcompileError(file, \"More than %d characters\", EMPHMODECHARSSIZE);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tok = 1;\n\t\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\t\tif (!getChar(ruleChars.chars[k], *table, NULL)) {\n\t\t\t\t\t\tcompileError(file, \"Emphasis mode character undefined\");\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\temphmodechars[len++] = ruleChars.chars[k];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CTO_NoEmphChars: {\n\t\t\t\tif (!getRuleCharsText(file, &ruleChars)) break;\n\t\t\t\twidechar *noemphchars = (*table)->noEmphChars[i];\n\t\t\t\tint len;\n\t\t\t\tfor (len = 0; len < NOEMPHCHARSSIZE && noemphchars[len]; len++)\n\t\t\t\t\t;\n\t\t\t\tif (len + ruleChars.length > NOEMPHCHARSSIZE) {\n\t\t\t\t\tcompileError(file, \"More than %d characters\", NOEMPHCHARSSIZE);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tok = 1;\n\t\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\t\tif (!getChar(ruleChars.chars[k], *table, NULL)) {\n\t\t\t\t\t\tcompileError(file, \"Character undefined\");\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tnoemphchars[len++] = ruleChars.chars[k];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfree(s);\n\t\t\treturn ok;\n\t\t}\n\t\tcase CTO_LetterSign: {\n\t\t\t// not passing pointer because compileBrailleIndicator may reallocate table\n\t\t\tTranslationTableOffset ruleOffset = (*table)->letterSign;\n\t\t\tif (!compileBrailleIndicator(file, \"letter sign\", CTO_LetterRule, &ruleOffset,\n\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\t(*table)->letterSign = ruleOffset;\n\t\t\treturn 1;\n\t\t}\n\t\tcase CTO_NoLetsignBefore:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (((*table)->noLetsignBeforeCount + ruleChars.length) > LETSIGNBEFORESIZE) {\n\t\t\t\tcompileError(file, \"More than %d characters\", LETSIGNBEFORESIZE);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor (int k = 0; k < ruleChars.length; k++)\n\t\t\t\t(*table)->noLetsignBefore[(*table)->noLetsignBeforeCount++] =\n\t\t\t\t\t\truleChars.chars[k];\n\t\t\treturn 1;\n\t\tcase CTO_NoLetsign:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (((*table)->noLetsignCount + ruleChars.length) > LETSIGNSIZE) {\n\t\t\t\tcompileError(file, \"More than %d characters\", LETSIGNSIZE);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor (int k = 0; k < ruleChars.length; k++)\n\t\t\t\t(*table)->noLetsign[(*table)->noLetsignCount++] = ruleChars.chars[k];\n\t\t\treturn 1;\n\t\tcase CTO_NoLetsignAfter:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (((*table)->noLetsignAfterCount + ruleChars.length) > LETSIGNAFTERSIZE) {\n\t\t\t\tcompileError(file, \"More than %d characters\", LETSIGNAFTERSIZE);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor (int k = 0; k < ruleChars.length; k++)\n\t\t\t\t(*table)->noLetsignAfter[(*table)->noLetsignAfterCount++] =\n\t\t\t\t\t\truleChars.chars[k];\n\t\t\treturn 1;\n\t\tcase CTO_NumberSign: {\n\t\t\t// not passing pointer because compileBrailleIndicator may reallocate table\n\t\t\tTranslationTableOffset ruleOffset = (*table)->numberSign;\n\t\t\tif (!compileBrailleIndicator(file, \"number sign\", CTO_NumberRule, &ruleOffset,\n\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\t(*table)->numberSign = ruleOffset;\n\t\t\treturn 1;\n\t\t}\n\n\t\tcase CTO_NumericModeChars:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!c) {\n\t\t\t\t\tcompileError(file, \"Numeric mode character undefined: %s\",\n\t\t\t\t\t\t\t_lou_showString(&ruleChars.chars[k], 1, 0));\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc->attributes |= CTC_NumericMode;\n\t\t\t\t(*table)->usesNumericMode = 1;\n\t\t\t}\n\t\t\treturn 1;\n\n\t\tcase CTO_MidEndNumericModeChars:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!c) {\n\t\t\t\t\tcompileError(file, \"Midendnumeric mode character undefined\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc->attributes |= CTC_MidEndNumericMode;\n\t\t\t\t(*table)->usesNumericMode = 1;\n\t\t\t}\n\t\t\treturn 1;\n\n\t\tcase CTO_NumericNoContractChars:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!c) {\n\t\t\t\t\tcompileError(file, \"Numeric no contraction character undefined\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc->attributes |= CTC_NumericNoContract;\n\t\t\t\t(*table)->usesNumericMode = 1;\n\t\t\t}\n\t\t\treturn 1;\n\n\t\tcase CTO_NoContractSign: {\n\t\t\t// not passing pointer because compileBrailleIndicator may reallocate table\n\t\t\tTranslationTableOffset ruleOffset = (*table)->noContractSign;\n\t\t\tif (!compileBrailleIndicator(file, \"no contractions sign\", CTO_NoContractRule,\n\t\t\t\t\t\t&ruleOffset, noback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\t(*table)->noContractSign = ruleOffset;\n\t\t\treturn 1;\n\t\t}\n\t\tcase CTO_SeqDelimiter:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!c) {\n\t\t\t\t\tcompileError(file, \"Sequence delimiter character undefined\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc->attributes |= CTC_SeqDelimiter;\n\t\t\t\t(*table)->usesSequences = 1;\n\t\t\t}\n\t\t\treturn 1;\n\n\t\tcase CTO_SeqBeforeChars:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!c) {\n\t\t\t\t\tcompileError(file, \"Sequence before character undefined\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc->attributes |= CTC_SeqBefore;\n\t\t\t}\n\t\t\treturn 1;\n\n\t\tcase CTO_SeqAfterChars:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!c) {\n\t\t\t\t\tcompileError(file, \"Sequence after character undefined\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc->attributes |= CTC_SeqAfter;\n\t\t\t}\n\t\t\treturn 1;\n\n\t\tcase CTO_SeqAfterPattern:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (((*table)->seqPatternsCount + ruleChars.length + 1) > SEQPATTERNSIZE) {\n\t\t\t\tcompileError(file, \"More than %d characters\", SEQPATTERNSIZE);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor (int k = 0; k < ruleChars.length; k++)\n\t\t\t\t(*table)->seqPatterns[(*table)->seqPatternsCount++] = ruleChars.chars[k];\n\t\t\t(*table)->seqPatterns[(*table)->seqPatternsCount++] = 0;\n\t\t\treturn 1;\n\n\t\tcase CTO_SeqAfterExpression:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor ((*table)->seqAfterExpressionLength = 0;\n\t\t\t\t\t(*table)->seqAfterExpressionLength < ruleChars.length;\n\t\t\t\t\t(*table)->seqAfterExpressionLength++)\n\t\t\t\t(*table)->seqAfterExpression[(*table)->seqAfterExpressionLength] =\n\t\t\t\t\t\truleChars.chars[(*table)->seqAfterExpressionLength];\n\t\t\t(*table)->seqAfterExpression[(*table)->seqAfterExpressionLength] = 0;\n\t\t\treturn 1;\n\n\t\tcase CTO_CapsModeChars:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!c) {\n\t\t\t\t\tcompileError(file, \"Capital mode character undefined\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc->attributes |= CTC_CapsMode;\n\t\t\t\t(*table)->hasCapsModeChars = 1;\n\t\t\t}\n\t\t\treturn 1;\n\n\t\tcase CTO_BegComp: {\n\t\t\t// not passing pointer because compileBrailleIndicator may reallocate table\n\t\t\tTranslationTableOffset ruleOffset = (*table)->begComp;\n\t\t\tif (!compileBrailleIndicator(file, \"begin computer braille\", CTO_BegCompRule,\n\t\t\t\t\t\t&ruleOffset, noback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\t(*table)->begComp = ruleOffset;\n\t\t\treturn 1;\n\t\t}\n\t\tcase CTO_EndComp: {\n\t\t\t// not passing pointer because compileBrailleIndicator may reallocate table\n\t\t\tTranslationTableOffset ruleOffset = (*table)->endComp;\n\t\t\tif (!compileBrailleIndicator(file, \"end computer braslle\", CTO_EndCompRule,\n\t\t\t\t\t\t&ruleOffset, noback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\t(*table)->endComp = ruleOffset;\n\t\t\treturn 1;\n\t\t}\n\t\tcase CTO_NoCross:\n\t\t\tif (nocross) {\n\t\t\t\tcompileError(\n\t\t\t\t\t\tfile, \"%s already specified.\", _lou_findOpcodeName(CTO_NoCross));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tnocross = 1;\n\t\t\tgoto doOpcode;\n\t\tcase CTO_Syllable:\n\t\t\t(*table)->syllables = 1;\n\t\tcase CTO_Always:\n\t\tcase CTO_LargeSign:\n\t\tcase CTO_WholeWord:\n\t\tcase CTO_PartWord:\n\t\tcase CTO_JoinNum:\n\t\tcase CTO_JoinableWord:\n\t\tcase CTO_LowWord:\n\t\tcase CTO_SuffixableWord:\n\t\tcase CTO_PrefixableWord:\n\t\tcase CTO_BegWord:\n\t\tcase CTO_BegMidWord:\n\t\tcase CTO_MidWord:\n\t\tcase CTO_MidEndWord:\n\t\tcase CTO_EndWord:\n\t\tcase CTO_PrePunc:\n\t\tcase CTO_PostPunc:\n\t\tcase CTO_BegNum:\n\t\tcase CTO_MidNum:\n\t\tcase CTO_EndNum:\n\t\tcase CTO_Repeated:\n\t\tcase CTO_RepWord:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (!getRuleDotsPattern(file, &ruleDots)) return 0;\n\t\t\tif (ruleDots.length == 0)\n\t\t\t\t// check that all characters in a rule with `=` as second operand are\n\t\t\t\t// defined (or based on another character)\n\t\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\t\tTranslationTableCharacter *c =\n\t\t\t\t\t\t\tgetChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\t\tif (!(c && (c->definitionRule || c->basechar))) {\n\t\t\t\t\t\tcompileError(file, \"Character %s is not defined\",\n\t\t\t\t\t\t\t\t_lou_showString(&ruleChars.chars[k], 1, 0));\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tTranslationTableRule *r;\n\t\t\tif (!addRule(file, opcode, &ruleChars, &ruleDots, after, before, NULL, &r,\n\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\tif (nocross) r->nocross = 1;\n\t\t\treturn 1;\n\t\t\t// if (opcode == CTO_MidNum)\n\t\t\t// {\n\t\t\t//   TranslationTableCharacter *c = getChar(ruleChars.chars[0]);\n\t\t\t//   if(c)\n\t\t\t//     c->attributes |= CTC_NumericMode;\n\t\t\t// }\n\t\tcase CTO_RepEndWord:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tCharsString dots;\n\t\t\tif (!getToken(file, &dots, \"dots,dots operand\")) return 0;\n\t\t\tint len = dots.length;\n\t\t\tfor (int k = 0; k < len - 1; k++) {\n\t\t\t\tif (dots.chars[k] == ',') {\n\t\t\t\t\tdots.length = k;\n\t\t\t\t\tif (!parseDots(file, &ruleDots, &dots)) return 0;\n\t\t\t\t\truleDots.chars[ruleDots.length++] = ',';\n\t\t\t\t\tk++;\n\t\t\t\t\tif (k == len - 1 && dots.chars[k] == '=') {\n\t\t\t\t\t\t// check that all characters are defined (or based on another\n\t\t\t\t\t\t// character)\n\t\t\t\t\t\tfor (int l = 0; l < ruleChars.length; l++) {\n\t\t\t\t\t\t\tTranslationTableCharacter *c =\n\t\t\t\t\t\t\t\t\tgetChar(ruleChars.chars[l], *table, NULL);\n\t\t\t\t\t\t\tif (!(c && (c->definitionRule || c->basechar))) {\n\t\t\t\t\t\t\t\tcompileError(file, \"Character %s is not defined\",\n\t\t\t\t\t\t\t\t\t\t_lou_showString(&ruleChars.chars[l], 1, 0));\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tCharsString x, y;\n\t\t\t\t\t\tx.length = 0;\n\t\t\t\t\t\twhile (k < len) x.chars[x.length++] = dots.chars[k++];\n\t\t\t\t\t\tif (parseDots(file, &y, &x))\n\t\t\t\t\t\t\tfor (int l = 0; l < y.length; l++)\n\t\t\t\t\t\t\t\truleDots.chars[ruleDots.length++] = y.chars[l];\n\t\t\t\t\t}\n\t\t\t\t\treturn addRule(file, opcode, &ruleChars, &ruleDots, after, before,\n\t\t\t\t\t\t\tNULL, NULL, noback, nofor, table);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\tcase CTO_CompDots:\n\t\tcase CTO_Comp6: {\n\t\t\tTranslationTableOffset ruleOffset;\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (ruleChars.length != 1) {\n\t\t\t\tcompileError(file, \"first operand must be 1 character\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (nofor || noback) {\n\t\t\t\tcompileWarning(file, \"nofor and noback not allowed on comp6 rules\");\n\t\t\t}\n\t\t\tif (!getRuleDotsPattern(file, &ruleDots)) return 0;\n\t\t\tif (!addRule(file, opcode, &ruleChars, &ruleDots, after, before, &ruleOffset,\n\t\t\t\t\t\tNULL, noback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\treturn 1;\n\t\t}\n\t\tcase CTO_ExactDots:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (ruleChars.chars[0] != '@') {\n\t\t\t\tcompileError(file, \"The operand must begin with an at sign (@)\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor (int k = 1; k < ruleChars.length; k++)\n\t\t\t\tscratchPad.chars[k - 1] = ruleChars.chars[k];\n\t\t\tscratchPad.length = ruleChars.length - 1;\n\t\t\tif (!parseDots(file, &ruleDots, &scratchPad)) return 0;\n\t\t\treturn addRule(file, opcode, &ruleChars, &ruleDots, before, after, NULL, NULL,\n\t\t\t\t\tnoback, nofor, table);\n\t\tcase CTO_CapsNoCont: {\n\t\t\tTranslationTableOffset ruleOffset;\n\t\t\truleChars.length = 1;\n\t\t\truleChars.chars[0] = 'a';\n\t\t\tif (!addRule(file, CTO_CapsNoContRule, &ruleChars, NULL, after, before,\n\t\t\t\t\t\t&ruleOffset, NULL, noback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\t(*table)->capsNoCont = ruleOffset;\n\t\t\treturn 1;\n\t\t}\n\t\tcase CTO_Replace:\n\t\t\tif (getRuleCharsText(file, &ruleChars)) {\n\t\t\t\tif (atEndOfLine(file))\n\t\t\t\t\truleDots.length = ruleDots.chars[0] = 0;\n\t\t\t\telse {\n\t\t\t\t\tgetRuleDotsText(file, &ruleDots);\n\t\t\t\t\tif (ruleDots.chars[0] == '#')\n\t\t\t\t\t\truleDots.length = ruleDots.chars[0] = 0;\n\t\t\t\t\telse if (ruleDots.chars[0] == '\\\\' && ruleDots.chars[1] == '#')\n\t\t\t\t\t\tmemmove(&ruleDots.chars[0], &ruleDots.chars[1],\n\t\t\t\t\t\t\t\truleDots.length-- * CHARSIZE);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int k = 0; k < ruleChars.length; k++)\n\t\t\t\tputChar(file, ruleChars.chars[k], table, NULL);\n\t\t\tfor (int k = 0; k < ruleDots.length; k++)\n\t\t\t\tputChar(file, ruleDots.chars[k], table, NULL);\n\t\t\treturn addRule(file, opcode, &ruleChars, &ruleDots, after, before, NULL, NULL,\n\t\t\t\t\tnoback, nofor, table);\n\t\tcase CTO_Correct:\n\t\t\t(*table)->corrections = 1;\n\t\t\tgoto doPass;\n\t\tcase CTO_Pass2:\n\t\t\tif ((*table)->numPasses < 2) (*table)->numPasses = 2;\n\t\t\tgoto doPass;\n\t\tcase CTO_Pass3:\n\t\t\tif ((*table)->numPasses < 3) (*table)->numPasses = 3;\n\t\t\tgoto doPass;\n\t\tcase CTO_Pass4:\n\t\t\tif ((*table)->numPasses < 4) (*table)->numPasses = 4;\n\t\tdoPass:\n\t\tcase CTO_Context:\n\t\t\tif (!(nofor || noback)) {\n\t\t\t\tcompileError(file, \"%s or %s must be specified.\",\n\t\t\t\t\t\t_lou_findOpcodeName(CTO_NoFor), _lou_findOpcodeName(CTO_NoBack));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn compilePassOpcode(file, opcode, noback, nofor, table);\n\t\tcase CTO_Contraction:\n\t\tcase CTO_NoCont:\n\t\tcase CTO_CompBrl:\n\t\tcase CTO_Literal:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\t// check that all characters in a compbrl, contraction,\n\t\t\t// nocont or literal rule are defined (or based on another\n\t\t\t// character)\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!(c && (c->definitionRule || c->basechar))) {\n\t\t\t\t\tcompileError(file, \"Character %s is not defined\",\n\t\t\t\t\t\t\t_lou_showString(&ruleChars.chars[k], 1, 0));\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn addRule(file, opcode, &ruleChars, NULL, after, before, NULL, NULL,\n\t\t\t\t\tnoback, nofor, table);\n\t\tcase CTO_MultInd: {\n\t\t\truleChars.length = 0;\n\t\t\tif (!getToken(file, &token, \"multiple braille indicators\") ||\n\t\t\t\t\t!parseDots(file, &cells, &token))\n\t\t\t\treturn 0;\n\t\t\twhile (getToken(file, &token, \"multind opcodes\")) {\n\t\t\t\topcode = getOpcode(file, &token);\n\t\t\t\tif (opcode == CTO_None) {\n\t\t\t\t\tcompileError(file, \"opcode %s not defined.\",\n\t\t\t\t\t\t\t_lou_showString(token.chars, token.length, 0));\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif (!(opcode >= CTO_CapsLetter && opcode < CTO_MultInd)) {\n\t\t\t\t\tcompileError(file, \"Not a braille indicator opcode.\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\truleChars.chars[ruleChars.length++] = (widechar)opcode;\n\t\t\t\tif (atEndOfLine(file)) break;\n\t\t\t}\n\t\t\treturn addRule(file, CTO_MultInd, &ruleChars, &cells, after, before, NULL,\n\t\t\t\t\tNULL, noback, nofor, table);\n\t\t}\n\n\t\tcase CTO_Class:\n\t\t\tcompileWarning(file, \"class is deprecated, use attribute instead\");\n\t\tcase CTO_Attribute: {\n\t\t\tif (nofor || noback) {\n\t\t\t\tcompileWarning(\n\t\t\t\t\t\tfile, \"nofor and noback not allowed before class/attribute\");\n\t\t\t}\n\t\t\tif ((opcode == CTO_Class && (*table)->usesAttributeOrClass == 1) ||\n\t\t\t\t\t(opcode == CTO_Attribute && (*table)->usesAttributeOrClass == 2)) {\n\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\"attribute and class rules must not be both present in a table\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (opcode == CTO_Class)\n\t\t\t\t(*table)->usesAttributeOrClass = 2;\n\t\t\telse\n\t\t\t\t(*table)->usesAttributeOrClass = 1;\n\t\t\tif (!getToken(file, &token, \"attribute name\")) {\n\t\t\t\tcompileError(file, \"Expected %s\", \"attribute name\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!(*table)->characterClasses && !allocateCharacterClasses(*table)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tTranslationTableCharacterAttributes attribute = 0;\n\t\t\t{\n\t\t\t\tint attrNumber = -1;\n\t\t\t\tswitch (token.chars[0]) {\n\t\t\t\tcase '0':\n\t\t\t\tcase '1':\n\t\t\t\tcase '2':\n\t\t\t\tcase '3':\n\t\t\t\tcase '4':\n\t\t\t\tcase '5':\n\t\t\t\tcase '6':\n\t\t\t\tcase '7':\n\t\t\t\tcase '8':\n\t\t\t\tcase '9':\n\t\t\t\t\tattrNumber = token.chars[0] - '0';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (attrNumber >= 0) {\n\t\t\t\t\tif (opcode == CTO_Class) {\n\t\t\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\t\t\"Invalid class name: may not contain digits, use \"\n\t\t\t\t\t\t\t\t\"attribute instead of class\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (token.length > 1 || attrNumber > 7) {\n\t\t\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\t\t\"Invalid attribute name: must be a digit between 0 and 7 \"\n\t\t\t\t\t\t\t\t\"or a word containing only letters\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (!(*table)->numberedAttributes[attrNumber])\n\t\t\t\t\t\t// attribute not used before yet: assign it a value\n\t\t\t\t\t\t(*table)->numberedAttributes[attrNumber] =\n\t\t\t\t\t\t\t\tgetNextNumberedAttribute(*table);\n\t\t\t\t\tattribute = (*table)->numberedAttributes[attrNumber];\n\t\t\t\t} else {\n\t\t\t\t\tconst CharacterClass *namedAttr = findCharacterClass(&token, *table);\n\t\t\t\t\tif (!namedAttr) {\n\t\t\t\t\t\t// no class with that name: create one\n\t\t\t\t\t\tnamedAttr = addCharacterClass(\n\t\t\t\t\t\t\t\tfile, &token.chars[0], token.length, *table, 1);\n\t\t\t\t\t\tif (!namedAttr) return 0;\n\t\t\t\t\t}\n\t\t\t\t\t// there is a class with that name or a new class was successfully\n\t\t\t\t\t// created\n\t\t\t\t\tattribute = namedAttr->attribute;\n\t\t\t\t\tif (attribute == CTC_UpperCase || attribute == CTC_LowerCase)\n\t\t\t\t\t\tattribute |= CTC_Letter;\n\t\t\t\t}\n\t\t\t}\n\t\t\tCharsString characters;\n\t\t\tif (!getCharacters(file, &characters)) return 0;\n\t\t\tfor (int i = 0; i < characters.length; i++) {\n\t\t\t\t// get the character from the table, or if it is not defined yet,\n\t\t\t\t// define it\n\t\t\t\tTranslationTableCharacter *character =\n\t\t\t\t\t\tputChar(file, characters.chars[i], table, NULL);\n\t\t\t\t// set the attribute\n\t\t\t\tcharacter->attributes |= attribute;\n\t\t\t\t// also set the attribute on the associated dots (if any)\n\t\t\t\tif (character->basechar)\n\t\t\t\t\tcharacter = (TranslationTableCharacter *)&(*table)\n\t\t\t\t\t\t\t\t\t\t->ruleArea[character->basechar];\n\t\t\t\tif (character->definitionRule) {\n\t\t\t\t\tTranslationTableRule *defRule =\n\t\t\t\t\t\t\t(TranslationTableRule *)&(*table)\n\t\t\t\t\t\t\t\t\t->ruleArea[character->definitionRule];\n\t\t\t\t\tif (defRule->dotslen == 1) {\n\t\t\t\t\t\tTranslationTableCharacter *dots =\n\t\t\t\t\t\t\t\tgetDots(defRule->charsdots[defRule->charslen], *table);\n\t\t\t\t\t\tif (dots) dots->attributes |= attribute;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\n\t\t\t{\n\t\t\t\tTranslationTableCharacterAttributes *attributes;\n\t\t\t\tconst CharacterClass *class;\n\t\t\tcase CTO_After:\n\t\t\t\tattributes = &after;\n\t\t\t\tgoto doBeforeAfter;\n\t\t\tcase CTO_Before:\n\t\t\t\tattributes = &before;\n\t\t\tdoBeforeAfter:\n\t\t\t\tif (!(*table)->characterClasses) {\n\t\t\t\t\tif (!allocateCharacterClasses(*table)) return 0;\n\t\t\t\t}\n\t\t\t\tif (!getToken(file, &token, \"attribute name\")) return 0;\n\t\t\t\tif (!(class = findCharacterClass(&token, *table))) {\n\t\t\t\t\tcompileError(file, \"attribute not defined\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t*attributes |= class->attribute;\n\t\t\t\tgoto doOpcode;\n\t\t\t}\n\t\tcase CTO_Base:\n\t\t\tif (nofor || noback) {\n\t\t\t\tcompileWarning(file, \"nofor and noback not allowed before base\");\n\t\t\t}\n\t\t\tif (!getToken(file, &token, \"attribute name\")) {\n\t\t\t\tcompileError(\n\t\t\t\t\t\tfile, \"base opcode must be followed by a valid attribute name.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!(*table)->characterClasses && !allocateCharacterClasses(*table)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tconst CharacterClass *mode = findCharacterClass(&token, *table);\n\t\t\tif (!mode) {\n\t\t\t\tmode = addCharacterClass(file, token.chars, token.length, *table, 1);\n\t\t\t\tif (!mode) return 0;\n\t\t\t}\n\t\t\tif (!(mode->attribute == CTC_UpperCase || mode->attribute == CTC_Digit) &&\n\t\t\t\t\tmode->attribute >= CTC_Space && mode->attribute <= CTC_LitDigit) {\n\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\"base opcode must be followed by \\\"uppercase\\\", \\\"digit\\\", or a \"\n\t\t\t\t\t\t\"custom attribute name.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!getRuleCharsText(file, &token)) return 0;\n\t\t\tif (token.length != 1) {\n\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\"Exactly one character followed by one base character is \"\n\t\t\t\t\t\t\"required.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tTranslationTableOffset characterOffset;\n\t\t\tTranslationTableCharacter *character =\n\t\t\t\t\tputChar(file, token.chars[0], table, &characterOffset);\n\t\t\tif (!getRuleCharsText(file, &token)) return 0;\n\t\t\tif (token.length != 1) {\n\t\t\t\tcompileError(file, \"Exactly one base character is required.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (character->definitionRule) {\n\t\t\t\tTranslationTableRule *prevRule =\n\t\t\t\t\t\t(TranslationTableRule *)&(*table)\n\t\t\t\t\t\t\t\t->ruleArea[character->definitionRule];\n\t\t\t\t_lou_logMessage(LOU_LOG_DEBUG,\n\t\t\t\t\t\t\"%s:%d: Character already defined (%s). The base rule will take \"\n\t\t\t\t\t\t\"precedence.\",\n\t\t\t\t\t\tfile->fileName, file->lineNumber,\n\t\t\t\t\t\tprintSource(file, prevRule->sourceFile, prevRule->sourceLine));\n\t\t\t\tcharacter->definitionRule = 0;\n\t\t\t}\n\t\t\tTranslationTableOffset basechar;\n\t\t\tputChar(file, token.chars[0], table, &basechar);\n\t\t\t// putChar may have moved table, so make sure character is still valid\n\t\t\tcharacter = (TranslationTableCharacter *)&(*table)->ruleArea[characterOffset];\n\t\t\tif (character->basechar) {\n\t\t\t\tif (character->basechar == basechar &&\n\t\t\t\t\t\tcharacter->mode == mode->attribute) {\n\t\t\t\t\t_lou_logMessage(LOU_LOG_DEBUG, \"%s:%d: Duplicate base rule.\",\n\t\t\t\t\t\t\tfile->fileName, file->lineNumber);\n\t\t\t\t} else {\n\t\t\t\t\t_lou_logMessage(LOU_LOG_DEBUG,\n\t\t\t\t\t\t\t\"%s:%d: A different base rule already exists for this \"\n\t\t\t\t\t\t\t\"character (%s). The new rule will take precedence.\",\n\t\t\t\t\t\t\tfile->fileName, file->lineNumber,\n\t\t\t\t\t\t\tprintSource(\n\t\t\t\t\t\t\t\t\tfile, character->sourceFile, character->sourceLine));\n\t\t\t\t}\n\t\t\t}\n\t\t\tcharacter->basechar = basechar;\n\t\t\tcharacter->mode = mode->attribute;\n\t\t\tcharacter->sourceFile = file->sourceFile;\n\t\t\tcharacter->sourceLine = file->lineNumber;\n\t\t\t/* some other processing is done at the end of the compilation, in\n\t\t\t * finalizeTable() */\n\t\t\treturn 1;\n\t\tcase CTO_EmpMatchBefore:\n\t\t\tbefore |= CTC_EmpMatch;\n\t\t\tgoto doOpcode;\n\t\tcase CTO_EmpMatchAfter:\n\t\t\tafter |= CTC_EmpMatch;\n\t\t\tgoto doOpcode;\n\n\t\tcase CTO_SwapCc:\n\t\tcase CTO_SwapCd:\n\t\tcase CTO_SwapDd:\n\t\t\treturn compileSwap(file, opcode, noback, nofor, table);\n\t\tcase CTO_Hyphen:\n\t\tcase CTO_DecPoint:\n\t\t\t//\tcase CTO_Apostrophe:\n\t\t\t//\tcase CTO_Initial:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (!getRuleDotsPattern(file, &ruleDots)) return 0;\n\t\t\tif (ruleChars.length != 1 || ruleDots.length < 1) {\n\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\"One Unicode character and at least one cell are \"\n\t\t\t\t\t\t\"required.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn addRule(file, opcode, &ruleChars, &ruleDots, after, before, NULL, NULL,\n\t\t\t\t\tnoback, nofor, table);\n\t\t\t// if (opcode == CTO_DecPoint)\n\t\t\t// {\n\t\t\t//   TranslationTableCharacter *c =\n\t\t\t//   getChar(ruleChars.chars[0]);\n\t\t\t//   if(c)\n\t\t\t//     c->attributes |= CTC_NumericMode;\n\t\t\t// }\n\t\tdefault:\n\t\t\tcompileError(file, \"unimplemented opcode.\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}", "func_hash": 114188111189139492438388270487144198902, "file_name": "compileTranslationTable.c", "file_hash": 130160890521779483138755278607355501086, "cwe": ["CWE-787"], "cve": "CVE-2022-31783", "cve_desc": "Liblouis 3.21.0 has an out-of-bounds write in compileRule in compileTranslationTable.c, as demonstrated by lou_trace.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-31783", "file_path": "liblouis/compileTranslationTable.c"}
{"idx": 482533, "project": "liblouis", "commit_id": "2e4772befb2b1c37cb4b9d6572945115ee28630a", "project_url": "https://github.com/liblouis/liblouis", "commit_url": "https://github.com/liblouis/liblouis/commit/2e4772befb2b1c37cb4b9d6572945115ee28630a", "commit_message": "Prevent an invalid memory writes in compileRule\n\nThanks to Han Zheng for reporting it\n\nFixes #1214", "target": 0, "func": "compileRule(FileInfo *file, TranslationTableHeader **table,\n\t\tDisplayTableHeader **displayTable, const MacroList **inScopeMacros) {\n\tCharsString token;\n\tTranslationTableOpcode opcode;\n\tCharsString ruleChars;\n\tCharsString ruleDots;\n\tCharsString cells;\n\tCharsString scratchPad;\n\tCharsString emphClass;\n\tTranslationTableCharacterAttributes after = 0;\n\tTranslationTableCharacterAttributes before = 0;\n\tint noback, nofor, nocross;\n\tnoback = nofor = nocross = 0;\ndoOpcode:\n\tif (!getToken(file, &token, NULL)) return 1;\t\t\t\t  /* blank line */\n\tif (token.chars[0] == '#' || token.chars[0] == '<') return 1; /* comment */\n\tif (file->lineNumber == 1 &&\n\t\t\t(eqasc2uni((unsigned char *)\"ISO\", token.chars, 3) ||\n\t\t\t\t\teqasc2uni((unsigned char *)\"UTF-8\", token.chars, 5))) {\n\t\tif (table)\n\t\t\tcompileHyphenation(file, &token, table);\n\t\telse\n\t\t\t/* ignore the whole file */\n\t\t\twhile (_lou_getALine(file))\n\t\t\t\t;\n\t\treturn 1;\n\t}\n\topcode = getOpcode(file, &token);\n\tswitch (opcode) {\n\tcase CTO_Macro: {\n\t\tconst Macro *macro;\n#ifdef ENABLE_MACROS\n\t\tif (!inScopeMacros) {\n\t\t\tcompileError(file, \"Defining macros only allowed in table files.\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (compileMacro(file, &macro)) {\n\t\t\t*inScopeMacros = cons_macro(macro, *inScopeMacros);\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n#else\n\t\tcompileError(file, \"Macro feature is disabled.\");\n\t\treturn 0;\n#endif\n\t}\n\tcase CTO_IncludeFile: {\n\t\tCharsString includedFile;\n\t\tif (!getToken(file, &token, \"include file name\")) return 0;\n\t\tif (!parseChars(file, &includedFile, &token)) return 0;\n\t\treturn includeFile(file, &includedFile, table, displayTable);\n\t}\n\tcase CTO_NoBack:\n\t\tif (nofor) {\n\t\t\tcompileError(file, \"%s already specified.\", _lou_findOpcodeName(CTO_NoFor));\n\t\t\treturn 0;\n\t\t}\n\t\tnoback = 1;\n\t\tgoto doOpcode;\n\tcase CTO_NoFor:\n\t\tif (noback) {\n\t\t\tcompileError(file, \"%s already specified.\", _lou_findOpcodeName(CTO_NoBack));\n\t\t\treturn 0;\n\t\t}\n\t\tnofor = 1;\n\t\tgoto doOpcode;\n\tcase CTO_Space:\n\t\treturn compileCharDef(\n\t\t\t\tfile, opcode, CTC_Space, noback, nofor, table, displayTable);\n\tcase CTO_Digit:\n\t\treturn compileCharDef(\n\t\t\t\tfile, opcode, CTC_Digit, noback, nofor, table, displayTable);\n\tcase CTO_LitDigit:\n\t\treturn compileCharDef(\n\t\t\t\tfile, opcode, CTC_LitDigit, noback, nofor, table, displayTable);\n\tcase CTO_Punctuation:\n\t\treturn compileCharDef(\n\t\t\t\tfile, opcode, CTC_Punctuation, noback, nofor, table, displayTable);\n\tcase CTO_Math:\n\t\treturn compileCharDef(file, opcode, CTC_Math, noback, nofor, table, displayTable);\n\tcase CTO_Sign:\n\t\treturn compileCharDef(file, opcode, CTC_Sign, noback, nofor, table, displayTable);\n\tcase CTO_Letter:\n\t\treturn compileCharDef(\n\t\t\t\tfile, opcode, CTC_Letter, noback, nofor, table, displayTable);\n\tcase CTO_UpperCase:\n\t\treturn compileCharDef(\n\t\t\t\tfile, opcode, CTC_UpperCase, noback, nofor, table, displayTable);\n\tcase CTO_LowerCase:\n\t\treturn compileCharDef(\n\t\t\t\tfile, opcode, CTC_LowerCase, noback, nofor, table, displayTable);\n\tcase CTO_Grouping:\n\t\treturn compileGrouping(file, noback, nofor, table, displayTable);\n\tcase CTO_Display:\n\t\tif (!displayTable) return 1;  // ignore\n\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\tif (!getRuleDotsPattern(file, &ruleDots)) return 0;\n\t\tif (ruleChars.length != 1 || ruleDots.length != 1) {\n\t\t\tcompileError(file, \"Exactly one character and one cell are required.\");\n\t\t\treturn 0;\n\t\t}\n\t\treturn putCharDotsMapping(\n\t\t\t\tfile, ruleChars.chars[0], ruleDots.chars[0], displayTable);\n\tcase CTO_UpLow:\n\tcase CTO_None: {\n\t\t// check if token is a macro name\n\t\tif (inScopeMacros) {\n\t\t\tconst MacroList *macros = *inScopeMacros;\n\t\t\twhile (macros) {\n\t\t\t\tconst Macro *m = macros->head;\n\t\t\t\tif (token.length == strlen(m->name) &&\n\t\t\t\t\t\teqasc2uni((unsigned char *)m->name, token.chars, token.length)) {\n\t\t\t\t\tif (!inScopeMacros) {\n\t\t\t\t\t\tcompileError(file, \"Calling macros only allowed in table files.\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tFileInfo tmpFile;\n\t\t\t\t\tmemset(&tmpFile, 0, sizeof(tmpFile));\n\t\t\t\t\ttmpFile.fileName = file->fileName;\n\t\t\t\t\ttmpFile.sourceFile = file->sourceFile;\n\t\t\t\t\ttmpFile.lineNumber = file->lineNumber;\n\t\t\t\t\ttmpFile.encoding = noEncoding;\n\t\t\t\t\ttmpFile.status = 0;\n\t\t\t\t\ttmpFile.linepos = 0;\n\t\t\t\t\ttmpFile.linelen = 0;\n\t\t\t\t\tint argument_count = 0;\n\t\t\t\t\tCharsString *arguments =\n\t\t\t\t\t\t\tmalloc(m->argument_count * sizeof(CharsString));\n\t\t\t\t\twhile (argument_count < m->argument_count) {\n\t\t\t\t\t\tif (getToken(file, &token, \"macro argument\"))\n\t\t\t\t\t\t\targuments[argument_count++] = token;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (argument_count < m->argument_count) {\n\t\t\t\t\t\tcompileError(file, \"Expected %d arguments\", m->argument_count);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tint i = 0;\n\t\t\t\t\tint subst = 0;\n\t\t\t\t\tint next = subst < m->substitution_count ? m->substitutions[2 * subst]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t : m->definition_length;\n\t\t\t\t\tfor (;;) {\n\t\t\t\t\t\twhile (i < next) {\n\t\t\t\t\t\t\twidechar c = m->definition[i++];\n\t\t\t\t\t\t\tif (c == '\\n') {\n\t\t\t\t\t\t\t\tif (!compileRule(&tmpFile, table, displayTable,\n\t\t\t\t\t\t\t\t\t\t\tinScopeMacros)) {\n\t\t\t\t\t\t\t\t\t_lou_logMessage(LOU_LOG_ERROR,\n\t\t\t\t\t\t\t\t\t\t\t\"result of macro expansion was: %s\",\n\t\t\t\t\t\t\t\t\t\t\t_lou_showString(\n\t\t\t\t\t\t\t\t\t\t\t\t\ttmpFile.line, tmpFile.linelen, 0));\n\t\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttmpFile.linepos = 0;\n\t\t\t\t\t\t\t\ttmpFile.linelen = 0;\n\t\t\t\t\t\t\t} else if (tmpFile.linelen >= MAXSTRING) {\n\t\t\t\t\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\t\t\t\t\"Line exceeds %d characters (post macro \"\n\t\t\t\t\t\t\t\t\t\t\"expansion)\",\n\t\t\t\t\t\t\t\t\t\tMAXSTRING);\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\ttmpFile.line[tmpFile.linelen++] = c;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (subst < m->substitution_count) {\n\t\t\t\t\t\t\tCharsString arg =\n\t\t\t\t\t\t\t\t\targuments[m->substitutions[2 * subst + 1] - 1];\n\t\t\t\t\t\t\tfor (int j = 0; j < arg.length; j++)\n\t\t\t\t\t\t\t\ttmpFile.line[tmpFile.linelen++] = arg.chars[j];\n\t\t\t\t\t\t\tsubst++;\n\t\t\t\t\t\t\tnext = subst < m->substitution_count\n\t\t\t\t\t\t\t\t\t? m->substitutions[2 * subst]\n\t\t\t\t\t\t\t\t\t: m->definition_length;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (!compileRule(\n\t\t\t\t\t\t\t\t\t\t&tmpFile, table, displayTable, inScopeMacros)) {\n\t\t\t\t\t\t\t\t_lou_logMessage(LOU_LOG_ERROR,\n\t\t\t\t\t\t\t\t\t\t\"result of macro expansion was: %s\",\n\t\t\t\t\t\t\t\t\t\t_lou_showString(\n\t\t\t\t\t\t\t\t\t\t\t\ttmpFile.line, tmpFile.linelen, 0));\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tmacros = macros->tail;\n\t\t\t}\n\t\t}\n\t\tif (opcode == CTO_UpLow) {\n\t\t\tcompileError(file, \"The uplow opcode is deprecated.\");\n\t\t\treturn 0;\n\t\t}\n\t\tcompileError(file, \"opcode %s not defined.\",\n\t\t\t\t_lou_showString(token.chars, token.length, 0));\n\t\treturn 0;\n\t}\n\n\t/* now only opcodes follow that don't modify the display table */\n\tdefault:\n\t\tif (!table) return 1;\n\t\tswitch (opcode) {\n\t\tcase CTO_Locale:\n\t\t\tcompileWarning(file,\n\t\t\t\t\t\"The locale opcode is not implemented. Use the locale meta data \"\n\t\t\t\t\t\"instead.\");\n\t\t\treturn 1;\n\t\tcase CTO_Undefined: {\n\t\t\t// not passing pointer because compileBrailleIndicator may reallocate table\n\t\t\tTranslationTableOffset ruleOffset = (*table)->undefined;\n\t\t\tif (!compileBrailleIndicator(file, \"undefined character opcode\",\n\t\t\t\t\t\tCTO_Undefined, &ruleOffset, noback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\t(*table)->undefined = ruleOffset;\n\t\t\treturn 1;\n\t\t}\n\t\tcase CTO_Match: {\n\t\t\tint ok = 0;\n\t\t\twidechar *patterns = NULL;\n\t\t\tTranslationTableRule *rule;\n\t\t\tTranslationTableOffset ruleOffset;\n\t\t\tCharsString ptn_before, ptn_after;\n\t\t\tTranslationTableOffset patternsOffset;\n\t\t\tint len, mrk;\n\t\t\tsize_t patternsByteSize = sizeof(*patterns) * 27720;\n\t\t\tpatterns = (widechar *)malloc(patternsByteSize);\n\t\t\tif (!patterns) _lou_outOfMemory();\n\t\t\tmemset(patterns, 0xffff, patternsByteSize);\n\t\t\tnoback = 1;\n\t\t\tgetCharacters(file, &ptn_before);\n\t\t\tgetRuleCharsText(file, &ruleChars);\n\t\t\tgetCharacters(file, &ptn_after);\n\t\t\tgetRuleDotsPattern(file, &ruleDots);\n\t\t\tif (!addRule(file, opcode, &ruleChars, &ruleDots, after, before, &ruleOffset,\n\t\t\t\t\t\t&rule, noback, nofor, table))\n\t\t\t\tgoto CTO_Match_cleanup;\n\t\t\tif (ptn_before.chars[0] == '-' && ptn_before.length == 1)\n\t\t\t\tlen = _lou_pattern_compile(\n\t\t\t\t\t\t&ptn_before.chars[0], 0, &patterns[1], 13841, *table, file);\n\t\t\telse\n\t\t\t\tlen = _lou_pattern_compile(&ptn_before.chars[0], ptn_before.length,\n\t\t\t\t\t\t&patterns[1], 13841, *table, file);\n\t\t\tif (!len) goto CTO_Match_cleanup;\n\t\t\tmrk = patterns[0] = len + 1;\n\t\t\t_lou_pattern_reverse(&patterns[1]);\n\t\t\tif (ptn_after.chars[0] == '-' && ptn_after.length == 1)\n\t\t\t\tlen = _lou_pattern_compile(\n\t\t\t\t\t\t&ptn_after.chars[0], 0, &patterns[mrk], 13841, *table, file);\n\t\t\telse\n\t\t\t\tlen = _lou_pattern_compile(&ptn_after.chars[0], ptn_after.length,\n\t\t\t\t\t\t&patterns[mrk], 13841, *table, file);\n\t\t\tif (!len) goto CTO_Match_cleanup;\n\t\t\tlen += mrk;\n\t\t\tif (!allocateSpaceInTranslationTable(\n\t\t\t\t\t\tfile, &patternsOffset, len * sizeof(widechar), table))\n\t\t\t\tgoto CTO_Match_cleanup;\n\t\t\t// allocateSpaceInTranslationTable may have moved table, so make sure rule is\n\t\t\t// still valid\n\t\t\trule = (TranslationTableRule *)&(*table)->ruleArea[ruleOffset];\n\t\t\tmemcpy(&(*table)->ruleArea[patternsOffset], patterns, len * sizeof(widechar));\n\t\t\trule->patterns = patternsOffset;\n\t\t\tok = 1;\n\t\tCTO_Match_cleanup:\n\t\t\tfree(patterns);\n\t\t\treturn ok;\n\t\t}\n\n\t\tcase CTO_BackMatch: {\n\t\t\tint ok = 0;\n\t\t\twidechar *patterns = NULL;\n\t\t\tTranslationTableRule *rule;\n\t\t\tTranslationTableOffset ruleOffset;\n\t\t\tCharsString ptn_before, ptn_after;\n\t\t\tTranslationTableOffset patternOffset;\n\t\t\tint len, mrk;\n\t\t\tsize_t patternsByteSize = sizeof(*patterns) * 27720;\n\t\t\tpatterns = (widechar *)malloc(patternsByteSize);\n\t\t\tif (!patterns) _lou_outOfMemory();\n\t\t\tmemset(patterns, 0xffff, patternsByteSize);\n\t\t\tnofor = 1;\n\t\t\tgetCharacters(file, &ptn_before);\n\t\t\tgetRuleCharsText(file, &ruleChars);\n\t\t\tgetCharacters(file, &ptn_after);\n\t\t\tgetRuleDotsPattern(file, &ruleDots);\n\t\t\tif (!addRule(file, opcode, &ruleChars, &ruleDots, 0, 0, &ruleOffset, &rule,\n\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\tgoto CTO_BackMatch_cleanup;\n\t\t\tif (ptn_before.chars[0] == '-' && ptn_before.length == 1)\n\t\t\t\tlen = _lou_pattern_compile(\n\t\t\t\t\t\t&ptn_before.chars[0], 0, &patterns[1], 13841, *table, file);\n\t\t\telse\n\t\t\t\tlen = _lou_pattern_compile(&ptn_before.chars[0], ptn_before.length,\n\t\t\t\t\t\t&patterns[1], 13841, *table, file);\n\t\t\tif (!len) goto CTO_BackMatch_cleanup;\n\t\t\tmrk = patterns[0] = len + 1;\n\t\t\t_lou_pattern_reverse(&patterns[1]);\n\t\t\tif (ptn_after.chars[0] == '-' && ptn_after.length == 1)\n\t\t\t\tlen = _lou_pattern_compile(\n\t\t\t\t\t\t&ptn_after.chars[0], 0, &patterns[mrk], 13841, *table, file);\n\t\t\telse\n\t\t\t\tlen = _lou_pattern_compile(&ptn_after.chars[0], ptn_after.length,\n\t\t\t\t\t\t&patterns[mrk], 13841, *table, file);\n\t\t\tif (!len) goto CTO_BackMatch_cleanup;\n\t\t\tlen += mrk;\n\t\t\tif (!allocateSpaceInTranslationTable(\n\t\t\t\t\t\tfile, &patternOffset, len * sizeof(widechar), table))\n\t\t\t\tgoto CTO_BackMatch_cleanup;\n\t\t\t// allocateSpaceInTranslationTable may have moved table, so make sure rule is\n\t\t\t// still valid\n\t\t\trule = (TranslationTableRule *)&(*table)->ruleArea[ruleOffset];\n\t\t\tmemcpy(&(*table)->ruleArea[patternOffset], patterns, len * sizeof(widechar));\n\t\t\trule->patterns = patternOffset;\n\t\t\tok = 1;\n\t\tCTO_BackMatch_cleanup:\n\t\t\tfree(patterns);\n\t\t\treturn ok;\n\t\t}\n\n\t\tcase CTO_CapsLetter:\n\t\tcase CTO_BegCapsWord:\n\t\tcase CTO_EndCapsWord:\n\t\tcase CTO_BegCaps:\n\t\tcase CTO_EndCaps:\n\t\tcase CTO_BegCapsPhrase:\n\t\tcase CTO_EndCapsPhrase:\n\t\tcase CTO_LenCapsPhrase:\n\t\t/* these 8 general purpose opcodes are compiled further down to more specific\n\t\t * internal opcodes:\n\t\t * - modeletter\n\t\t * - begmodeword\n\t\t * - endmodeword\n\t\t * - begmode\n\t\t * - endmode\n\t\t * - begmodephrase\n\t\t * - endmodephrase\n\t\t * - lenmodephrase\n\t\t */\n\t\tcase CTO_ModeLetter:\n\t\tcase CTO_BegModeWord:\n\t\tcase CTO_EndModeWord:\n\t\tcase CTO_BegMode:\n\t\tcase CTO_EndMode:\n\t\tcase CTO_BegModePhrase:\n\t\tcase CTO_EndModePhrase:\n\t\tcase CTO_LenModePhrase: {\n\t\t\tTranslationTableCharacterAttributes mode;\n\t\t\tint i;\n\t\t\tswitch (opcode) {\n\t\t\tcase CTO_CapsLetter:\n\t\t\tcase CTO_BegCapsWord:\n\t\t\tcase CTO_EndCapsWord:\n\t\t\tcase CTO_BegCaps:\n\t\t\tcase CTO_EndCaps:\n\t\t\tcase CTO_BegCapsPhrase:\n\t\t\tcase CTO_EndCapsPhrase:\n\t\t\tcase CTO_LenCapsPhrase:\n\t\t\t\tmode = CTC_UpperCase;\n\t\t\t\ti = 0;\n\t\t\t\topcode += (CTO_ModeLetter - CTO_CapsLetter);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (!getToken(file, &token, \"attribute name\")) return 0;\n\t\t\t\tif (!(*table)->characterClasses && !allocateCharacterClasses(*table)) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tconst CharacterClass *characterClass = findCharacterClass(&token, *table);\n\t\t\t\tif (!characterClass) {\n\t\t\t\t\tcharacterClass =\n\t\t\t\t\t\t\taddCharacterClass(file, token.chars, token.length, *table, 1);\n\t\t\t\t\tif (!characterClass) return 0;\n\t\t\t\t}\n\t\t\t\tmode = characterClass->attribute;\n\t\t\t\tif (!(mode == CTC_UpperCase || mode == CTC_Digit) && mode >= CTC_Space &&\n\t\t\t\t\t\tmode <= CTC_LitDigit) {\n\t\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\t\"mode must be \\\"uppercase\\\", \\\"digit\\\", or a custom \"\n\t\t\t\t\t\t\t\"attribute name.\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t/* check if this mode is already defined and if the number of modes does\n\t\t\t\t * not exceed the maximal number */\n\t\t\t\tif (mode == CTC_UpperCase)\n\t\t\t\t\ti = 0;\n\t\t\t\telse {\n\t\t\t\t\tfor (i = 1; i < MAX_MODES && (*table)->modes[i].value; i++) {\n\t\t\t\t\t\tif ((*table)->modes[i].mode == mode) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (i == MAX_MODES) {\n\t\t\t\t\t\tcompileError(file, \"Max number of modes (%i) reached\", MAX_MODES);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!(*table)->modes[i].value)\n\t\t\t\t(*table)->modes[i] = (EmphasisClass){ plain_text, mode,\n\t\t\t\t\t0x1 << (MAX_EMPH_CLASSES + i), MAX_EMPH_CLASSES + i };\n\t\t\tswitch (opcode) {\n\t\t\tcase CTO_BegModePhrase: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][begPhraseOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"first word capital sign\",\n\t\t\t\t\t\t\tCTO_BegCapsPhraseRule + (8 * i), &ruleOffset, noback, nofor,\n\t\t\t\t\t\t\ttable))\n\t\t\t\t\treturn 0;\n\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][begPhraseOffset] = ruleOffset;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcase CTO_EndModePhrase: {\n\t\t\t\tTranslationTableOffset ruleOffset;\n\t\t\t\tswitch (compileBeforeAfter(file)) {\n\t\t\t\tcase 1:\t // before\n\t\t\t\t\tif ((*table)->emphRules[MAX_EMPH_CLASSES + i][endPhraseAfterOffset]) {\n\t\t\t\t\t\tcompileError(\n\t\t\t\t\t\t\t\tfile, \"Capital sign after last word already defined.\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t\t// table\n\t\t\t\t\truleOffset = (*table)->emphRules[MAX_EMPH_CLASSES + i]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[endPhraseBeforeOffset];\n\t\t\t\t\tif (!compileBrailleIndicator(file, \"capital sign before last word\",\n\t\t\t\t\t\t\t\tCTO_EndCapsPhraseBeforeRule + (8 * i), &ruleOffset,\n\t\t\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][endPhraseBeforeOffset] =\n\t\t\t\t\t\t\truleOffset;\n\t\t\t\t\treturn 1;\n\t\t\t\tcase 2:\t // after\n\t\t\t\t\tif ((*table)->emphRules[MAX_EMPH_CLASSES + i]\n\t\t\t\t\t\t\t\t\t\t   [endPhraseBeforeOffset]) {\n\t\t\t\t\t\tcompileError(\n\t\t\t\t\t\t\t\tfile, \"Capital sign before last word already defined.\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t\t// table\n\t\t\t\t\truleOffset = (*table)->emphRules[MAX_EMPH_CLASSES + i]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[endPhraseAfterOffset];\n\t\t\t\t\tif (!compileBrailleIndicator(file, \"capital sign after last word\",\n\t\t\t\t\t\t\t\tCTO_EndCapsPhraseAfterRule + (8 * i), &ruleOffset, noback,\n\t\t\t\t\t\t\t\tnofor, table))\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][endPhraseAfterOffset] =\n\t\t\t\t\t\t\truleOffset;\n\t\t\t\t\treturn 1;\n\t\t\t\tdefault:  // error\n\t\t\t\t\tcompileError(file, \"Invalid lastword indicator location.\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcase CTO_BegMode: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][begOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"first letter capital sign\",\n\t\t\t\t\t\t\tCTO_BegCapsRule + (8 * i), &ruleOffset, noback, nofor, table))\n\t\t\t\t\treturn 0;\n\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][begOffset] = ruleOffset;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcase CTO_EndMode: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][endOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"last letter capital sign\",\n\t\t\t\t\t\t\tCTO_EndCapsRule + (8 * i), &ruleOffset, noback, nofor, table))\n\t\t\t\t\treturn 0;\n\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][endOffset] = ruleOffset;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcase CTO_ModeLetter: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][letterOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"single letter capital sign\",\n\t\t\t\t\t\t\tCTO_CapsLetterRule + (8 * i), &ruleOffset, noback, nofor,\n\t\t\t\t\t\t\ttable))\n\t\t\t\t\treturn 0;\n\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][letterOffset] = ruleOffset;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcase CTO_BegModeWord: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][begWordOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"capital word\",\n\t\t\t\t\t\t\tCTO_BegCapsWordRule + (8 * i), &ruleOffset, noback, nofor,\n\t\t\t\t\t\t\ttable))\n\t\t\t\t\treturn 0;\n\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][begWordOffset] = ruleOffset;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcase CTO_EndModeWord: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][endWordOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"capital word stop\",\n\t\t\t\t\t\t\tCTO_EndCapsWordRule + (8 * i), &ruleOffset, noback, nofor,\n\t\t\t\t\t\t\ttable))\n\t\t\t\t\treturn 0;\n\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][endWordOffset] = ruleOffset;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcase CTO_LenModePhrase:\n\t\t\t\treturn (*table)->emphRules[MAX_EMPH_CLASSES + i][lenPhraseOffset] =\n\t\t\t\t\t\t\t   compileNumber(file);\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/* these 8 general purpose emphasis opcodes are compiled further down to more\n\t\t * specific internal opcodes:\n\t\t * - emphletter\n\t\t * - begemphword\n\t\t * - endemphword\n\t\t * - begemph\n\t\t * - endemph\n\t\t * - begemphphrase\n\t\t * - endemphphrase\n\t\t * - lenemphphrase\n\t\t */\n\t\tcase CTO_EmphClass:\n\t\t\tif (!getToken(file, &emphClass, \"emphasis class\")) {\n\t\t\t\tcompileError(file, \"emphclass must be followed by a valid class name.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tint k, i;\n\t\t\tchar *s = malloc(sizeof(char) * (emphClass.length + 1));\n\t\t\tfor (k = 0; k < emphClass.length; k++) s[k] = (char)emphClass.chars[k];\n\t\t\ts[k++] = '\\0';\n\t\t\tfor (i = 0; i < MAX_EMPH_CLASSES && (*table)->emphClassNames[i]; i++)\n\t\t\t\tif (strcmp(s, (*table)->emphClassNames[i]) == 0) {\n\t\t\t\t\t_lou_logMessage(LOU_LOG_WARN, \"Duplicate emphasis class: %s\", s);\n\t\t\t\t\twarningCount++;\n\t\t\t\t\tfree(s);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\tif (i == MAX_EMPH_CLASSES) {\n\t\t\t\t_lou_logMessage(LOU_LOG_ERROR,\n\t\t\t\t\t\t\"Max number of emphasis classes (%i) reached\", MAX_EMPH_CLASSES);\n\t\t\t\terrorCount++;\n\t\t\t\tfree(s);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tswitch (i) {\n\t\t\t/* For backwards compatibility (i.e. because programs will assume\n\t\t\t * the first 3 typeform bits are `italic', `underline' and `bold')\n\t\t\t * we require that the first 3 emphclass definitions are (in that\n\t\t\t * order):\n\t\t\t *\n\t\t\t *   emphclass italic\n\t\t\t *   emphclass underline\n\t\t\t *   emphclass bold\n\t\t\t *\n\t\t\t * While it would be possible to use the emphclass opcode only for\n\t\t\t * defining _additional_ classes (not allowing for them to be called\n\t\t\t * italic, underline or bold), thereby reducing the amount of\n\t\t\t * boilerplate, we deliberately choose not to do that in order to\n\t\t\t * not give italic, underline and bold any special status. The\n\t\t\t * hope is that eventually all programs will use liblouis for\n\t\t\t * emphasis the recommended way (i.e. by looking up the supported\n\t\t\t * typeforms in the documentation or API) so that we can drop this\n\t\t\t * restriction.\n\t\t\t */\n\t\t\tcase 0:\n\t\t\t\tif (strcmp(s, \"italic\") != 0) {\n\t\t\t\t\t_lou_logMessage(LOU_LOG_ERROR,\n\t\t\t\t\t\t\t\"First emphasis class must be \\\"italic\\\" but got \"\n\t\t\t\t\t\t\t\"%s\",\n\t\t\t\t\t\t\ts);\n\t\t\t\t\terrorCount++;\n\t\t\t\t\tfree(s);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tif (strcmp(s, \"underline\") != 0) {\n\t\t\t\t\t_lou_logMessage(LOU_LOG_ERROR,\n\t\t\t\t\t\t\t\"Second emphasis class must be \\\"underline\\\" but \"\n\t\t\t\t\t\t\t\"got \"\n\t\t\t\t\t\t\t\"%s\",\n\t\t\t\t\t\t\ts);\n\t\t\t\t\terrorCount++;\n\t\t\t\t\tfree(s);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tif (strcmp(s, \"bold\") != 0) {\n\t\t\t\t\t_lou_logMessage(LOU_LOG_ERROR,\n\t\t\t\t\t\t\t\"Third emphasis class must be \\\"bold\\\" but got \"\n\t\t\t\t\t\t\t\"%s\",\n\t\t\t\t\t\t\ts);\n\t\t\t\t\terrorCount++;\n\t\t\t\t\tfree(s);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t(*table)->emphClassNames[i] = s;\n\t\t\t(*table)->emphClasses[i] = (EmphasisClass){ emph_1\n\t\t\t\t\t\t<< i, /* relies on the order of typeforms emph_1..emph_10 */\n\t\t\t\t0, 0x1 << i, i };\n\t\t\treturn 1;\n\t\tcase CTO_EmphLetter:\n\t\tcase CTO_BegEmphWord:\n\t\tcase CTO_EndEmphWord:\n\t\tcase CTO_BegEmph:\n\t\tcase CTO_EndEmph:\n\t\tcase CTO_BegEmphPhrase:\n\t\tcase CTO_EndEmphPhrase:\n\t\tcase CTO_LenEmphPhrase:\n\t\tcase CTO_EmphModeChars:\n\t\tcase CTO_NoEmphChars: {\n\t\t\tif (!getToken(file, &token, \"emphasis class\")) return 0;\n\t\t\tif (!parseChars(file, &emphClass, &token)) return 0;\n\t\t\tchar *s = malloc(sizeof(char) * (emphClass.length + 1));\n\t\t\tint k, i;\n\t\t\tfor (k = 0; k < emphClass.length; k++) s[k] = (char)emphClass.chars[k];\n\t\t\ts[k++] = '\\0';\n\t\t\tfor (i = 0; i < MAX_EMPH_CLASSES && (*table)->emphClassNames[i]; i++)\n\t\t\t\tif (strcmp(s, (*table)->emphClassNames[i]) == 0) break;\n\t\t\tif (i == MAX_EMPH_CLASSES || !(*table)->emphClassNames[i]) {\n\t\t\t\t_lou_logMessage(LOU_LOG_ERROR, \"Emphasis class %s not declared\", s);\n\t\t\t\terrorCount++;\n\t\t\t\tfree(s);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tint ok = 0;\n\t\t\tswitch (opcode) {\n\t\t\tcase CTO_EmphLetter: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset = (*table)->emphRules[i][letterOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"single letter\",\n\t\t\t\t\t\t\tCTO_Emph1LetterRule + letterOffset + (8 * i), &ruleOffset,\n\t\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\t\tbreak;\n\t\t\t\t(*table)->emphRules[i][letterOffset] = ruleOffset;\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CTO_BegEmphWord: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset = (*table)->emphRules[i][begWordOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"word\",\n\t\t\t\t\t\t\tCTO_Emph1LetterRule + begWordOffset + (8 * i), &ruleOffset,\n\t\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\t\tbreak;\n\t\t\t\t(*table)->emphRules[i][begWordOffset] = ruleOffset;\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CTO_EndEmphWord: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset = (*table)->emphRules[i][endWordOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"word stop\",\n\t\t\t\t\t\t\tCTO_Emph1LetterRule + endWordOffset + (8 * i), &ruleOffset,\n\t\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\t\tbreak;\n\t\t\t\t(*table)->emphRules[i][endWordOffset] = ruleOffset;\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CTO_BegEmph: {\n\t\t\t\t/* fail if both begemph and any of begemphphrase or begemphword are\n\t\t\t\t * defined */\n\t\t\t\tif ((*table)->emphRules[i][begWordOffset] ||\n\t\t\t\t\t\t(*table)->emphRules[i][begPhraseOffset]) {\n\t\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\t\"Cannot define emphasis for both no context and word or \"\n\t\t\t\t\t\t\t\"phrase context, i.e. cannot have both begemph and \"\n\t\t\t\t\t\t\t\"begemphword or begemphphrase.\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset = (*table)->emphRules[i][begOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"first letter\",\n\t\t\t\t\t\t\tCTO_Emph1LetterRule + begOffset + (8 * i), &ruleOffset,\n\t\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\t\tbreak;\n\t\t\t\t(*table)->emphRules[i][begOffset] = ruleOffset;\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CTO_EndEmph: {\n\t\t\t\tif ((*table)->emphRules[i][endWordOffset] ||\n\t\t\t\t\t\t(*table)->emphRules[i][endPhraseBeforeOffset] ||\n\t\t\t\t\t\t(*table)->emphRules[i][endPhraseAfterOffset]) {\n\t\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\t\"Cannot define emphasis for both no context and word or \"\n\t\t\t\t\t\t\t\"phrase context, i.e. cannot have both endemph and \"\n\t\t\t\t\t\t\t\"endemphword or endemphphrase.\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset = (*table)->emphRules[i][endOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"last letter\",\n\t\t\t\t\t\t\tCTO_Emph1LetterRule + endOffset + (8 * i), &ruleOffset,\n\t\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\t\tbreak;\n\t\t\t\t(*table)->emphRules[i][endOffset] = ruleOffset;\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CTO_BegEmphPhrase: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t(*table)->emphRules[i][begPhraseOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"first word\",\n\t\t\t\t\t\t\tCTO_Emph1LetterRule + begPhraseOffset + (8 * i), &ruleOffset,\n\t\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\t\tbreak;\n\t\t\t\t(*table)->emphRules[i][begPhraseOffset] = ruleOffset;\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CTO_EndEmphPhrase:\n\t\t\t\tswitch (compileBeforeAfter(file)) {\n\t\t\t\tcase 1: {  // before\n\t\t\t\t\tif ((*table)->emphRules[i][endPhraseAfterOffset]) {\n\t\t\t\t\t\tcompileError(file, \"last word after already defined.\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t\t// table\n\t\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t\t(*table)->emphRules[i][endPhraseBeforeOffset];\n\t\t\t\t\tif (!compileBrailleIndicator(file, \"last word before\",\n\t\t\t\t\t\t\t\tCTO_Emph1LetterRule + endPhraseBeforeOffset + (8 * i),\n\t\t\t\t\t\t\t\t&ruleOffset, noback, nofor, table))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t(*table)->emphRules[i][endPhraseBeforeOffset] = ruleOffset;\n\t\t\t\t\tok = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 2: {  // after\n\t\t\t\t\tif ((*table)->emphRules[i][endPhraseBeforeOffset]) {\n\t\t\t\t\t\tcompileError(file, \"last word before already defined.\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t\t// table\n\t\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t\t(*table)->emphRules[i][endPhraseAfterOffset];\n\t\t\t\t\tif (!compileBrailleIndicator(file, \"last word after\",\n\t\t\t\t\t\t\t\tCTO_Emph1LetterRule + endPhraseAfterOffset + (8 * i),\n\t\t\t\t\t\t\t\t&ruleOffset, noback, nofor, table))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t(*table)->emphRules[i][endPhraseAfterOffset] = ruleOffset;\n\t\t\t\t\tok = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdefault:  // error\n\t\t\t\t\tcompileError(file, \"Invalid lastword indicator location.\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CTO_LenEmphPhrase:\n\t\t\t\tif (((*table)->emphRules[i][lenPhraseOffset] = compileNumber(file)))\n\t\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\tcase CTO_EmphModeChars: {\n\t\t\t\tif (!getRuleCharsText(file, &ruleChars)) break;\n\t\t\t\twidechar *emphmodechars = (*table)->emphModeChars[i];\n\t\t\t\tint len;\n\t\t\t\tfor (len = 0; len < EMPHMODECHARSSIZE && emphmodechars[len]; len++)\n\t\t\t\t\t;\n\t\t\t\tif (len + ruleChars.length > EMPHMODECHARSSIZE) {\n\t\t\t\t\tcompileError(file, \"More than %d characters\", EMPHMODECHARSSIZE);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tok = 1;\n\t\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\t\tif (!getChar(ruleChars.chars[k], *table, NULL)) {\n\t\t\t\t\t\tcompileError(file, \"Emphasis mode character undefined\");\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\temphmodechars[len++] = ruleChars.chars[k];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CTO_NoEmphChars: {\n\t\t\t\tif (!getRuleCharsText(file, &ruleChars)) break;\n\t\t\t\twidechar *noemphchars = (*table)->noEmphChars[i];\n\t\t\t\tint len;\n\t\t\t\tfor (len = 0; len < NOEMPHCHARSSIZE && noemphchars[len]; len++)\n\t\t\t\t\t;\n\t\t\t\tif (len + ruleChars.length > NOEMPHCHARSSIZE) {\n\t\t\t\t\tcompileError(file, \"More than %d characters\", NOEMPHCHARSSIZE);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tok = 1;\n\t\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\t\tif (!getChar(ruleChars.chars[k], *table, NULL)) {\n\t\t\t\t\t\tcompileError(file, \"Character undefined\");\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tnoemphchars[len++] = ruleChars.chars[k];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfree(s);\n\t\t\treturn ok;\n\t\t}\n\t\tcase CTO_LetterSign: {\n\t\t\t// not passing pointer because compileBrailleIndicator may reallocate table\n\t\t\tTranslationTableOffset ruleOffset = (*table)->letterSign;\n\t\t\tif (!compileBrailleIndicator(file, \"letter sign\", CTO_LetterRule, &ruleOffset,\n\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\t(*table)->letterSign = ruleOffset;\n\t\t\treturn 1;\n\t\t}\n\t\tcase CTO_NoLetsignBefore:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (((*table)->noLetsignBeforeCount + ruleChars.length) > LETSIGNBEFORESIZE) {\n\t\t\t\tcompileError(file, \"More than %d characters\", LETSIGNBEFORESIZE);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor (int k = 0; k < ruleChars.length; k++)\n\t\t\t\t(*table)->noLetsignBefore[(*table)->noLetsignBeforeCount++] =\n\t\t\t\t\t\truleChars.chars[k];\n\t\t\treturn 1;\n\t\tcase CTO_NoLetsign:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (((*table)->noLetsignCount + ruleChars.length) > LETSIGNSIZE) {\n\t\t\t\tcompileError(file, \"More than %d characters\", LETSIGNSIZE);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor (int k = 0; k < ruleChars.length; k++)\n\t\t\t\t(*table)->noLetsign[(*table)->noLetsignCount++] = ruleChars.chars[k];\n\t\t\treturn 1;\n\t\tcase CTO_NoLetsignAfter:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (((*table)->noLetsignAfterCount + ruleChars.length) > LETSIGNAFTERSIZE) {\n\t\t\t\tcompileError(file, \"More than %d characters\", LETSIGNAFTERSIZE);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor (int k = 0; k < ruleChars.length; k++)\n\t\t\t\t(*table)->noLetsignAfter[(*table)->noLetsignAfterCount++] =\n\t\t\t\t\t\truleChars.chars[k];\n\t\t\treturn 1;\n\t\tcase CTO_NumberSign: {\n\t\t\t// not passing pointer because compileBrailleIndicator may reallocate table\n\t\t\tTranslationTableOffset ruleOffset = (*table)->numberSign;\n\t\t\tif (!compileBrailleIndicator(file, \"number sign\", CTO_NumberRule, &ruleOffset,\n\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\t(*table)->numberSign = ruleOffset;\n\t\t\treturn 1;\n\t\t}\n\n\t\tcase CTO_NumericModeChars:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!c) {\n\t\t\t\t\tcompileError(file, \"Numeric mode character undefined: %s\",\n\t\t\t\t\t\t\t_lou_showString(&ruleChars.chars[k], 1, 0));\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc->attributes |= CTC_NumericMode;\n\t\t\t\t(*table)->usesNumericMode = 1;\n\t\t\t}\n\t\t\treturn 1;\n\n\t\tcase CTO_MidEndNumericModeChars:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!c) {\n\t\t\t\t\tcompileError(file, \"Midendnumeric mode character undefined\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc->attributes |= CTC_MidEndNumericMode;\n\t\t\t\t(*table)->usesNumericMode = 1;\n\t\t\t}\n\t\t\treturn 1;\n\n\t\tcase CTO_NumericNoContractChars:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!c) {\n\t\t\t\t\tcompileError(file, \"Numeric no contraction character undefined\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc->attributes |= CTC_NumericNoContract;\n\t\t\t\t(*table)->usesNumericMode = 1;\n\t\t\t}\n\t\t\treturn 1;\n\n\t\tcase CTO_NoContractSign: {\n\t\t\t// not passing pointer because compileBrailleIndicator may reallocate table\n\t\t\tTranslationTableOffset ruleOffset = (*table)->noContractSign;\n\t\t\tif (!compileBrailleIndicator(file, \"no contractions sign\", CTO_NoContractRule,\n\t\t\t\t\t\t&ruleOffset, noback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\t(*table)->noContractSign = ruleOffset;\n\t\t\treturn 1;\n\t\t}\n\t\tcase CTO_SeqDelimiter:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!c) {\n\t\t\t\t\tcompileError(file, \"Sequence delimiter character undefined\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc->attributes |= CTC_SeqDelimiter;\n\t\t\t\t(*table)->usesSequences = 1;\n\t\t\t}\n\t\t\treturn 1;\n\n\t\tcase CTO_SeqBeforeChars:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!c) {\n\t\t\t\t\tcompileError(file, \"Sequence before character undefined\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc->attributes |= CTC_SeqBefore;\n\t\t\t}\n\t\t\treturn 1;\n\n\t\tcase CTO_SeqAfterChars:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!c) {\n\t\t\t\t\tcompileError(file, \"Sequence after character undefined\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc->attributes |= CTC_SeqAfter;\n\t\t\t}\n\t\t\treturn 1;\n\n\t\tcase CTO_SeqAfterPattern:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (((*table)->seqPatternsCount + ruleChars.length + 1) > SEQPATTERNSIZE) {\n\t\t\t\tcompileError(file, \"More than %d characters\", SEQPATTERNSIZE);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor (int k = 0; k < ruleChars.length; k++)\n\t\t\t\t(*table)->seqPatterns[(*table)->seqPatternsCount++] = ruleChars.chars[k];\n\t\t\t(*table)->seqPatterns[(*table)->seqPatternsCount++] = 0;\n\t\t\treturn 1;\n\n\t\tcase CTO_SeqAfterExpression:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif ((ruleChars.length + 1) > SEQPATTERNSIZE) {\n\t\t\t\tcompileError(file, \"More than %d characters\", SEQPATTERNSIZE);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor (int k = 0; k < ruleChars.length; k++)\n\t\t\t\t(*table)->seqAfterExpression[k] = ruleChars.chars[k];\n\t\t\t(*table)->seqAfterExpression[ruleChars.length] = 0;\n\t\t\t(*table)->seqAfterExpressionLength = ruleChars.length;\n\t\t\treturn 1;\n\n\t\tcase CTO_CapsModeChars:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!c) {\n\t\t\t\t\tcompileError(file, \"Capital mode character undefined\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc->attributes |= CTC_CapsMode;\n\t\t\t\t(*table)->hasCapsModeChars = 1;\n\t\t\t}\n\t\t\treturn 1;\n\n\t\tcase CTO_BegComp: {\n\t\t\t// not passing pointer because compileBrailleIndicator may reallocate table\n\t\t\tTranslationTableOffset ruleOffset = (*table)->begComp;\n\t\t\tif (!compileBrailleIndicator(file, \"begin computer braille\", CTO_BegCompRule,\n\t\t\t\t\t\t&ruleOffset, noback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\t(*table)->begComp = ruleOffset;\n\t\t\treturn 1;\n\t\t}\n\t\tcase CTO_EndComp: {\n\t\t\t// not passing pointer because compileBrailleIndicator may reallocate table\n\t\t\tTranslationTableOffset ruleOffset = (*table)->endComp;\n\t\t\tif (!compileBrailleIndicator(file, \"end computer braslle\", CTO_EndCompRule,\n\t\t\t\t\t\t&ruleOffset, noback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\t(*table)->endComp = ruleOffset;\n\t\t\treturn 1;\n\t\t}\n\t\tcase CTO_NoCross:\n\t\t\tif (nocross) {\n\t\t\t\tcompileError(\n\t\t\t\t\t\tfile, \"%s already specified.\", _lou_findOpcodeName(CTO_NoCross));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tnocross = 1;\n\t\t\tgoto doOpcode;\n\t\tcase CTO_Syllable:\n\t\t\t(*table)->syllables = 1;\n\t\tcase CTO_Always:\n\t\tcase CTO_LargeSign:\n\t\tcase CTO_WholeWord:\n\t\tcase CTO_PartWord:\n\t\tcase CTO_JoinNum:\n\t\tcase CTO_JoinableWord:\n\t\tcase CTO_LowWord:\n\t\tcase CTO_SuffixableWord:\n\t\tcase CTO_PrefixableWord:\n\t\tcase CTO_BegWord:\n\t\tcase CTO_BegMidWord:\n\t\tcase CTO_MidWord:\n\t\tcase CTO_MidEndWord:\n\t\tcase CTO_EndWord:\n\t\tcase CTO_PrePunc:\n\t\tcase CTO_PostPunc:\n\t\tcase CTO_BegNum:\n\t\tcase CTO_MidNum:\n\t\tcase CTO_EndNum:\n\t\tcase CTO_Repeated:\n\t\tcase CTO_RepWord:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (!getRuleDotsPattern(file, &ruleDots)) return 0;\n\t\t\tif (ruleDots.length == 0)\n\t\t\t\t// check that all characters in a rule with `=` as second operand are\n\t\t\t\t// defined (or based on another character)\n\t\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\t\tTranslationTableCharacter *c =\n\t\t\t\t\t\t\tgetChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\t\tif (!(c && (c->definitionRule || c->basechar))) {\n\t\t\t\t\t\tcompileError(file, \"Character %s is not defined\",\n\t\t\t\t\t\t\t\t_lou_showString(&ruleChars.chars[k], 1, 0));\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tTranslationTableRule *r;\n\t\t\tif (!addRule(file, opcode, &ruleChars, &ruleDots, after, before, NULL, &r,\n\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\tif (nocross) r->nocross = 1;\n\t\t\treturn 1;\n\t\t\t// if (opcode == CTO_MidNum)\n\t\t\t// {\n\t\t\t//   TranslationTableCharacter *c = getChar(ruleChars.chars[0]);\n\t\t\t//   if(c)\n\t\t\t//     c->attributes |= CTC_NumericMode;\n\t\t\t// }\n\t\tcase CTO_RepEndWord:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tCharsString dots;\n\t\t\tif (!getToken(file, &dots, \"dots,dots operand\")) return 0;\n\t\t\tint len = dots.length;\n\t\t\tfor (int k = 0; k < len - 1; k++) {\n\t\t\t\tif (dots.chars[k] == ',') {\n\t\t\t\t\tdots.length = k;\n\t\t\t\t\tif (!parseDots(file, &ruleDots, &dots)) return 0;\n\t\t\t\t\truleDots.chars[ruleDots.length++] = ',';\n\t\t\t\t\tk++;\n\t\t\t\t\tif (k == len - 1 && dots.chars[k] == '=') {\n\t\t\t\t\t\t// check that all characters are defined (or based on another\n\t\t\t\t\t\t// character)\n\t\t\t\t\t\tfor (int l = 0; l < ruleChars.length; l++) {\n\t\t\t\t\t\t\tTranslationTableCharacter *c =\n\t\t\t\t\t\t\t\t\tgetChar(ruleChars.chars[l], *table, NULL);\n\t\t\t\t\t\t\tif (!(c && (c->definitionRule || c->basechar))) {\n\t\t\t\t\t\t\t\tcompileError(file, \"Character %s is not defined\",\n\t\t\t\t\t\t\t\t\t\t_lou_showString(&ruleChars.chars[l], 1, 0));\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tCharsString x, y;\n\t\t\t\t\t\tx.length = 0;\n\t\t\t\t\t\twhile (k < len) x.chars[x.length++] = dots.chars[k++];\n\t\t\t\t\t\tif (parseDots(file, &y, &x))\n\t\t\t\t\t\t\tfor (int l = 0; l < y.length; l++)\n\t\t\t\t\t\t\t\truleDots.chars[ruleDots.length++] = y.chars[l];\n\t\t\t\t\t}\n\t\t\t\t\treturn addRule(file, opcode, &ruleChars, &ruleDots, after, before,\n\t\t\t\t\t\t\tNULL, NULL, noback, nofor, table);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\tcase CTO_CompDots:\n\t\tcase CTO_Comp6: {\n\t\t\tTranslationTableOffset ruleOffset;\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (ruleChars.length != 1) {\n\t\t\t\tcompileError(file, \"first operand must be 1 character\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (nofor || noback) {\n\t\t\t\tcompileWarning(file, \"nofor and noback not allowed on comp6 rules\");\n\t\t\t}\n\t\t\tif (!getRuleDotsPattern(file, &ruleDots)) return 0;\n\t\t\tif (!addRule(file, opcode, &ruleChars, &ruleDots, after, before, &ruleOffset,\n\t\t\t\t\t\tNULL, noback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\treturn 1;\n\t\t}\n\t\tcase CTO_ExactDots:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (ruleChars.chars[0] != '@') {\n\t\t\t\tcompileError(file, \"The operand must begin with an at sign (@)\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor (int k = 1; k < ruleChars.length; k++)\n\t\t\t\tscratchPad.chars[k - 1] = ruleChars.chars[k];\n\t\t\tscratchPad.length = ruleChars.length - 1;\n\t\t\tif (!parseDots(file, &ruleDots, &scratchPad)) return 0;\n\t\t\treturn addRule(file, opcode, &ruleChars, &ruleDots, before, after, NULL, NULL,\n\t\t\t\t\tnoback, nofor, table);\n\t\tcase CTO_CapsNoCont: {\n\t\t\tTranslationTableOffset ruleOffset;\n\t\t\truleChars.length = 1;\n\t\t\truleChars.chars[0] = 'a';\n\t\t\tif (!addRule(file, CTO_CapsNoContRule, &ruleChars, NULL, after, before,\n\t\t\t\t\t\t&ruleOffset, NULL, noback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\t(*table)->capsNoCont = ruleOffset;\n\t\t\treturn 1;\n\t\t}\n\t\tcase CTO_Replace:\n\t\t\tif (getRuleCharsText(file, &ruleChars)) {\n\t\t\t\tif (atEndOfLine(file))\n\t\t\t\t\truleDots.length = ruleDots.chars[0] = 0;\n\t\t\t\telse {\n\t\t\t\t\tgetRuleDotsText(file, &ruleDots);\n\t\t\t\t\tif (ruleDots.chars[0] == '#')\n\t\t\t\t\t\truleDots.length = ruleDots.chars[0] = 0;\n\t\t\t\t\telse if (ruleDots.chars[0] == '\\\\' && ruleDots.chars[1] == '#')\n\t\t\t\t\t\tmemmove(&ruleDots.chars[0], &ruleDots.chars[1],\n\t\t\t\t\t\t\t\truleDots.length-- * CHARSIZE);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int k = 0; k < ruleChars.length; k++)\n\t\t\t\tputChar(file, ruleChars.chars[k], table, NULL);\n\t\t\tfor (int k = 0; k < ruleDots.length; k++)\n\t\t\t\tputChar(file, ruleDots.chars[k], table, NULL);\n\t\t\treturn addRule(file, opcode, &ruleChars, &ruleDots, after, before, NULL, NULL,\n\t\t\t\t\tnoback, nofor, table);\n\t\tcase CTO_Correct:\n\t\t\t(*table)->corrections = 1;\n\t\t\tgoto doPass;\n\t\tcase CTO_Pass2:\n\t\t\tif ((*table)->numPasses < 2) (*table)->numPasses = 2;\n\t\t\tgoto doPass;\n\t\tcase CTO_Pass3:\n\t\t\tif ((*table)->numPasses < 3) (*table)->numPasses = 3;\n\t\t\tgoto doPass;\n\t\tcase CTO_Pass4:\n\t\t\tif ((*table)->numPasses < 4) (*table)->numPasses = 4;\n\t\tdoPass:\n\t\tcase CTO_Context:\n\t\t\tif (!(nofor || noback)) {\n\t\t\t\tcompileError(file, \"%s or %s must be specified.\",\n\t\t\t\t\t\t_lou_findOpcodeName(CTO_NoFor), _lou_findOpcodeName(CTO_NoBack));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn compilePassOpcode(file, opcode, noback, nofor, table);\n\t\tcase CTO_Contraction:\n\t\tcase CTO_NoCont:\n\t\tcase CTO_CompBrl:\n\t\tcase CTO_Literal:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\t// check that all characters in a compbrl, contraction,\n\t\t\t// nocont or literal rule are defined (or based on another\n\t\t\t// character)\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!(c && (c->definitionRule || c->basechar))) {\n\t\t\t\t\tcompileError(file, \"Character %s is not defined\",\n\t\t\t\t\t\t\t_lou_showString(&ruleChars.chars[k], 1, 0));\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn addRule(file, opcode, &ruleChars, NULL, after, before, NULL, NULL,\n\t\t\t\t\tnoback, nofor, table);\n\t\tcase CTO_MultInd: {\n\t\t\truleChars.length = 0;\n\t\t\tif (!getToken(file, &token, \"multiple braille indicators\") ||\n\t\t\t\t\t!parseDots(file, &cells, &token))\n\t\t\t\treturn 0;\n\t\t\twhile (getToken(file, &token, \"multind opcodes\")) {\n\t\t\t\topcode = getOpcode(file, &token);\n\t\t\t\tif (opcode == CTO_None) {\n\t\t\t\t\tcompileError(file, \"opcode %s not defined.\",\n\t\t\t\t\t\t\t_lou_showString(token.chars, token.length, 0));\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif (!(opcode >= CTO_CapsLetter && opcode < CTO_MultInd)) {\n\t\t\t\t\tcompileError(file, \"Not a braille indicator opcode.\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\truleChars.chars[ruleChars.length++] = (widechar)opcode;\n\t\t\t\tif (atEndOfLine(file)) break;\n\t\t\t}\n\t\t\treturn addRule(file, CTO_MultInd, &ruleChars, &cells, after, before, NULL,\n\t\t\t\t\tNULL, noback, nofor, table);\n\t\t}\n\n\t\tcase CTO_Class:\n\t\t\tcompileWarning(file, \"class is deprecated, use attribute instead\");\n\t\tcase CTO_Attribute: {\n\t\t\tif (nofor || noback) {\n\t\t\t\tcompileWarning(\n\t\t\t\t\t\tfile, \"nofor and noback not allowed before class/attribute\");\n\t\t\t}\n\t\t\tif ((opcode == CTO_Class && (*table)->usesAttributeOrClass == 1) ||\n\t\t\t\t\t(opcode == CTO_Attribute && (*table)->usesAttributeOrClass == 2)) {\n\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\"attribute and class rules must not be both present in a table\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (opcode == CTO_Class)\n\t\t\t\t(*table)->usesAttributeOrClass = 2;\n\t\t\telse\n\t\t\t\t(*table)->usesAttributeOrClass = 1;\n\t\t\tif (!getToken(file, &token, \"attribute name\")) {\n\t\t\t\tcompileError(file, \"Expected %s\", \"attribute name\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!(*table)->characterClasses && !allocateCharacterClasses(*table)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tTranslationTableCharacterAttributes attribute = 0;\n\t\t\t{\n\t\t\t\tint attrNumber = -1;\n\t\t\t\tswitch (token.chars[0]) {\n\t\t\t\tcase '0':\n\t\t\t\tcase '1':\n\t\t\t\tcase '2':\n\t\t\t\tcase '3':\n\t\t\t\tcase '4':\n\t\t\t\tcase '5':\n\t\t\t\tcase '6':\n\t\t\t\tcase '7':\n\t\t\t\tcase '8':\n\t\t\t\tcase '9':\n\t\t\t\t\tattrNumber = token.chars[0] - '0';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (attrNumber >= 0) {\n\t\t\t\t\tif (opcode == CTO_Class) {\n\t\t\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\t\t\"Invalid class name: may not contain digits, use \"\n\t\t\t\t\t\t\t\t\"attribute instead of class\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (token.length > 1 || attrNumber > 7) {\n\t\t\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\t\t\"Invalid attribute name: must be a digit between 0 and 7 \"\n\t\t\t\t\t\t\t\t\"or a word containing only letters\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (!(*table)->numberedAttributes[attrNumber])\n\t\t\t\t\t\t// attribute not used before yet: assign it a value\n\t\t\t\t\t\t(*table)->numberedAttributes[attrNumber] =\n\t\t\t\t\t\t\t\tgetNextNumberedAttribute(*table);\n\t\t\t\t\tattribute = (*table)->numberedAttributes[attrNumber];\n\t\t\t\t} else {\n\t\t\t\t\tconst CharacterClass *namedAttr = findCharacterClass(&token, *table);\n\t\t\t\t\tif (!namedAttr) {\n\t\t\t\t\t\t// no class with that name: create one\n\t\t\t\t\t\tnamedAttr = addCharacterClass(\n\t\t\t\t\t\t\t\tfile, &token.chars[0], token.length, *table, 1);\n\t\t\t\t\t\tif (!namedAttr) return 0;\n\t\t\t\t\t}\n\t\t\t\t\t// there is a class with that name or a new class was successfully\n\t\t\t\t\t// created\n\t\t\t\t\tattribute = namedAttr->attribute;\n\t\t\t\t\tif (attribute == CTC_UpperCase || attribute == CTC_LowerCase)\n\t\t\t\t\t\tattribute |= CTC_Letter;\n\t\t\t\t}\n\t\t\t}\n\t\t\tCharsString characters;\n\t\t\tif (!getCharacters(file, &characters)) return 0;\n\t\t\tfor (int i = 0; i < characters.length; i++) {\n\t\t\t\t// get the character from the table, or if it is not defined yet,\n\t\t\t\t// define it\n\t\t\t\tTranslationTableCharacter *character =\n\t\t\t\t\t\tputChar(file, characters.chars[i], table, NULL);\n\t\t\t\t// set the attribute\n\t\t\t\tcharacter->attributes |= attribute;\n\t\t\t\t// also set the attribute on the associated dots (if any)\n\t\t\t\tif (character->basechar)\n\t\t\t\t\tcharacter = (TranslationTableCharacter *)&(*table)\n\t\t\t\t\t\t\t\t\t\t->ruleArea[character->basechar];\n\t\t\t\tif (character->definitionRule) {\n\t\t\t\t\tTranslationTableRule *defRule =\n\t\t\t\t\t\t\t(TranslationTableRule *)&(*table)\n\t\t\t\t\t\t\t\t\t->ruleArea[character->definitionRule];\n\t\t\t\t\tif (defRule->dotslen == 1) {\n\t\t\t\t\t\tTranslationTableCharacter *dots =\n\t\t\t\t\t\t\t\tgetDots(defRule->charsdots[defRule->charslen], *table);\n\t\t\t\t\t\tif (dots) dots->attributes |= attribute;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\n\t\t\t{\n\t\t\t\tTranslationTableCharacterAttributes *attributes;\n\t\t\t\tconst CharacterClass *class;\n\t\t\tcase CTO_After:\n\t\t\t\tattributes = &after;\n\t\t\t\tgoto doBeforeAfter;\n\t\t\tcase CTO_Before:\n\t\t\t\tattributes = &before;\n\t\t\tdoBeforeAfter:\n\t\t\t\tif (!(*table)->characterClasses) {\n\t\t\t\t\tif (!allocateCharacterClasses(*table)) return 0;\n\t\t\t\t}\n\t\t\t\tif (!getToken(file, &token, \"attribute name\")) return 0;\n\t\t\t\tif (!(class = findCharacterClass(&token, *table))) {\n\t\t\t\t\tcompileError(file, \"attribute not defined\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t*attributes |= class->attribute;\n\t\t\t\tgoto doOpcode;\n\t\t\t}\n\t\tcase CTO_Base:\n\t\t\tif (nofor || noback) {\n\t\t\t\tcompileWarning(file, \"nofor and noback not allowed before base\");\n\t\t\t}\n\t\t\tif (!getToken(file, &token, \"attribute name\")) {\n\t\t\t\tcompileError(\n\t\t\t\t\t\tfile, \"base opcode must be followed by a valid attribute name.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!(*table)->characterClasses && !allocateCharacterClasses(*table)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tconst CharacterClass *mode = findCharacterClass(&token, *table);\n\t\t\tif (!mode) {\n\t\t\t\tmode = addCharacterClass(file, token.chars, token.length, *table, 1);\n\t\t\t\tif (!mode) return 0;\n\t\t\t}\n\t\t\tif (!(mode->attribute == CTC_UpperCase || mode->attribute == CTC_Digit) &&\n\t\t\t\t\tmode->attribute >= CTC_Space && mode->attribute <= CTC_LitDigit) {\n\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\"base opcode must be followed by \\\"uppercase\\\", \\\"digit\\\", or a \"\n\t\t\t\t\t\t\"custom attribute name.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!getRuleCharsText(file, &token)) return 0;\n\t\t\tif (token.length != 1) {\n\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\"Exactly one character followed by one base character is \"\n\t\t\t\t\t\t\"required.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tTranslationTableOffset characterOffset;\n\t\t\tTranslationTableCharacter *character =\n\t\t\t\t\tputChar(file, token.chars[0], table, &characterOffset);\n\t\t\tif (!getRuleCharsText(file, &token)) return 0;\n\t\t\tif (token.length != 1) {\n\t\t\t\tcompileError(file, \"Exactly one base character is required.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (character->definitionRule) {\n\t\t\t\tTranslationTableRule *prevRule =\n\t\t\t\t\t\t(TranslationTableRule *)&(*table)\n\t\t\t\t\t\t\t\t->ruleArea[character->definitionRule];\n\t\t\t\t_lou_logMessage(LOU_LOG_DEBUG,\n\t\t\t\t\t\t\"%s:%d: Character already defined (%s). The base rule will take \"\n\t\t\t\t\t\t\"precedence.\",\n\t\t\t\t\t\tfile->fileName, file->lineNumber,\n\t\t\t\t\t\tprintSource(file, prevRule->sourceFile, prevRule->sourceLine));\n\t\t\t\tcharacter->definitionRule = 0;\n\t\t\t}\n\t\t\tTranslationTableOffset basechar;\n\t\t\tputChar(file, token.chars[0], table, &basechar);\n\t\t\t// putChar may have moved table, so make sure character is still valid\n\t\t\tcharacter = (TranslationTableCharacter *)&(*table)->ruleArea[characterOffset];\n\t\t\tif (character->basechar) {\n\t\t\t\tif (character->basechar == basechar &&\n\t\t\t\t\t\tcharacter->mode == mode->attribute) {\n\t\t\t\t\t_lou_logMessage(LOU_LOG_DEBUG, \"%s:%d: Duplicate base rule.\",\n\t\t\t\t\t\t\tfile->fileName, file->lineNumber);\n\t\t\t\t} else {\n\t\t\t\t\t_lou_logMessage(LOU_LOG_DEBUG,\n\t\t\t\t\t\t\t\"%s:%d: A different base rule already exists for this \"\n\t\t\t\t\t\t\t\"character (%s). The new rule will take precedence.\",\n\t\t\t\t\t\t\tfile->fileName, file->lineNumber,\n\t\t\t\t\t\t\tprintSource(\n\t\t\t\t\t\t\t\t\tfile, character->sourceFile, character->sourceLine));\n\t\t\t\t}\n\t\t\t}\n\t\t\tcharacter->basechar = basechar;\n\t\t\tcharacter->mode = mode->attribute;\n\t\t\tcharacter->sourceFile = file->sourceFile;\n\t\t\tcharacter->sourceLine = file->lineNumber;\n\t\t\t/* some other processing is done at the end of the compilation, in\n\t\t\t * finalizeTable() */\n\t\t\treturn 1;\n\t\tcase CTO_EmpMatchBefore:\n\t\t\tbefore |= CTC_EmpMatch;\n\t\t\tgoto doOpcode;\n\t\tcase CTO_EmpMatchAfter:\n\t\t\tafter |= CTC_EmpMatch;\n\t\t\tgoto doOpcode;\n\n\t\tcase CTO_SwapCc:\n\t\tcase CTO_SwapCd:\n\t\tcase CTO_SwapDd:\n\t\t\treturn compileSwap(file, opcode, noback, nofor, table);\n\t\tcase CTO_Hyphen:\n\t\tcase CTO_DecPoint:\n\t\t\t//\tcase CTO_Apostrophe:\n\t\t\t//\tcase CTO_Initial:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (!getRuleDotsPattern(file, &ruleDots)) return 0;\n\t\t\tif (ruleChars.length != 1 || ruleDots.length < 1) {\n\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\"One Unicode character and at least one cell are \"\n\t\t\t\t\t\t\"required.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn addRule(file, opcode, &ruleChars, &ruleDots, after, before, NULL, NULL,\n\t\t\t\t\tnoback, nofor, table);\n\t\t\t// if (opcode == CTO_DecPoint)\n\t\t\t// {\n\t\t\t//   TranslationTableCharacter *c =\n\t\t\t//   getChar(ruleChars.chars[0]);\n\t\t\t//   if(c)\n\t\t\t//     c->attributes |= CTC_NumericMode;\n\t\t\t// }\n\t\tdefault:\n\t\t\tcompileError(file, \"unimplemented opcode.\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}", "func_hash": 188995041946566375099409962387038802381, "file_name": "compileTranslationTable.c", "file_hash": 129515444966510079462991982245291196170, "cwe": ["CWE-787"], "cve": "CVE-2022-31783", "cve_desc": "Liblouis 3.21.0 has an out-of-bounds write in compileRule in compileTranslationTable.c, as demonstrated by lou_trace.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-31783", "file_path": "liblouis/compileTranslationTable.c"}
