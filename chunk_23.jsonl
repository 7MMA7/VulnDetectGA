{"idx": 208107, "project": "linux", "commit_id": "f85daf0e725358be78dfd208dea5fd665d8cb901", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/f85daf0e725358be78dfd208dea5fd665d8cb901", "commit_message": "xfrm: xfrm_policy: fix a possible double xfrm_pols_put() in xfrm_bundle_lookup()\n\nxfrm_policy_lookup() will call xfrm_pol_hold_rcu() to get a refcount of\npols[0]. This refcount can be dropped in xfrm_expand_policies() when\nxfrm_expand_policies() return error. pols[0]'s refcount is balanced in\nhere. But xfrm_bundle_lookup() will also call xfrm_pols_put() with\nnum_pols == 1 to drop this refcount when xfrm_expand_policies() return\nerror.\n\nThis patch also fix an illegal address access. pols[0] will save a error\npoint when xfrm_policy_lookup fails. This lead to xfrm_pols_put to resolve\nan illegal address in xfrm_bundle_lookup's error path.\n\nFix these by setting num_pols = 0 in xfrm_expand_policies()'s error path.\n\nFixes: 80c802f3073e (\"xfrm: cache bundles instead of policies for outgoing flows\")\nSigned-off-by: Hangyu Hua <hbh25y@gmail.com>\nSigned-off-by: Steffen Klassert <steffen.klassert@secunet.com>", "target": 1, "func": "static int xfrm_expand_policies(const struct flowi *fl, u16 family,\n\t\t\t\tstruct xfrm_policy **pols,\n\t\t\t\tint *num_pols, int *num_xfrms)\n{\n\tint i;\n\n\tif (*num_pols == 0 || !pols[0]) {\n\t\t*num_pols = 0;\n\t\t*num_xfrms = 0;\n\t\treturn 0;\n\t}\n\tif (IS_ERR(pols[0]))\n\t\treturn PTR_ERR(pols[0]);\n\n\t*num_xfrms = pols[0]->xfrm_nr;\n\n#ifdef CONFIG_XFRM_SUB_POLICY\n\tif (pols[0]->action == XFRM_POLICY_ALLOW &&\n\t    pols[0]->type != XFRM_POLICY_TYPE_MAIN) {\n\t\tpols[1] = xfrm_policy_lookup_bytype(xp_net(pols[0]),\n\t\t\t\t\t\t    XFRM_POLICY_TYPE_MAIN,\n\t\t\t\t\t\t    fl, family,\n\t\t\t\t\t\t    XFRM_POLICY_OUT,\n\t\t\t\t\t\t    pols[0]->if_id);\n\t\tif (pols[1]) {\n\t\t\tif (IS_ERR(pols[1])) {\n\t\t\t\txfrm_pols_put(pols, *num_pols);\n\t\t\t\treturn PTR_ERR(pols[1]);\n\t\t\t}\n\t\t\t(*num_pols)++;\n\t\t\t(*num_xfrms) += pols[1]->xfrm_nr;\n\t\t}\n\t}\n#endif\n\tfor (i = 0; i < *num_pols; i++) {\n\t\tif (pols[i]->action != XFRM_POLICY_ALLOW) {\n\t\t\t*num_xfrms = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n\n}", "func_hash": 251684023315514826982518858194996142213, "file_name": "xfrm_policy.c", "file_hash": 240690312801703995044299112379503581676, "cwe": ["CWE-703"], "cve": "CVE-2022-36879", "cve_desc": "An issue was discovered in the Linux kernel through 5.18.14. xfrm_expand_policies in net/xfrm/xfrm_policy.c can cause a refcount to be dropped twice.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-36879", "file_path": "net/xfrm/xfrm_policy.c"}
{"idx": 405333, "project": "linux", "commit_id": "f85daf0e725358be78dfd208dea5fd665d8cb901", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/f85daf0e725358be78dfd208dea5fd665d8cb901", "commit_message": "xfrm: xfrm_policy: fix a possible double xfrm_pols_put() in xfrm_bundle_lookup()\n\nxfrm_policy_lookup() will call xfrm_pol_hold_rcu() to get a refcount of\npols[0]. This refcount can be dropped in xfrm_expand_policies() when\nxfrm_expand_policies() return error. pols[0]'s refcount is balanced in\nhere. But xfrm_bundle_lookup() will also call xfrm_pols_put() with\nnum_pols == 1 to drop this refcount when xfrm_expand_policies() return\nerror.\n\nThis patch also fix an illegal address access. pols[0] will save a error\npoint when xfrm_policy_lookup fails. This lead to xfrm_pols_put to resolve\nan illegal address in xfrm_bundle_lookup's error path.\n\nFix these by setting num_pols = 0 in xfrm_expand_policies()'s error path.\n\nFixes: 80c802f3073e (\"xfrm: cache bundles instead of policies for outgoing flows\")\nSigned-off-by: Hangyu Hua <hbh25y@gmail.com>\nSigned-off-by: Steffen Klassert <steffen.klassert@secunet.com>", "target": 0, "func": "static int xfrm_expand_policies(const struct flowi *fl, u16 family,\n\t\t\t\tstruct xfrm_policy **pols,\n\t\t\t\tint *num_pols, int *num_xfrms)\n{\n\tint i;\n\n\tif (*num_pols == 0 || !pols[0]) {\n\t\t*num_pols = 0;\n\t\t*num_xfrms = 0;\n\t\treturn 0;\n\t}\n\tif (IS_ERR(pols[0])) {\n\t\t*num_pols = 0;\n\t\treturn PTR_ERR(pols[0]);\n\t}\n\n\t*num_xfrms = pols[0]->xfrm_nr;\n\n#ifdef CONFIG_XFRM_SUB_POLICY\n\tif (pols[0]->action == XFRM_POLICY_ALLOW &&\n\t    pols[0]->type != XFRM_POLICY_TYPE_MAIN) {\n\t\tpols[1] = xfrm_policy_lookup_bytype(xp_net(pols[0]),\n\t\t\t\t\t\t    XFRM_POLICY_TYPE_MAIN,\n\t\t\t\t\t\t    fl, family,\n\t\t\t\t\t\t    XFRM_POLICY_OUT,\n\t\t\t\t\t\t    pols[0]->if_id);\n\t\tif (pols[1]) {\n\t\t\tif (IS_ERR(pols[1])) {\n\t\t\t\txfrm_pols_put(pols, *num_pols);\n\t\t\t\t*num_pols = 0;\n\t\t\t\treturn PTR_ERR(pols[1]);\n\t\t\t}\n\t\t\t(*num_pols)++;\n\t\t\t(*num_xfrms) += pols[1]->xfrm_nr;\n\t\t}\n\t}\n#endif\n\tfor (i = 0; i < *num_pols; i++) {\n\t\tif (pols[i]->action != XFRM_POLICY_ALLOW) {\n\t\t\t*num_xfrms = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n\n}", "func_hash": 29732626654088535700777069321150029090, "file_name": "xfrm_policy.c", "file_hash": 264724924246430289692801756816591917107, "cwe": ["CWE-703"], "cve": "CVE-2022-36879", "cve_desc": "An issue was discovered in the Linux kernel through 5.18.14. xfrm_expand_policies in net/xfrm/xfrm_policy.c can cause a refcount to be dropped twice.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-36879", "file_path": "net/xfrm/xfrm_policy.c"}
{"idx": 208115, "project": "linux", "commit_id": "d0d62baa7f505bd4c59cd169692ff07ec49dde37", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/d0d62baa7f505bd4c59cd169692ff07ec49dde37", "commit_message": "net: xilinx_emaclite: Do not print real IOMEM pointer\n\nPrinting kernel pointers is discouraged because they might leak kernel\nmemory layout.  This fixes smatch warning:\n\ndrivers/net/ethernet/xilinx/xilinx_emaclite.c:1191 xemaclite_of_probe() warn:\n argument 4 to %08lX specifier is cast from pointer\n\nSigned-off-by: YueHaibing <yuehaibing@huawei.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "target": 1, "func": "static int xemaclite_of_probe(struct platform_device *ofdev)\n{\n\tstruct resource *res;\n\tstruct net_device *ndev = NULL;\n\tstruct net_local *lp = NULL;\n\tstruct device *dev = &ofdev->dev;\n\n\tint rc = 0;\n\n\tdev_info(dev, \"Device Tree Probing\\n\");\n\n\t/* Create an ethernet device instance */\n\tndev = alloc_etherdev(sizeof(struct net_local));\n\tif (!ndev)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, ndev);\n\tSET_NETDEV_DEV(ndev, &ofdev->dev);\n\n\tlp = netdev_priv(ndev);\n\tlp->ndev = ndev;\n\n\t/* Get IRQ for the device */\n\tres = platform_get_resource(ofdev, IORESOURCE_IRQ, 0);\n\tif (!res) {\n\t\tdev_err(dev, \"no IRQ found\\n\");\n\t\trc = -ENXIO;\n\t\tgoto error;\n\t}\n\n\tndev->irq = res->start;\n\n\tres = platform_get_resource(ofdev, IORESOURCE_MEM, 0);\n\tlp->base_addr = devm_ioremap_resource(&ofdev->dev, res);\n\tif (IS_ERR(lp->base_addr)) {\n\t\trc = PTR_ERR(lp->base_addr);\n\t\tgoto error;\n\t}\n\n\tndev->mem_start = res->start;\n\tndev->mem_end = res->end;\n\n\tspin_lock_init(&lp->reset_lock);\n\tlp->next_tx_buf_to_use = 0x0;\n\tlp->next_rx_buf_to_use = 0x0;\n\tlp->tx_ping_pong = get_bool(ofdev, \"xlnx,tx-ping-pong\");\n\tlp->rx_ping_pong = get_bool(ofdev, \"xlnx,rx-ping-pong\");\n\n\trc = of_get_mac_address(ofdev->dev.of_node, ndev->dev_addr);\n\tif (rc) {\n\t\tdev_warn(dev, \"No MAC address found, using random\\n\");\n\t\teth_hw_addr_random(ndev);\n\t}\n\n\t/* Clear the Tx CSR's in case this is a restart */\n\txemaclite_writel(0, lp->base_addr + XEL_TSR_OFFSET);\n\txemaclite_writel(0, lp->base_addr + XEL_BUFFER_OFFSET + XEL_TSR_OFFSET);\n\n\t/* Set the MAC address in the EmacLite device */\n\txemaclite_update_address(lp, ndev->dev_addr);\n\n\tlp->phy_node = of_parse_phandle(ofdev->dev.of_node, \"phy-handle\", 0);\n\txemaclite_mdio_setup(lp, &ofdev->dev);\n\n\tdev_info(dev, \"MAC address is now %pM\\n\", ndev->dev_addr);\n\n\tndev->netdev_ops = &xemaclite_netdev_ops;\n\tndev->ethtool_ops = &xemaclite_ethtool_ops;\n\tndev->flags &= ~IFF_MULTICAST;\n\tndev->watchdog_timeo = TX_TIMEOUT;\n\n\t/* Finally, register the device */\n\trc = register_netdev(ndev);\n\tif (rc) {\n\t\tdev_err(dev,\n\t\t\t\"Cannot register network device, aborting\\n\");\n\t\tgoto error;\n\t}\n\n\tdev_info(dev,\n\t\t \"Xilinx EmacLite at 0x%08lX mapped to 0x%08lX, irq=%d\\n\",\n\t\t (unsigned long __force)ndev->mem_start,\n\t\t (unsigned long __force)lp->base_addr, ndev->irq);\n\treturn 0;\n\nerror:\n\tfree_netdev(ndev);\n\treturn rc;\n}", "func_hash": 7539144956808128275181130217400039273, "file_name": "xilinx_emaclite.c", "file_hash": 195328153780575985681144288401844286686, "cwe": ["CWE-703"], "cve": "CVE-2021-38205", "cve_desc": "drivers/net/ethernet/xilinx/xilinx_emaclite.c in the Linux kernel before 5.13.3 makes it easier for attackers to defeat an ASLR protection mechanism because it prints a kernel pointer (i.e., the real IOMEM pointer).", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-38205", "file_path": "drivers/net/ethernet/xilinx/xilinx_emaclite.c"}
{"idx": 405698, "project": "linux", "commit_id": "d0d62baa7f505bd4c59cd169692ff07ec49dde37", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/d0d62baa7f505bd4c59cd169692ff07ec49dde37", "commit_message": "net: xilinx_emaclite: Do not print real IOMEM pointer\n\nPrinting kernel pointers is discouraged because they might leak kernel\nmemory layout.  This fixes smatch warning:\n\ndrivers/net/ethernet/xilinx/xilinx_emaclite.c:1191 xemaclite_of_probe() warn:\n argument 4 to %08lX specifier is cast from pointer\n\nSigned-off-by: YueHaibing <yuehaibing@huawei.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "target": 0, "func": "static int xemaclite_of_probe(struct platform_device *ofdev)\n{\n\tstruct resource *res;\n\tstruct net_device *ndev = NULL;\n\tstruct net_local *lp = NULL;\n\tstruct device *dev = &ofdev->dev;\n\n\tint rc = 0;\n\n\tdev_info(dev, \"Device Tree Probing\\n\");\n\n\t/* Create an ethernet device instance */\n\tndev = alloc_etherdev(sizeof(struct net_local));\n\tif (!ndev)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, ndev);\n\tSET_NETDEV_DEV(ndev, &ofdev->dev);\n\n\tlp = netdev_priv(ndev);\n\tlp->ndev = ndev;\n\n\t/* Get IRQ for the device */\n\tres = platform_get_resource(ofdev, IORESOURCE_IRQ, 0);\n\tif (!res) {\n\t\tdev_err(dev, \"no IRQ found\\n\");\n\t\trc = -ENXIO;\n\t\tgoto error;\n\t}\n\n\tndev->irq = res->start;\n\n\tres = platform_get_resource(ofdev, IORESOURCE_MEM, 0);\n\tlp->base_addr = devm_ioremap_resource(&ofdev->dev, res);\n\tif (IS_ERR(lp->base_addr)) {\n\t\trc = PTR_ERR(lp->base_addr);\n\t\tgoto error;\n\t}\n\n\tndev->mem_start = res->start;\n\tndev->mem_end = res->end;\n\n\tspin_lock_init(&lp->reset_lock);\n\tlp->next_tx_buf_to_use = 0x0;\n\tlp->next_rx_buf_to_use = 0x0;\n\tlp->tx_ping_pong = get_bool(ofdev, \"xlnx,tx-ping-pong\");\n\tlp->rx_ping_pong = get_bool(ofdev, \"xlnx,rx-ping-pong\");\n\n\trc = of_get_mac_address(ofdev->dev.of_node, ndev->dev_addr);\n\tif (rc) {\n\t\tdev_warn(dev, \"No MAC address found, using random\\n\");\n\t\teth_hw_addr_random(ndev);\n\t}\n\n\t/* Clear the Tx CSR's in case this is a restart */\n\txemaclite_writel(0, lp->base_addr + XEL_TSR_OFFSET);\n\txemaclite_writel(0, lp->base_addr + XEL_BUFFER_OFFSET + XEL_TSR_OFFSET);\n\n\t/* Set the MAC address in the EmacLite device */\n\txemaclite_update_address(lp, ndev->dev_addr);\n\n\tlp->phy_node = of_parse_phandle(ofdev->dev.of_node, \"phy-handle\", 0);\n\txemaclite_mdio_setup(lp, &ofdev->dev);\n\n\tdev_info(dev, \"MAC address is now %pM\\n\", ndev->dev_addr);\n\n\tndev->netdev_ops = &xemaclite_netdev_ops;\n\tndev->ethtool_ops = &xemaclite_ethtool_ops;\n\tndev->flags &= ~IFF_MULTICAST;\n\tndev->watchdog_timeo = TX_TIMEOUT;\n\n\t/* Finally, register the device */\n\trc = register_netdev(ndev);\n\tif (rc) {\n\t\tdev_err(dev,\n\t\t\t\"Cannot register network device, aborting\\n\");\n\t\tgoto error;\n\t}\n\n\tdev_info(dev,\n\t\t \"Xilinx EmacLite at 0x%08lX mapped to 0x%p, irq=%d\\n\",\n\t\t (unsigned long __force)ndev->mem_start, lp->base_addr, ndev->irq);\n\treturn 0;\n\nerror:\n\tfree_netdev(ndev);\n\treturn rc;\n}", "func_hash": 304374419764415204432847844541033449466, "file_name": "xilinx_emaclite.c", "file_hash": 308517377946216969047380117029804691833, "cwe": ["CWE-703"], "cve": "CVE-2021-38205", "cve_desc": "drivers/net/ethernet/xilinx/xilinx_emaclite.c in the Linux kernel before 5.13.3 makes it easier for attackers to defeat an ASLR protection mechanism because it prints a kernel pointer (i.e., the real IOMEM pointer).", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-38205", "file_path": "drivers/net/ethernet/xilinx/xilinx_emaclite.c"}
{"idx": 208140, "project": "util-linux", "commit_id": "5ebbc3865d1e53ef42e5f121c41faab23dd59075", "project_url": "https://github.com/karelzak/util-linux", "commit_url": "http://git.kernel.org/?p=utils/util-linux/util-linux.git;a=commit;h=5ebbc3865d1e53ef42e5f121c41faab23dd59075", "commit_message": "mount: sanitize paths from non-root users\n\n $ mount /root/.ssh/../../dev/sda2\n mount: only root can mount UUID=17bc65ec-4125-4e7c-8a7d-e2795064c736 on /boot\n\nthis is too promiscuous. It seems better to ignore on command line\nspecified paths which are not resolve-able for non-root users.\n\nFixed version:\n\n  $ mount /root/.ssh/../../dev/sda2\n  mount: /root/.ssh/../../dev/sda2: Permission denied\n\n  $ mount /dev/sda2\n  mount: only root can mount UUID=17bc65ec-4125-4e7c-8a7d-e2795064c736 on /boot\n\nNote that this bug has no relation to mount(2) permissions evaluation\nin suid mode. The way how non-root user specifies paths on command\nline is completely irrelevant for comparison with fstab entries.\n\nSigned-off-by: Karel Zak <kzak@redhat.com>", "target": 1, "func": "int main(int argc, char **argv)\n{\n\tint c, rc = MOUNT_EX_SUCCESS, all = 0, show_labels = 0;\n\tstruct libmnt_context *cxt;\n\tstruct libmnt_table *fstab = NULL;\n\tchar *srcbuf = NULL;\n\tchar *types = NULL;\n\tunsigned long oper = 0;\n\n\tenum {\n\t\tMOUNT_OPT_SHARED = CHAR_MAX + 1,\n\t\tMOUNT_OPT_SLAVE,\n\t\tMOUNT_OPT_PRIVATE,\n\t\tMOUNT_OPT_UNBINDABLE,\n\t\tMOUNT_OPT_RSHARED,\n\t\tMOUNT_OPT_RSLAVE,\n\t\tMOUNT_OPT_RPRIVATE,\n\t\tMOUNT_OPT_RUNBINDABLE,\n\t\tMOUNT_OPT_TARGET,\n\t\tMOUNT_OPT_SOURCE\n\t};\n\n\tstatic const struct option longopts[] = {\n\t\t{ \"all\", 0, 0, 'a' },\n\t\t{ \"fake\", 0, 0, 'f' },\n\t\t{ \"fstab\", 1, 0, 'T' },\n\t\t{ \"fork\", 0, 0, 'F' },\n\t\t{ \"help\", 0, 0, 'h' },\n\t\t{ \"no-mtab\", 0, 0, 'n' },\n\t\t{ \"read-only\", 0, 0, 'r' },\n\t\t{ \"ro\", 0, 0, 'r' },\n\t\t{ \"verbose\", 0, 0, 'v' },\n\t\t{ \"version\", 0, 0, 'V' },\n\t\t{ \"read-write\", 0, 0, 'w' },\n\t\t{ \"rw\", 0, 0, 'w' },\n\t\t{ \"options\", 1, 0, 'o' },\n\t\t{ \"test-opts\", 1, 0, 'O' },\n\t\t{ \"pass-fd\", 1, 0, 'p' },\n\t\t{ \"types\", 1, 0, 't' },\n\t\t{ \"uuid\", 1, 0, 'U' },\n\t\t{ \"label\", 1, 0, 'L'},\n\t\t{ \"bind\", 0, 0, 'B' },\n\t\t{ \"move\", 0, 0, 'M' },\n\t\t{ \"rbind\", 0, 0, 'R' },\n\t\t{ \"make-shared\", 0, 0, MOUNT_OPT_SHARED },\n\t\t{ \"make-slave\", 0, 0, MOUNT_OPT_SLAVE },\n\t\t{ \"make-private\", 0, 0, MOUNT_OPT_PRIVATE },\n\t\t{ \"make-unbindable\", 0, 0, MOUNT_OPT_UNBINDABLE },\n\t\t{ \"make-rshared\", 0, 0, MOUNT_OPT_RSHARED },\n\t\t{ \"make-rslave\", 0, 0, MOUNT_OPT_RSLAVE },\n\t\t{ \"make-rprivate\", 0, 0, MOUNT_OPT_RPRIVATE },\n\t\t{ \"make-runbindable\", 0, 0, MOUNT_OPT_RUNBINDABLE },\n\t\t{ \"no-canonicalize\", 0, 0, 'c' },\n\t\t{ \"internal-only\", 0, 0, 'i' },\n\t\t{ \"show-labels\", 0, 0, 'l' },\n\t\t{ \"target\", 1, 0, MOUNT_OPT_TARGET },\n\t\t{ \"source\", 1, 0, MOUNT_OPT_SOURCE },\n\t\t{ NULL, 0, 0, 0 }\n\t};\n\n\tstatic const ul_excl_t excl[] = {       /* rows and cols in in ASCII order */\n\t\t{ 'B','M','R',\t\t\t/* bind,move,rbind */\n\t\t   MOUNT_OPT_SHARED,   MOUNT_OPT_SLAVE,\n\t\t   MOUNT_OPT_PRIVATE,  MOUNT_OPT_UNBINDABLE,\n\t\t   MOUNT_OPT_RSHARED,  MOUNT_OPT_RSLAVE,\n\t\t   MOUNT_OPT_RPRIVATE, MOUNT_OPT_RUNBINDABLE },\n\n\t\t{ 'L','U', MOUNT_OPT_SOURCE },\t/* label,uuid,source */\n\t\t{ 0 }\n\t};\n\tint excl_st[ARRAY_SIZE(excl)] = UL_EXCL_STATUS_INIT;\n\n\tsanitize_env();\n\tsetlocale(LC_ALL, \"\");\n\tbindtextdomain(PACKAGE, LOCALEDIR);\n\ttextdomain(PACKAGE);\n\tatexit(close_stdout);\n\n\tmnt_init_debug(0);\n\tcxt = mnt_new_context();\n\tif (!cxt)\n\t\terr(MOUNT_EX_SYSERR, _(\"libmount context allocation failed\"));\n\n\tmnt_context_set_tables_errcb(cxt, table_parser_errcb);\n\n\twhile ((c = getopt_long(argc, argv, \"aBcfFhilL:Mno:O:p:rRsU:vVwt:T:\",\n\t\t\t\t\tlongopts, NULL)) != -1) {\n\n\t\t/* only few options are allowed for non-root users */\n\t\tif (mnt_context_is_restricted(cxt) &&\n\t\t    !strchr(\"hlLUVvpris\", c) &&\n\t\t    c != MOUNT_OPT_TARGET &&\n\t\t    c != MOUNT_OPT_SOURCE)\n\t\t\texit_non_root(option_to_longopt(c, longopts));\n\n\t\terr_exclusive_options(c, longopts, excl, excl_st);\n\n\t\tswitch(c) {\n\t\tcase 'a':\n\t\t\tall = 1;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tmnt_context_disable_canonicalize(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tmnt_context_enable_fake(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tmnt_context_enable_fork(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage(stdout);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tmnt_context_disable_helpers(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tmnt_context_disable_mtab(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tif (mnt_context_append_options(cxt, \"ro\"))\n\t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to append options\"));\n\t\t\treadwrite = 0;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tmnt_context_enable_verbose(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tprint_version();\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tif (mnt_context_append_options(cxt, \"rw\"))\n\t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to append options\"));\n\t\t\treadwrite = 1;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tif (mnt_context_append_options(cxt, optarg))\n\t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to append options\"));\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tif (mnt_context_set_options_pattern(cxt, optarg))\n\t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to set options pattern\"));\n\t\t\tbreak;\n\t\tcase 'p':\n                        warnx(_(\"--pass-fd is no longer supported\"));\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\txasprintf(&srcbuf, \"LABEL=\\\"%s\\\"\", optarg);\n\t\t\tmnt_context_disable_swapmatch(cxt, 1);\n\t\t\tmnt_context_set_source(cxt, srcbuf);\n\t\t\tfree(srcbuf);\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\txasprintf(&srcbuf, \"UUID=\\\"%s\\\"\", optarg);\n\t\t\tmnt_context_disable_swapmatch(cxt, 1);\n\t\t\tmnt_context_set_source(cxt, srcbuf);\n\t\t\tfree(srcbuf);\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tshow_labels = 1;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\ttypes = optarg;\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tfstab = append_fstab(cxt, fstab, optarg);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tmnt_context_enable_sloppy(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'B':\n\t\t\toper |= MS_BIND;\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\toper |= MS_MOVE;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\toper |= (MS_BIND | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_SHARED:\n\t\t\toper |= MS_SHARED;\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_SLAVE:\n\t\t\toper |= MS_SLAVE;\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_PRIVATE:\n\t\t\toper |= MS_PRIVATE;\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_UNBINDABLE:\n\t\t\toper |= MS_UNBINDABLE;\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_RSHARED:\n\t\t\toper |= (MS_SHARED | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_RSLAVE:\n\t\t\toper |= (MS_SLAVE | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_RPRIVATE:\n\t\t\toper |= (MS_PRIVATE | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_RUNBINDABLE:\n\t\t\toper |= (MS_UNBINDABLE | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_TARGET:\n\t\t\tmnt_context_disable_swapmatch(cxt, 1);\n\t\t\tmnt_context_set_target(cxt, optarg);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_SOURCE:\n\t\t\tmnt_context_disable_swapmatch(cxt, 1);\n\t\t\tmnt_context_set_source(cxt, optarg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage(stderr);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\tif (fstab && !mnt_context_is_nocanonicalize(cxt)) {\n\t\t/*\n\t\t * We have external (context independent) fstab instance, let's\n\t\t * make a connection between the fstab and the canonicalization\n\t\t * cache.\n\t\t */\n\t\tstruct libmnt_cache *cache = mnt_context_get_cache(cxt);\n\t\tmnt_table_set_cache(fstab, cache);\n\t}\n\n\tif (!mnt_context_get_source(cxt) &&\n\t    !mnt_context_get_target(cxt) &&\n\t    !argc &&\n\t    !all) {\n\t\tif (oper)\n\t\t\tusage(stderr);\n\t\tprint_all(cxt, types, show_labels);\n\t\tgoto done;\n\t}\n\n\tif (oper && (types || all || mnt_context_get_source(cxt)))\n\t\tusage(stderr);\n\n\tif (types && (all || strchr(types, ',') ||\n\t\t\t     strncmp(types, \"no\", 2) == 0))\n\t\tmnt_context_set_fstype_pattern(cxt, types);\n\telse if (types)\n\t\tmnt_context_set_fstype(cxt, types);\n\n\tif (all) {\n\t\t/*\n\t\t * A) Mount all\n\t\t */\n\t\trc = mount_all(cxt);\n\t\tgoto done;\n\n\t} else if (argc == 0 && (mnt_context_get_source(cxt) ||\n\t\t\t\t mnt_context_get_target(cxt))) {\n\t\t/*\n\t\t * B) mount -L|-U|--source|--target\n\t\t */\n\t\tif (mnt_context_is_restricted(cxt) &&\n\t\t    mnt_context_get_source(cxt) &&\n\t\t    mnt_context_get_target(cxt))\n\t\t\texit_non_root(NULL);\n\n\t} else if (argc == 1) {\n\t\t/*\n\t\t * C) mount [-L|-U|--source] <target>\n\t\t *    mount <source|target>\n\t\t *\n\t\t * non-root may specify source *or* target, but not both\n\t\t */\n\t\tif (mnt_context_is_restricted(cxt) &&\n\t\t    mnt_context_get_source(cxt))\n\t\t\texit_non_root(NULL);\n\n\t\tmnt_context_set_target(cxt, argv[0]);\n\n\t} else if (argc == 2 && !mnt_context_get_source(cxt)\n\t\t\t     && !mnt_context_get_target(cxt)) {\n\t\t/*\n\t\t * D) mount <source> <target>\n\t\t */\n\t\tif (mnt_context_is_restricted(cxt))\n\t\t\texit_non_root(NULL);\n\t\tmnt_context_set_source(cxt, argv[0]);\n\t\tmnt_context_set_target(cxt, argv[1]);\n\n\t} else\n\t\tusage(stderr);\n\n\tif (oper) {\n\t\t/* MS_PROPAGATION operations, let's set the mount flags */\n\t\tmnt_context_set_mflags(cxt, oper);\n\n\t\t/* For -make* or --bind is fstab unnecessary */\n\t\tmnt_context_set_optsmode(cxt, MNT_OMODE_NOTAB);\n\t}\n\n\trc = mnt_context_mount(cxt);\n\trc = mk_exit_code(cxt, rc);\n\n\tif (rc == MOUNT_EX_SUCCESS && mnt_context_is_verbose(cxt))\n\t\tsuccess_message(cxt);\ndone:\n\tmnt_free_context(cxt);\n\tmnt_free_table(fstab);\n\treturn rc;\n}", "func_hash": 219498005792940261578066564094421095366, "file_name": "mount.c", "file_hash": 324534442685972817552003935079520935664, "cwe": ["CWE-200"], "cve": "CVE-2013-0157", "cve_desc": "(a) mount and (b) umount in util-linux 2.14.1, 2.17.2, and probably other versions allow local users to determine the existence of restricted directories by (1) using the --guess-fstype command-line option or (2) attempting to mount a non-existent device, which generates different error messages depending on whether the directory exists.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-0157", "file_path": "mount-deprecated/mount.c"}
{"idx": 406206, "project": "util-linux", "commit_id": "5ebbc3865d1e53ef42e5f121c41faab23dd59075", "project_url": "https://github.com/karelzak/util-linux", "commit_url": "http://git.kernel.org/?p=utils/util-linux/util-linux.git;a=commit;h=5ebbc3865d1e53ef42e5f121c41faab23dd59075", "commit_message": "mount: sanitize paths from non-root users\n\n $ mount /root/.ssh/../../dev/sda2\n mount: only root can mount UUID=17bc65ec-4125-4e7c-8a7d-e2795064c736 on /boot\n\nthis is too promiscuous. It seems better to ignore on command line\nspecified paths which are not resolve-able for non-root users.\n\nFixed version:\n\n  $ mount /root/.ssh/../../dev/sda2\n  mount: /root/.ssh/../../dev/sda2: Permission denied\n\n  $ mount /dev/sda2\n  mount: only root can mount UUID=17bc65ec-4125-4e7c-8a7d-e2795064c736 on /boot\n\nNote that this bug has no relation to mount(2) permissions evaluation\nin suid mode. The way how non-root user specifies paths on command\nline is completely irrelevant for comparison with fstab entries.\n\nSigned-off-by: Karel Zak <kzak@redhat.com>", "target": 0, "func": "int main(int argc, char **argv)\n{\n\tint c, rc = MOUNT_EX_SUCCESS, all = 0, show_labels = 0;\n\tstruct libmnt_context *cxt;\n\tstruct libmnt_table *fstab = NULL;\n\tchar *srcbuf = NULL;\n\tchar *types = NULL;\n\tunsigned long oper = 0;\n\n\tenum {\n\t\tMOUNT_OPT_SHARED = CHAR_MAX + 1,\n\t\tMOUNT_OPT_SLAVE,\n\t\tMOUNT_OPT_PRIVATE,\n\t\tMOUNT_OPT_UNBINDABLE,\n\t\tMOUNT_OPT_RSHARED,\n\t\tMOUNT_OPT_RSLAVE,\n\t\tMOUNT_OPT_RPRIVATE,\n\t\tMOUNT_OPT_RUNBINDABLE,\n\t\tMOUNT_OPT_TARGET,\n\t\tMOUNT_OPT_SOURCE\n\t};\n\n\tstatic const struct option longopts[] = {\n\t\t{ \"all\", 0, 0, 'a' },\n\t\t{ \"fake\", 0, 0, 'f' },\n\t\t{ \"fstab\", 1, 0, 'T' },\n\t\t{ \"fork\", 0, 0, 'F' },\n\t\t{ \"help\", 0, 0, 'h' },\n\t\t{ \"no-mtab\", 0, 0, 'n' },\n\t\t{ \"read-only\", 0, 0, 'r' },\n\t\t{ \"ro\", 0, 0, 'r' },\n\t\t{ \"verbose\", 0, 0, 'v' },\n\t\t{ \"version\", 0, 0, 'V' },\n\t\t{ \"read-write\", 0, 0, 'w' },\n\t\t{ \"rw\", 0, 0, 'w' },\n\t\t{ \"options\", 1, 0, 'o' },\n\t\t{ \"test-opts\", 1, 0, 'O' },\n\t\t{ \"pass-fd\", 1, 0, 'p' },\n\t\t{ \"types\", 1, 0, 't' },\n\t\t{ \"uuid\", 1, 0, 'U' },\n\t\t{ \"label\", 1, 0, 'L'},\n\t\t{ \"bind\", 0, 0, 'B' },\n\t\t{ \"move\", 0, 0, 'M' },\n\t\t{ \"rbind\", 0, 0, 'R' },\n\t\t{ \"make-shared\", 0, 0, MOUNT_OPT_SHARED },\n\t\t{ \"make-slave\", 0, 0, MOUNT_OPT_SLAVE },\n\t\t{ \"make-private\", 0, 0, MOUNT_OPT_PRIVATE },\n\t\t{ \"make-unbindable\", 0, 0, MOUNT_OPT_UNBINDABLE },\n\t\t{ \"make-rshared\", 0, 0, MOUNT_OPT_RSHARED },\n\t\t{ \"make-rslave\", 0, 0, MOUNT_OPT_RSLAVE },\n\t\t{ \"make-rprivate\", 0, 0, MOUNT_OPT_RPRIVATE },\n\t\t{ \"make-runbindable\", 0, 0, MOUNT_OPT_RUNBINDABLE },\n\t\t{ \"no-canonicalize\", 0, 0, 'c' },\n\t\t{ \"internal-only\", 0, 0, 'i' },\n\t\t{ \"show-labels\", 0, 0, 'l' },\n\t\t{ \"target\", 1, 0, MOUNT_OPT_TARGET },\n\t\t{ \"source\", 1, 0, MOUNT_OPT_SOURCE },\n\t\t{ NULL, 0, 0, 0 }\n\t};\n\n\tstatic const ul_excl_t excl[] = {       /* rows and cols in in ASCII order */\n\t\t{ 'B','M','R',\t\t\t/* bind,move,rbind */\n\t\t   MOUNT_OPT_SHARED,   MOUNT_OPT_SLAVE,\n\t\t   MOUNT_OPT_PRIVATE,  MOUNT_OPT_UNBINDABLE,\n\t\t   MOUNT_OPT_RSHARED,  MOUNT_OPT_RSLAVE,\n\t\t   MOUNT_OPT_RPRIVATE, MOUNT_OPT_RUNBINDABLE },\n\n\t\t{ 'L','U', MOUNT_OPT_SOURCE },\t/* label,uuid,source */\n\t\t{ 0 }\n\t};\n\tint excl_st[ARRAY_SIZE(excl)] = UL_EXCL_STATUS_INIT;\n\n\tsanitize_env();\n\tsetlocale(LC_ALL, \"\");\n\tbindtextdomain(PACKAGE, LOCALEDIR);\n\ttextdomain(PACKAGE);\n\tatexit(close_stdout);\n\n\tmnt_init_debug(0);\n\tcxt = mnt_new_context();\n\tif (!cxt)\n\t\terr(MOUNT_EX_SYSERR, _(\"libmount context allocation failed\"));\n\n\tmnt_context_set_tables_errcb(cxt, table_parser_errcb);\n\n\twhile ((c = getopt_long(argc, argv, \"aBcfFhilL:Mno:O:p:rRsU:vVwt:T:\",\n\t\t\t\t\tlongopts, NULL)) != -1) {\n\n\t\t/* only few options are allowed for non-root users */\n\t\tif (mnt_context_is_restricted(cxt) &&\n\t\t    !strchr(\"hlLUVvpris\", c) &&\n\t\t    c != MOUNT_OPT_TARGET &&\n\t\t    c != MOUNT_OPT_SOURCE)\n\t\t\texit_non_root(option_to_longopt(c, longopts));\n\n\t\terr_exclusive_options(c, longopts, excl, excl_st);\n\n\t\tswitch(c) {\n\t\tcase 'a':\n\t\t\tall = 1;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tmnt_context_disable_canonicalize(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tmnt_context_enable_fake(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tmnt_context_enable_fork(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage(stdout);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tmnt_context_disable_helpers(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tmnt_context_disable_mtab(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tif (mnt_context_append_options(cxt, \"ro\"))\n\t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to append options\"));\n\t\t\treadwrite = 0;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tmnt_context_enable_verbose(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tprint_version();\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tif (mnt_context_append_options(cxt, \"rw\"))\n\t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to append options\"));\n\t\t\treadwrite = 1;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tif (mnt_context_append_options(cxt, optarg))\n\t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to append options\"));\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tif (mnt_context_set_options_pattern(cxt, optarg))\n\t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to set options pattern\"));\n\t\t\tbreak;\n\t\tcase 'p':\n                        warnx(_(\"--pass-fd is no longer supported\"));\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\txasprintf(&srcbuf, \"LABEL=\\\"%s\\\"\", optarg);\n\t\t\tmnt_context_disable_swapmatch(cxt, 1);\n\t\t\tmnt_context_set_source(cxt, srcbuf);\n\t\t\tfree(srcbuf);\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\txasprintf(&srcbuf, \"UUID=\\\"%s\\\"\", optarg);\n\t\t\tmnt_context_disable_swapmatch(cxt, 1);\n\t\t\tmnt_context_set_source(cxt, srcbuf);\n\t\t\tfree(srcbuf);\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tshow_labels = 1;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\ttypes = optarg;\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tfstab = append_fstab(cxt, fstab, optarg);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tmnt_context_enable_sloppy(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'B':\n\t\t\toper |= MS_BIND;\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\toper |= MS_MOVE;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\toper |= (MS_BIND | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_SHARED:\n\t\t\toper |= MS_SHARED;\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_SLAVE:\n\t\t\toper |= MS_SLAVE;\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_PRIVATE:\n\t\t\toper |= MS_PRIVATE;\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_UNBINDABLE:\n\t\t\toper |= MS_UNBINDABLE;\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_RSHARED:\n\t\t\toper |= (MS_SHARED | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_RSLAVE:\n\t\t\toper |= (MS_SLAVE | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_RPRIVATE:\n\t\t\toper |= (MS_PRIVATE | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_RUNBINDABLE:\n\t\t\toper |= (MS_UNBINDABLE | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_TARGET:\n\t\t\tmnt_context_disable_swapmatch(cxt, 1);\n\t\t\tmnt_context_set_target(cxt, optarg);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_SOURCE:\n\t\t\tmnt_context_disable_swapmatch(cxt, 1);\n\t\t\tmnt_context_set_source(cxt, optarg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage(stderr);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\tif (fstab && !mnt_context_is_nocanonicalize(cxt)) {\n\t\t/*\n\t\t * We have external (context independent) fstab instance, let's\n\t\t * make a connection between the fstab and the canonicalization\n\t\t * cache.\n\t\t */\n\t\tstruct libmnt_cache *cache = mnt_context_get_cache(cxt);\n\t\tmnt_table_set_cache(fstab, cache);\n\t}\n\n\tif (!mnt_context_get_source(cxt) &&\n\t    !mnt_context_get_target(cxt) &&\n\t    !argc &&\n\t    !all) {\n\t\tif (oper)\n\t\t\tusage(stderr);\n\t\tprint_all(cxt, types, show_labels);\n\t\tgoto done;\n\t}\n\n\tif (oper && (types || all || mnt_context_get_source(cxt)))\n\t\tusage(stderr);\n\n\tif (types && (all || strchr(types, ',') ||\n\t\t\t     strncmp(types, \"no\", 2) == 0))\n\t\tmnt_context_set_fstype_pattern(cxt, types);\n\telse if (types)\n\t\tmnt_context_set_fstype(cxt, types);\n\n\tif (all) {\n\t\t/*\n\t\t * A) Mount all\n\t\t */\n\t\trc = mount_all(cxt);\n\t\tgoto done;\n\n\t} else if (argc == 0 && (mnt_context_get_source(cxt) ||\n\t\t\t\t mnt_context_get_target(cxt))) {\n\t\t/*\n\t\t * B) mount -L|-U|--source|--target\n\t\t */\n\t\tif (mnt_context_is_restricted(cxt) &&\n\t\t    mnt_context_get_source(cxt) &&\n\t\t    mnt_context_get_target(cxt))\n\t\t\texit_non_root(NULL);\n\n\t} else if (argc == 1) {\n\t\t/*\n\t\t * C) mount [-L|-U|--source] <target>\n\t\t *    mount <source|target>\n\t\t *\n\t\t * non-root may specify source *or* target, but not both\n\t\t */\n\t\tif (mnt_context_is_restricted(cxt) &&\n\t\t    mnt_context_get_source(cxt))\n\t\t\texit_non_root(NULL);\n\n\t\tmnt_context_set_target(cxt, argv[0]);\n\n\t} else if (argc == 2 && !mnt_context_get_source(cxt)\n\t\t\t     && !mnt_context_get_target(cxt)) {\n\t\t/*\n\t\t * D) mount <source> <target>\n\t\t */\n\t\tif (mnt_context_is_restricted(cxt))\n\t\t\texit_non_root(NULL);\n\t\tmnt_context_set_source(cxt, argv[0]);\n\t\tmnt_context_set_target(cxt, argv[1]);\n\n\t} else\n\t\tusage(stderr);\n\n\tif (mnt_context_is_restricted(cxt))\n\t\tsanitize_paths(cxt);\n\n\tif (oper) {\n\t\t/* MS_PROPAGATION operations, let's set the mount flags */\n\t\tmnt_context_set_mflags(cxt, oper);\n\n\t\t/* For -make* or --bind is fstab unnecessary */\n\t\tmnt_context_set_optsmode(cxt, MNT_OMODE_NOTAB);\n\t}\n\n\trc = mnt_context_mount(cxt);\n\trc = mk_exit_code(cxt, rc);\n\n\tif (rc == MOUNT_EX_SUCCESS && mnt_context_is_verbose(cxt))\n\t\tsuccess_message(cxt);\ndone:\n\tmnt_free_context(cxt);\n\tmnt_free_table(fstab);\n\treturn rc;\n}", "func_hash": 43692452455655783216200177030716124780, "file_name": "mount.c", "file_hash": 7925930289343170386207247806304317495, "cwe": ["CWE-200"], "cve": "CVE-2013-0157", "cve_desc": "(a) mount and (b) umount in util-linux 2.14.1, 2.17.2, and probably other versions allow local users to determine the existence of restricted directories by (1) using the --guess-fstype command-line option or (2) attempting to mount a non-existent device, which generates different error messages depending on whether the directory exists.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-0157", "file_path": "mount-deprecated/mount.c"}
{"idx": 208370, "project": "vim", "commit_id": "806d037671e133bd28a7864248763f643967973a", "project_url": "https://github.com/vim/vim", "commit_url": "https://github.com/vim/vim/commit/806d037671e133bd28a7864248763f643967973a", "commit_message": "patch 8.2.4218: illegal memory access with bracketed paste in Ex mode\n\nProblem:    Illegal memory access with bracketed paste in Ex mode.\nSolution:   Reserve space for the trailing NUL.", "target": 1, "func": "bracketed_paste(paste_mode_T mode, int drop, garray_T *gap)\n{\n    int\t\tc;\n    char_u\tbuf[NUMBUFLEN + MB_MAXBYTES];\n    int\t\tidx = 0;\n    char_u\t*end = find_termcode((char_u *)\"PE\");\n    int\t\tret_char = -1;\n    int\t\tsave_allow_keys = allow_keys;\n    int\t\tsave_paste = p_paste;\n\n    // If the end code is too long we can't detect it, read everything.\n    if (end != NULL && STRLEN(end) >= NUMBUFLEN)\n\tend = NULL;\n    ++no_mapping;\n    allow_keys = 0;\n    if (!p_paste)\n\t// Also have the side effects of setting 'paste' to make it work much\n\t// faster.\n\tset_option_value((char_u *)\"paste\", TRUE, NULL, 0);\n\n    for (;;)\n    {\n\t// When the end is not defined read everything there is.\n\tif (end == NULL && vpeekc() == NUL)\n\t    break;\n\tdo\n\t    c = vgetc();\n\twhile (c == K_IGNORE || c == K_VER_SCROLLBAR || c == K_HOR_SCROLLBAR);\n\tif (c == NUL || got_int || (ex_normal_busy > 0 && c == Ctrl_C))\n\t    // When CTRL-C was encountered the typeahead will be flushed and we\n\t    // won't get the end sequence.  Except when using \":normal\".\n\t    break;\n\n\tif (has_mbyte)\n\t    idx += (*mb_char2bytes)(c, buf + idx);\n\telse\n\t    buf[idx++] = c;\n\tbuf[idx] = NUL;\n\tif (end != NULL && STRNCMP(buf, end, idx) == 0)\n\t{\n\t    if (end[idx] == NUL)\n\t\tbreak; // Found the end of paste code.\n\t    continue;\n\t}\n\tif (!drop)\n\t{\n\t    switch (mode)\n\t    {\n\t\tcase PASTE_CMDLINE:\n\t\t    put_on_cmdline(buf, idx, TRUE);\n\t\t    break;\n\n\t\tcase PASTE_EX:\n\t\t    if (gap != NULL && ga_grow(gap, idx) == OK)\n\t\t    {\n\t\t\tmch_memmove((char *)gap->ga_data + gap->ga_len,\n\t\t\t\t\t\t\t     buf, (size_t)idx);\n\t\t\tgap->ga_len += idx;\n\t\t    }\n\t\t    break;\n\n\t\tcase PASTE_INSERT:\n\t\t    if (stop_arrow() == OK)\n\t\t    {\n\t\t\tc = buf[0];\n\t\t\tif (idx == 1 && (c == CAR || c == K_KENTER || c == NL))\n\t\t\t    ins_eol(c);\n\t\t\telse\n\t\t\t{\n\t\t\t    ins_char_bytes(buf, idx);\n\t\t\t    AppendToRedobuffLit(buf, idx);\n\t\t\t}\n\t\t    }\n\t\t    break;\n\n\t\tcase PASTE_ONE_CHAR:\n\t\t    if (ret_char == -1)\n\t\t    {\n\t\t\tif (has_mbyte)\n\t\t\t    ret_char = (*mb_ptr2char)(buf);\n\t\t\telse\n\t\t\t    ret_char = buf[0];\n\t\t    }\n\t\t    break;\n\t    }\n\t}\n\tidx = 0;\n    }\n\n    --no_mapping;\n    allow_keys = save_allow_keys;\n    if (!save_paste)\n\tset_option_value((char_u *)\"paste\", FALSE, NULL, 0);\n\n    return ret_char;\n}", "func_hash": 304493990488783960232843007629982350455, "file_name": "edit.c", "file_hash": 253330379214920739736877102106471261423, "cwe": ["CWE-787"], "cve": "CVE-2022-0392", "cve_desc": "Heap-based Buffer Overflow in GitHub repository vim prior to 8.2.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-0392", "file_path": "src/edit.c"}
{"idx": 408968, "project": "vim", "commit_id": "806d037671e133bd28a7864248763f643967973a", "project_url": "https://github.com/vim/vim", "commit_url": "https://github.com/vim/vim/commit/806d037671e133bd28a7864248763f643967973a", "commit_message": "patch 8.2.4218: illegal memory access with bracketed paste in Ex mode\n\nProblem:    Illegal memory access with bracketed paste in Ex mode.\nSolution:   Reserve space for the trailing NUL.", "target": 0, "func": "bracketed_paste(paste_mode_T mode, int drop, garray_T *gap)\n{\n    int\t\tc;\n    char_u\tbuf[NUMBUFLEN + MB_MAXBYTES];\n    int\t\tidx = 0;\n    char_u\t*end = find_termcode((char_u *)\"PE\");\n    int\t\tret_char = -1;\n    int\t\tsave_allow_keys = allow_keys;\n    int\t\tsave_paste = p_paste;\n\n    // If the end code is too long we can't detect it, read everything.\n    if (end != NULL && STRLEN(end) >= NUMBUFLEN)\n\tend = NULL;\n    ++no_mapping;\n    allow_keys = 0;\n    if (!p_paste)\n\t// Also have the side effects of setting 'paste' to make it work much\n\t// faster.\n\tset_option_value((char_u *)\"paste\", TRUE, NULL, 0);\n\n    for (;;)\n    {\n\t// When the end is not defined read everything there is.\n\tif (end == NULL && vpeekc() == NUL)\n\t    break;\n\tdo\n\t    c = vgetc();\n\twhile (c == K_IGNORE || c == K_VER_SCROLLBAR || c == K_HOR_SCROLLBAR);\n\tif (c == NUL || got_int || (ex_normal_busy > 0 && c == Ctrl_C))\n\t    // When CTRL-C was encountered the typeahead will be flushed and we\n\t    // won't get the end sequence.  Except when using \":normal\".\n\t    break;\n\n\tif (has_mbyte)\n\t    idx += (*mb_char2bytes)(c, buf + idx);\n\telse\n\t    buf[idx++] = c;\n\tbuf[idx] = NUL;\n\tif (end != NULL && STRNCMP(buf, end, idx) == 0)\n\t{\n\t    if (end[idx] == NUL)\n\t\tbreak; // Found the end of paste code.\n\t    continue;\n\t}\n\tif (!drop)\n\t{\n\t    switch (mode)\n\t    {\n\t\tcase PASTE_CMDLINE:\n\t\t    put_on_cmdline(buf, idx, TRUE);\n\t\t    break;\n\n\t\tcase PASTE_EX:\n\t\t    // add one for the NUL that is going to be appended\n\t\t    if (gap != NULL && ga_grow(gap, idx + 1) == OK)\n\t\t    {\n\t\t\tmch_memmove((char *)gap->ga_data + gap->ga_len,\n\t\t\t\t\t\t\t     buf, (size_t)idx);\n\t\t\tgap->ga_len += idx;\n\t\t    }\n\t\t    break;\n\n\t\tcase PASTE_INSERT:\n\t\t    if (stop_arrow() == OK)\n\t\t    {\n\t\t\tc = buf[0];\n\t\t\tif (idx == 1 && (c == CAR || c == K_KENTER || c == NL))\n\t\t\t    ins_eol(c);\n\t\t\telse\n\t\t\t{\n\t\t\t    ins_char_bytes(buf, idx);\n\t\t\t    AppendToRedobuffLit(buf, idx);\n\t\t\t}\n\t\t    }\n\t\t    break;\n\n\t\tcase PASTE_ONE_CHAR:\n\t\t    if (ret_char == -1)\n\t\t    {\n\t\t\tif (has_mbyte)\n\t\t\t    ret_char = (*mb_ptr2char)(buf);\n\t\t\telse\n\t\t\t    ret_char = buf[0];\n\t\t    }\n\t\t    break;\n\t    }\n\t}\n\tidx = 0;\n    }\n\n    --no_mapping;\n    allow_keys = save_allow_keys;\n    if (!save_paste)\n\tset_option_value((char_u *)\"paste\", FALSE, NULL, 0);\n\n    return ret_char;\n}", "func_hash": 237228533852438658740165650986586610988, "file_name": "edit.c", "file_hash": 72953735620149631855784875265490970900, "cwe": ["CWE-787"], "cve": "CVE-2022-0392", "cve_desc": "Heap-based Buffer Overflow in GitHub repository vim prior to 8.2.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-0392", "file_path": "src/edit.c"}
{"idx": 208411, "project": "vim", "commit_id": "27efc62f5d86afcb2ecb7565587fe8dea4b036fe", "project_url": "https://github.com/vim/vim", "commit_url": "https://github.com/vim/vim/commit/27efc62f5d86afcb2ecb7565587fe8dea4b036fe", "commit_message": "patch 9.0.0018: going over the end of the typahead\n\nProblem:    Going over the end of the typahead.\nSolution:   Put a NUL after the typeahead.", "target": 1, "func": "check_termcode(\n    int\t\tmax_offset,\n    char_u\t*buf,\n    int\t\tbufsize,\n    int\t\t*buflen)\n{\n    char_u\t*tp;\n    char_u\t*p;\n    int\t\tslen = 0;\t// init for GCC\n    int\t\tmodslen;\n    int\t\tlen;\n    int\t\tretval = 0;\n    int\t\toffset;\n    char_u\tkey_name[2];\n    int\t\tmodifiers;\n    char_u\t*modifiers_start = NULL;\n    int\t\tkey;\n    int\t\tnew_slen;   // Length of what will replace the termcode\n    char_u\tstring[MAX_KEY_CODE_LEN + 1];\n    int\t\ti, j;\n    int\t\tidx = 0;\n    int\t\tcpo_koffset;\n\n    cpo_koffset = (vim_strchr(p_cpo, CPO_KOFFSET) != NULL);\n\n    /*\n     * Speed up the checks for terminal codes by gathering all first bytes\n     * used in termleader[].  Often this is just a single <Esc>.\n     */\n    if (need_gather)\n\tgather_termleader();\n\n    /*\n     * Check at several positions in typebuf.tb_buf[], to catch something like\n     * \"x<Up>\" that can be mapped. Stop at max_offset, because characters\n     * after that cannot be used for mapping, and with @r commands\n     * typebuf.tb_buf[] can become very long.\n     * This is used often, KEEP IT FAST!\n     */\n    for (offset = 0; offset < max_offset; ++offset)\n    {\n\tif (buf == NULL)\n\t{\n\t    if (offset >= typebuf.tb_len)\n\t\tbreak;\n\t    tp = typebuf.tb_buf + typebuf.tb_off + offset;\n\t    len = typebuf.tb_len - offset;\t// length of the input\n\t}\n\telse\n\t{\n\t    if (offset >= *buflen)\n\t\tbreak;\n\t    tp = buf + offset;\n\t    len = *buflen - offset;\n\t}\n\n\t/*\n\t * Don't check characters after K_SPECIAL, those are already\n\t * translated terminal chars (avoid translating ~@^Hx).\n\t */\n\tif (*tp == K_SPECIAL)\n\t{\n\t    offset += 2;\t// there are always 2 extra characters\n\t    continue;\n\t}\n\n\t/*\n\t * Skip this position if the character does not appear as the first\n\t * character in term_strings. This speeds up a lot, since most\n\t * termcodes start with the same character (ESC or CSI).\n\t */\n\ti = *tp;\n\tfor (p = termleader; *p && *p != i; ++p)\n\t    ;\n\tif (*p == NUL)\n\t    continue;\n\n\t/*\n\t * Skip this position if p_ek is not set and tp[0] is an ESC and we\n\t * are in Insert mode.\n\t */\n\tif (*tp == ESC && !p_ek && (State & MODE_INSERT))\n\t    continue;\n\n\tkey_name[0] = NUL;\t// no key name found yet\n\tkey_name[1] = NUL;\t// no key name found yet\n\tmodifiers = 0;\t\t// no modifiers yet\n\n#ifdef FEAT_GUI\n\tif (gui.in_use)\n\t{\n\t    /*\n\t     * GUI special key codes are all of the form [CSI xx].\n\t     */\n\t    if (*tp == CSI)\t    // Special key from GUI\n\t    {\n\t\tif (len < 3)\n\t\t    return -1;\t    // Shouldn't happen\n\t\tslen = 3;\n\t\tkey_name[0] = tp[1];\n\t\tkey_name[1] = tp[2];\n\t    }\n\t}\n\telse\n#endif // FEAT_GUI\n\t{\n\t    int  mouse_index_found = -1;\n\n\t    for (idx = 0; idx < tc_len; ++idx)\n\t    {\n\t\t/*\n\t\t * Ignore the entry if we are not at the start of\n\t\t * typebuf.tb_buf[]\n\t\t * and there are not enough characters to make a match.\n\t\t * But only when the 'K' flag is in 'cpoptions'.\n\t\t */\n\t\tslen = termcodes[idx].len;\n\t\tmodifiers_start = NULL;\n\t\tif (cpo_koffset && offset && len < slen)\n\t\t    continue;\n\t\tif (STRNCMP(termcodes[idx].code, tp,\n\t\t\t\t     (size_t)(slen > len ? len : slen)) == 0)\n\t\t{\n\t\t    int\t    looks_like_mouse_start = FALSE;\n\n\t\t    if (len < slen)\t\t// got a partial sequence\n\t\t\treturn -1;\t\t// need to get more chars\n\n\t\t    /*\n\t\t     * When found a keypad key, check if there is another key\n\t\t     * that matches and use that one.  This makes <Home> to be\n\t\t     * found instead of <kHome> when they produce the same\n\t\t     * key code.\n\t\t     */\n\t\t    if (termcodes[idx].name[0] == 'K'\n\t\t\t\t       && VIM_ISDIGIT(termcodes[idx].name[1]))\n\t\t    {\n\t\t\tfor (j = idx + 1; j < tc_len; ++j)\n\t\t\t    if (termcodes[j].len == slen &&\n\t\t\t\t    STRNCMP(termcodes[idx].code,\n\t\t\t\t\t    termcodes[j].code, slen) == 0)\n\t\t\t    {\n\t\t\t\tidx = j;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t    }\n\n\t\t    if (slen == 2 && len > 2\n\t\t\t    && termcodes[idx].code[0] == ESC\n\t\t\t    && termcodes[idx].code[1] == '[')\n\t\t    {\n\t\t\t// The mouse termcode \"ESC [\" is also the prefix of\n\t\t\t// \"ESC [ I\" (focus gained) and other keys.  Check some\n\t\t\t// more bytes to find out.\n\t\t\tif (!isdigit(tp[2]))\n\t\t\t{\n\t\t\t    // ESC [ without number following: Only use it when\n\t\t\t    // there is no other match.\n\t\t\t    looks_like_mouse_start = TRUE;\n\t\t\t}\n\t\t\telse if (termcodes[idx].name[0] == KS_DEC_MOUSE)\n\t\t\t{\n\t\t\t    char_u  *nr = tp + 2;\n\t\t\t    int\t    count = 0;\n\n\t\t\t    // If a digit is following it could be a key with\n\t\t\t    // modifier, e.g., ESC [ 1;2P.  Can be confused\n\t\t\t    // with DEC_MOUSE, which requires four numbers\n\t\t\t    // following.  If not then it can't be a DEC_MOUSE\n\t\t\t    // code.\n\t\t\t    for (;;)\n\t\t\t    {\n\t\t\t\t++count;\n\t\t\t\t(void)getdigits(&nr);\n\t\t\t\tif (nr >= tp + len)\n\t\t\t\t    return -1;\t// partial sequence\n\t\t\t\tif (*nr != ';')\n\t\t\t\t    break;\n\t\t\t\t++nr;\n\t\t\t\tif (nr >= tp + len)\n\t\t\t\t    return -1;\t// partial sequence\n\t\t\t    }\n\t\t\t    if (count < 4)\n\t\t\t\tcontinue;\t// no match\n\t\t\t}\n\t\t    }\n\t\t    if (looks_like_mouse_start)\n\t\t    {\n\t\t\t// Only use it when there is no other match.\n\t\t\tif (mouse_index_found < 0)\n\t\t\t    mouse_index_found = idx;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tkey_name[0] = termcodes[idx].name[0];\n\t\t\tkey_name[1] = termcodes[idx].name[1];\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\n\t\t/*\n\t\t * Check for code with modifier, like xterm uses:\n\t\t * <Esc>[123;*X  (modslen == slen - 3)\n\t\t * <Esc>[@;*X    (matches <Esc>[X and <Esc>[1;9X )\n\t\t * Also <Esc>O*X and <M-O>*X (modslen == slen - 2).\n\t\t * When there is a modifier the * matches a number.\n\t\t * When there is no modifier the ;* or * is omitted.\n\t\t */\n\t\tif (termcodes[idx].modlen > 0 && mouse_index_found < 0)\n\t\t{\n\t\t    int at_code;\n\n\t\t    modslen = termcodes[idx].modlen;\n\t\t    if (cpo_koffset && offset && len < modslen)\n\t\t\tcontinue;\n\t\t    at_code = termcodes[idx].code[modslen] == '@';\n\t\t    if (STRNCMP(termcodes[idx].code, tp,\n\t\t\t\t(size_t)(modslen > len ? len : modslen)) == 0)\n\t\t    {\n\t\t\tint\t    n;\n\n\t\t\tif (len <= modslen)\t// got a partial sequence\n\t\t\t    return -1;\t\t// need to get more chars\n\n\t\t\tif (tp[modslen] == termcodes[idx].code[slen - 1])\n\t\t\t    // no modifiers\n\t\t\t    slen = modslen + 1;\n\t\t\telse if (tp[modslen] != ';' && modslen == slen - 3)\n\t\t\t    // no match for \"code;*X\" with \"code;\"\n\t\t\t    continue;\n\t\t\telse if (at_code && tp[modslen] != '1')\n\t\t\t    // no match for \"<Esc>[@\" with \"<Esc>[1\"\n\t\t\t    continue;\n\t\t\telse\n\t\t\t{\n\t\t\t    // Skip over the digits, the final char must\n\t\t\t    // follow. URXVT can use a negative value, thus\n\t\t\t    // also accept '-'.\n\t\t\t    for (j = slen - 2; j < len && (isdigit(tp[j])\n\t\t\t\t       || tp[j] == '-' || tp[j] == ';'); ++j)\n\t\t\t\t;\n\t\t\t    ++j;\n\t\t\t    if (len < j)\t// got a partial sequence\n\t\t\t\treturn -1;\t// need to get more chars\n\t\t\t    if (tp[j - 1] != termcodes[idx].code[slen - 1])\n\t\t\t\tcontinue;\t// no match\n\n\t\t\t    modifiers_start = tp + slen - 2;\n\n\t\t\t    // Match!  Convert modifier bits.\n\t\t\t    n = atoi((char *)modifiers_start);\n\t\t\t    modifiers |= decode_modifiers(n);\n\n\t\t\t    slen = j;\n\t\t\t}\n\t\t\tkey_name[0] = termcodes[idx].name[0];\n\t\t\tkey_name[1] = termcodes[idx].name[1];\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t    if (idx == tc_len && mouse_index_found >= 0)\n\t    {\n\t\tkey_name[0] = termcodes[mouse_index_found].name[0];\n\t\tkey_name[1] = termcodes[mouse_index_found].name[1];\n\t    }\n\t}\n\n#ifdef FEAT_TERMRESPONSE\n\tif (key_name[0] == NUL\n\t    // Mouse codes of DEC and pterm start with <ESC>[.  When\n\t    // detecting the start of these mouse codes they might as well be\n\t    // another key code or terminal response.\n# ifdef FEAT_MOUSE_DEC\n\t    || key_name[0] == KS_DEC_MOUSE\n# endif\n# ifdef FEAT_MOUSE_PTERM\n\t    || key_name[0] == KS_PTERM_MOUSE\n# endif\n\t   )\n\t{\n\t    char_u *argp = tp[0] == ESC ? tp + 2 : tp + 1;\n\n\t    /*\n\t     * Check for responses from the terminal starting with {lead}:\n\t     * \"<Esc>[\" or CSI followed by [0-9>?]\n\t     *\n\t     * - Xterm version string: {lead}>{x};{vers};{y}c\n\t     *   Also eat other possible responses to t_RV, rxvt returns\n\t     *   \"{lead}?1;2c\".\n\t     *\n\t     * - Cursor position report: {lead}{row};{col}R\n\t     *   The final byte must be 'R'. It is used for checking the\n\t     *   ambiguous-width character state.\n\t     *\n\t     * - window position reply: {lead}3;{x};{y}t\n\t     *\n\t     * - key with modifiers when modifyOtherKeys is enabled:\n\t     *\t    {lead}27;{modifier};{key}~\n\t     *\t    {lead}{key};{modifier}u\n\t     */\n\t    if (((tp[0] == ESC && len >= 3 && tp[1] == '[')\n\t\t\t    || (tp[0] == CSI && len >= 2))\n\t\t    && (VIM_ISDIGIT(*argp) || *argp == '>' || *argp == '?'))\n\t    {\n\t\tint resp = handle_csi(tp, len, argp, offset, buf,\n\t\t\t\t\t     bufsize, buflen, key_name, &slen);\n\t\tif (resp != 0)\n\t\t{\n# ifdef DEBUG_TERMRESPONSE\n\t\t    if (resp == -1)\n\t\t\tLOG_TR((\"Not enough characters for CSI sequence\"));\n# endif\n\t\t    return resp;\n\t\t}\n\t    }\n\n\t    // Check for fore/background color response from the terminal,\n\t    // starting} with <Esc>] or OSC\n\t    else if ((*T_RBG != NUL || *T_RFG != NUL)\n\t\t\t&& ((tp[0] == ESC && len >= 2 && tp[1] == ']')\n\t\t\t    || tp[0] == OSC))\n\t    {\n\t\tif (handle_osc(tp, argp, len, key_name, &slen) == FAIL)\n\t\t    return -1;\n\t    }\n\n\t    // Check for key code response from xterm,\n\t    // starting with <Esc>P or DCS\n\t    else if ((check_for_codes || rcs_status.tr_progress == STATUS_SENT)\n\t\t    && ((tp[0] == ESC && len >= 2 && tp[1] == 'P')\n\t\t\t|| tp[0] == DCS))\n\t    {\n\t\tif (handle_dcs(tp, argp, len, key_name, &slen) == FAIL)\n\t\t    return -1;\n\t    }\n\t}\n#endif\n\n\tif (key_name[0] == NUL)\n\t    continue;\t    // No match at this position, try next one\n\n\t// We only get here when we have a complete termcode match\n\n#ifdef FEAT_GUI\n\t/*\n\t * Only in the GUI: Fetch the pointer coordinates of the scroll event\n\t * so that we know which window to scroll later.\n\t */\n\tif (gui.in_use\n\t\t&& key_name[0] == (int)KS_EXTRA\n\t\t&& (key_name[1] == (int)KE_X1MOUSE\n\t\t    || key_name[1] == (int)KE_X2MOUSE\n\t\t    || key_name[1] == (int)KE_MOUSEMOVE_XY\n\t\t    || key_name[1] == (int)KE_MOUSELEFT\n\t\t    || key_name[1] == (int)KE_MOUSERIGHT\n\t\t    || key_name[1] == (int)KE_MOUSEDOWN\n\t\t    || key_name[1] == (int)KE_MOUSEUP))\n\t{\n\t    char_u\tbytes[6];\n\t    int\t\tnum_bytes = get_bytes_from_buf(tp + slen, bytes, 4);\n\n\t    if (num_bytes == -1)\t// not enough coordinates\n\t\treturn -1;\n\t    mouse_col = 128 * (bytes[0] - ' ' - 1) + bytes[1] - ' ' - 1;\n\t    mouse_row = 128 * (bytes[2] - ' ' - 1) + bytes[3] - ' ' - 1;\n\t    slen += num_bytes;\n\t    // equal to K_MOUSEMOVE\n\t    if (key_name[1] == (int)KE_MOUSEMOVE_XY)\n\t\tkey_name[1] = (int)KE_MOUSEMOVE;\n\t}\n\telse\n#endif\n\t/*\n\t * If it is a mouse click, get the coordinates.\n\t */\n\tif (key_name[0] == KS_MOUSE\n#ifdef FEAT_MOUSE_GPM\n\t\t|| key_name[0] == KS_GPM_MOUSE\n#endif\n#ifdef FEAT_MOUSE_JSB\n\t\t|| key_name[0] == KS_JSBTERM_MOUSE\n#endif\n#ifdef FEAT_MOUSE_NET\n\t\t|| key_name[0] == KS_NETTERM_MOUSE\n#endif\n#ifdef FEAT_MOUSE_DEC\n\t\t|| key_name[0] == KS_DEC_MOUSE\n#endif\n#ifdef FEAT_MOUSE_PTERM\n\t\t|| key_name[0] == KS_PTERM_MOUSE\n#endif\n#ifdef FEAT_MOUSE_URXVT\n\t\t|| key_name[0] == KS_URXVT_MOUSE\n#endif\n\t\t|| key_name[0] == KS_SGR_MOUSE\n\t\t|| key_name[0] == KS_SGR_MOUSE_RELEASE)\n\t{\n\t    if (check_termcode_mouse(tp, &slen, key_name, modifiers_start, idx,\n\t\t\t\t\t\t\t     &modifiers) == -1)\n\t\treturn -1;\n\t}\n\n#ifdef FEAT_GUI\n\t/*\n\t * If using the GUI, then we get menu and scrollbar events.\n\t *\n\t * A menu event is encoded as K_SPECIAL, KS_MENU, KE_FILLER followed by\n\t * four bytes which are to be taken as a pointer to the vimmenu_T\n\t * structure.\n\t *\n\t * A tab line event is encoded as K_SPECIAL KS_TABLINE nr, where \"nr\"\n\t * is one byte with the tab index.\n\t *\n\t * A scrollbar event is K_SPECIAL, KS_VER_SCROLLBAR, KE_FILLER followed\n\t * by one byte representing the scrollbar number, and then four bytes\n\t * representing a long_u which is the new value of the scrollbar.\n\t *\n\t * A horizontal scrollbar event is K_SPECIAL, KS_HOR_SCROLLBAR,\n\t * KE_FILLER followed by four bytes representing a long_u which is the\n\t * new value of the scrollbar.\n\t */\n# ifdef FEAT_MENU\n\telse if (key_name[0] == (int)KS_MENU)\n\t{\n\t    long_u\tval;\n\t    int\t\tnum_bytes = get_long_from_buf(tp + slen, &val);\n\n\t    if (num_bytes == -1)\n\t\treturn -1;\n\t    current_menu = (vimmenu_T *)val;\n\t    slen += num_bytes;\n\n\t    // The menu may have been deleted right after it was used, check\n\t    // for that.\n\t    if (check_menu_pointer(root_menu, current_menu) == FAIL)\n\t    {\n\t\tkey_name[0] = KS_EXTRA;\n\t\tkey_name[1] = (int)KE_IGNORE;\n\t    }\n\t}\n# endif\n# ifdef FEAT_GUI_TABLINE\n\telse if (key_name[0] == (int)KS_TABLINE)\n\t{\n\t    // Selecting tabline tab or using its menu.\n\t    char_u\tbytes[6];\n\t    int\t\tnum_bytes = get_bytes_from_buf(tp + slen, bytes, 1);\n\n\t    if (num_bytes == -1)\n\t\treturn -1;\n\t    current_tab = (int)bytes[0];\n\t    if (current_tab == 255)\t// -1 in a byte gives 255\n\t\tcurrent_tab = -1;\n\t    slen += num_bytes;\n\t}\n\telse if (key_name[0] == (int)KS_TABMENU)\n\t{\n\t    // Selecting tabline tab or using its menu.\n\t    char_u\tbytes[6];\n\t    int\t\tnum_bytes = get_bytes_from_buf(tp + slen, bytes, 2);\n\n\t    if (num_bytes == -1)\n\t\treturn -1;\n\t    current_tab = (int)bytes[0];\n\t    current_tabmenu = (int)bytes[1];\n\t    slen += num_bytes;\n\t}\n# endif\n# ifndef USE_ON_FLY_SCROLL\n\telse if (key_name[0] == (int)KS_VER_SCROLLBAR)\n\t{\n\t    long_u\tval;\n\t    char_u\tbytes[6];\n\t    int\t\tnum_bytes;\n\n\t    // Get the last scrollbar event in the queue of the same type\n\t    j = 0;\n\t    for (i = 0; tp[j] == CSI && tp[j + 1] == KS_VER_SCROLLBAR\n\t\t\t\t\t\t     && tp[j + 2] != NUL; ++i)\n\t    {\n\t\tj += 3;\n\t\tnum_bytes = get_bytes_from_buf(tp + j, bytes, 1);\n\t\tif (num_bytes == -1)\n\t\t    break;\n\t\tif (i == 0)\n\t\t    current_scrollbar = (int)bytes[0];\n\t\telse if (current_scrollbar != (int)bytes[0])\n\t\t    break;\n\t\tj += num_bytes;\n\t\tnum_bytes = get_long_from_buf(tp + j, &val);\n\t\tif (num_bytes == -1)\n\t\t    break;\n\t\tscrollbar_value = val;\n\t\tj += num_bytes;\n\t\tslen = j;\n\t    }\n\t    if (i == 0)\t\t// not enough characters to make one\n\t\treturn -1;\n\t}\n\telse if (key_name[0] == (int)KS_HOR_SCROLLBAR)\n\t{\n\t    long_u\tval;\n\t    int\t\tnum_bytes;\n\n\t    // Get the last horiz. scrollbar event in the queue\n\t    j = 0;\n\t    for (i = 0; tp[j] == CSI && tp[j + 1] == KS_HOR_SCROLLBAR\n\t\t\t\t\t\t     && tp[j + 2] != NUL; ++i)\n\t    {\n\t\tj += 3;\n\t\tnum_bytes = get_long_from_buf(tp + j, &val);\n\t\tif (num_bytes == -1)\n\t\t    break;\n\t\tscrollbar_value = val;\n\t\tj += num_bytes;\n\t\tslen = j;\n\t    }\n\t    if (i == 0)\t\t// not enough characters to make one\n\t\treturn -1;\n\t}\n# endif // !USE_ON_FLY_SCROLL\n#endif // FEAT_GUI\n\n#if (defined(UNIX) || defined(VMS))\n\t/*\n\t * Handle FocusIn/FocusOut event sequences reported by XTerm.\n\t * (CSI I/CSI O)\n\t */\n\tif (key_name[0] == KS_EXTRA\n# ifdef FEAT_GUI\n\t\t&& !gui.in_use\n# endif\n\t    )\n\t{\n\t    if (key_name[1] == KE_FOCUSGAINED)\n\t    {\n\t\tif (!focus_state)\n\t\t{\n\t\t    ui_focus_change(TRUE);\n\t\t    did_cursorhold = TRUE;\n\t\t    focus_state = TRUE;\n\t\t}\n\t\tkey_name[1] = (int)KE_IGNORE;\n\t    }\n\t    else if (key_name[1] == KE_FOCUSLOST)\n\t    {\n\t\tif (focus_state)\n\t\t{\n\t\t    ui_focus_change(FALSE);\n\t\t    did_cursorhold = TRUE;\n\t\t    focus_state = FALSE;\n\t\t}\n\t\tkey_name[1] = (int)KE_IGNORE;\n\t    }\n\t}\n#endif\n\n\t/*\n\t * Change <xHome> to <Home>, <xUp> to <Up>, etc.\n\t */\n\tkey = handle_x_keys(TERMCAP2KEY(key_name[0], key_name[1]));\n\n\t/*\n\t * Add any modifier codes to our string.\n\t */\n\tnew_slen = modifiers2keycode(modifiers, &key, string);\n\n\t// Finally, add the special key code to our string\n\tkey_name[0] = KEY2TERMCAP0(key);\n\tkey_name[1] = KEY2TERMCAP1(key);\n\tif (key_name[0] == KS_KEY)\n\t{\n\t    // from \":set <M-b>=xx\"\n\t    if (has_mbyte)\n\t\tnew_slen += (*mb_char2bytes)(key_name[1], string + new_slen);\n\t    else\n\t\tstring[new_slen++] = key_name[1];\n\t}\n\telse if (new_slen == 0 && key_name[0] == KS_EXTRA\n\t\t\t\t\t\t  && key_name[1] == KE_IGNORE)\n\t{\n\t    // Do not put K_IGNORE into the buffer, do return KEYLEN_REMOVED\n\t    // to indicate what happened.\n\t    retval = KEYLEN_REMOVED;\n\t}\n\telse\n\t{\n\t    string[new_slen++] = K_SPECIAL;\n\t    string[new_slen++] = key_name[0];\n\t    string[new_slen++] = key_name[1];\n\t}\n\tif (put_string_in_typebuf(offset, slen, string, new_slen,\n\t\t\t\t\t\t buf, bufsize, buflen) == FAIL)\n\t    return -1;\n\treturn retval == 0 ? (len + new_slen - slen + offset) : retval;\n    }\n\n#ifdef FEAT_TERMRESPONSE\n    LOG_TR((\"normal character\"));\n#endif\n\n    return 0;\t\t\t    // no match found\n}", "func_hash": 196889976171376146553776878857496634863, "file_name": "term.c", "file_hash": 255079853890988870585830908048537470004, "cwe": ["CWE-787"], "cve": "CVE-2022-2285", "cve_desc": "Integer Overflow or Wraparound in GitHub repository vim/vim prior to 9.0.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-2285", "file_path": "src/term.c"}
{"idx": 409515, "project": "vim", "commit_id": "27efc62f5d86afcb2ecb7565587fe8dea4b036fe", "project_url": "https://github.com/vim/vim", "commit_url": "https://github.com/vim/vim/commit/27efc62f5d86afcb2ecb7565587fe8dea4b036fe", "commit_message": "patch 9.0.0018: going over the end of the typahead\n\nProblem:    Going over the end of the typahead.\nSolution:   Put a NUL after the typeahead.", "target": 0, "func": "check_termcode(\n    int\t\tmax_offset,\n    char_u\t*buf,\n    int\t\tbufsize,\n    int\t\t*buflen)\n{\n    char_u\t*tp;\n    char_u\t*p;\n    int\t\tslen = 0;\t// init for GCC\n    int\t\tmodslen;\n    int\t\tlen;\n    int\t\tretval = 0;\n    int\t\toffset;\n    char_u\tkey_name[2];\n    int\t\tmodifiers;\n    char_u\t*modifiers_start = NULL;\n    int\t\tkey;\n    int\t\tnew_slen;   // Length of what will replace the termcode\n    char_u\tstring[MAX_KEY_CODE_LEN + 1];\n    int\t\ti, j;\n    int\t\tidx = 0;\n    int\t\tcpo_koffset;\n\n    cpo_koffset = (vim_strchr(p_cpo, CPO_KOFFSET) != NULL);\n\n    /*\n     * Speed up the checks for terminal codes by gathering all first bytes\n     * used in termleader[].  Often this is just a single <Esc>.\n     */\n    if (need_gather)\n\tgather_termleader();\n\n    /*\n     * Check at several positions in typebuf.tb_buf[], to catch something like\n     * \"x<Up>\" that can be mapped. Stop at max_offset, because characters\n     * after that cannot be used for mapping, and with @r commands\n     * typebuf.tb_buf[] can become very long.\n     * This is used often, KEEP IT FAST!\n     */\n    for (offset = 0; offset < max_offset; ++offset)\n    {\n\tif (buf == NULL)\n\t{\n\t    if (offset >= typebuf.tb_len)\n\t\tbreak;\n\t    tp = typebuf.tb_buf + typebuf.tb_off + offset;\n\t    len = typebuf.tb_len - offset;\t// length of the input\n\t}\n\telse\n\t{\n\t    if (offset >= *buflen)\n\t\tbreak;\n\t    tp = buf + offset;\n\t    len = *buflen - offset;\n\t}\n\n\t/*\n\t * Don't check characters after K_SPECIAL, those are already\n\t * translated terminal chars (avoid translating ~@^Hx).\n\t */\n\tif (*tp == K_SPECIAL)\n\t{\n\t    offset += 2;\t// there are always 2 extra characters\n\t    continue;\n\t}\n\n\t/*\n\t * Skip this position if the character does not appear as the first\n\t * character in term_strings. This speeds up a lot, since most\n\t * termcodes start with the same character (ESC or CSI).\n\t */\n\ti = *tp;\n\tfor (p = termleader; *p && *p != i; ++p)\n\t    ;\n\tif (*p == NUL)\n\t    continue;\n\n\t/*\n\t * Skip this position if p_ek is not set and tp[0] is an ESC and we\n\t * are in Insert mode.\n\t */\n\tif (*tp == ESC && !p_ek && (State & MODE_INSERT))\n\t    continue;\n\n\ttp[len] = NUL;\n\tkey_name[0] = NUL;\t// no key name found yet\n\tkey_name[1] = NUL;\t// no key name found yet\n\tmodifiers = 0;\t\t// no modifiers yet\n\n#ifdef FEAT_GUI\n\tif (gui.in_use)\n\t{\n\t    /*\n\t     * GUI special key codes are all of the form [CSI xx].\n\t     */\n\t    if (*tp == CSI)\t    // Special key from GUI\n\t    {\n\t\tif (len < 3)\n\t\t    return -1;\t    // Shouldn't happen\n\t\tslen = 3;\n\t\tkey_name[0] = tp[1];\n\t\tkey_name[1] = tp[2];\n\t    }\n\t}\n\telse\n#endif // FEAT_GUI\n\t{\n\t    int  mouse_index_found = -1;\n\n\t    for (idx = 0; idx < tc_len; ++idx)\n\t    {\n\t\t/*\n\t\t * Ignore the entry if we are not at the start of\n\t\t * typebuf.tb_buf[]\n\t\t * and there are not enough characters to make a match.\n\t\t * But only when the 'K' flag is in 'cpoptions'.\n\t\t */\n\t\tslen = termcodes[idx].len;\n\t\tmodifiers_start = NULL;\n\t\tif (cpo_koffset && offset && len < slen)\n\t\t    continue;\n\t\tif (STRNCMP(termcodes[idx].code, tp,\n\t\t\t\t     (size_t)(slen > len ? len : slen)) == 0)\n\t\t{\n\t\t    int\t    looks_like_mouse_start = FALSE;\n\n\t\t    if (len < slen)\t\t// got a partial sequence\n\t\t\treturn -1;\t\t// need to get more chars\n\n\t\t    /*\n\t\t     * When found a keypad key, check if there is another key\n\t\t     * that matches and use that one.  This makes <Home> to be\n\t\t     * found instead of <kHome> when they produce the same\n\t\t     * key code.\n\t\t     */\n\t\t    if (termcodes[idx].name[0] == 'K'\n\t\t\t\t       && VIM_ISDIGIT(termcodes[idx].name[1]))\n\t\t    {\n\t\t\tfor (j = idx + 1; j < tc_len; ++j)\n\t\t\t    if (termcodes[j].len == slen &&\n\t\t\t\t    STRNCMP(termcodes[idx].code,\n\t\t\t\t\t    termcodes[j].code, slen) == 0)\n\t\t\t    {\n\t\t\t\tidx = j;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t    }\n\n\t\t    if (slen == 2 && len > 2\n\t\t\t    && termcodes[idx].code[0] == ESC\n\t\t\t    && termcodes[idx].code[1] == '[')\n\t\t    {\n\t\t\t// The mouse termcode \"ESC [\" is also the prefix of\n\t\t\t// \"ESC [ I\" (focus gained) and other keys.  Check some\n\t\t\t// more bytes to find out.\n\t\t\tif (!isdigit(tp[2]))\n\t\t\t{\n\t\t\t    // ESC [ without number following: Only use it when\n\t\t\t    // there is no other match.\n\t\t\t    looks_like_mouse_start = TRUE;\n\t\t\t}\n\t\t\telse if (termcodes[idx].name[0] == KS_DEC_MOUSE)\n\t\t\t{\n\t\t\t    char_u  *nr = tp + 2;\n\t\t\t    int\t    count = 0;\n\n\t\t\t    // If a digit is following it could be a key with\n\t\t\t    // modifier, e.g., ESC [ 1;2P.  Can be confused\n\t\t\t    // with DEC_MOUSE, which requires four numbers\n\t\t\t    // following.  If not then it can't be a DEC_MOUSE\n\t\t\t    // code.\n\t\t\t    for (;;)\n\t\t\t    {\n\t\t\t\t++count;\n\t\t\t\t(void)getdigits(&nr);\n\t\t\t\tif (nr >= tp + len)\n\t\t\t\t    return -1;\t// partial sequence\n\t\t\t\tif (*nr != ';')\n\t\t\t\t    break;\n\t\t\t\t++nr;\n\t\t\t\tif (nr >= tp + len)\n\t\t\t\t    return -1;\t// partial sequence\n\t\t\t    }\n\t\t\t    if (count < 4)\n\t\t\t\tcontinue;\t// no match\n\t\t\t}\n\t\t    }\n\t\t    if (looks_like_mouse_start)\n\t\t    {\n\t\t\t// Only use it when there is no other match.\n\t\t\tif (mouse_index_found < 0)\n\t\t\t    mouse_index_found = idx;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tkey_name[0] = termcodes[idx].name[0];\n\t\t\tkey_name[1] = termcodes[idx].name[1];\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\n\t\t/*\n\t\t * Check for code with modifier, like xterm uses:\n\t\t * <Esc>[123;*X  (modslen == slen - 3)\n\t\t * <Esc>[@;*X    (matches <Esc>[X and <Esc>[1;9X )\n\t\t * Also <Esc>O*X and <M-O>*X (modslen == slen - 2).\n\t\t * When there is a modifier the * matches a number.\n\t\t * When there is no modifier the ;* or * is omitted.\n\t\t */\n\t\tif (termcodes[idx].modlen > 0 && mouse_index_found < 0)\n\t\t{\n\t\t    int at_code;\n\n\t\t    modslen = termcodes[idx].modlen;\n\t\t    if (cpo_koffset && offset && len < modslen)\n\t\t\tcontinue;\n\t\t    at_code = termcodes[idx].code[modslen] == '@';\n\t\t    if (STRNCMP(termcodes[idx].code, tp,\n\t\t\t\t(size_t)(modslen > len ? len : modslen)) == 0)\n\t\t    {\n\t\t\tint\t    n;\n\n\t\t\tif (len <= modslen)\t// got a partial sequence\n\t\t\t    return -1;\t\t// need to get more chars\n\n\t\t\tif (tp[modslen] == termcodes[idx].code[slen - 1])\n\t\t\t    // no modifiers\n\t\t\t    slen = modslen + 1;\n\t\t\telse if (tp[modslen] != ';' && modslen == slen - 3)\n\t\t\t    // no match for \"code;*X\" with \"code;\"\n\t\t\t    continue;\n\t\t\telse if (at_code && tp[modslen] != '1')\n\t\t\t    // no match for \"<Esc>[@\" with \"<Esc>[1\"\n\t\t\t    continue;\n\t\t\telse\n\t\t\t{\n\t\t\t    // Skip over the digits, the final char must\n\t\t\t    // follow. URXVT can use a negative value, thus\n\t\t\t    // also accept '-'.\n\t\t\t    for (j = slen - 2; j < len && (isdigit(tp[j])\n\t\t\t\t       || tp[j] == '-' || tp[j] == ';'); ++j)\n\t\t\t\t;\n\t\t\t    ++j;\n\t\t\t    if (len < j)\t// got a partial sequence\n\t\t\t\treturn -1;\t// need to get more chars\n\t\t\t    if (tp[j - 1] != termcodes[idx].code[slen - 1])\n\t\t\t\tcontinue;\t// no match\n\n\t\t\t    modifiers_start = tp + slen - 2;\n\n\t\t\t    // Match!  Convert modifier bits.\n\t\t\t    n = atoi((char *)modifiers_start);\n\t\t\t    modifiers |= decode_modifiers(n);\n\n\t\t\t    slen = j;\n\t\t\t}\n\t\t\tkey_name[0] = termcodes[idx].name[0];\n\t\t\tkey_name[1] = termcodes[idx].name[1];\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t    if (idx == tc_len && mouse_index_found >= 0)\n\t    {\n\t\tkey_name[0] = termcodes[mouse_index_found].name[0];\n\t\tkey_name[1] = termcodes[mouse_index_found].name[1];\n\t    }\n\t}\n\n#ifdef FEAT_TERMRESPONSE\n\tif (key_name[0] == NUL\n\t    // Mouse codes of DEC and pterm start with <ESC>[.  When\n\t    // detecting the start of these mouse codes they might as well be\n\t    // another key code or terminal response.\n# ifdef FEAT_MOUSE_DEC\n\t    || key_name[0] == KS_DEC_MOUSE\n# endif\n# ifdef FEAT_MOUSE_PTERM\n\t    || key_name[0] == KS_PTERM_MOUSE\n# endif\n\t   )\n\t{\n\t    char_u *argp = tp[0] == ESC ? tp + 2 : tp + 1;\n\n\t    /*\n\t     * Check for responses from the terminal starting with {lead}:\n\t     * \"<Esc>[\" or CSI followed by [0-9>?]\n\t     *\n\t     * - Xterm version string: {lead}>{x};{vers};{y}c\n\t     *   Also eat other possible responses to t_RV, rxvt returns\n\t     *   \"{lead}?1;2c\".\n\t     *\n\t     * - Cursor position report: {lead}{row};{col}R\n\t     *   The final byte must be 'R'. It is used for checking the\n\t     *   ambiguous-width character state.\n\t     *\n\t     * - window position reply: {lead}3;{x};{y}t\n\t     *\n\t     * - key with modifiers when modifyOtherKeys is enabled:\n\t     *\t    {lead}27;{modifier};{key}~\n\t     *\t    {lead}{key};{modifier}u\n\t     */\n\t    if (((tp[0] == ESC && len >= 3 && tp[1] == '[')\n\t\t\t    || (tp[0] == CSI && len >= 2))\n\t\t    && (VIM_ISDIGIT(*argp) || *argp == '>' || *argp == '?'))\n\t    {\n\t\tint resp = handle_csi(tp, len, argp, offset, buf,\n\t\t\t\t\t     bufsize, buflen, key_name, &slen);\n\t\tif (resp != 0)\n\t\t{\n# ifdef DEBUG_TERMRESPONSE\n\t\t    if (resp == -1)\n\t\t\tLOG_TR((\"Not enough characters for CSI sequence\"));\n# endif\n\t\t    return resp;\n\t\t}\n\t    }\n\n\t    // Check for fore/background color response from the terminal,\n\t    // starting} with <Esc>] or OSC\n\t    else if ((*T_RBG != NUL || *T_RFG != NUL)\n\t\t\t&& ((tp[0] == ESC && len >= 2 && tp[1] == ']')\n\t\t\t    || tp[0] == OSC))\n\t    {\n\t\tif (handle_osc(tp, argp, len, key_name, &slen) == FAIL)\n\t\t    return -1;\n\t    }\n\n\t    // Check for key code response from xterm,\n\t    // starting with <Esc>P or DCS\n\t    else if ((check_for_codes || rcs_status.tr_progress == STATUS_SENT)\n\t\t    && ((tp[0] == ESC && len >= 2 && tp[1] == 'P')\n\t\t\t|| tp[0] == DCS))\n\t    {\n\t\tif (handle_dcs(tp, argp, len, key_name, &slen) == FAIL)\n\t\t    return -1;\n\t    }\n\t}\n#endif\n\n\tif (key_name[0] == NUL)\n\t    continue;\t    // No match at this position, try next one\n\n\t// We only get here when we have a complete termcode match\n\n#ifdef FEAT_GUI\n\t/*\n\t * Only in the GUI: Fetch the pointer coordinates of the scroll event\n\t * so that we know which window to scroll later.\n\t */\n\tif (gui.in_use\n\t\t&& key_name[0] == (int)KS_EXTRA\n\t\t&& (key_name[1] == (int)KE_X1MOUSE\n\t\t    || key_name[1] == (int)KE_X2MOUSE\n\t\t    || key_name[1] == (int)KE_MOUSEMOVE_XY\n\t\t    || key_name[1] == (int)KE_MOUSELEFT\n\t\t    || key_name[1] == (int)KE_MOUSERIGHT\n\t\t    || key_name[1] == (int)KE_MOUSEDOWN\n\t\t    || key_name[1] == (int)KE_MOUSEUP))\n\t{\n\t    char_u\tbytes[6];\n\t    int\t\tnum_bytes = get_bytes_from_buf(tp + slen, bytes, 4);\n\n\t    if (num_bytes == -1)\t// not enough coordinates\n\t\treturn -1;\n\t    mouse_col = 128 * (bytes[0] - ' ' - 1) + bytes[1] - ' ' - 1;\n\t    mouse_row = 128 * (bytes[2] - ' ' - 1) + bytes[3] - ' ' - 1;\n\t    slen += num_bytes;\n\t    // equal to K_MOUSEMOVE\n\t    if (key_name[1] == (int)KE_MOUSEMOVE_XY)\n\t\tkey_name[1] = (int)KE_MOUSEMOVE;\n\t}\n\telse\n#endif\n\t/*\n\t * If it is a mouse click, get the coordinates.\n\t */\n\tif (key_name[0] == KS_MOUSE\n#ifdef FEAT_MOUSE_GPM\n\t\t|| key_name[0] == KS_GPM_MOUSE\n#endif\n#ifdef FEAT_MOUSE_JSB\n\t\t|| key_name[0] == KS_JSBTERM_MOUSE\n#endif\n#ifdef FEAT_MOUSE_NET\n\t\t|| key_name[0] == KS_NETTERM_MOUSE\n#endif\n#ifdef FEAT_MOUSE_DEC\n\t\t|| key_name[0] == KS_DEC_MOUSE\n#endif\n#ifdef FEAT_MOUSE_PTERM\n\t\t|| key_name[0] == KS_PTERM_MOUSE\n#endif\n#ifdef FEAT_MOUSE_URXVT\n\t\t|| key_name[0] == KS_URXVT_MOUSE\n#endif\n\t\t|| key_name[0] == KS_SGR_MOUSE\n\t\t|| key_name[0] == KS_SGR_MOUSE_RELEASE)\n\t{\n\t    if (check_termcode_mouse(tp, &slen, key_name, modifiers_start, idx,\n\t\t\t\t\t\t\t     &modifiers) == -1)\n\t\treturn -1;\n\t}\n\n#ifdef FEAT_GUI\n\t/*\n\t * If using the GUI, then we get menu and scrollbar events.\n\t *\n\t * A menu event is encoded as K_SPECIAL, KS_MENU, KE_FILLER followed by\n\t * four bytes which are to be taken as a pointer to the vimmenu_T\n\t * structure.\n\t *\n\t * A tab line event is encoded as K_SPECIAL KS_TABLINE nr, where \"nr\"\n\t * is one byte with the tab index.\n\t *\n\t * A scrollbar event is K_SPECIAL, KS_VER_SCROLLBAR, KE_FILLER followed\n\t * by one byte representing the scrollbar number, and then four bytes\n\t * representing a long_u which is the new value of the scrollbar.\n\t *\n\t * A horizontal scrollbar event is K_SPECIAL, KS_HOR_SCROLLBAR,\n\t * KE_FILLER followed by four bytes representing a long_u which is the\n\t * new value of the scrollbar.\n\t */\n# ifdef FEAT_MENU\n\telse if (key_name[0] == (int)KS_MENU)\n\t{\n\t    long_u\tval;\n\t    int\t\tnum_bytes = get_long_from_buf(tp + slen, &val);\n\n\t    if (num_bytes == -1)\n\t\treturn -1;\n\t    current_menu = (vimmenu_T *)val;\n\t    slen += num_bytes;\n\n\t    // The menu may have been deleted right after it was used, check\n\t    // for that.\n\t    if (check_menu_pointer(root_menu, current_menu) == FAIL)\n\t    {\n\t\tkey_name[0] = KS_EXTRA;\n\t\tkey_name[1] = (int)KE_IGNORE;\n\t    }\n\t}\n# endif\n# ifdef FEAT_GUI_TABLINE\n\telse if (key_name[0] == (int)KS_TABLINE)\n\t{\n\t    // Selecting tabline tab or using its menu.\n\t    char_u\tbytes[6];\n\t    int\t\tnum_bytes = get_bytes_from_buf(tp + slen, bytes, 1);\n\n\t    if (num_bytes == -1)\n\t\treturn -1;\n\t    current_tab = (int)bytes[0];\n\t    if (current_tab == 255)\t// -1 in a byte gives 255\n\t\tcurrent_tab = -1;\n\t    slen += num_bytes;\n\t}\n\telse if (key_name[0] == (int)KS_TABMENU)\n\t{\n\t    // Selecting tabline tab or using its menu.\n\t    char_u\tbytes[6];\n\t    int\t\tnum_bytes = get_bytes_from_buf(tp + slen, bytes, 2);\n\n\t    if (num_bytes == -1)\n\t\treturn -1;\n\t    current_tab = (int)bytes[0];\n\t    current_tabmenu = (int)bytes[1];\n\t    slen += num_bytes;\n\t}\n# endif\n# ifndef USE_ON_FLY_SCROLL\n\telse if (key_name[0] == (int)KS_VER_SCROLLBAR)\n\t{\n\t    long_u\tval;\n\t    char_u\tbytes[6];\n\t    int\t\tnum_bytes;\n\n\t    // Get the last scrollbar event in the queue of the same type\n\t    j = 0;\n\t    for (i = 0; tp[j] == CSI && tp[j + 1] == KS_VER_SCROLLBAR\n\t\t\t\t\t\t     && tp[j + 2] != NUL; ++i)\n\t    {\n\t\tj += 3;\n\t\tnum_bytes = get_bytes_from_buf(tp + j, bytes, 1);\n\t\tif (num_bytes == -1)\n\t\t    break;\n\t\tif (i == 0)\n\t\t    current_scrollbar = (int)bytes[0];\n\t\telse if (current_scrollbar != (int)bytes[0])\n\t\t    break;\n\t\tj += num_bytes;\n\t\tnum_bytes = get_long_from_buf(tp + j, &val);\n\t\tif (num_bytes == -1)\n\t\t    break;\n\t\tscrollbar_value = val;\n\t\tj += num_bytes;\n\t\tslen = j;\n\t    }\n\t    if (i == 0)\t\t// not enough characters to make one\n\t\treturn -1;\n\t}\n\telse if (key_name[0] == (int)KS_HOR_SCROLLBAR)\n\t{\n\t    long_u\tval;\n\t    int\t\tnum_bytes;\n\n\t    // Get the last horiz. scrollbar event in the queue\n\t    j = 0;\n\t    for (i = 0; tp[j] == CSI && tp[j + 1] == KS_HOR_SCROLLBAR\n\t\t\t\t\t\t     && tp[j + 2] != NUL; ++i)\n\t    {\n\t\tj += 3;\n\t\tnum_bytes = get_long_from_buf(tp + j, &val);\n\t\tif (num_bytes == -1)\n\t\t    break;\n\t\tscrollbar_value = val;\n\t\tj += num_bytes;\n\t\tslen = j;\n\t    }\n\t    if (i == 0)\t\t// not enough characters to make one\n\t\treturn -1;\n\t}\n# endif // !USE_ON_FLY_SCROLL\n#endif // FEAT_GUI\n\n#if (defined(UNIX) || defined(VMS))\n\t/*\n\t * Handle FocusIn/FocusOut event sequences reported by XTerm.\n\t * (CSI I/CSI O)\n\t */\n\tif (key_name[0] == KS_EXTRA\n# ifdef FEAT_GUI\n\t\t&& !gui.in_use\n# endif\n\t    )\n\t{\n\t    if (key_name[1] == KE_FOCUSGAINED)\n\t    {\n\t\tif (!focus_state)\n\t\t{\n\t\t    ui_focus_change(TRUE);\n\t\t    did_cursorhold = TRUE;\n\t\t    focus_state = TRUE;\n\t\t}\n\t\tkey_name[1] = (int)KE_IGNORE;\n\t    }\n\t    else if (key_name[1] == KE_FOCUSLOST)\n\t    {\n\t\tif (focus_state)\n\t\t{\n\t\t    ui_focus_change(FALSE);\n\t\t    did_cursorhold = TRUE;\n\t\t    focus_state = FALSE;\n\t\t}\n\t\tkey_name[1] = (int)KE_IGNORE;\n\t    }\n\t}\n#endif\n\n\t/*\n\t * Change <xHome> to <Home>, <xUp> to <Up>, etc.\n\t */\n\tkey = handle_x_keys(TERMCAP2KEY(key_name[0], key_name[1]));\n\n\t/*\n\t * Add any modifier codes to our string.\n\t */\n\tnew_slen = modifiers2keycode(modifiers, &key, string);\n\n\t// Finally, add the special key code to our string\n\tkey_name[0] = KEY2TERMCAP0(key);\n\tkey_name[1] = KEY2TERMCAP1(key);\n\tif (key_name[0] == KS_KEY)\n\t{\n\t    // from \":set <M-b>=xx\"\n\t    if (has_mbyte)\n\t\tnew_slen += (*mb_char2bytes)(key_name[1], string + new_slen);\n\t    else\n\t\tstring[new_slen++] = key_name[1];\n\t}\n\telse if (new_slen == 0 && key_name[0] == KS_EXTRA\n\t\t\t\t\t\t  && key_name[1] == KE_IGNORE)\n\t{\n\t    // Do not put K_IGNORE into the buffer, do return KEYLEN_REMOVED\n\t    // to indicate what happened.\n\t    retval = KEYLEN_REMOVED;\n\t}\n\telse\n\t{\n\t    string[new_slen++] = K_SPECIAL;\n\t    string[new_slen++] = key_name[0];\n\t    string[new_slen++] = key_name[1];\n\t}\n\tif (put_string_in_typebuf(offset, slen, string, new_slen,\n\t\t\t\t\t\t buf, bufsize, buflen) == FAIL)\n\t    return -1;\n\treturn retval == 0 ? (len + new_slen - slen + offset) : retval;\n    }\n\n#ifdef FEAT_TERMRESPONSE\n    LOG_TR((\"normal character\"));\n#endif\n\n    return 0;\t\t\t    // no match found\n}", "func_hash": 105354748681163651663383549655228844664, "file_name": "term.c", "file_hash": 113564079834188954277061754674630069521, "cwe": ["CWE-787"], "cve": "CVE-2022-2285", "cve_desc": "Integer Overflow or Wraparound in GitHub repository vim/vim prior to 9.0.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-2285", "file_path": "src/term.c"}
{"idx": 208505, "project": "tor", "commit_id": "57e35ad3d91724882c345ac709666a551a977f0f", "project_url": "https://github.com/torproject/tor", "commit_url": "https://gitweb.torproject.org/tor.git/commitdiff/57e35ad3d91724882c345ac709666a551a977f0f", "commit_message": "Avoid possible segfault when handling networkstatus vote with bad flavor\n\nFix for 6530; fix on 0.2.2.6-alpha.", "target": 1, "func": "networkstatus_parse_vote_from_string(const char *s, const char **eos_out,\n                                     networkstatus_type_t ns_type)\n{\n  smartlist_t *tokens = smartlist_create();\n  smartlist_t *rs_tokens = NULL, *footer_tokens = NULL;\n  networkstatus_voter_info_t *voter = NULL;\n  networkstatus_t *ns = NULL;\n  digests_t ns_digests;\n  const char *cert, *end_of_header, *end_of_footer, *s_dup = s;\n  directory_token_t *tok;\n  int ok;\n  struct in_addr in;\n  int i, inorder, n_signatures = 0;\n  memarea_t *area = NULL, *rs_area = NULL;\n  consensus_flavor_t flav = FLAV_NS;\n\n  tor_assert(s);\n\n  if (eos_out)\n    *eos_out = NULL;\n\n  if (router_get_networkstatus_v3_hashes(s, &ns_digests)) {\n    log_warn(LD_DIR, \"Unable to compute digest of network-status\");\n    goto err;\n  }\n\n  area = memarea_new();\n  end_of_header = find_start_of_next_routerstatus(s);\n  if (tokenize_string(area, s, end_of_header, tokens,\n                      (ns_type == NS_TYPE_CONSENSUS) ?\n                      networkstatus_consensus_token_table :\n                      networkstatus_token_table, 0)) {\n    log_warn(LD_DIR, \"Error tokenizing network-status vote header\");\n    goto err;\n  }\n\n  ns = tor_malloc_zero(sizeof(networkstatus_t));\n  memcpy(&ns->digests, &ns_digests, sizeof(ns_digests));\n\n  tok = find_by_keyword(tokens, K_NETWORK_STATUS_VERSION);\n  tor_assert(tok);\n  if (tok->n_args > 1) {\n    int flavor = networkstatus_parse_flavor_name(tok->args[1]);\n    if (flavor < 0) {\n      log_warn(LD_DIR, \"Can't parse document with unknown flavor %s\",\n               escaped(tok->args[2]));\n      goto err;\n    }\n    ns->flavor = flav = flavor;\n  }\n  if (flav != FLAV_NS && ns_type != NS_TYPE_CONSENSUS) {\n    log_warn(LD_DIR, \"Flavor found on non-consensus networkstatus.\");\n    goto err;\n  }\n\n  if (ns_type != NS_TYPE_CONSENSUS) {\n    const char *end_of_cert = NULL;\n    if (!(cert = strstr(s, \"\\ndir-key-certificate-version\")))\n      goto err;\n    ++cert;\n    ns->cert = authority_cert_parse_from_string(cert, &end_of_cert);\n    if (!ns->cert || !end_of_cert || end_of_cert > end_of_header)\n      goto err;\n  }\n\n  tok = find_by_keyword(tokens, K_VOTE_STATUS);\n  tor_assert(tok->n_args);\n  if (!strcmp(tok->args[0], \"vote\")) {\n    ns->type = NS_TYPE_VOTE;\n  } else if (!strcmp(tok->args[0], \"consensus\")) {\n    ns->type = NS_TYPE_CONSENSUS;\n  } else if (!strcmp(tok->args[0], \"opinion\")) {\n    ns->type = NS_TYPE_OPINION;\n  } else {\n    log_warn(LD_DIR, \"Unrecognized vote status %s in network-status\",\n             escaped(tok->args[0]));\n    goto err;\n  }\n  if (ns_type != ns->type) {\n    log_warn(LD_DIR, \"Got the wrong kind of v3 networkstatus.\");\n    goto err;\n  }\n\n  if (ns->type == NS_TYPE_VOTE || ns->type == NS_TYPE_OPINION) {\n    tok = find_by_keyword(tokens, K_PUBLISHED);\n    if (parse_iso_time(tok->args[0], &ns->published))\n      goto err;\n\n    ns->supported_methods = smartlist_create();\n    tok = find_opt_by_keyword(tokens, K_CONSENSUS_METHODS);\n    if (tok) {\n      for (i=0; i < tok->n_args; ++i)\n        smartlist_add(ns->supported_methods, tor_strdup(tok->args[i]));\n    } else {\n      smartlist_add(ns->supported_methods, tor_strdup(\"1\"));\n    }\n  } else {\n    tok = find_opt_by_keyword(tokens, K_CONSENSUS_METHOD);\n    if (tok) {\n      ns->consensus_method = (int)tor_parse_long(tok->args[0], 10, 1, INT_MAX,\n                                                 &ok, NULL);\n      if (!ok)\n        goto err;\n    } else {\n      ns->consensus_method = 1;\n    }\n  }\n\n  tok = find_by_keyword(tokens, K_VALID_AFTER);\n  if (parse_iso_time(tok->args[0], &ns->valid_after))\n    goto err;\n\n  tok = find_by_keyword(tokens, K_FRESH_UNTIL);\n  if (parse_iso_time(tok->args[0], &ns->fresh_until))\n    goto err;\n\n  tok = find_by_keyword(tokens, K_VALID_UNTIL);\n  if (parse_iso_time(tok->args[0], &ns->valid_until))\n    goto err;\n\n  tok = find_by_keyword(tokens, K_VOTING_DELAY);\n  tor_assert(tok->n_args >= 2);\n  ns->vote_seconds =\n    (int) tor_parse_long(tok->args[0], 10, 0, INT_MAX, &ok, NULL);\n  if (!ok)\n    goto err;\n  ns->dist_seconds =\n    (int) tor_parse_long(tok->args[1], 10, 0, INT_MAX, &ok, NULL);\n  if (!ok)\n    goto err;\n  if (ns->valid_after + MIN_VOTE_INTERVAL > ns->fresh_until) {\n    log_warn(LD_DIR, \"Vote/consensus freshness interval is too short\");\n    goto err;\n  }\n  if (ns->valid_after + MIN_VOTE_INTERVAL*2 > ns->valid_until) {\n    log_warn(LD_DIR, \"Vote/consensus liveness interval is too short\");\n    goto err;\n  }\n  if (ns->vote_seconds < MIN_VOTE_SECONDS) {\n    log_warn(LD_DIR, \"Vote seconds is too short\");\n    goto err;\n  }\n  if (ns->dist_seconds < MIN_DIST_SECONDS) {\n    log_warn(LD_DIR, \"Dist seconds is too short\");\n    goto err;\n  }\n\n  if ((tok = find_opt_by_keyword(tokens, K_CLIENT_VERSIONS))) {\n    ns->client_versions = tor_strdup(tok->args[0]);\n  }\n  if ((tok = find_opt_by_keyword(tokens, K_SERVER_VERSIONS))) {\n    ns->server_versions = tor_strdup(tok->args[0]);\n  }\n\n  tok = find_by_keyword(tokens, K_KNOWN_FLAGS);\n  ns->known_flags = smartlist_create();\n  inorder = 1;\n  for (i = 0; i < tok->n_args; ++i) {\n    smartlist_add(ns->known_flags, tor_strdup(tok->args[i]));\n    if (i>0 && strcmp(tok->args[i-1], tok->args[i])>= 0) {\n      log_warn(LD_DIR, \"%s >= %s\", tok->args[i-1], tok->args[i]);\n      inorder = 0;\n    }\n  }\n  if (!inorder) {\n    log_warn(LD_DIR, \"known-flags not in order\");\n    goto err;\n  }\n\n  tok = find_opt_by_keyword(tokens, K_PARAMS);\n  if (tok) {\n    inorder = 1;\n    ns->net_params = smartlist_create();\n    for (i = 0; i < tok->n_args; ++i) {\n      int ok=0;\n      char *eq = strchr(tok->args[i], '=');\n      if (!eq) {\n        log_warn(LD_DIR, \"Bad element '%s' in params\", escaped(tok->args[i]));\n        goto err;\n      }\n      tor_parse_long(eq+1, 10, INT32_MIN, INT32_MAX, &ok, NULL);\n      if (!ok) {\n        log_warn(LD_DIR, \"Bad element '%s' in params\", escaped(tok->args[i]));\n        goto err;\n      }\n      if (i > 0 && strcmp(tok->args[i-1], tok->args[i]) >= 0) {\n        log_warn(LD_DIR, \"%s >= %s\", tok->args[i-1], tok->args[i]);\n        inorder = 0;\n      }\n      smartlist_add(ns->net_params, tor_strdup(tok->args[i]));\n    }\n    if (!inorder) {\n      log_warn(LD_DIR, \"params not in order\");\n      goto err;\n    }\n  }\n\n  ns->voters = smartlist_create();\n\n  SMARTLIST_FOREACH_BEGIN(tokens, directory_token_t *, _tok) {\n    tok = _tok;\n    if (tok->tp == K_DIR_SOURCE) {\n      tor_assert(tok->n_args >= 6);\n\n      if (voter)\n        smartlist_add(ns->voters, voter);\n      voter = tor_malloc_zero(sizeof(networkstatus_voter_info_t));\n      voter->sigs = smartlist_create();\n      if (ns->type != NS_TYPE_CONSENSUS)\n        memcpy(voter->vote_digest, ns_digests.d[DIGEST_SHA1], DIGEST_LEN);\n\n      voter->nickname = tor_strdup(tok->args[0]);\n      if (strlen(tok->args[1]) != HEX_DIGEST_LEN ||\n          base16_decode(voter->identity_digest, sizeof(voter->identity_digest),\n                        tok->args[1], HEX_DIGEST_LEN) < 0) {\n        log_warn(LD_DIR, \"Error decoding identity digest %s in \"\n                 \"network-status vote.\", escaped(tok->args[1]));\n        goto err;\n      }\n      if (ns->type != NS_TYPE_CONSENSUS &&\n          tor_memneq(ns->cert->cache_info.identity_digest,\n                 voter->identity_digest, DIGEST_LEN)) {\n        log_warn(LD_DIR,\"Mismatch between identities in certificate and vote\");\n        goto err;\n      }\n      voter->address = tor_strdup(tok->args[2]);\n      if (!tor_inet_aton(tok->args[3], &in)) {\n        log_warn(LD_DIR, \"Error decoding IP address %s in network-status.\",\n                 escaped(tok->args[3]));\n        goto err;\n      }\n      voter->addr = ntohl(in.s_addr);\n      voter->dir_port = (uint16_t)\n        tor_parse_long(tok->args[4], 10, 0, 65535, &ok, NULL);\n      if (!ok)\n        goto err;\n      voter->or_port = (uint16_t)\n        tor_parse_long(tok->args[5], 10, 0, 65535, &ok, NULL);\n      if (!ok)\n        goto err;\n    } else if (tok->tp == K_CONTACT) {\n      if (!voter || voter->contact) {\n        log_warn(LD_DIR, \"contact element is out of place.\");\n        goto err;\n      }\n      voter->contact = tor_strdup(tok->args[0]);\n    } else if (tok->tp == K_VOTE_DIGEST) {\n      tor_assert(ns->type == NS_TYPE_CONSENSUS);\n      tor_assert(tok->n_args >= 1);\n      if (!voter || ! tor_digest_is_zero(voter->vote_digest)) {\n        log_warn(LD_DIR, \"vote-digest element is out of place.\");\n        goto err;\n      }\n      if (strlen(tok->args[0]) != HEX_DIGEST_LEN ||\n        base16_decode(voter->vote_digest, sizeof(voter->vote_digest),\n                      tok->args[0], HEX_DIGEST_LEN) < 0) {\n        log_warn(LD_DIR, \"Error decoding vote digest %s in \"\n                 \"network-status consensus.\", escaped(tok->args[0]));\n        goto err;\n      }\n    }\n  } SMARTLIST_FOREACH_END(_tok);\n  if (voter) {\n    smartlist_add(ns->voters, voter);\n    voter = NULL;\n  }\n  if (smartlist_len(ns->voters) == 0) {\n    log_warn(LD_DIR, \"Missing dir-source elements in a vote networkstatus.\");\n    goto err;\n  } else if (ns->type != NS_TYPE_CONSENSUS && smartlist_len(ns->voters) != 1) {\n    log_warn(LD_DIR, \"Too many dir-source elements in a vote networkstatus.\");\n    goto err;\n  }\n\n  if (ns->type != NS_TYPE_CONSENSUS &&\n      (tok = find_opt_by_keyword(tokens, K_LEGACY_DIR_KEY))) {\n    int bad = 1;\n    if (strlen(tok->args[0]) == HEX_DIGEST_LEN) {\n      networkstatus_voter_info_t *voter = smartlist_get(ns->voters, 0);\n      if (base16_decode(voter->legacy_id_digest, DIGEST_LEN,\n                        tok->args[0], HEX_DIGEST_LEN)<0)\n        bad = 1;\n      else\n        bad = 0;\n    }\n    if (bad) {\n      log_warn(LD_DIR, \"Invalid legacy key digest %s on vote.\",\n               escaped(tok->args[0]));\n    }\n  }\n\n  /* Parse routerstatus lines. */\n  rs_tokens = smartlist_create();\n  rs_area = memarea_new();\n  s = end_of_header;\n  ns->routerstatus_list = smartlist_create();\n\n  while (!strcmpstart(s, \"r \")) {\n    if (ns->type != NS_TYPE_CONSENSUS) {\n      vote_routerstatus_t *rs = tor_malloc_zero(sizeof(vote_routerstatus_t));\n      if (routerstatus_parse_entry_from_string(rs_area, &s, rs_tokens, ns,\n                                               rs, 0, 0))\n        smartlist_add(ns->routerstatus_list, rs);\n      else {\n        tor_free(rs->version);\n        tor_free(rs);\n      }\n    } else {\n      routerstatus_t *rs;\n      if ((rs = routerstatus_parse_entry_from_string(rs_area, &s, rs_tokens,\n                                                     NULL, NULL,\n                                                     ns->consensus_method,\n                                                     flav)))\n        smartlist_add(ns->routerstatus_list, rs);\n    }\n  }\n  for (i = 1; i < smartlist_len(ns->routerstatus_list); ++i) {\n    routerstatus_t *rs1, *rs2;\n    if (ns->type != NS_TYPE_CONSENSUS) {\n      vote_routerstatus_t *a = smartlist_get(ns->routerstatus_list, i-1);\n      vote_routerstatus_t *b = smartlist_get(ns->routerstatus_list, i);\n      rs1 = &a->status; rs2 = &b->status;\n    } else {\n      rs1 = smartlist_get(ns->routerstatus_list, i-1);\n      rs2 = smartlist_get(ns->routerstatus_list, i);\n    }\n    if (fast_memcmp(rs1->identity_digest, rs2->identity_digest, DIGEST_LEN)\n        >= 0) {\n      log_warn(LD_DIR, \"Vote networkstatus entries not sorted by identity \"\n               \"digest\");\n      goto err;\n    }\n  }\n\n  /* Parse footer; check signature. */\n  footer_tokens = smartlist_create();\n  if ((end_of_footer = strstr(s, \"\\nnetwork-status-version \")))\n    ++end_of_footer;\n  else\n    end_of_footer = s + strlen(s);\n  if (tokenize_string(area,s, end_of_footer, footer_tokens,\n                      networkstatus_vote_footer_token_table, 0)) {\n    log_warn(LD_DIR, \"Error tokenizing network-status vote footer.\");\n    goto err;\n  }\n\n  {\n    int found_sig = 0;\n    SMARTLIST_FOREACH_BEGIN(footer_tokens, directory_token_t *, _tok) {\n      tok = _tok;\n      if (tok->tp == K_DIRECTORY_SIGNATURE)\n        found_sig = 1;\n      else if (found_sig) {\n        log_warn(LD_DIR, \"Extraneous token after first directory-signature\");\n        goto err;\n      }\n    } SMARTLIST_FOREACH_END(_tok);\n  }\n\n  if ((tok = find_opt_by_keyword(footer_tokens, K_DIRECTORY_FOOTER))) {\n    if (tok != smartlist_get(footer_tokens, 0)) {\n      log_warn(LD_DIR, \"Misplaced directory-footer token\");\n      goto err;\n    }\n  }\n\n  tok = find_opt_by_keyword(footer_tokens, K_BW_WEIGHTS);\n  if (tok) {\n    ns->weight_params = smartlist_create();\n    for (i = 0; i < tok->n_args; ++i) {\n      int ok=0;\n      char *eq = strchr(tok->args[i], '=');\n      if (!eq) {\n        log_warn(LD_DIR, \"Bad element '%s' in weight params\",\n                 escaped(tok->args[i]));\n        goto err;\n      }\n      tor_parse_long(eq+1, 10, INT32_MIN, INT32_MAX, &ok, NULL);\n      if (!ok) {\n        log_warn(LD_DIR, \"Bad element '%s' in params\", escaped(tok->args[i]));\n        goto err;\n      }\n      smartlist_add(ns->weight_params, tor_strdup(tok->args[i]));\n    }\n  }\n\n  SMARTLIST_FOREACH_BEGIN(footer_tokens, directory_token_t *, _tok) {\n    char declared_identity[DIGEST_LEN];\n    networkstatus_voter_info_t *v;\n    document_signature_t *sig;\n    const char *id_hexdigest = NULL;\n    const char *sk_hexdigest = NULL;\n    digest_algorithm_t alg = DIGEST_SHA1;\n    tok = _tok;\n    if (tok->tp != K_DIRECTORY_SIGNATURE)\n      continue;\n    tor_assert(tok->n_args >= 2);\n    if (tok->n_args == 2) {\n      id_hexdigest = tok->args[0];\n      sk_hexdigest = tok->args[1];\n    } else {\n      const char *algname = tok->args[0];\n      int a;\n      id_hexdigest = tok->args[1];\n      sk_hexdigest = tok->args[2];\n      a = crypto_digest_algorithm_parse_name(algname);\n      if (a<0) {\n        log_warn(LD_DIR, \"Unknown digest algorithm %s; skipping\",\n                 escaped(algname));\n        continue;\n      }\n      alg = a;\n    }\n\n    if (!tok->object_type ||\n        strcmp(tok->object_type, \"SIGNATURE\") ||\n        tok->object_size < 128 || tok->object_size > 512) {\n      log_warn(LD_DIR, \"Bad object type or length on directory-signature\");\n      goto err;\n    }\n\n    if (strlen(id_hexdigest) != HEX_DIGEST_LEN ||\n        base16_decode(declared_identity, sizeof(declared_identity),\n                      id_hexdigest, HEX_DIGEST_LEN) < 0) {\n      log_warn(LD_DIR, \"Error decoding declared identity %s in \"\n               \"network-status vote.\", escaped(id_hexdigest));\n      goto err;\n    }\n    if (!(v = networkstatus_get_voter_by_id(ns, declared_identity))) {\n      log_warn(LD_DIR, \"ID on signature on network-status vote does not match \"\n               \"any declared directory source.\");\n      goto err;\n    }\n    sig = tor_malloc_zero(sizeof(document_signature_t));\n    memcpy(sig->identity_digest, v->identity_digest, DIGEST_LEN);\n    sig->alg = alg;\n    if (strlen(sk_hexdigest) != HEX_DIGEST_LEN ||\n        base16_decode(sig->signing_key_digest, sizeof(sig->signing_key_digest),\n                      sk_hexdigest, HEX_DIGEST_LEN) < 0) {\n      log_warn(LD_DIR, \"Error decoding declared signing key digest %s in \"\n               \"network-status vote.\", escaped(sk_hexdigest));\n      tor_free(sig);\n      goto err;\n    }\n\n    if (ns->type != NS_TYPE_CONSENSUS) {\n      if (tor_memneq(declared_identity, ns->cert->cache_info.identity_digest,\n                 DIGEST_LEN)) {\n        log_warn(LD_DIR, \"Digest mismatch between declared and actual on \"\n                 \"network-status vote.\");\n        tor_free(sig);\n        goto err;\n      }\n    }\n\n    if (voter_get_sig_by_algorithm(v, sig->alg)) {\n      /* We already parsed a vote with this algorithm from this voter. Use the\n         first one. */\n      log_fn(LOG_PROTOCOL_WARN, LD_DIR, \"We received a networkstatus \"\n             \"that contains two votes from the same voter with the same \"\n             \"algorithm. Ignoring the second vote.\");\n      tor_free(sig);\n      continue;\n    }\n\n    if (ns->type != NS_TYPE_CONSENSUS) {\n      if (check_signature_token(ns_digests.d[DIGEST_SHA1], DIGEST_LEN,\n                                tok, ns->cert->signing_key, 0,\n                                \"network-status vote\")) {\n        tor_free(sig);\n        goto err;\n      }\n      sig->good_signature = 1;\n    } else {\n      if (tok->object_size >= INT_MAX || tok->object_size >= SIZE_T_CEILING) {\n        tor_free(sig);\n        goto err;\n      }\n      sig->signature = tor_memdup(tok->object_body, tok->object_size);\n      sig->signature_len = (int) tok->object_size;\n    }\n    smartlist_add(v->sigs, sig);\n\n    ++n_signatures;\n  } SMARTLIST_FOREACH_END(_tok);\n\n  if (! n_signatures) {\n    log_warn(LD_DIR, \"No signatures on networkstatus vote.\");\n    goto err;\n  } else if (ns->type == NS_TYPE_VOTE && n_signatures != 1) {\n    log_warn(LD_DIR, \"Received more than one signature on a \"\n             \"network-status vote.\");\n    goto err;\n  }\n\n  if (eos_out)\n    *eos_out = end_of_footer;\n\n  goto done;\n err:\n  dump_desc(s_dup, \"v3 networkstatus\");\n  networkstatus_vote_free(ns);\n  ns = NULL;\n done:\n  if (tokens) {\n    SMARTLIST_FOREACH(tokens, directory_token_t *, t, token_clear(t));\n    smartlist_free(tokens);\n  }\n  if (voter) {\n    if (voter->sigs) {\n      SMARTLIST_FOREACH(voter->sigs, document_signature_t *, sig,\n                        document_signature_free(sig));\n      smartlist_free(voter->sigs);\n    }\n    tor_free(voter->nickname);\n    tor_free(voter->address);\n    tor_free(voter->contact);\n    tor_free(voter);\n  }\n  if (rs_tokens) {\n    SMARTLIST_FOREACH(rs_tokens, directory_token_t *, t, token_clear(t));\n    smartlist_free(rs_tokens);\n  }\n  if (footer_tokens) {\n    SMARTLIST_FOREACH(footer_tokens, directory_token_t *, t, token_clear(t));\n    smartlist_free(footer_tokens);\n  }\n  if (area) {\n    DUMP_AREA(area, \"v3 networkstatus\");\n    memarea_drop_all(area);\n  }\n  if (rs_area)\n    memarea_drop_all(rs_area);\n\n  return ns;\n}", "func_hash": 297795787979009632344281497591388902899, "file_name": "routerparse.c", "file_hash": 22420103474128049345359193080521452725, "cwe": ["CWE-399"], "cve": "CVE-2012-3517", "cve_desc": "Use-after-free vulnerability in dns.c in Tor before 0.2.2.38 might allow remote attackers to cause a denial of service (daemon crash) via vectors related to failed DNS requests.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-3517", "file_path": "src/or/routerparse.c"}
{"idx": 411896, "project": "tor", "commit_id": "57e35ad3d91724882c345ac709666a551a977f0f", "project_url": "https://github.com/torproject/tor", "commit_url": "https://gitweb.torproject.org/tor.git/commitdiff/57e35ad3d91724882c345ac709666a551a977f0f", "commit_message": "Avoid possible segfault when handling networkstatus vote with bad flavor\n\nFix for 6530; fix on 0.2.2.6-alpha.", "target": 0, "func": "networkstatus_parse_vote_from_string(const char *s, const char **eos_out,\n                                     networkstatus_type_t ns_type)\n{\n  smartlist_t *tokens = smartlist_create();\n  smartlist_t *rs_tokens = NULL, *footer_tokens = NULL;\n  networkstatus_voter_info_t *voter = NULL;\n  networkstatus_t *ns = NULL;\n  digests_t ns_digests;\n  const char *cert, *end_of_header, *end_of_footer, *s_dup = s;\n  directory_token_t *tok;\n  int ok;\n  struct in_addr in;\n  int i, inorder, n_signatures = 0;\n  memarea_t *area = NULL, *rs_area = NULL;\n  consensus_flavor_t flav = FLAV_NS;\n\n  tor_assert(s);\n\n  if (eos_out)\n    *eos_out = NULL;\n\n  if (router_get_networkstatus_v3_hashes(s, &ns_digests)) {\n    log_warn(LD_DIR, \"Unable to compute digest of network-status\");\n    goto err;\n  }\n\n  area = memarea_new();\n  end_of_header = find_start_of_next_routerstatus(s);\n  if (tokenize_string(area, s, end_of_header, tokens,\n                      (ns_type == NS_TYPE_CONSENSUS) ?\n                      networkstatus_consensus_token_table :\n                      networkstatus_token_table, 0)) {\n    log_warn(LD_DIR, \"Error tokenizing network-status vote header\");\n    goto err;\n  }\n\n  ns = tor_malloc_zero(sizeof(networkstatus_t));\n  memcpy(&ns->digests, &ns_digests, sizeof(ns_digests));\n\n  tok = find_by_keyword(tokens, K_NETWORK_STATUS_VERSION);\n  tor_assert(tok);\n  if (tok->n_args > 1) {\n    int flavor = networkstatus_parse_flavor_name(tok->args[1]);\n    if (flavor < 0) {\n      log_warn(LD_DIR, \"Can't parse document with unknown flavor %s\",\n               escaped(tok->args[1]));\n      goto err;\n    }\n    ns->flavor = flav = flavor;\n  }\n  if (flav != FLAV_NS && ns_type != NS_TYPE_CONSENSUS) {\n    log_warn(LD_DIR, \"Flavor found on non-consensus networkstatus.\");\n    goto err;\n  }\n\n  if (ns_type != NS_TYPE_CONSENSUS) {\n    const char *end_of_cert = NULL;\n    if (!(cert = strstr(s, \"\\ndir-key-certificate-version\")))\n      goto err;\n    ++cert;\n    ns->cert = authority_cert_parse_from_string(cert, &end_of_cert);\n    if (!ns->cert || !end_of_cert || end_of_cert > end_of_header)\n      goto err;\n  }\n\n  tok = find_by_keyword(tokens, K_VOTE_STATUS);\n  tor_assert(tok->n_args);\n  if (!strcmp(tok->args[0], \"vote\")) {\n    ns->type = NS_TYPE_VOTE;\n  } else if (!strcmp(tok->args[0], \"consensus\")) {\n    ns->type = NS_TYPE_CONSENSUS;\n  } else if (!strcmp(tok->args[0], \"opinion\")) {\n    ns->type = NS_TYPE_OPINION;\n  } else {\n    log_warn(LD_DIR, \"Unrecognized vote status %s in network-status\",\n             escaped(tok->args[0]));\n    goto err;\n  }\n  if (ns_type != ns->type) {\n    log_warn(LD_DIR, \"Got the wrong kind of v3 networkstatus.\");\n    goto err;\n  }\n\n  if (ns->type == NS_TYPE_VOTE || ns->type == NS_TYPE_OPINION) {\n    tok = find_by_keyword(tokens, K_PUBLISHED);\n    if (parse_iso_time(tok->args[0], &ns->published))\n      goto err;\n\n    ns->supported_methods = smartlist_create();\n    tok = find_opt_by_keyword(tokens, K_CONSENSUS_METHODS);\n    if (tok) {\n      for (i=0; i < tok->n_args; ++i)\n        smartlist_add(ns->supported_methods, tor_strdup(tok->args[i]));\n    } else {\n      smartlist_add(ns->supported_methods, tor_strdup(\"1\"));\n    }\n  } else {\n    tok = find_opt_by_keyword(tokens, K_CONSENSUS_METHOD);\n    if (tok) {\n      ns->consensus_method = (int)tor_parse_long(tok->args[0], 10, 1, INT_MAX,\n                                                 &ok, NULL);\n      if (!ok)\n        goto err;\n    } else {\n      ns->consensus_method = 1;\n    }\n  }\n\n  tok = find_by_keyword(tokens, K_VALID_AFTER);\n  if (parse_iso_time(tok->args[0], &ns->valid_after))\n    goto err;\n\n  tok = find_by_keyword(tokens, K_FRESH_UNTIL);\n  if (parse_iso_time(tok->args[0], &ns->fresh_until))\n    goto err;\n\n  tok = find_by_keyword(tokens, K_VALID_UNTIL);\n  if (parse_iso_time(tok->args[0], &ns->valid_until))\n    goto err;\n\n  tok = find_by_keyword(tokens, K_VOTING_DELAY);\n  tor_assert(tok->n_args >= 2);\n  ns->vote_seconds =\n    (int) tor_parse_long(tok->args[0], 10, 0, INT_MAX, &ok, NULL);\n  if (!ok)\n    goto err;\n  ns->dist_seconds =\n    (int) tor_parse_long(tok->args[1], 10, 0, INT_MAX, &ok, NULL);\n  if (!ok)\n    goto err;\n  if (ns->valid_after + MIN_VOTE_INTERVAL > ns->fresh_until) {\n    log_warn(LD_DIR, \"Vote/consensus freshness interval is too short\");\n    goto err;\n  }\n  if (ns->valid_after + MIN_VOTE_INTERVAL*2 > ns->valid_until) {\n    log_warn(LD_DIR, \"Vote/consensus liveness interval is too short\");\n    goto err;\n  }\n  if (ns->vote_seconds < MIN_VOTE_SECONDS) {\n    log_warn(LD_DIR, \"Vote seconds is too short\");\n    goto err;\n  }\n  if (ns->dist_seconds < MIN_DIST_SECONDS) {\n    log_warn(LD_DIR, \"Dist seconds is too short\");\n    goto err;\n  }\n\n  if ((tok = find_opt_by_keyword(tokens, K_CLIENT_VERSIONS))) {\n    ns->client_versions = tor_strdup(tok->args[0]);\n  }\n  if ((tok = find_opt_by_keyword(tokens, K_SERVER_VERSIONS))) {\n    ns->server_versions = tor_strdup(tok->args[0]);\n  }\n\n  tok = find_by_keyword(tokens, K_KNOWN_FLAGS);\n  ns->known_flags = smartlist_create();\n  inorder = 1;\n  for (i = 0; i < tok->n_args; ++i) {\n    smartlist_add(ns->known_flags, tor_strdup(tok->args[i]));\n    if (i>0 && strcmp(tok->args[i-1], tok->args[i])>= 0) {\n      log_warn(LD_DIR, \"%s >= %s\", tok->args[i-1], tok->args[i]);\n      inorder = 0;\n    }\n  }\n  if (!inorder) {\n    log_warn(LD_DIR, \"known-flags not in order\");\n    goto err;\n  }\n\n  tok = find_opt_by_keyword(tokens, K_PARAMS);\n  if (tok) {\n    inorder = 1;\n    ns->net_params = smartlist_create();\n    for (i = 0; i < tok->n_args; ++i) {\n      int ok=0;\n      char *eq = strchr(tok->args[i], '=');\n      if (!eq) {\n        log_warn(LD_DIR, \"Bad element '%s' in params\", escaped(tok->args[i]));\n        goto err;\n      }\n      tor_parse_long(eq+1, 10, INT32_MIN, INT32_MAX, &ok, NULL);\n      if (!ok) {\n        log_warn(LD_DIR, \"Bad element '%s' in params\", escaped(tok->args[i]));\n        goto err;\n      }\n      if (i > 0 && strcmp(tok->args[i-1], tok->args[i]) >= 0) {\n        log_warn(LD_DIR, \"%s >= %s\", tok->args[i-1], tok->args[i]);\n        inorder = 0;\n      }\n      smartlist_add(ns->net_params, tor_strdup(tok->args[i]));\n    }\n    if (!inorder) {\n      log_warn(LD_DIR, \"params not in order\");\n      goto err;\n    }\n  }\n\n  ns->voters = smartlist_create();\n\n  SMARTLIST_FOREACH_BEGIN(tokens, directory_token_t *, _tok) {\n    tok = _tok;\n    if (tok->tp == K_DIR_SOURCE) {\n      tor_assert(tok->n_args >= 6);\n\n      if (voter)\n        smartlist_add(ns->voters, voter);\n      voter = tor_malloc_zero(sizeof(networkstatus_voter_info_t));\n      voter->sigs = smartlist_create();\n      if (ns->type != NS_TYPE_CONSENSUS)\n        memcpy(voter->vote_digest, ns_digests.d[DIGEST_SHA1], DIGEST_LEN);\n\n      voter->nickname = tor_strdup(tok->args[0]);\n      if (strlen(tok->args[1]) != HEX_DIGEST_LEN ||\n          base16_decode(voter->identity_digest, sizeof(voter->identity_digest),\n                        tok->args[1], HEX_DIGEST_LEN) < 0) {\n        log_warn(LD_DIR, \"Error decoding identity digest %s in \"\n                 \"network-status vote.\", escaped(tok->args[1]));\n        goto err;\n      }\n      if (ns->type != NS_TYPE_CONSENSUS &&\n          tor_memneq(ns->cert->cache_info.identity_digest,\n                 voter->identity_digest, DIGEST_LEN)) {\n        log_warn(LD_DIR,\"Mismatch between identities in certificate and vote\");\n        goto err;\n      }\n      voter->address = tor_strdup(tok->args[2]);\n      if (!tor_inet_aton(tok->args[3], &in)) {\n        log_warn(LD_DIR, \"Error decoding IP address %s in network-status.\",\n                 escaped(tok->args[3]));\n        goto err;\n      }\n      voter->addr = ntohl(in.s_addr);\n      voter->dir_port = (uint16_t)\n        tor_parse_long(tok->args[4], 10, 0, 65535, &ok, NULL);\n      if (!ok)\n        goto err;\n      voter->or_port = (uint16_t)\n        tor_parse_long(tok->args[5], 10, 0, 65535, &ok, NULL);\n      if (!ok)\n        goto err;\n    } else if (tok->tp == K_CONTACT) {\n      if (!voter || voter->contact) {\n        log_warn(LD_DIR, \"contact element is out of place.\");\n        goto err;\n      }\n      voter->contact = tor_strdup(tok->args[0]);\n    } else if (tok->tp == K_VOTE_DIGEST) {\n      tor_assert(ns->type == NS_TYPE_CONSENSUS);\n      tor_assert(tok->n_args >= 1);\n      if (!voter || ! tor_digest_is_zero(voter->vote_digest)) {\n        log_warn(LD_DIR, \"vote-digest element is out of place.\");\n        goto err;\n      }\n      if (strlen(tok->args[0]) != HEX_DIGEST_LEN ||\n        base16_decode(voter->vote_digest, sizeof(voter->vote_digest),\n                      tok->args[0], HEX_DIGEST_LEN) < 0) {\n        log_warn(LD_DIR, \"Error decoding vote digest %s in \"\n                 \"network-status consensus.\", escaped(tok->args[0]));\n        goto err;\n      }\n    }\n  } SMARTLIST_FOREACH_END(_tok);\n  if (voter) {\n    smartlist_add(ns->voters, voter);\n    voter = NULL;\n  }\n  if (smartlist_len(ns->voters) == 0) {\n    log_warn(LD_DIR, \"Missing dir-source elements in a vote networkstatus.\");\n    goto err;\n  } else if (ns->type != NS_TYPE_CONSENSUS && smartlist_len(ns->voters) != 1) {\n    log_warn(LD_DIR, \"Too many dir-source elements in a vote networkstatus.\");\n    goto err;\n  }\n\n  if (ns->type != NS_TYPE_CONSENSUS &&\n      (tok = find_opt_by_keyword(tokens, K_LEGACY_DIR_KEY))) {\n    int bad = 1;\n    if (strlen(tok->args[0]) == HEX_DIGEST_LEN) {\n      networkstatus_voter_info_t *voter = smartlist_get(ns->voters, 0);\n      if (base16_decode(voter->legacy_id_digest, DIGEST_LEN,\n                        tok->args[0], HEX_DIGEST_LEN)<0)\n        bad = 1;\n      else\n        bad = 0;\n    }\n    if (bad) {\n      log_warn(LD_DIR, \"Invalid legacy key digest %s on vote.\",\n               escaped(tok->args[0]));\n    }\n  }\n\n  /* Parse routerstatus lines. */\n  rs_tokens = smartlist_create();\n  rs_area = memarea_new();\n  s = end_of_header;\n  ns->routerstatus_list = smartlist_create();\n\n  while (!strcmpstart(s, \"r \")) {\n    if (ns->type != NS_TYPE_CONSENSUS) {\n      vote_routerstatus_t *rs = tor_malloc_zero(sizeof(vote_routerstatus_t));\n      if (routerstatus_parse_entry_from_string(rs_area, &s, rs_tokens, ns,\n                                               rs, 0, 0))\n        smartlist_add(ns->routerstatus_list, rs);\n      else {\n        tor_free(rs->version);\n        tor_free(rs);\n      }\n    } else {\n      routerstatus_t *rs;\n      if ((rs = routerstatus_parse_entry_from_string(rs_area, &s, rs_tokens,\n                                                     NULL, NULL,\n                                                     ns->consensus_method,\n                                                     flav)))\n        smartlist_add(ns->routerstatus_list, rs);\n    }\n  }\n  for (i = 1; i < smartlist_len(ns->routerstatus_list); ++i) {\n    routerstatus_t *rs1, *rs2;\n    if (ns->type != NS_TYPE_CONSENSUS) {\n      vote_routerstatus_t *a = smartlist_get(ns->routerstatus_list, i-1);\n      vote_routerstatus_t *b = smartlist_get(ns->routerstatus_list, i);\n      rs1 = &a->status; rs2 = &b->status;\n    } else {\n      rs1 = smartlist_get(ns->routerstatus_list, i-1);\n      rs2 = smartlist_get(ns->routerstatus_list, i);\n    }\n    if (fast_memcmp(rs1->identity_digest, rs2->identity_digest, DIGEST_LEN)\n        >= 0) {\n      log_warn(LD_DIR, \"Vote networkstatus entries not sorted by identity \"\n               \"digest\");\n      goto err;\n    }\n  }\n\n  /* Parse footer; check signature. */\n  footer_tokens = smartlist_create();\n  if ((end_of_footer = strstr(s, \"\\nnetwork-status-version \")))\n    ++end_of_footer;\n  else\n    end_of_footer = s + strlen(s);\n  if (tokenize_string(area,s, end_of_footer, footer_tokens,\n                      networkstatus_vote_footer_token_table, 0)) {\n    log_warn(LD_DIR, \"Error tokenizing network-status vote footer.\");\n    goto err;\n  }\n\n  {\n    int found_sig = 0;\n    SMARTLIST_FOREACH_BEGIN(footer_tokens, directory_token_t *, _tok) {\n      tok = _tok;\n      if (tok->tp == K_DIRECTORY_SIGNATURE)\n        found_sig = 1;\n      else if (found_sig) {\n        log_warn(LD_DIR, \"Extraneous token after first directory-signature\");\n        goto err;\n      }\n    } SMARTLIST_FOREACH_END(_tok);\n  }\n\n  if ((tok = find_opt_by_keyword(footer_tokens, K_DIRECTORY_FOOTER))) {\n    if (tok != smartlist_get(footer_tokens, 0)) {\n      log_warn(LD_DIR, \"Misplaced directory-footer token\");\n      goto err;\n    }\n  }\n\n  tok = find_opt_by_keyword(footer_tokens, K_BW_WEIGHTS);\n  if (tok) {\n    ns->weight_params = smartlist_create();\n    for (i = 0; i < tok->n_args; ++i) {\n      int ok=0;\n      char *eq = strchr(tok->args[i], '=');\n      if (!eq) {\n        log_warn(LD_DIR, \"Bad element '%s' in weight params\",\n                 escaped(tok->args[i]));\n        goto err;\n      }\n      tor_parse_long(eq+1, 10, INT32_MIN, INT32_MAX, &ok, NULL);\n      if (!ok) {\n        log_warn(LD_DIR, \"Bad element '%s' in params\", escaped(tok->args[i]));\n        goto err;\n      }\n      smartlist_add(ns->weight_params, tor_strdup(tok->args[i]));\n    }\n  }\n\n  SMARTLIST_FOREACH_BEGIN(footer_tokens, directory_token_t *, _tok) {\n    char declared_identity[DIGEST_LEN];\n    networkstatus_voter_info_t *v;\n    document_signature_t *sig;\n    const char *id_hexdigest = NULL;\n    const char *sk_hexdigest = NULL;\n    digest_algorithm_t alg = DIGEST_SHA1;\n    tok = _tok;\n    if (tok->tp != K_DIRECTORY_SIGNATURE)\n      continue;\n    tor_assert(tok->n_args >= 2);\n    if (tok->n_args == 2) {\n      id_hexdigest = tok->args[0];\n      sk_hexdigest = tok->args[1];\n    } else {\n      const char *algname = tok->args[0];\n      int a;\n      id_hexdigest = tok->args[1];\n      sk_hexdigest = tok->args[2];\n      a = crypto_digest_algorithm_parse_name(algname);\n      if (a<0) {\n        log_warn(LD_DIR, \"Unknown digest algorithm %s; skipping\",\n                 escaped(algname));\n        continue;\n      }\n      alg = a;\n    }\n\n    if (!tok->object_type ||\n        strcmp(tok->object_type, \"SIGNATURE\") ||\n        tok->object_size < 128 || tok->object_size > 512) {\n      log_warn(LD_DIR, \"Bad object type or length on directory-signature\");\n      goto err;\n    }\n\n    if (strlen(id_hexdigest) != HEX_DIGEST_LEN ||\n        base16_decode(declared_identity, sizeof(declared_identity),\n                      id_hexdigest, HEX_DIGEST_LEN) < 0) {\n      log_warn(LD_DIR, \"Error decoding declared identity %s in \"\n               \"network-status vote.\", escaped(id_hexdigest));\n      goto err;\n    }\n    if (!(v = networkstatus_get_voter_by_id(ns, declared_identity))) {\n      log_warn(LD_DIR, \"ID on signature on network-status vote does not match \"\n               \"any declared directory source.\");\n      goto err;\n    }\n    sig = tor_malloc_zero(sizeof(document_signature_t));\n    memcpy(sig->identity_digest, v->identity_digest, DIGEST_LEN);\n    sig->alg = alg;\n    if (strlen(sk_hexdigest) != HEX_DIGEST_LEN ||\n        base16_decode(sig->signing_key_digest, sizeof(sig->signing_key_digest),\n                      sk_hexdigest, HEX_DIGEST_LEN) < 0) {\n      log_warn(LD_DIR, \"Error decoding declared signing key digest %s in \"\n               \"network-status vote.\", escaped(sk_hexdigest));\n      tor_free(sig);\n      goto err;\n    }\n\n    if (ns->type != NS_TYPE_CONSENSUS) {\n      if (tor_memneq(declared_identity, ns->cert->cache_info.identity_digest,\n                 DIGEST_LEN)) {\n        log_warn(LD_DIR, \"Digest mismatch between declared and actual on \"\n                 \"network-status vote.\");\n        tor_free(sig);\n        goto err;\n      }\n    }\n\n    if (voter_get_sig_by_algorithm(v, sig->alg)) {\n      /* We already parsed a vote with this algorithm from this voter. Use the\n         first one. */\n      log_fn(LOG_PROTOCOL_WARN, LD_DIR, \"We received a networkstatus \"\n             \"that contains two votes from the same voter with the same \"\n             \"algorithm. Ignoring the second vote.\");\n      tor_free(sig);\n      continue;\n    }\n\n    if (ns->type != NS_TYPE_CONSENSUS) {\n      if (check_signature_token(ns_digests.d[DIGEST_SHA1], DIGEST_LEN,\n                                tok, ns->cert->signing_key, 0,\n                                \"network-status vote\")) {\n        tor_free(sig);\n        goto err;\n      }\n      sig->good_signature = 1;\n    } else {\n      if (tok->object_size >= INT_MAX || tok->object_size >= SIZE_T_CEILING) {\n        tor_free(sig);\n        goto err;\n      }\n      sig->signature = tor_memdup(tok->object_body, tok->object_size);\n      sig->signature_len = (int) tok->object_size;\n    }\n    smartlist_add(v->sigs, sig);\n\n    ++n_signatures;\n  } SMARTLIST_FOREACH_END(_tok);\n\n  if (! n_signatures) {\n    log_warn(LD_DIR, \"No signatures on networkstatus vote.\");\n    goto err;\n  } else if (ns->type == NS_TYPE_VOTE && n_signatures != 1) {\n    log_warn(LD_DIR, \"Received more than one signature on a \"\n             \"network-status vote.\");\n    goto err;\n  }\n\n  if (eos_out)\n    *eos_out = end_of_footer;\n\n  goto done;\n err:\n  dump_desc(s_dup, \"v3 networkstatus\");\n  networkstatus_vote_free(ns);\n  ns = NULL;\n done:\n  if (tokens) {\n    SMARTLIST_FOREACH(tokens, directory_token_t *, t, token_clear(t));\n    smartlist_free(tokens);\n  }\n  if (voter) {\n    if (voter->sigs) {\n      SMARTLIST_FOREACH(voter->sigs, document_signature_t *, sig,\n                        document_signature_free(sig));\n      smartlist_free(voter->sigs);\n    }\n    tor_free(voter->nickname);\n    tor_free(voter->address);\n    tor_free(voter->contact);\n    tor_free(voter);\n  }\n  if (rs_tokens) {\n    SMARTLIST_FOREACH(rs_tokens, directory_token_t *, t, token_clear(t));\n    smartlist_free(rs_tokens);\n  }\n  if (footer_tokens) {\n    SMARTLIST_FOREACH(footer_tokens, directory_token_t *, t, token_clear(t));\n    smartlist_free(footer_tokens);\n  }\n  if (area) {\n    DUMP_AREA(area, \"v3 networkstatus\");\n    memarea_drop_all(area);\n  }\n  if (rs_area)\n    memarea_drop_all(rs_area);\n\n  return ns;\n}", "func_hash": 32476189085047846654485357461000169303, "file_name": "routerparse.c", "file_hash": 74078993205863755729749320619386018823, "cwe": ["CWE-399"], "cve": "CVE-2012-3517", "cve_desc": "Use-after-free vulnerability in dns.c in Tor before 0.2.2.38 might allow remote attackers to cause a denial of service (daemon crash) via vectors related to failed DNS requests.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-3517", "file_path": "src/or/routerparse.c"}
{"idx": 208522, "project": "unbound", "commit_id": "02080f6b180232f43b77f403d0c038e9360a460f", "project_url": "https://github.com/NLnetLabs/unbound", "commit_url": "https://github.com/NLnetLabs/unbound/commit/02080f6b180232f43b77f403d0c038e9360a460f", "commit_message": "- Fix Integer Overflows in Size Calculations,\n  reported by X41 D-Sec.", "target": 1, "func": "dnsc_load_local_data(struct dnsc_env* dnscenv, struct config_file *cfg)\n{\n    size_t i, j;\n\t// Insert 'local-zone: \"2.dnscrypt-cert.example.com\" deny'\n    if(!cfg_str2list_insert(&cfg->local_zones,\n                            strdup(dnscenv->provider_name),\n                            strdup(\"deny\"))) {\n        log_err(\"Could not load dnscrypt local-zone: %s deny\",\n                dnscenv->provider_name);\n        return -1;\n    }\n\n    // Add local data entry of type:\n    // 2.dnscrypt-cert.example.com 86400 IN TXT \"DNSC......\"\n    for(i=0; i<dnscenv->signed_certs_count; i++) {\n        const char *ttl_class_type = \" 86400 IN TXT \\\"\";\n        int rotated_cert = 0;\n\tuint32_t serial;\n\tuint16_t rrlen;\n\tchar* rr;\n        struct SignedCert *cert = dnscenv->signed_certs + i;\n\t\t// Check if the certificate is being rotated and should not be published\n        for(j=0; j<dnscenv->rotated_certs_count; j++){\n            if(cert == dnscenv->rotated_certs[j]) {\n                rotated_cert = 1;\n                break;\n            }\n        }\n\t\tmemcpy(&serial, cert->serial, sizeof serial);\n\t\tserial = htonl(serial);\n        if(rotated_cert) {\n            verbose(VERB_OPS,\n                \"DNSCrypt: not adding cert with serial #%\"\n                PRIu32\n                \" to local-data as it is rotated\",\n                serial\n            );\n            continue;\n        }\n        rrlen = strlen(dnscenv->provider_name) +\n                         strlen(ttl_class_type) +\n                         4 * sizeof(struct SignedCert) + // worst case scenario\n                         1 + // trailing double quote\n                         1;\n        rr = malloc(rrlen);\n        if(!rr) {\n            log_err(\"Could not allocate memory\");\n            return -2;\n        }\n        snprintf(rr, rrlen - 1, \"%s 86400 IN TXT \\\"\", dnscenv->provider_name);\n        for(j=0; j<sizeof(struct SignedCert); j++) {\n\t\t\tint c = (int)*((const uint8_t *) cert + j);\n            if (isprint(c) && c != '\"' && c != '\\\\') {\n                snprintf(rr + strlen(rr), rrlen - 1 - strlen(rr), \"%c\", c);\n            } else {\n                snprintf(rr + strlen(rr), rrlen - 1 - strlen(rr), \"\\\\%03d\", c);\n            }\n        }\n        verbose(VERB_OPS,\n\t\t\t\"DNSCrypt: adding cert with serial #%\"\n\t\t\tPRIu32\n\t\t\t\" to local-data to config: %s\",\n\t\t\tserial, rr\n\t\t);\n        snprintf(rr + strlen(rr), rrlen - 1 - strlen(rr), \"\\\"\");\n        cfg_strlist_insert(&cfg->local_data, strdup(rr));\n        free(rr);\n    }\n    return dnscenv->signed_certs_count;\n}", "func_hash": 44451332163685602086826854088983200257, "file_name": "dnscrypt.c", "file_hash": 338731906376917706393921999097571082291, "cwe": ["CWE-190"], "cve": "CVE-2019-25038", "cve_desc": "Unbound before 1.9.5 allows an integer overflow in a size calculation in dnscrypt/dnscrypt.c. NOTE: The vendor disputes that this is a vulnerability. Although the code may be vulnerable, a running Unbound installation cannot be remotely or locally exploited", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2019-25038", "file_path": "dnscrypt/dnscrypt.c"}
{"idx": 412117, "project": "unbound", "commit_id": "02080f6b180232f43b77f403d0c038e9360a460f", "project_url": "https://github.com/NLnetLabs/unbound", "commit_url": "https://github.com/NLnetLabs/unbound/commit/02080f6b180232f43b77f403d0c038e9360a460f", "commit_message": "- Fix Integer Overflows in Size Calculations,\n  reported by X41 D-Sec.", "target": 0, "func": "dnsc_load_local_data(struct dnsc_env* dnscenv, struct config_file *cfg)\n{\n    size_t i, j;\n\t// Insert 'local-zone: \"2.dnscrypt-cert.example.com\" deny'\n    if(!cfg_str2list_insert(&cfg->local_zones,\n                            strdup(dnscenv->provider_name),\n                            strdup(\"deny\"))) {\n        log_err(\"Could not load dnscrypt local-zone: %s deny\",\n                dnscenv->provider_name);\n        return -1;\n    }\n\n    // Add local data entry of type:\n    // 2.dnscrypt-cert.example.com 86400 IN TXT \"DNSC......\"\n    for(i=0; i<dnscenv->signed_certs_count; i++) {\n        const char *ttl_class_type = \" 86400 IN TXT \\\"\";\n        int rotated_cert = 0;\n\tuint32_t serial;\n\tuint16_t rrlen;\n\tchar* rr;\n        struct SignedCert *cert = dnscenv->signed_certs + i;\n\t\t// Check if the certificate is being rotated and should not be published\n        for(j=0; j<dnscenv->rotated_certs_count; j++){\n            if(cert == dnscenv->rotated_certs[j]) {\n                rotated_cert = 1;\n                break;\n            }\n        }\n\t\tmemcpy(&serial, cert->serial, sizeof serial);\n\t\tserial = htonl(serial);\n        if(rotated_cert) {\n            verbose(VERB_OPS,\n                \"DNSCrypt: not adding cert with serial #%\"\n                PRIu32\n                \" to local-data as it is rotated\",\n                serial\n            );\n            continue;\n        }\n\tif((unsigned)strlen(dnscenv->provider_name) >= (unsigned)0xffff0000) {\n\t\t/* guard against integer overflow in rrlen calculation */\n\t\tverbose(VERB_OPS, \"cert #%\" PRIu32 \" is too long\", serial);\n\t\tcontinue\n\t}\n        rrlen = strlen(dnscenv->provider_name) +\n                         strlen(ttl_class_type) +\n                         4 * sizeof(struct SignedCert) + // worst case scenario\n                         1 + // trailing double quote\n                         1;\n        rr = malloc(rrlen);\n        if(!rr) {\n            log_err(\"Could not allocate memory\");\n            return -2;\n        }\n        snprintf(rr, rrlen - 1, \"%s 86400 IN TXT \\\"\", dnscenv->provider_name);\n        for(j=0; j<sizeof(struct SignedCert); j++) {\n\t\t\tint c = (int)*((const uint8_t *) cert + j);\n            if (isprint(c) && c != '\"' && c != '\\\\') {\n                snprintf(rr + strlen(rr), rrlen - 1 - strlen(rr), \"%c\", c);\n            } else {\n                snprintf(rr + strlen(rr), rrlen - 1 - strlen(rr), \"\\\\%03d\", c);\n            }\n        }\n        verbose(VERB_OPS,\n\t\t\t\"DNSCrypt: adding cert with serial #%\"\n\t\t\tPRIu32\n\t\t\t\" to local-data to config: %s\",\n\t\t\tserial, rr\n\t\t);\n        snprintf(rr + strlen(rr), rrlen - 1 - strlen(rr), \"\\\"\");\n        cfg_strlist_insert(&cfg->local_data, strdup(rr));\n        free(rr);\n    }\n    return dnscenv->signed_certs_count;\n}", "func_hash": 220864762997315196932796822660985000469, "file_name": "dnscrypt.c", "file_hash": 151631660973156645492009635074477412124, "cwe": ["CWE-190"], "cve": "CVE-2019-25038", "cve_desc": "Unbound before 1.9.5 allows an integer overflow in a size calculation in dnscrypt/dnscrypt.c. NOTE: The vendor disputes that this is a vulnerability. Although the code may be vulnerable, a running Unbound installation cannot be remotely or locally exploited", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2019-25038", "file_path": "dnscrypt/dnscrypt.c"}
{"idx": 208525, "project": "vim", "commit_id": "6046aded8da002b08d380db29de2ba0268b6616e", "project_url": "https://github.com/vim/vim", "commit_url": "https://github.com/vim/vim/commit/6046aded8da002b08d380db29de2ba0268b6616e", "commit_message": "patch 8.2.5148: invalid memory access when using expression on command line\n\nProblem:    Invalid memory access when using an expression on the command line.\nSolution:   Make sure the position does not go negative.", "target": 1, "func": "cmdline_insert_reg(int *gotesc UNUSED)\n{\n    int\t\ti;\n    int\t\tc;\n\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = TRUE;\t// disallow scrolling here\n#endif\n    putcmdline('\"', TRUE);\n    ++no_mapping;\n    ++allow_keys;\n    i = c = plain_vgetc();\t// CTRL-R <char>\n    if (i == Ctrl_O)\n\ti = Ctrl_R;\t\t// CTRL-R CTRL-O == CTRL-R CTRL-R\n    if (i == Ctrl_R)\n\tc = plain_vgetc();\t// CTRL-R CTRL-R <char>\n    extra_char = NUL;\n    --no_mapping;\n    --allow_keys;\n#ifdef FEAT_EVAL\n    /*\n     * Insert the result of an expression.\n     * Need to save the current command line, to be able to enter\n     * a new one...\n     */\n    new_cmdpos = -1;\n    if (c == '=')\n    {\n\tif (ccline.cmdfirstc == '='  // can't do this recursively\n\t\t|| cmdline_star > 0) // or when typing a password\n\t{\n\t    beep_flush();\n\t    c = ESC;\n\t}\n\telse\n\t    c = get_expr_register();\n    }\n#endif\n    if (c != ESC)\t    // use ESC to cancel inserting register\n    {\n\tcmdline_paste(c, i == Ctrl_R, FALSE);\n\n#ifdef FEAT_EVAL\n\t// When there was a serious error abort getting the\n\t// command line.\n\tif (aborting())\n\t{\n\t    *gotesc = TRUE;  // will free ccline.cmdbuff after\n\t    // putting it in history\n\t    return GOTO_NORMAL_MODE;\n\t}\n#endif\n\tKeyTyped = FALSE;\t// Don't do p_wc completion.\n#ifdef FEAT_EVAL\n\tif (new_cmdpos >= 0)\n\t{\n\t    // set_cmdline_pos() was used\n\t    if (new_cmdpos > ccline.cmdlen)\n\t\tccline.cmdpos = ccline.cmdlen;\n\t    else\n\t\tccline.cmdpos = new_cmdpos;\n\t}\n#endif\n    }\n    // remove the double quote\n    redrawcmd();\n\n    // The text has been stuffed, the command line didn't change yet.\n    return CMDLINE_NOT_CHANGED;\n}", "func_hash": 167804329878727127060395714139665031179, "file_name": "ex_getln.c", "file_hash": 269509646770853684376504137864854849552, "cwe": ["CWE-787"], "cve": "CVE-2022-2175", "cve_desc": "Buffer Over-read in GitHub repository vim/vim prior to 8.2.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-2175", "file_path": "src/ex_getln.c"}
{"idx": 412190, "project": "vim", "commit_id": "6046aded8da002b08d380db29de2ba0268b6616e", "project_url": "https://github.com/vim/vim", "commit_url": "https://github.com/vim/vim/commit/6046aded8da002b08d380db29de2ba0268b6616e", "commit_message": "patch 8.2.5148: invalid memory access when using expression on command line\n\nProblem:    Invalid memory access when using an expression on the command line.\nSolution:   Make sure the position does not go negative.", "target": 0, "func": "cmdline_insert_reg(int *gotesc UNUSED)\n{\n    int\t\ti;\n    int\t\tc;\n    int\t\tsave_new_cmdpos = new_cmdpos;\n\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = TRUE;\t// disallow scrolling here\n#endif\n    putcmdline('\"', TRUE);\n    ++no_mapping;\n    ++allow_keys;\n    i = c = plain_vgetc();\t// CTRL-R <char>\n    if (i == Ctrl_O)\n\ti = Ctrl_R;\t\t// CTRL-R CTRL-O == CTRL-R CTRL-R\n    if (i == Ctrl_R)\n\tc = plain_vgetc();\t// CTRL-R CTRL-R <char>\n    extra_char = NUL;\n    --no_mapping;\n    --allow_keys;\n#ifdef FEAT_EVAL\n    /*\n     * Insert the result of an expression.\n     */\n    new_cmdpos = -1;\n    if (c == '=')\n    {\n\tif (ccline.cmdfirstc == '='  // can't do this recursively\n\t\t|| cmdline_star > 0) // or when typing a password\n\t{\n\t    beep_flush();\n\t    c = ESC;\n\t}\n\telse\n\t    c = get_expr_register();\n    }\n#endif\n    if (c != ESC)\t    // use ESC to cancel inserting register\n    {\n\tcmdline_paste(c, i == Ctrl_R, FALSE);\n\n#ifdef FEAT_EVAL\n\t// When there was a serious error abort getting the\n\t// command line.\n\tif (aborting())\n\t{\n\t    *gotesc = TRUE;  // will free ccline.cmdbuff after\n\t    // putting it in history\n\t    return GOTO_NORMAL_MODE;\n\t}\n#endif\n\tKeyTyped = FALSE;\t// Don't do p_wc completion.\n#ifdef FEAT_EVAL\n\tif (new_cmdpos >= 0)\n\t{\n\t    // set_cmdline_pos() was used\n\t    if (new_cmdpos > ccline.cmdlen)\n\t\tccline.cmdpos = ccline.cmdlen;\n\t    else\n\t\tccline.cmdpos = new_cmdpos;\n\t}\n#endif\n    }\n    new_cmdpos = save_new_cmdpos;\n\n    // remove the double quote\n    redrawcmd();\n\n    // The text has been stuffed, the command line didn't change yet.\n    return CMDLINE_NOT_CHANGED;\n}", "func_hash": 5421090615610689574320991257810194043, "file_name": "ex_getln.c", "file_hash": 9575536184258751931455824501169284802, "cwe": ["CWE-787"], "cve": "CVE-2022-2175", "cve_desc": "Buffer Over-read in GitHub repository vim/vim prior to 8.2.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-2175", "file_path": "src/ex_getln.c"}
{"idx": 208535, "project": "rizin", "commit_id": "58926dffbe819fe9ebf5062f7130e026351cae01", "project_url": "https://github.com/rizinorg/rizin", "commit_url": "https://github.com/rizinorg/rizin/commit/58926dffbe819fe9ebf5062f7130e026351cae01", "commit_message": "fix #2964 - double-free in bin_qnx.c", "target": 1, "func": "static RzList *relocs(RzBinFile *bf) {\n\trz_return_val_if_fail(bf && bf->o, NULL);\n\tQnxObj *qo = bf->o->bin_obj;\n\treturn rz_list_clone(qo->fixups);\n}", "func_hash": 41829514855496977293704373413382810445, "file_name": "bin_qnx.c", "file_hash": 327448367050510652704729380638932181720, "cwe": ["CWE-415"], "cve": "CVE-2022-36043", "cve_desc": "Rizin is a UNIX-like reverse engineering framework and command-line toolset. Versions 0.4.0 and prior are vulnerable to a double free in bobj.c:rz_bin_reloc_storage_free() when freeing relocations generated from qnx binary plugin. A user opening a malicious qnx binary could be affected by this vulnerability, allowing an attacker to execute code on the user's machine. Commit number a3d50c1ea185f3f642f2d8180715f82d98840784 contains a patch for this issue.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-36043", "file_path": "librz/bin/p/bin_qnx.c"}
{"idx": 412332, "project": "rizin", "commit_id": "58926dffbe819fe9ebf5062f7130e026351cae01", "project_url": "https://github.com/rizinorg/rizin", "commit_url": "https://github.com/rizinorg/rizin/commit/58926dffbe819fe9ebf5062f7130e026351cae01", "commit_message": "fix #2964 - double-free in bin_qnx.c", "target": 0, "func": "static RzList *maps(RzBinFile *bf) {\n\trz_return_val_if_fail(bf && bf->o, NULL);\n\tQnxObj *qo = bf->o->bin_obj;\n\treturn rz_list_clone(qo->maps);\n}", "func_hash": 19242058764705601713784045996495740023, "file_name": "bin_qnx.c", "file_hash": 19463219798062548086589627833690645590, "cwe": ["CWE-415"], "cve": "CVE-2022-36043", "cve_desc": "Rizin is a UNIX-like reverse engineering framework and command-line toolset. Versions 0.4.0 and prior are vulnerable to a double free in bobj.c:rz_bin_reloc_storage_free() when freeing relocations generated from qnx binary plugin. A user opening a malicious qnx binary could be affected by this vulnerability, allowing an attacker to execute code on the user's machine. Commit number a3d50c1ea185f3f642f2d8180715f82d98840784 contains a patch for this issue.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-36043", "file_path": "librz/bin/p/bin_qnx.c"}
{"idx": 208654, "project": "php-src", "commit_id": "cab1c3b3708eead315e033359d07049b23b147a3", "project_url": "https://github.com/php/php-src", "commit_url": "http://git.php.net/?p=php-src.git;a=commit;h=cab1c3b3708eead315e033359d07049b23b147a3", "commit_message": "Fixed bug #72479 - same as #72434", "target": 1, "func": "PHP_MINIT_FUNCTION(snmp)\n{\n\tnetsnmp_log_handler *logh;\n\tzend_class_entry ce, cex;\n\n\tle_snmp_session = zend_register_list_destructors_ex(php_snmp_session_destructor, NULL, PHP_SNMP_SESSION_RES_NAME, module_number);\n\n\tinit_snmp(\"snmpapp\");\n\n#ifdef NETSNMP_DS_LIB_DONT_PERSIST_STATE\n\t/* Prevent update of the snmpapp.conf file */\n\tnetsnmp_ds_set_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DONT_PERSIST_STATE, 1);\n#endif\n\n\t/* Disable logging, use exit status'es and related variabled to detect errors */\n\tshutdown_snmp_logging();\n\tlogh = netsnmp_register_loghandler(NETSNMP_LOGHANDLER_NONE, LOG_ERR);\n\tif (logh) {\n\t\tlogh->pri_max = LOG_ERR;\n\t}\n\n\tmemcpy(&php_snmp_object_handlers, zend_get_std_object_handlers(), sizeof(zend_object_handlers));\n\tphp_snmp_object_handlers.read_property = php_snmp_read_property;\n\tphp_snmp_object_handlers.write_property = php_snmp_write_property;\n\tphp_snmp_object_handlers.has_property = php_snmp_has_property;\n\tphp_snmp_object_handlers.get_properties = php_snmp_get_properties;\n\n\t/* Register SNMP Class */\n\tINIT_CLASS_ENTRY(ce, \"SNMP\", php_snmp_class_methods);\n\tce.create_object = php_snmp_object_new;\n\tphp_snmp_object_handlers.clone_obj = NULL;\n\tphp_snmp_ce = zend_register_internal_class(&ce TSRMLS_CC);\n\n\t/* Register SNMP Class properties */\n\tzend_hash_init(&php_snmp_properties, 0, NULL, NULL, 1);\n\tPHP_SNMP_ADD_PROPERTIES(&php_snmp_properties, php_snmp_property_entries);\n\n\tREGISTER_LONG_CONSTANT(\"SNMP_OID_OUTPUT_SUFFIX\",\tNETSNMP_OID_OUTPUT_SUFFIX,\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SNMP_OID_OUTPUT_MODULE\",\tNETSNMP_OID_OUTPUT_MODULE,\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SNMP_OID_OUTPUT_FULL\",\t\tNETSNMP_OID_OUTPUT_FULL,\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SNMP_OID_OUTPUT_NUMERIC\",\tNETSNMP_OID_OUTPUT_NUMERIC,\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SNMP_OID_OUTPUT_UCD\",\t\tNETSNMP_OID_OUTPUT_UCD,\t\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SNMP_OID_OUTPUT_NONE\",\t\tNETSNMP_OID_OUTPUT_NONE,\tCONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"SNMP_VALUE_LIBRARY\",\tSNMP_VALUE_LIBRARY,\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SNMP_VALUE_PLAIN\",\tSNMP_VALUE_PLAIN,\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SNMP_VALUE_OBJECT\",\tSNMP_VALUE_OBJECT,\tCONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"SNMP_BIT_STR\",\t\tASN_BIT_STR,\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SNMP_OCTET_STR\",\tASN_OCTET_STR,\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SNMP_OPAQUE\",\t\tASN_OPAQUE,\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SNMP_NULL\",\t\tASN_NULL,\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SNMP_OBJECT_ID\",\tASN_OBJECT_ID,\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SNMP_IPADDRESS\",\tASN_IPADDRESS,\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SNMP_COUNTER\",\t\tASN_GAUGE,\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SNMP_UNSIGNED\",\t\tASN_UNSIGNED,\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SNMP_TIMETICKS\",\tASN_TIMETICKS,\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SNMP_UINTEGER\",\t\tASN_UINTEGER,\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SNMP_INTEGER\",\t\tASN_INTEGER,\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SNMP_COUNTER64\",\tASN_COUNTER64,\tCONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_SNMP_CLASS_CONST_LONG(\"VERSION_1\",\t\t\tSNMP_VERSION_1);\n\tREGISTER_SNMP_CLASS_CONST_LONG(\"VERSION_2c\",\t\t\tSNMP_VERSION_2c);\n\tREGISTER_SNMP_CLASS_CONST_LONG(\"VERSION_2C\",\t\t\tSNMP_VERSION_2c);\n\tREGISTER_SNMP_CLASS_CONST_LONG(\"VERSION_3\",\t\t\tSNMP_VERSION_3);\n\n\tREGISTER_SNMP_CLASS_CONST_LONG(\"ERRNO_NOERROR\",\t\t\tPHP_SNMP_ERRNO_NOERROR);\n\tREGISTER_SNMP_CLASS_CONST_LONG(\"ERRNO_ANY\",\t\t\tPHP_SNMP_ERRNO_ANY);\n\tREGISTER_SNMP_CLASS_CONST_LONG(\"ERRNO_GENERIC\",\t\t\tPHP_SNMP_ERRNO_GENERIC);\n\tREGISTER_SNMP_CLASS_CONST_LONG(\"ERRNO_TIMEOUT\",\t\t\tPHP_SNMP_ERRNO_TIMEOUT);\n\tREGISTER_SNMP_CLASS_CONST_LONG(\"ERRNO_ERROR_IN_REPLY\",\t\tPHP_SNMP_ERRNO_ERROR_IN_REPLY);\n\tREGISTER_SNMP_CLASS_CONST_LONG(\"ERRNO_OID_NOT_INCREASING\",\tPHP_SNMP_ERRNO_OID_NOT_INCREASING);\n\tREGISTER_SNMP_CLASS_CONST_LONG(\"ERRNO_OID_PARSING_ERROR\",\tPHP_SNMP_ERRNO_OID_PARSING_ERROR);\n\tREGISTER_SNMP_CLASS_CONST_LONG(\"ERRNO_MULTIPLE_SET_QUERIES\",\tPHP_SNMP_ERRNO_MULTIPLE_SET_QUERIES);\n\n\t/* Register SNMPException class */\n\tINIT_CLASS_ENTRY(cex, \"SNMPException\", NULL);\n#ifdef HAVE_SPL\n\tphp_snmp_exception_ce = zend_register_internal_class_ex(&cex, spl_ce_RuntimeException, NULL TSRMLS_CC);\n#else\n\tphp_snmp_exception_ce = zend_register_internal_class_ex(&cex, zend_exception_get_default(TSRMLS_C), NULL TSRMLS_CC);\n#endif\n\n\treturn SUCCESS;\n}", "func_hash": 67376393539603801542933710123087364670, "file_name": "snmp.c", "file_hash": 23932759773432740913613151934817775847, "cwe": ["CWE-416"], "cve": "CVE-2016-6295", "cve_desc": "ext/snmp/snmp.c in PHP before 5.5.38, 5.6.x before 5.6.24, and 7.x before 7.0.9 improperly interacts with the unserialize implementation and garbage collection, which allows remote attackers to cause a denial of service (use-after-free and application crash) or possibly have unspecified other impact via crafted serialized data, a related issue to CVE-2016-5773.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-6295", "file_path": "ext/snmp/snmp.c"}
{"idx": 413339, "project": "php-src", "commit_id": "cab1c3b3708eead315e033359d07049b23b147a3", "project_url": "https://github.com/php/php-src", "commit_url": "http://git.php.net/?p=php-src.git;a=commit;h=cab1c3b3708eead315e033359d07049b23b147a3", "commit_message": "Fixed bug #72479 - same as #72434", "target": 0, "func": "PHP_MINIT_FUNCTION(snmp)\n{\n\tnetsnmp_log_handler *logh;\n\tzend_class_entry ce, cex;\n\n\tle_snmp_session = zend_register_list_destructors_ex(php_snmp_session_destructor, NULL, PHP_SNMP_SESSION_RES_NAME, module_number);\n\n\tinit_snmp(\"snmpapp\");\n\n#ifdef NETSNMP_DS_LIB_DONT_PERSIST_STATE\n\t/* Prevent update of the snmpapp.conf file */\n\tnetsnmp_ds_set_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DONT_PERSIST_STATE, 1);\n#endif\n\n\t/* Disable logging, use exit status'es and related variabled to detect errors */\n\tshutdown_snmp_logging();\n\tlogh = netsnmp_register_loghandler(NETSNMP_LOGHANDLER_NONE, LOG_ERR);\n\tif (logh) {\n\t\tlogh->pri_max = LOG_ERR;\n\t}\n\n\tmemcpy(&php_snmp_object_handlers, zend_get_std_object_handlers(), sizeof(zend_object_handlers));\n\tphp_snmp_object_handlers.read_property = php_snmp_read_property;\n\tphp_snmp_object_handlers.write_property = php_snmp_write_property;\n\tphp_snmp_object_handlers.has_property = php_snmp_has_property;\n\tphp_snmp_object_handlers.get_properties = php_snmp_get_properties;\n\tphp_snmp_object_handlers.get_gc = php_snmp_get_gc;\n\n\t/* Register SNMP Class */\n\tINIT_CLASS_ENTRY(ce, \"SNMP\", php_snmp_class_methods);\n\tce.create_object = php_snmp_object_new;\n\tphp_snmp_object_handlers.clone_obj = NULL;\n\tphp_snmp_ce = zend_register_internal_class(&ce TSRMLS_CC);\n\n\t/* Register SNMP Class properties */\n\tzend_hash_init(&php_snmp_properties, 0, NULL, NULL, 1);\n\tPHP_SNMP_ADD_PROPERTIES(&php_snmp_properties, php_snmp_property_entries);\n\n\tREGISTER_LONG_CONSTANT(\"SNMP_OID_OUTPUT_SUFFIX\",\tNETSNMP_OID_OUTPUT_SUFFIX,\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SNMP_OID_OUTPUT_MODULE\",\tNETSNMP_OID_OUTPUT_MODULE,\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SNMP_OID_OUTPUT_FULL\",\t\tNETSNMP_OID_OUTPUT_FULL,\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SNMP_OID_OUTPUT_NUMERIC\",\tNETSNMP_OID_OUTPUT_NUMERIC,\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SNMP_OID_OUTPUT_UCD\",\t\tNETSNMP_OID_OUTPUT_UCD,\t\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SNMP_OID_OUTPUT_NONE\",\t\tNETSNMP_OID_OUTPUT_NONE,\tCONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"SNMP_VALUE_LIBRARY\",\tSNMP_VALUE_LIBRARY,\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SNMP_VALUE_PLAIN\",\tSNMP_VALUE_PLAIN,\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SNMP_VALUE_OBJECT\",\tSNMP_VALUE_OBJECT,\tCONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"SNMP_BIT_STR\",\t\tASN_BIT_STR,\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SNMP_OCTET_STR\",\tASN_OCTET_STR,\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SNMP_OPAQUE\",\t\tASN_OPAQUE,\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SNMP_NULL\",\t\tASN_NULL,\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SNMP_OBJECT_ID\",\tASN_OBJECT_ID,\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SNMP_IPADDRESS\",\tASN_IPADDRESS,\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SNMP_COUNTER\",\t\tASN_GAUGE,\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SNMP_UNSIGNED\",\t\tASN_UNSIGNED,\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SNMP_TIMETICKS\",\tASN_TIMETICKS,\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SNMP_UINTEGER\",\t\tASN_UINTEGER,\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SNMP_INTEGER\",\t\tASN_INTEGER,\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SNMP_COUNTER64\",\tASN_COUNTER64,\tCONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_SNMP_CLASS_CONST_LONG(\"VERSION_1\",\t\t\tSNMP_VERSION_1);\n\tREGISTER_SNMP_CLASS_CONST_LONG(\"VERSION_2c\",\t\t\tSNMP_VERSION_2c);\n\tREGISTER_SNMP_CLASS_CONST_LONG(\"VERSION_2C\",\t\t\tSNMP_VERSION_2c);\n\tREGISTER_SNMP_CLASS_CONST_LONG(\"VERSION_3\",\t\t\tSNMP_VERSION_3);\n\n\tREGISTER_SNMP_CLASS_CONST_LONG(\"ERRNO_NOERROR\",\t\t\tPHP_SNMP_ERRNO_NOERROR);\n\tREGISTER_SNMP_CLASS_CONST_LONG(\"ERRNO_ANY\",\t\t\tPHP_SNMP_ERRNO_ANY);\n\tREGISTER_SNMP_CLASS_CONST_LONG(\"ERRNO_GENERIC\",\t\t\tPHP_SNMP_ERRNO_GENERIC);\n\tREGISTER_SNMP_CLASS_CONST_LONG(\"ERRNO_TIMEOUT\",\t\t\tPHP_SNMP_ERRNO_TIMEOUT);\n\tREGISTER_SNMP_CLASS_CONST_LONG(\"ERRNO_ERROR_IN_REPLY\",\t\tPHP_SNMP_ERRNO_ERROR_IN_REPLY);\n\tREGISTER_SNMP_CLASS_CONST_LONG(\"ERRNO_OID_NOT_INCREASING\",\tPHP_SNMP_ERRNO_OID_NOT_INCREASING);\n\tREGISTER_SNMP_CLASS_CONST_LONG(\"ERRNO_OID_PARSING_ERROR\",\tPHP_SNMP_ERRNO_OID_PARSING_ERROR);\n\tREGISTER_SNMP_CLASS_CONST_LONG(\"ERRNO_MULTIPLE_SET_QUERIES\",\tPHP_SNMP_ERRNO_MULTIPLE_SET_QUERIES);\n\n\t/* Register SNMPException class */\n\tINIT_CLASS_ENTRY(cex, \"SNMPException\", NULL);\n#ifdef HAVE_SPL\n\tphp_snmp_exception_ce = zend_register_internal_class_ex(&cex, spl_ce_RuntimeException, NULL TSRMLS_CC);\n#else\n\tphp_snmp_exception_ce = zend_register_internal_class_ex(&cex, zend_exception_get_default(TSRMLS_C), NULL TSRMLS_CC);\n#endif\n\n\treturn SUCCESS;\n}", "func_hash": 61841669860685177602281773654543637365, "file_name": "snmp.c", "file_hash": 195062314366498303509175847868002620782, "cwe": ["CWE-416"], "cve": "CVE-2016-6295", "cve_desc": "ext/snmp/snmp.c in PHP before 5.5.38, 5.6.x before 5.6.24, and 7.x before 7.0.9 improperly interacts with the unserialize implementation and garbage collection, which allows remote attackers to cause a denial of service (use-after-free and application crash) or possibly have unspecified other impact via crafted serialized data, a related issue to CVE-2016-5773.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-6295", "file_path": "ext/snmp/snmp.c"}
