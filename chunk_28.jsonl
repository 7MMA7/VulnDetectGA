{"idx": 211113, "project": "linux", "commit_id": "7fd25e6fc035f4b04b75bca6d7e8daa069603a76", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=7fd25e6fc035f4b04b75bca6d7e8daa069603a76", "commit_message": "ieee802154: atusb: fix use-after-free at disconnect\n\nThe disconnect callback was accessing the hardware-descriptor private\ndata after having having freed it.\n\nFixes: 7490b008d123 (\"ieee802154: add support for atusb transceiver\")\nCc: stable <stable@vger.kernel.org>     # 4.2\nCc: Alexander Aring <alex.aring@gmail.com>\nReported-by: syzbot+f4509a9138a1472e7e80@syzkaller.appspotmail.com\nSigned-off-by: Johan Hovold <johan@kernel.org>\nSigned-off-by: Stefan Schmidt <stefan@datenfreihafen.org>", "target": 1, "func": "static void atusb_disconnect(struct usb_interface *interface)\n{\n\tstruct atusb *atusb = usb_get_intfdata(interface);\n\n\tdev_dbg(&atusb->usb_dev->dev, \"%s\\n\", __func__);\n\n\tatusb->shutdown = 1;\n\tcancel_delayed_work_sync(&atusb->work);\n\n\tusb_kill_anchored_urbs(&atusb->rx_urbs);\n\tatusb_free_urbs(atusb);\n\tusb_kill_urb(atusb->tx_urb);\n\tusb_free_urb(atusb->tx_urb);\n\n\tieee802154_unregister_hw(atusb->hw);\n\n\tieee802154_free_hw(atusb->hw);\n\n\tusb_set_intfdata(interface, NULL);\n\tusb_put_dev(atusb->usb_dev);\n\n\tpr_debug(\"%s done\\n\", __func__);\n}", "func_hash": 299709833249026599914455726415271875676, "file_name": "atusb.c", "file_hash": 263846166810107854630006099143080706726, "cwe": ["CWE-416"], "cve": "CVE-2019-19525", "cve_desc": "In the Linux kernel before 5.3.6, there is a use-after-free bug that can be caused by a malicious USB device in the drivers/net/ieee802154/atusb.c driver, aka CID-7fd25e6fc035.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2019-19525", "file_path": "drivers/net/ieee802154/atusb.c"}
{"idx": 446096, "project": "linux", "commit_id": "7fd25e6fc035f4b04b75bca6d7e8daa069603a76", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=7fd25e6fc035f4b04b75bca6d7e8daa069603a76", "commit_message": "ieee802154: atusb: fix use-after-free at disconnect\n\nThe disconnect callback was accessing the hardware-descriptor private\ndata after having having freed it.\n\nFixes: 7490b008d123 (\"ieee802154: add support for atusb transceiver\")\nCc: stable <stable@vger.kernel.org>     # 4.2\nCc: Alexander Aring <alex.aring@gmail.com>\nReported-by: syzbot+f4509a9138a1472e7e80@syzkaller.appspotmail.com\nSigned-off-by: Johan Hovold <johan@kernel.org>\nSigned-off-by: Stefan Schmidt <stefan@datenfreihafen.org>", "target": 0, "func": "static void atusb_disconnect(struct usb_interface *interface)\n{\n\tstruct atusb *atusb = usb_get_intfdata(interface);\n\n\tdev_dbg(&atusb->usb_dev->dev, \"%s\\n\", __func__);\n\n\tatusb->shutdown = 1;\n\tcancel_delayed_work_sync(&atusb->work);\n\n\tusb_kill_anchored_urbs(&atusb->rx_urbs);\n\tatusb_free_urbs(atusb);\n\tusb_kill_urb(atusb->tx_urb);\n\tusb_free_urb(atusb->tx_urb);\n\n\tieee802154_unregister_hw(atusb->hw);\n\n\tusb_put_dev(atusb->usb_dev);\n\n\tieee802154_free_hw(atusb->hw);\n\n\tusb_set_intfdata(interface, NULL);\n\n\tpr_debug(\"%s done\\n\", __func__);\n}", "func_hash": 293071923509968126139073732172721628591, "file_name": "atusb.c", "file_hash": 16875570992325006941870506429771552384, "cwe": ["CWE-416"], "cve": "CVE-2019-19525", "cve_desc": "In the Linux kernel before 5.3.6, there is a use-after-free bug that can be caused by a malicious USB device in the drivers/net/ieee802154/atusb.c driver, aka CID-7fd25e6fc035.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2019-19525", "file_path": "drivers/net/ieee802154/atusb.c"}
{"idx": 211126, "project": "libmobi", "commit_id": "612562bc1ea38f1708b044e7a079c47a05b1291d", "project_url": "https://github.com/bfabiszewski/libmobi", "commit_url": "https://github.com/bfabiszewski/libmobi/commit/612562bc1ea38f1708b044e7a079c47a05b1291d", "commit_message": "Fix: index entry label not being zero-terminated with corrupt input", "target": 1, "func": "static MOBI_RET mobi_parse_index_entry(MOBIIndx *indx, const MOBIIdxt idxt, const MOBITagx *tagx, const MOBIOrdt *ordt, MOBIBuffer *buf, const size_t curr_number) {\n    if (indx == NULL) {\n        debug_print(\"%s\", \"INDX structure not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    const size_t entry_offset = indx->entries_count;\n    const size_t entry_length = idxt.offsets[curr_number + 1] - idxt.offsets[curr_number];\n    mobi_buffer_setpos(buf, idxt.offsets[curr_number]);\n    size_t entry_number = curr_number + entry_offset;\n    if (entry_number >= indx->total_entries_count) {\n        debug_print(\"Entry number beyond array: %zu\\n\", entry_number);\n        return MOBI_DATA_CORRUPT;\n    }\n    /* save original record maxlen */\n    const size_t buf_maxlen = buf->maxlen;\n    if (buf->offset + entry_length >= buf_maxlen) {\n        debug_print(\"Entry length too long: %zu\\n\", entry_length);\n        return MOBI_DATA_CORRUPT;\n    }\n    buf->maxlen = buf->offset + entry_length;\n    size_t label_length = mobi_buffer_get8(buf);\n    if (label_length > entry_length) {\n        debug_print(\"Label length too long: %zu\\n\", label_length);\n        return MOBI_DATA_CORRUPT;\n    }\n    char text[INDX_LABEL_SIZEMAX];\n    /* FIXME: what is ORDT1 for? */\n    if (ordt->ordt2) {\n        label_length = mobi_getstring_ordt(ordt, buf, (unsigned char*) text, label_length);\n    } else {\n        label_length = mobi_indx_get_label((unsigned char*) text, buf, label_length, indx->ligt_entries_count);\n    }\n    indx->entries[entry_number].label = malloc(label_length + 1);\n    if (indx->entries[entry_number].label == NULL) {\n        debug_print(\"Memory allocation failed (%zu bytes)\\n\", label_length);\n        return MOBI_MALLOC_FAILED;\n    }\n    strncpy(indx->entries[entry_number].label, text, label_length + 1);\n    //debug_print(\"tag label[%zu]: %s\\n\", entry_number, indx->entries[entry_number].label);\n    unsigned char *control_bytes;\n    control_bytes = buf->data + buf->offset;\n    mobi_buffer_seek(buf, (int) tagx->control_byte_count);\n    indx->entries[entry_number].tags_count = 0;\n    indx->entries[entry_number].tags = NULL;\n    if (tagx->tags_count > 0) {\n        typedef struct {\n            uint8_t tag;\n            uint8_t tag_value_count;\n            uint32_t value_count;\n            uint32_t value_bytes;\n        } MOBIPtagx;\n        MOBIPtagx *ptagx = malloc(tagx->tags_count * sizeof(MOBIPtagx));\n        if (ptagx == NULL) {\n            debug_print(\"Memory allocation failed (%zu bytes)\\n\", tagx->tags_count * sizeof(MOBIPtagx));\n            return MOBI_MALLOC_FAILED;\n        }\n        uint32_t ptagx_count = 0;\n        size_t len;\n        size_t i = 0;\n        while (i < tagx->tags_count) {\n            if (tagx->tags[i].control_byte == 1) {\n                control_bytes++;\n                i++;\n                continue;\n            }\n            uint32_t value = control_bytes[0] & tagx->tags[i].bitmask;\n            if (value != 0) {\n                /* FIXME: is it safe to use MOBI_NOTSET? */\n                uint32_t value_count = MOBI_NOTSET;\n                uint32_t value_bytes = MOBI_NOTSET;\n                /* all bits of masked value are set */\n                if (value == tagx->tags[i].bitmask) {\n                    /* more than 1 bit set */\n                    if (mobi_bitcount(tagx->tags[i].bitmask) > 1) {\n                        /* read value bytes from entry */\n                        len = 0;\n                        value_bytes = mobi_buffer_get_varlen(buf, &len);\n                    } else {\n                        value_count = 1;\n                    }\n                } else {\n                    uint8_t mask = tagx->tags[i].bitmask;\n                    while ((mask & 1) == 0) {\n                        mask >>= 1;\n                        value >>= 1;\n                    }\n                    value_count = value;\n                }\n                ptagx[ptagx_count].tag = tagx->tags[i].tag;\n                ptagx[ptagx_count].tag_value_count = tagx->tags[i].values_count;\n                ptagx[ptagx_count].value_count = value_count;\n                ptagx[ptagx_count].value_bytes = value_bytes;\n                ptagx_count++;\n            }\n            i++;\n        }\n        indx->entries[entry_number].tags = malloc(tagx->tags_count * sizeof(MOBIIndexTag));\n        if (indx->entries[entry_number].tags == NULL) {\n            debug_print(\"Memory allocation failed (%zu bytes)\\n\", tagx->tags_count * sizeof(MOBIIndexTag));\n            free(ptagx);\n            return MOBI_MALLOC_FAILED;\n        }\n        i = 0;\n        while (i < ptagx_count) {\n            uint32_t tagvalues_count = 0;\n            /* FIXME: is it safe to use MOBI_NOTSET? */\n            /* value count is set */\n            uint32_t tagvalues[INDX_TAGVALUES_MAX];\n            if (ptagx[i].value_count != MOBI_NOTSET) {\n                size_t count = ptagx[i].value_count * ptagx[i].tag_value_count;\n                while (count-- && tagvalues_count < INDX_TAGVALUES_MAX) {\n                    len = 0;\n                    const uint32_t value_bytes = mobi_buffer_get_varlen(buf, &len);\n                    tagvalues[tagvalues_count++] = value_bytes;\n                }\n            /* value count is not set */\n            } else {\n                /* read value_bytes bytes */\n                len = 0;\n                while (len < ptagx[i].value_bytes && tagvalues_count < INDX_TAGVALUES_MAX) {\n                    const uint32_t value_bytes = mobi_buffer_get_varlen(buf, &len);\n                    tagvalues[tagvalues_count++] = value_bytes;\n                }\n            }\n            if (tagvalues_count) {\n                const size_t arr_size = tagvalues_count * sizeof(*indx->entries[entry_number].tags[i].tagvalues);\n                indx->entries[entry_number].tags[i].tagvalues = malloc(arr_size);\n                if (indx->entries[entry_number].tags[i].tagvalues == NULL) {\n                    debug_print(\"Memory allocation failed (%zu bytes)\\n\", arr_size);\n                    free(ptagx);\n                    return MOBI_MALLOC_FAILED;\n                }\n                memcpy(indx->entries[entry_number].tags[i].tagvalues, tagvalues, arr_size);\n            } else {\n                indx->entries[entry_number].tags[i].tagvalues = NULL;\n            }\n            indx->entries[entry_number].tags[i].tagid = ptagx[i].tag;\n            indx->entries[entry_number].tags[i].tagvalues_count = tagvalues_count;\n            indx->entries[entry_number].tags_count++;\n            i++;\n        }\n        free(ptagx);\n    }\n    /* restore buffer maxlen */\n    buf->maxlen = buf_maxlen;\n    return MOBI_SUCCESS;\n}", "func_hash": 251371537702901623564985735187675051869, "file_name": "index.c", "file_hash": 309095437889005741044332361577356993393, "cwe": ["CWE-125"], "cve": "CVE-2022-1987", "cve_desc": "Buffer Over-read in GitHub repository bfabiszewski/libmobi prior to 0.11.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-1987", "file_path": "src/index.c"}
{"idx": 446279, "project": "libmobi", "commit_id": "612562bc1ea38f1708b044e7a079c47a05b1291d", "project_url": "https://github.com/bfabiszewski/libmobi", "commit_url": "https://github.com/bfabiszewski/libmobi/commit/612562bc1ea38f1708b044e7a079c47a05b1291d", "commit_message": "Fix: index entry label not being zero-terminated with corrupt input", "target": 0, "func": "static MOBI_RET mobi_parse_index_entry(MOBIIndx *indx, const MOBIIdxt idxt, const MOBITagx *tagx, const MOBIOrdt *ordt, MOBIBuffer *buf, const size_t curr_number) {\n    if (indx == NULL) {\n        debug_print(\"%s\", \"INDX structure not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    const size_t entry_offset = indx->entries_count;\n    const size_t entry_length = idxt.offsets[curr_number + 1] - idxt.offsets[curr_number];\n    mobi_buffer_setpos(buf, idxt.offsets[curr_number]);\n    size_t entry_number = curr_number + entry_offset;\n    if (entry_number >= indx->total_entries_count) {\n        debug_print(\"Entry number beyond array: %zu\\n\", entry_number);\n        return MOBI_DATA_CORRUPT;\n    }\n    /* save original record maxlen */\n    const size_t buf_maxlen = buf->maxlen;\n    if (buf->offset + entry_length >= buf_maxlen) {\n        debug_print(\"Entry length too long: %zu\\n\", entry_length);\n        return MOBI_DATA_CORRUPT;\n    }\n    buf->maxlen = buf->offset + entry_length;\n    size_t label_length = mobi_buffer_get8(buf);\n    if (label_length > entry_length) {\n        debug_print(\"Label length too long: %zu\\n\", label_length);\n        return MOBI_DATA_CORRUPT;\n    }\n    char text[INDX_LABEL_SIZEMAX + 1];\n    /* FIXME: what is ORDT1 for? */\n    if (ordt->ordt2) {\n        label_length = mobi_getstring_ordt(ordt, buf, (unsigned char*) text, label_length);\n    } else {\n        label_length = mobi_indx_get_label((unsigned char*) text, buf, label_length, indx->ligt_entries_count);\n        if (buf->error != MOBI_SUCCESS) {\n            debug_print(\"Buffer error reading label: %d\\n\", buf->error);\n            return MOBI_DATA_CORRUPT;\n        }\n    }\n    indx->entries[entry_number].label = malloc(label_length + 1);\n    if (indx->entries[entry_number].label == NULL) {\n        debug_print(\"Memory allocation failed (%zu bytes)\\n\", label_length);\n        return MOBI_MALLOC_FAILED;\n    }\n    strncpy(indx->entries[entry_number].label, text, label_length + 1);\n    //debug_print(\"tag label[%zu]: %s\\n\", entry_number, indx->entries[entry_number].label);\n    unsigned char *control_bytes;\n    control_bytes = buf->data + buf->offset;\n    mobi_buffer_seek(buf, (int) tagx->control_byte_count);\n    indx->entries[entry_number].tags_count = 0;\n    indx->entries[entry_number].tags = NULL;\n    if (tagx->tags_count > 0) {\n        typedef struct {\n            uint8_t tag;\n            uint8_t tag_value_count;\n            uint32_t value_count;\n            uint32_t value_bytes;\n        } MOBIPtagx;\n        MOBIPtagx *ptagx = malloc(tagx->tags_count * sizeof(MOBIPtagx));\n        if (ptagx == NULL) {\n            debug_print(\"Memory allocation failed (%zu bytes)\\n\", tagx->tags_count * sizeof(MOBIPtagx));\n            return MOBI_MALLOC_FAILED;\n        }\n        uint32_t ptagx_count = 0;\n        size_t len;\n        size_t i = 0;\n        while (i < tagx->tags_count) {\n            if (tagx->tags[i].control_byte == 1) {\n                control_bytes++;\n                i++;\n                continue;\n            }\n            uint32_t value = control_bytes[0] & tagx->tags[i].bitmask;\n            if (value != 0) {\n                /* FIXME: is it safe to use MOBI_NOTSET? */\n                uint32_t value_count = MOBI_NOTSET;\n                uint32_t value_bytes = MOBI_NOTSET;\n                /* all bits of masked value are set */\n                if (value == tagx->tags[i].bitmask) {\n                    /* more than 1 bit set */\n                    if (mobi_bitcount(tagx->tags[i].bitmask) > 1) {\n                        /* read value bytes from entry */\n                        len = 0;\n                        value_bytes = mobi_buffer_get_varlen(buf, &len);\n                    } else {\n                        value_count = 1;\n                    }\n                } else {\n                    uint8_t mask = tagx->tags[i].bitmask;\n                    while ((mask & 1) == 0) {\n                        mask >>= 1;\n                        value >>= 1;\n                    }\n                    value_count = value;\n                }\n                ptagx[ptagx_count].tag = tagx->tags[i].tag;\n                ptagx[ptagx_count].tag_value_count = tagx->tags[i].values_count;\n                ptagx[ptagx_count].value_count = value_count;\n                ptagx[ptagx_count].value_bytes = value_bytes;\n                ptagx_count++;\n            }\n            i++;\n        }\n        indx->entries[entry_number].tags = malloc(tagx->tags_count * sizeof(MOBIIndexTag));\n        if (indx->entries[entry_number].tags == NULL) {\n            debug_print(\"Memory allocation failed (%zu bytes)\\n\", tagx->tags_count * sizeof(MOBIIndexTag));\n            free(ptagx);\n            return MOBI_MALLOC_FAILED;\n        }\n        i = 0;\n        while (i < ptagx_count) {\n            uint32_t tagvalues_count = 0;\n            /* FIXME: is it safe to use MOBI_NOTSET? */\n            /* value count is set */\n            uint32_t tagvalues[INDX_TAGVALUES_MAX];\n            if (ptagx[i].value_count != MOBI_NOTSET) {\n                size_t count = ptagx[i].value_count * ptagx[i].tag_value_count;\n                while (count-- && tagvalues_count < INDX_TAGVALUES_MAX) {\n                    len = 0;\n                    const uint32_t value_bytes = mobi_buffer_get_varlen(buf, &len);\n                    tagvalues[tagvalues_count++] = value_bytes;\n                }\n            /* value count is not set */\n            } else {\n                /* read value_bytes bytes */\n                len = 0;\n                while (len < ptagx[i].value_bytes && tagvalues_count < INDX_TAGVALUES_MAX) {\n                    const uint32_t value_bytes = mobi_buffer_get_varlen(buf, &len);\n                    tagvalues[tagvalues_count++] = value_bytes;\n                }\n            }\n            if (tagvalues_count) {\n                const size_t arr_size = tagvalues_count * sizeof(*indx->entries[entry_number].tags[i].tagvalues);\n                indx->entries[entry_number].tags[i].tagvalues = malloc(arr_size);\n                if (indx->entries[entry_number].tags[i].tagvalues == NULL) {\n                    debug_print(\"Memory allocation failed (%zu bytes)\\n\", arr_size);\n                    free(ptagx);\n                    return MOBI_MALLOC_FAILED;\n                }\n                memcpy(indx->entries[entry_number].tags[i].tagvalues, tagvalues, arr_size);\n            } else {\n                indx->entries[entry_number].tags[i].tagvalues = NULL;\n            }\n            indx->entries[entry_number].tags[i].tagid = ptagx[i].tag;\n            indx->entries[entry_number].tags[i].tagvalues_count = tagvalues_count;\n            indx->entries[entry_number].tags_count++;\n            i++;\n        }\n        free(ptagx);\n    }\n    /* restore buffer maxlen */\n    buf->maxlen = buf_maxlen;\n    return MOBI_SUCCESS;\n}", "func_hash": 15245136244377426883811242014385645170, "file_name": "index.c", "file_hash": 108195340824579059268746364836110051712, "cwe": ["CWE-125"], "cve": "CVE-2022-1987", "cve_desc": "Buffer Over-read in GitHub repository bfabiszewski/libmobi prior to 0.11.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-1987", "file_path": "src/index.c"}
{"idx": 211136, "project": "rizin", "commit_id": "556ca2f9eef01ec0f4a76d1fbacfcf3a87a44810", "project_url": "https://github.com/rizinorg/rizin", "commit_url": "https://github.com/rizinorg/rizin/commit/556ca2f9eef01ec0f4a76d1fbacfcf3a87a44810", "commit_message": "Fix oob write in dyldcache\n\nWhen the individual n_slide_infos were too high, the sum would overflow\nand too few entries would be allocated.", "target": 1, "func": "static RzDyldRebaseInfos *get_rebase_infos(RzDyldCache *cache) {\n\tRzDyldRebaseInfos *result = RZ_NEW0(RzDyldRebaseInfos);\n\tif (!result) {\n\t\treturn NULL;\n\t}\n\n\tif (!cache->hdr->slideInfoOffset || !cache->hdr->slideInfoSize) {\n\t\tut32 total_slide_infos = 0;\n\t\tut32 n_slide_infos[MAX_N_HDR];\n\n\t\tut32 i;\n\t\tfor (i = 0; i < cache->n_hdr && i < MAX_N_HDR; i++) {\n\t\t\tut64 hdr_offset = cache->hdr_offset[i];\n\t\t\tif (!rz_buf_read_le32_at(cache->buf, 0x13c + hdr_offset, &n_slide_infos[i])) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\ttotal_slide_infos += n_slide_infos[i];\n\t\t}\n\n\t\tif (!total_slide_infos) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tRzDyldRebaseInfosEntry *infos = RZ_NEWS0(RzDyldRebaseInfosEntry, total_slide_infos);\n\t\tif (!infos) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tut32 k = 0;\n\t\tfor (i = 0; i < cache->n_hdr && i < MAX_N_HDR; i++) {\n\t\t\tut64 hdr_offset = cache->hdr_offset[i];\n\t\t\tif (!n_slide_infos[i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tut32 sio;\n\t\t\tif (!rz_buf_read_le32_at(cache->buf, 0x138 + hdr_offset, &sio)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tut64 slide_infos_offset = sio;\n\t\t\tif (!slide_infos_offset) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tslide_infos_offset += hdr_offset;\n\n\t\t\tut32 j;\n\t\t\tRzDyldRebaseInfo *prev_info = NULL;\n\t\t\tfor (j = 0; j < n_slide_infos[i]; j++) {\n\t\t\t\tut64 offset = slide_infos_offset + j * sizeof(cache_mapping_slide);\n\t\t\t\tcache_mapping_slide entry;\n\t\t\t\tif (rz_buf_fread_at(cache->buf, offset, (ut8 *)&entry, \"6lii\", 1) != sizeof(cache_mapping_slide)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (entry.slideInfoOffset && entry.slideInfoSize) {\n\t\t\t\t\tinfos[k].start = entry.fileOffset + hdr_offset;\n\t\t\t\t\tinfos[k].end = infos[k].start + entry.size;\n\t\t\t\t\tut64 slide = prev_info ? prev_info->slide : UT64_MAX;\n\t\t\t\t\tinfos[k].info = get_rebase_info(cache, entry.slideInfoOffset + hdr_offset, entry.slideInfoSize, entry.fileOffset + hdr_offset, slide);\n\t\t\t\t\tprev_info = infos[k].info;\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!k) {\n\t\t\tfree(infos);\n\t\t\tgoto beach;\n\t\t}\n\n\t\tif (k < total_slide_infos) {\n\t\t\tRzDyldRebaseInfosEntry *pruned_infos = RZ_NEWS0(RzDyldRebaseInfosEntry, k);\n\t\t\tif (!pruned_infos) {\n\t\t\t\tfree(infos);\n\t\t\t\tgoto beach;\n\t\t\t}\n\n\t\t\tmemcpy(pruned_infos, infos, sizeof(RzDyldRebaseInfosEntry) * k);\n\t\t\tfree(infos);\n\t\t\tinfos = pruned_infos;\n\t\t}\n\n\t\tresult->entries = infos;\n\t\tresult->length = k;\n\t\treturn result;\n\t}\n\n\tif (cache->hdr->mappingCount > 1) {\n\t\tRzDyldRebaseInfosEntry *infos = RZ_NEWS0(RzDyldRebaseInfosEntry, 1);\n\t\tif (!infos) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tinfos[0].start = cache->maps[1].fileOffset;\n\t\tinfos[0].end = infos[0].start + cache->maps[1].size;\n\t\tinfos[0].info = get_rebase_info(cache, cache->hdr->slideInfoOffset, cache->hdr->slideInfoSize, infos[0].start, UT64_MAX);\n\n\t\tresult->entries = infos;\n\t\tresult->length = 1;\n\t\treturn result;\n\t}\n\nbeach:\n\tfree(result);\n\treturn NULL;\n}", "func_hash": 322670680444734680611953548583170676242, "file_name": "dyldcache.c", "file_hash": 282393003255280688273305906326648900280, "cwe": ["CWE-787"], "cve": "CVE-2022-36042", "cve_desc": "Rizin is a UNIX-like reverse engineering framework and command-line toolset. Versions 0.4.0 and prior are vulnerable to an out-of-bounds write when getting data from dyld cache files. A user opening a malicious dyld cache file could be affected by this vulnerability, allowing an attacker to execute code on the user's machine. Commit number 556ca2f9eef01ec0f4a76d1fbacfcf3a87a44810 contains a patch.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-36042", "file_path": "librz/bin/format/mach0/dyldcache.c"}
{"idx": 446416, "project": "rizin", "commit_id": "556ca2f9eef01ec0f4a76d1fbacfcf3a87a44810", "project_url": "https://github.com/rizinorg/rizin", "commit_url": "https://github.com/rizinorg/rizin/commit/556ca2f9eef01ec0f4a76d1fbacfcf3a87a44810", "commit_message": "Fix oob write in dyldcache\n\nWhen the individual n_slide_infos were too high, the sum would overflow\nand too few entries would be allocated.", "target": 0, "func": "static RzDyldRebaseInfos *get_rebase_infos(RzDyldCache *cache) {\n\tRzDyldRebaseInfos *result = RZ_NEW0(RzDyldRebaseInfos);\n\tif (!result) {\n\t\treturn NULL;\n\t}\n\n\tif (!cache->hdr->slideInfoOffset || !cache->hdr->slideInfoSize) {\n\t\tsize_t total_slide_infos = 0;\n\t\tut32 n_slide_infos[MAX_N_HDR];\n\n\t\tut32 i;\n\t\tfor (i = 0; i < cache->n_hdr && i < MAX_N_HDR; i++) {\n\t\t\tut64 hdr_offset = cache->hdr_offset[i];\n\t\t\tif (!rz_buf_read_le32_at(cache->buf, 0x13c + hdr_offset, &n_slide_infos[i])) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tut32 total = total_slide_infos + n_slide_infos[i];\n\t\t\tif (total < total_slide_infos) {\n\t\t\t\t// overflow\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\ttotal_slide_infos = total;\n\t\t}\n\n\t\tif (!total_slide_infos) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tRzDyldRebaseInfosEntry *infos = RZ_NEWS0(RzDyldRebaseInfosEntry, total_slide_infos);\n\t\tif (!infos) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tut32 k = 0;\n\t\tfor (i = 0; i < cache->n_hdr && i < MAX_N_HDR; i++) {\n\t\t\tut64 hdr_offset = cache->hdr_offset[i];\n\t\t\tif (!n_slide_infos[i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tut32 sio;\n\t\t\tif (!rz_buf_read_le32_at(cache->buf, 0x138 + hdr_offset, &sio)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tut64 slide_infos_offset = sio;\n\t\t\tif (!slide_infos_offset) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tslide_infos_offset += hdr_offset;\n\n\t\t\tut32 j;\n\t\t\tRzDyldRebaseInfo *prev_info = NULL;\n\t\t\tfor (j = 0; j < n_slide_infos[i]; j++) {\n\t\t\t\tut64 offset = slide_infos_offset + j * sizeof(cache_mapping_slide);\n\t\t\t\tcache_mapping_slide entry;\n\t\t\t\tif (rz_buf_fread_at(cache->buf, offset, (ut8 *)&entry, \"6lii\", 1) != sizeof(cache_mapping_slide)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (entry.slideInfoOffset && entry.slideInfoSize) {\n\t\t\t\t\tinfos[k].start = entry.fileOffset + hdr_offset;\n\t\t\t\t\tinfos[k].end = infos[k].start + entry.size;\n\t\t\t\t\tut64 slide = prev_info ? prev_info->slide : UT64_MAX;\n\t\t\t\t\tinfos[k].info = get_rebase_info(cache, entry.slideInfoOffset + hdr_offset, entry.slideInfoSize, entry.fileOffset + hdr_offset, slide);\n\t\t\t\t\tprev_info = infos[k].info;\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!k) {\n\t\t\tfree(infos);\n\t\t\tgoto beach;\n\t\t}\n\n\t\tif (k < total_slide_infos) {\n\t\t\tRzDyldRebaseInfosEntry *pruned_infos = RZ_NEWS0(RzDyldRebaseInfosEntry, k);\n\t\t\tif (!pruned_infos) {\n\t\t\t\tfree(infos);\n\t\t\t\tgoto beach;\n\t\t\t}\n\n\t\t\tmemcpy(pruned_infos, infos, sizeof(RzDyldRebaseInfosEntry) * k);\n\t\t\tfree(infos);\n\t\t\tinfos = pruned_infos;\n\t\t}\n\n\t\tresult->entries = infos;\n\t\tresult->length = k;\n\t\treturn result;\n\t}\n\n\tif (cache->hdr->mappingCount > 1) {\n\t\tRzDyldRebaseInfosEntry *infos = RZ_NEWS0(RzDyldRebaseInfosEntry, 1);\n\t\tif (!infos) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tinfos[0].start = cache->maps[1].fileOffset;\n\t\tinfos[0].end = infos[0].start + cache->maps[1].size;\n\t\tinfos[0].info = get_rebase_info(cache, cache->hdr->slideInfoOffset, cache->hdr->slideInfoSize, infos[0].start, UT64_MAX);\n\n\t\tresult->entries = infos;\n\t\tresult->length = 1;\n\t\treturn result;\n\t}\n\nbeach:\n\tfree(result);\n\treturn NULL;\n}", "func_hash": 118361840381472328590054655200772047943, "file_name": "dyldcache.c", "file_hash": 6264328448164427099716487918952046116, "cwe": ["CWE-787"], "cve": "CVE-2022-36042", "cve_desc": "Rizin is a UNIX-like reverse engineering framework and command-line toolset. Versions 0.4.0 and prior are vulnerable to an out-of-bounds write when getting data from dyld cache files. A user opening a malicious dyld cache file could be affected by this vulnerability, allowing an attacker to execute code on the user's machine. Commit number 556ca2f9eef01ec0f4a76d1fbacfcf3a87a44810 contains a patch.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-36042", "file_path": "librz/bin/format/mach0/dyldcache.c"}
{"idx": 211179, "project": "exiv2", "commit_id": "6e3855aed7ba8bb4731fc4087ca7f9078b2f3d97", "project_url": "https://github.com/Exiv2/exiv2", "commit_url": "https://github.com/Exiv2/exiv2/commit/6e3855aed7ba8bb4731fc4087ca7f9078b2f3d97", "commit_message": "Fix https://github.com/Exiv2/exiv2/issues/55", "target": 1, "func": "    void Image::printIFDStructure(BasicIo& io, std::ostream& out, Exiv2::PrintStructureOption option,uint32_t start,bool bSwap,char c,int depth)\n    {\n        depth++;\n        bool bFirst  = true  ;\n\n        // buffer\n        const size_t dirSize = 32;\n        DataBuf  dir(dirSize);\n        bool bPrint = option == kpsBasic || option == kpsRecursive;\n\n        do {\n            // Read top of directory\n            io.seek(start,BasicIo::beg);\n            io.read(dir.pData_, 2);\n            uint16_t   dirLength = byteSwap2(dir,0,bSwap);\n\n            bool tooBig = dirLength > 500;\n            if ( tooBig ) throw Error(55);\n\n            if ( bFirst && bPrint ) {\n                out << Internal::indent(depth) << Internal::stringFormat(\"STRUCTURE OF TIFF FILE (%c%c): \",c,c) << io.path() << std::endl;\n                if ( tooBig ) out << Internal::indent(depth) << \"dirLength = \" << dirLength << std::endl;\n            }\n\n            // Read the dictionary\n            for ( int i = 0 ; i < dirLength ; i ++ ) {\n                if ( bFirst && bPrint ) {\n                    out << Internal::indent(depth)\n                        << \" address |    tag                              |     \"\n                        << \" type |    count |    offset | value\\n\";\n                }\n                bFirst = false;\n\n                io.read(dir.pData_, 12);\n                uint16_t tag    = byteSwap2(dir,0,bSwap);\n                uint16_t type   = byteSwap2(dir,2,bSwap);\n                uint32_t count  = byteSwap4(dir,4,bSwap);\n                uint32_t offset = byteSwap4(dir,8,bSwap);\n\n                // Break for unknown tag types else we may segfault.\n                if ( !typeValid(type) ) {\n                    std::cerr << \"invalid type value detected in Image::printIFDStructure:  \" << type << std::endl;\n                    start = 0; // break from do loop\n                    throw Error(56);\n                    break; // break from for loop\n                }\n\n                std::string sp  = \"\" ; // output spacer\n\n                //prepare to print the value\n                uint32_t kount  = isPrintXMP(tag,option) ? count // haul in all the data\n                                : isPrintICC(tag,option) ? count // ditto\n                                : isStringType(type)     ? (count > 32 ? 32 : count) // restrict long arrays\n                                : count > 5              ? 5\n                                : count\n                                ;\n                uint32_t pad    = isStringType(type) ? 1 : 0;\n                uint32_t size   = isStringType(type) ? 1\n                                : is2ByteType(type)  ? 2\n                                : is4ByteType(type)  ? 4\n                                : is8ByteType(type)  ? 8\n                                : 1\n                                ;\n\n                // if ( offset > io.size() ) offset = 0; // Denial of service?\n                DataBuf  buf(size*count + pad+20);  // allocate a buffer\n                std::memcpy(buf.pData_,dir.pData_+8,4);  // copy dir[8:11] into buffer (short strings)\n                const bool bOffsetIsPointer = count*size > 4;\n\n                if ( bOffsetIsPointer ) {         // read into buffer\n                    size_t   restore = io.tell();  // save\n                    io.seek(offset,BasicIo::beg);  // position\n                    io.read(buf.pData_,count*size);// read\n                    io.seek(restore,BasicIo::beg); // restore\n                }\n\n                if ( bPrint ) {\n                    const uint32_t address = start + 2 + i*12 ;\n                    const std::string offsetString = bOffsetIsPointer?\n                        Internal::stringFormat(\"%10u\", offset):\n                        \"\";\n\n                    out << Internal::indent(depth)\n                    << Internal::stringFormat(\"%8u | %#06x %-28s |%10s |%9u |%10s | \"\n                                              ,address,tag,tagName(tag).c_str(),typeName(type),count,offsetString.c_str());\n                    if ( isShortType(type) ){\n                        for ( size_t k = 0 ; k < kount ; k++ ) {\n                            out << sp << byteSwap2(buf,k*size,bSwap);\n                            sp = \" \";\n                        }\n                    } else if ( isLongType(type) ){\n                        for ( size_t k = 0 ; k < kount ; k++ ) {\n                            out << sp << byteSwap4(buf,k*size,bSwap);\n                            sp = \" \";\n                        }\n\n                    } else if ( isRationalType(type) ){\n                        for ( size_t k = 0 ; k < kount ; k++ ) {\n                            uint32_t a = byteSwap4(buf,k*size+0,bSwap);\n                            uint32_t b = byteSwap4(buf,k*size+4,bSwap);\n                            out << sp << a << \"/\" << b;\n                            sp = \" \";\n                        }\n                    } else if ( isStringType(type) ) {\n                        out << sp << Internal::binaryToString(buf, kount);\n                    }\n\n                    sp = kount == count ? \"\" : \" ...\";\n                    out << sp << std::endl;\n\n                    if ( option == kpsRecursive && (tag == 0x8769 /* ExifTag */ || tag == 0x014a/*SubIFDs*/  || type == tiffIfd) ) {\n                        for ( size_t k = 0 ; k < count ; k++ ) {\n                            size_t   restore = io.tell();\n                            uint32_t offset = byteSwap4(buf,k*size,bSwap);\n                            printIFDStructure(io,out,option,offset,bSwap,c,depth);\n                            io.seek(restore,BasicIo::beg);\n                        }\n                    } else if ( option == kpsRecursive && tag == 0x83bb /* IPTCNAA */ ) {\n                        size_t   restore = io.tell();  // save\n                        io.seek(offset,BasicIo::beg);  // position\n                        byte* bytes=new byte[count] ;  // allocate memory\n                        io.read(bytes,count)        ;  // read\n                        io.seek(restore,BasicIo::beg); // restore\n                        IptcData::printStructure(out,bytes,count,depth);\n                        delete[] bytes;                // free\n                    }  else if ( option == kpsRecursive && tag == 0x927c /* MakerNote */ && count > 10) {\n                        size_t   restore = io.tell();  // save\n\n                        uint32_t jump= 10           ;\n                        byte     bytes[20]          ;\n                        const char* chars = (const char*) &bytes[0] ;\n                        io.seek(offset,BasicIo::beg);  // position\n                        io.read(bytes,jump    )     ;  // read\n                        bytes[jump]=0               ;\n                        if ( ::strcmp(\"Nikon\",chars) == 0 ) {\n                            // tag is an embedded tiff\n                            byte* bytes=new byte[count-jump] ;  // allocate memory\n                            io.read(bytes,count-jump)        ;  // read\n                            MemIo memIo(bytes,count-jump)    ;  // create a file\n                            printTiffStructure(memIo,out,option,depth);\n                            delete[] bytes                   ;  // free\n                        } else {\n                            // tag is an IFD\n                            io.seek(0,BasicIo::beg);  // position\n                            printIFDStructure(io,out,option,offset,bSwap,c,depth);\n                        }\n\n                        io.seek(restore,BasicIo::beg); // restore\n                    }\n                }\n\n                if ( isPrintXMP(tag,option) ) {\n                    buf.pData_[count]=0;\n                    out << (char*) buf.pData_;\n                }\n                if ( isPrintICC(tag,option) ) {\n                    out.write((const char*)buf.pData_,count);\n                }\n            }\n            if ( start ) {\n                io.read(dir.pData_, 4);\n                start = tooBig ? 0 : byteSwap4(dir,0,bSwap);\n            }\n        } while (start) ;\n\n        if ( bPrint ) {\n            out << Internal::indent(depth) << \"END \" << io.path() << std::endl;\n        }\n        out.flush();\n        depth--;\n    }", "func_hash": 34928413875325993015079651771204457360, "file_name": "image.cpp", "file_hash": 9570858013269078968090500181487179730, "cwe": ["CWE-125"], "cve": "CVE-2017-17723", "cve_desc": "In Exiv2 0.26, there is a heap-based buffer over-read in the Exiv2::Image::byteSwap4 function in image.cpp. Remote attackers can exploit this vulnerability to disclose memory data or cause a denial of service via a crafted TIFF file.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-17723", "file_path": "src/image.cpp"}
{"idx": 447053, "project": "exiv2", "commit_id": "6e3855aed7ba8bb4731fc4087ca7f9078b2f3d97", "project_url": "https://github.com/Exiv2/exiv2", "commit_url": "https://github.com/Exiv2/exiv2/commit/6e3855aed7ba8bb4731fc4087ca7f9078b2f3d97", "commit_message": "Fix https://github.com/Exiv2/exiv2/issues/55", "target": 0, "func": "    void Image::printIFDStructure(BasicIo& io, std::ostream& out, Exiv2::PrintStructureOption option,uint32_t start,bool bSwap,char c,int depth)\n    {\n        depth++;\n        bool bFirst  = true  ;\n\n        // buffer\n        const size_t dirSize = 32;\n        DataBuf  dir(dirSize);\n        bool bPrint = option == kpsBasic || option == kpsRecursive;\n\n        do {\n            // Read top of directory\n            io.seek(start,BasicIo::beg);\n            io.read(dir.pData_, 2);\n            uint16_t   dirLength = byteSwap2(dir,0,bSwap);\n\n            bool tooBig = dirLength > 500;\n            if ( tooBig ) throw Error(55);\n\n            if ( bFirst && bPrint ) {\n                out << Internal::indent(depth) << Internal::stringFormat(\"STRUCTURE OF TIFF FILE (%c%c): \",c,c) << io.path() << std::endl;\n                if ( tooBig ) out << Internal::indent(depth) << \"dirLength = \" << dirLength << std::endl;\n            }\n\n            // Read the dictionary\n            for ( int i = 0 ; i < dirLength ; i ++ ) {\n                if ( bFirst && bPrint ) {\n                    out << Internal::indent(depth)\n                        << \" address |    tag                              |     \"\n                        << \" type |    count |    offset | value\\n\";\n                }\n                bFirst = false;\n\n                io.read(dir.pData_, 12);\n                uint16_t tag    = byteSwap2(dir,0,bSwap);\n                uint16_t type   = byteSwap2(dir,2,bSwap);\n                uint32_t count  = byteSwap4(dir,4,bSwap);\n                uint32_t offset = byteSwap4(dir,8,bSwap);\n\n                // Break for unknown tag types else we may segfault.\n                if ( !typeValid(type) ) {\n                    std::cerr << \"invalid type value detected in Image::printIFDStructure:  \" << type << std::endl;\n                    start = 0; // break from do loop\n                    throw Error(56);\n                    break; // break from for loop\n                }\n\n                std::string sp  = \"\" ; // output spacer\n\n                //prepare to print the value\n                uint32_t kount  = isPrintXMP(tag,option) ? count // haul in all the data\n                                : isPrintICC(tag,option) ? count // ditto\n                                : isStringType(type)     ? (count > 32 ? 32 : count) // restrict long arrays\n                                : count > 5              ? 5\n                                : count\n                                ;\n                uint32_t pad    = isStringType(type) ? 1 : 0;\n                uint32_t size   = isStringType(type) ? 1\n                                : is2ByteType(type)  ? 2\n                                : is4ByteType(type)  ? 4\n                                : is8ByteType(type)  ? 8\n                                : 1\n                                ;\n\n                // if ( offset > io.size() ) offset = 0; // Denial of service?\n\n                // #55 memory allocation crash test/data/POC8\n                long long allocate = (long long) (size*count + pad+20);\n                if ( allocate > (long long) io.size() ) {\n                    throw Error(57);\n                }\n                DataBuf  buf(allocate);  // allocate a buffer\n                std::memcpy(buf.pData_,dir.pData_+8,4);  // copy dir[8:11] into buffer (short strings)\n                const bool bOffsetIsPointer = count*size > 4;\n\n                if ( bOffsetIsPointer ) {         // read into buffer\n                    size_t   restore = io.tell();  // save\n                    io.seek(offset,BasicIo::beg);  // position\n                    io.read(buf.pData_,count*size);// read\n                    io.seek(restore,BasicIo::beg); // restore\n                }\n\n                if ( bPrint ) {\n                    const uint32_t address = start + 2 + i*12 ;\n                    const std::string offsetString = bOffsetIsPointer?\n                        Internal::stringFormat(\"%10u\", offset):\n                        \"\";\n\n                    out << Internal::indent(depth)\n                    << Internal::stringFormat(\"%8u | %#06x %-28s |%10s |%9u |%10s | \"\n                                              ,address,tag,tagName(tag).c_str(),typeName(type),count,offsetString.c_str());\n                    if ( isShortType(type) ){\n                        for ( size_t k = 0 ; k < kount ; k++ ) {\n                            out << sp << byteSwap2(buf,k*size,bSwap);\n                            sp = \" \";\n                        }\n                    } else if ( isLongType(type) ){\n                        for ( size_t k = 0 ; k < kount ; k++ ) {\n                            out << sp << byteSwap4(buf,k*size,bSwap);\n                            sp = \" \";\n                        }\n\n                    } else if ( isRationalType(type) ){\n                        for ( size_t k = 0 ; k < kount ; k++ ) {\n                            uint32_t a = byteSwap4(buf,k*size+0,bSwap);\n                            uint32_t b = byteSwap4(buf,k*size+4,bSwap);\n                            out << sp << a << \"/\" << b;\n                            sp = \" \";\n                        }\n                    } else if ( isStringType(type) ) {\n                        out << sp << Internal::binaryToString(buf, kount);\n                    }\n\n                    sp = kount == count ? \"\" : \" ...\";\n                    out << sp << std::endl;\n\n                    if ( option == kpsRecursive && (tag == 0x8769 /* ExifTag */ || tag == 0x014a/*SubIFDs*/  || type == tiffIfd) ) {\n                        for ( size_t k = 0 ; k < count ; k++ ) {\n                            size_t   restore = io.tell();\n                            uint32_t offset = byteSwap4(buf,k*size,bSwap);\n                            printIFDStructure(io,out,option,offset,bSwap,c,depth);\n                            io.seek(restore,BasicIo::beg);\n                        }\n                    } else if ( option == kpsRecursive && tag == 0x83bb /* IPTCNAA */ ) {\n                        size_t   restore = io.tell();  // save\n                        io.seek(offset,BasicIo::beg);  // position\n                        byte* bytes=new byte[count] ;  // allocate memory\n                        io.read(bytes,count)        ;  // read\n                        io.seek(restore,BasicIo::beg); // restore\n                        IptcData::printStructure(out,bytes,count,depth);\n                        delete[] bytes;                // free\n                    }  else if ( option == kpsRecursive && tag == 0x927c /* MakerNote */ && count > 10) {\n                        size_t   restore = io.tell();  // save\n\n                        uint32_t jump= 10           ;\n                        byte     bytes[20]          ;\n                        const char* chars = (const char*) &bytes[0] ;\n                        io.seek(offset,BasicIo::beg);  // position\n                        io.read(bytes,jump    )     ;  // read\n                        bytes[jump]=0               ;\n                        if ( ::strcmp(\"Nikon\",chars) == 0 ) {\n                            // tag is an embedded tiff\n                            byte* bytes=new byte[count-jump] ;  // allocate memory\n                            io.read(bytes,count-jump)        ;  // read\n                            MemIo memIo(bytes,count-jump)    ;  // create a file\n                            printTiffStructure(memIo,out,option,depth);\n                            delete[] bytes                   ;  // free\n                        } else {\n                            // tag is an IFD\n                            io.seek(0,BasicIo::beg);  // position\n                            printIFDStructure(io,out,option,offset,bSwap,c,depth);\n                        }\n\n                        io.seek(restore,BasicIo::beg); // restore\n                    }\n                }\n\n                if ( isPrintXMP(tag,option) ) {\n                    buf.pData_[count]=0;\n                    out << (char*) buf.pData_;\n                }\n                if ( isPrintICC(tag,option) ) {\n                    out.write((const char*)buf.pData_,count);\n                }\n            }\n            if ( start ) {\n                io.read(dir.pData_, 4);\n                start = tooBig ? 0 : byteSwap4(dir,0,bSwap);\n            }\n        } while (start) ;\n\n        if ( bPrint ) {\n            out << Internal::indent(depth) << \"END \" << io.path() << std::endl;\n        }\n        out.flush();\n        depth--;\n    }", "func_hash": 135908904515753765989749270271712491869, "file_name": "image.cpp", "file_hash": 158908380717507532391090050859668456498, "cwe": ["CWE-125"], "cve": "CVE-2017-17723", "cve_desc": "In Exiv2 0.26, there is a heap-based buffer over-read in the Exiv2::Image::byteSwap4 function in image.cpp. Remote attackers can exploit this vulnerability to disclose memory data or cause a denial of service via a crafted TIFF file.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-17723", "file_path": "src/image.cpp"}
{"idx": 211181, "project": "php-src", "commit_id": "a72cd07f2983dc43a6bb35209dc4687852e53c09", "project_url": "https://github.com/php/php-src", "commit_url": "http://git.php.net/?p=php-src.git;a=commit;h=a72cd07f2983dc43a6bb35209dc4687852e53c09", "commit_message": "Fixed bug #68665 (Invalid free)", "target": 1, "func": "apprentice_load(struct magic_set *ms, const char *fn, int action)\n{\n\tint errs = 0;\n\tuint32_t i, j;\n\tsize_t files = 0, maxfiles = 0;\n\tchar **filearr = NULL;\n\tstruct stat st;\n\tstruct magic_map *map;\n\tstruct magic_entry_set mset[MAGIC_SETS];\n\tphp_stream *dir;\n\tphp_stream_dirent d;\n \n\tTSRMLS_FETCH();\n\n\tmemset(mset, 0, sizeof(mset));\n\tms->flags |= MAGIC_CHECK;\t/* Enable checks for parsed files */\n\n\n\tif ((map = CAST(struct magic_map *, ecalloc(1, sizeof(*map)))) == NULL)\n\t{\n\t\tfile_oomem(ms, sizeof(*map));\n\t\treturn NULL;\n\t}\n\n\t/* print silly verbose header for USG compat. */\n\tif (action == FILE_CHECK)\n\t\t(void)fprintf(stderr, \"%s\\n\", usg_hdr);\n\n\t/* load directory or file */\n\t/* FIXME: Read file names and sort them to prevent\n\t   non-determinism. See Debian bug #488562. */\n\tif (php_sys_stat(fn, &st) == 0 && S_ISDIR(st.st_mode)) {\n\t\tint mflen;\n\t\tchar mfn[MAXPATHLEN];\n\n\t\tdir = php_stream_opendir((char *)fn, REPORT_ERRORS, NULL);\n\t\tif (!dir) {\n\t\t\terrs++;\n\t\t\tgoto out;\n\t\t}\n\t\twhile (php_stream_readdir(dir, &d)) {\n\t\t\tif ((mflen = snprintf(mfn, sizeof(mfn), \"%s/%s\", fn, d.d_name)) < 0) {\n\t\t\t\tfile_oomem(ms,\n\t\t\t\tstrlen(fn) + strlen(d.d_name) + 2);\n\t\t\t\terrs++;\n\t\t\t\tphp_stream_closedir(dir);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (stat(mfn, &st) == -1 || !S_ISREG(st.st_mode)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (files >= maxfiles) {\n\t\t\t\tsize_t mlen;\n\t\t\t\tmaxfiles = (maxfiles + 1) * 2;\n\t\t\t\tmlen = maxfiles * sizeof(*filearr);\n\t\t\t\tif ((filearr = CAST(char **,\n\t\t\t\t    erealloc(filearr, mlen))) == NULL) {\n\t\t\t\t\tfile_oomem(ms, mlen);\n\t\t\t\t\tefree(mfn);\n\t\t\t\t\tphp_stream_closedir(dir);\n\t\t\t\t\terrs++;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfilearr[files++] = estrndup(mfn, (mflen > sizeof(mfn) - 1)? sizeof(mfn) - 1: mflen);\n\t\t}\n\t\tphp_stream_closedir(dir);\n\t\tqsort(filearr, files, sizeof(*filearr), cmpstrp);\n\t\tfor (i = 0; i < files; i++) {\n\t\t\tload_1(ms, action, filearr[i], &errs, mset);\n\t\t\tefree(filearr[i]);\n\t\t}\n\t\tefree(filearr);\n\t} else\n\t\tload_1(ms, action, fn, &errs, mset);\n\tif (errs)\n\t\tgoto out;\n\n\tfor (j = 0; j < MAGIC_SETS; j++) {\n\t\t/* Set types of tests */\n\t\tfor (i = 0; i < mset[j].count; ) {\n\t\t\tif (mset[j].me[i].mp->cont_level != 0) {\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti = set_text_binary(ms, mset[j].me, mset[j].count, i);\n\t\t}\n\t\tqsort(mset[j].me, mset[j].count, sizeof(*mset[j].me),\n\t\t    apprentice_sort);\n\n\t\t/*\n\t\t * Make sure that any level 0 \"default\" line is last\n\t\t * (if one exists).\n\t\t */\n\t\tset_last_default(ms, mset[j].me, mset[j].count);\n\n\t\t/* coalesce per file arrays into a single one */\n\t\tif (coalesce_entries(ms, mset[j].me, mset[j].count,\n\t\t    &map->magic[j], &map->nmagic[j]) == -1) {\n\t\t\terrs++;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tfor (j = 0; j < MAGIC_SETS; j++)\n\t\tmagic_entry_free(mset[j].me, mset[j].count);\n\n\tif (errs) {\n\t\tfor (j = 0; j < MAGIC_SETS; j++) {\n\t\t\tif (map->magic[j])\n\t\t\t\tefree(map->magic[j]);\n\t\t}\n\t\tefree(map);\n\t\treturn NULL;\n\t}\n\treturn map;\n}", "func_hash": 215852170840415887446784967790257485070, "file_name": "apprentice.c", "file_hash": 136822894511518552455761565191570256868, "cwe": ["CWE-17"], "cve": "CVE-2014-9426", "cve_desc": "The apprentice_load function in libmagic/apprentice.c in the Fileinfo component in PHP through 5.6.4 attempts to perform a free operation on a stack-based character array, which allows remote attackers to cause a denial of service (memory corruption or application crash) or possibly have unspecified other impact via unknown vectors.  NOTE: this is disputed by the vendor because the standard erealloc behavior makes the free operation unreachable", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-9426", "file_path": "ext/fileinfo/libmagic/apprentice.c"}
{"idx": 447231, "project": "php-src", "commit_id": "a72cd07f2983dc43a6bb35209dc4687852e53c09", "project_url": "https://github.com/php/php-src", "commit_url": "http://git.php.net/?p=php-src.git;a=commit;h=a72cd07f2983dc43a6bb35209dc4687852e53c09", "commit_message": "Fixed bug #68665 (Invalid free)", "target": 0, "func": "apprentice_load(struct magic_set *ms, const char *fn, int action)\n{\n\tint errs = 0;\n\tuint32_t i, j;\n\tsize_t files = 0, maxfiles = 0;\n\tchar **filearr = NULL;\n\tstruct stat st;\n\tstruct magic_map *map;\n\tstruct magic_entry_set mset[MAGIC_SETS];\n\tphp_stream *dir;\n\tphp_stream_dirent d;\n \n\tTSRMLS_FETCH();\n\n\tmemset(mset, 0, sizeof(mset));\n\tms->flags |= MAGIC_CHECK;\t/* Enable checks for parsed files */\n\n\n\tif ((map = CAST(struct magic_map *, ecalloc(1, sizeof(*map)))) == NULL)\n\t{\n\t\tfile_oomem(ms, sizeof(*map));\n\t\treturn NULL;\n\t}\n\n\t/* print silly verbose header for USG compat. */\n\tif (action == FILE_CHECK)\n\t\t(void)fprintf(stderr, \"%s\\n\", usg_hdr);\n\n\t/* load directory or file */\n\t/* FIXME: Read file names and sort them to prevent\n\t   non-determinism. See Debian bug #488562. */\n\tif (php_sys_stat(fn, &st) == 0 && S_ISDIR(st.st_mode)) {\n\t\tint mflen;\n\t\tchar mfn[MAXPATHLEN];\n\n\t\tdir = php_stream_opendir((char *)fn, REPORT_ERRORS, NULL);\n\t\tif (!dir) {\n\t\t\terrs++;\n\t\t\tgoto out;\n\t\t}\n\t\twhile (php_stream_readdir(dir, &d)) {\n\t\t\tif ((mflen = snprintf(mfn, sizeof(mfn), \"%s/%s\", fn, d.d_name)) < 0) {\n\t\t\t\tfile_oomem(ms,\n\t\t\t\tstrlen(fn) + strlen(d.d_name) + 2);\n\t\t\t\terrs++;\n\t\t\t\tphp_stream_closedir(dir);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (stat(mfn, &st) == -1 || !S_ISREG(st.st_mode)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (files >= maxfiles) {\n\t\t\t\tsize_t mlen;\n\t\t\t\tmaxfiles = (maxfiles + 1) * 2;\n\t\t\t\tmlen = maxfiles * sizeof(*filearr);\n\t\t\t\tif ((filearr = CAST(char **,\n\t\t\t\t    erealloc(filearr, mlen))) == NULL) {\n\t\t\t\t\tfile_oomem(ms, mlen);\n\t\t\t\t\tphp_stream_closedir(dir);\n\t\t\t\t\terrs++;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfilearr[files++] = estrndup(mfn, (mflen > sizeof(mfn) - 1)? sizeof(mfn) - 1: mflen);\n\t\t}\n\t\tphp_stream_closedir(dir);\n\t\tqsort(filearr, files, sizeof(*filearr), cmpstrp);\n\t\tfor (i = 0; i < files; i++) {\n\t\t\tload_1(ms, action, filearr[i], &errs, mset);\n\t\t\tefree(filearr[i]);\n\t\t}\n\t\tefree(filearr);\n\t} else\n\t\tload_1(ms, action, fn, &errs, mset);\n\tif (errs)\n\t\tgoto out;\n\n\tfor (j = 0; j < MAGIC_SETS; j++) {\n\t\t/* Set types of tests */\n\t\tfor (i = 0; i < mset[j].count; ) {\n\t\t\tif (mset[j].me[i].mp->cont_level != 0) {\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti = set_text_binary(ms, mset[j].me, mset[j].count, i);\n\t\t}\n\t\tqsort(mset[j].me, mset[j].count, sizeof(*mset[j].me),\n\t\t    apprentice_sort);\n\n\t\t/*\n\t\t * Make sure that any level 0 \"default\" line is last\n\t\t * (if one exists).\n\t\t */\n\t\tset_last_default(ms, mset[j].me, mset[j].count);\n\n\t\t/* coalesce per file arrays into a single one */\n\t\tif (coalesce_entries(ms, mset[j].me, mset[j].count,\n\t\t    &map->magic[j], &map->nmagic[j]) == -1) {\n\t\t\terrs++;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tfor (j = 0; j < MAGIC_SETS; j++)\n\t\tmagic_entry_free(mset[j].me, mset[j].count);\n\n\tif (errs) {\n\t\tfor (j = 0; j < MAGIC_SETS; j++) {\n\t\t\tif (map->magic[j])\n\t\t\t\tefree(map->magic[j]);\n\t\t}\n\t\tefree(map);\n\t\treturn NULL;\n\t}\n\treturn map;\n}", "func_hash": 156454401926797998343757810189411499663, "file_name": "apprentice.c", "file_hash": 133128407981065524680771127461274572868, "cwe": ["CWE-17"], "cve": "CVE-2014-9426", "cve_desc": "The apprentice_load function in libmagic/apprentice.c in the Fileinfo component in PHP through 5.6.4 attempts to perform a free operation on a stack-based character array, which allows remote attackers to cause a denial of service (memory corruption or application crash) or possibly have unspecified other impact via unknown vectors.  NOTE: this is disputed by the vendor because the standard erealloc behavior makes the free operation unreachable", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-9426", "file_path": "ext/fileinfo/libmagic/apprentice.c"}
{"idx": 211471, "project": "frr", "commit_id": "ff6db1027f8f36df657ff2e5ea167773752537ed", "project_url": "https://github.com/FRRouting/frr", "commit_url": "https://github.com/FRRouting/frr/commit/ff6db1027f8f36df657ff2e5ea167773752537ed", "commit_message": "bgpd: Make sure hdr length is at a minimum of what is expected\n\nEnsure that if the capability length specified is enough data.\n\nSigned-off-by: Donald Sharp <sharpd@nvidia.com>", "target": 1, "func": "static int bgp_capability_msg_parse(struct peer *peer, uint8_t *pnt,\n\t\t\t\t    bgp_size_t length)\n{\n\tuint8_t *end;\n\tstruct capability_mp_data mpc;\n\tstruct capability_header *hdr;\n\tuint8_t action;\n\tiana_afi_t pkt_afi;\n\tafi_t afi;\n\tiana_safi_t pkt_safi;\n\tsafi_t safi;\n\n\tend = pnt + length;\n\n\twhile (pnt < end) {\n\t\t/* We need at least action, capability code and capability\n\t\t * length. */\n\t\tif (pnt + 3 > end) {\n\t\t\tzlog_info(\"%s Capability length error\", peer->host);\n\t\t\tbgp_notify_send(peer, BGP_NOTIFY_CEASE,\n\t\t\t\t\tBGP_NOTIFY_SUBCODE_UNSPECIFIC);\n\t\t\treturn BGP_Stop;\n\t\t}\n\t\taction = *pnt;\n\t\thdr = (struct capability_header *)(pnt + 1);\n\n\t\t/* Action value check.  */\n\t\tif (action != CAPABILITY_ACTION_SET\n\t\t    && action != CAPABILITY_ACTION_UNSET) {\n\t\t\tzlog_info(\"%s Capability Action Value error %d\",\n\t\t\t\t  peer->host, action);\n\t\t\tbgp_notify_send(peer, BGP_NOTIFY_CEASE,\n\t\t\t\t\tBGP_NOTIFY_SUBCODE_UNSPECIFIC);\n\t\t\treturn BGP_Stop;\n\t\t}\n\n\t\tif (bgp_debug_neighbor_events(peer))\n\t\t\tzlog_debug(\n\t\t\t\t\"%s CAPABILITY has action: %d, code: %u, length %u\",\n\t\t\t\tpeer->host, action, hdr->code, hdr->length);\n\n\t\t/* Capability length check. */\n\t\tif ((pnt + hdr->length + 3) > end) {\n\t\t\tzlog_info(\"%s Capability length error\", peer->host);\n\t\t\tbgp_notify_send(peer, BGP_NOTIFY_CEASE,\n\t\t\t\t\tBGP_NOTIFY_SUBCODE_UNSPECIFIC);\n\t\t\treturn BGP_Stop;\n\t\t}\n\n\t\t/* Fetch structure to the byte stream. */\n\t\tmemcpy(&mpc, pnt + 3, sizeof(struct capability_mp_data));\n\t\tpnt += hdr->length + 3;\n\n\t\t/* We know MP Capability Code. */\n\t\tif (hdr->code == CAPABILITY_CODE_MP) {\n\t\t\tpkt_afi = ntohs(mpc.afi);\n\t\t\tpkt_safi = mpc.safi;\n\n\t\t\t/* Ignore capability when override-capability is set. */\n\t\t\tif (CHECK_FLAG(peer->flags,\n\t\t\t\t       PEER_FLAG_OVERRIDE_CAPABILITY))\n\t\t\t\tcontinue;\n\n\t\t\t/* Convert AFI, SAFI to internal values. */\n\t\t\tif (bgp_map_afi_safi_iana2int(pkt_afi, pkt_safi, &afi,\n\t\t\t\t\t\t      &safi)) {\n\t\t\t\tif (bgp_debug_neighbor_events(peer))\n\t\t\t\t\tzlog_debug(\n\t\t\t\t\t\t\"%s Dynamic Capability MP_EXT afi/safi invalid (%s/%s)\",\n\t\t\t\t\t\tpeer->host,\n\t\t\t\t\t\tiana_afi2str(pkt_afi),\n\t\t\t\t\t\tiana_safi2str(pkt_safi));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Address family check.  */\n\t\t\tif (bgp_debug_neighbor_events(peer))\n\t\t\t\tzlog_debug(\n\t\t\t\t\t\"%s CAPABILITY has %s MP_EXT CAP for afi/safi: %s/%s\",\n\t\t\t\t\tpeer->host,\n\t\t\t\t\taction == CAPABILITY_ACTION_SET\n\t\t\t\t\t\t? \"Advertising\"\n\t\t\t\t\t\t: \"Removing\",\n\t\t\t\t\tiana_afi2str(pkt_afi),\n\t\t\t\t\tiana_safi2str(pkt_safi));\n\n\t\t\tif (action == CAPABILITY_ACTION_SET) {\n\t\t\t\tpeer->afc_recv[afi][safi] = 1;\n\t\t\t\tif (peer->afc[afi][safi]) {\n\t\t\t\t\tpeer->afc_nego[afi][safi] = 1;\n\t\t\t\t\tbgp_announce_route(peer, afi, safi,\n\t\t\t\t\t\t\t   false);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpeer->afc_recv[afi][safi] = 0;\n\t\t\t\tpeer->afc_nego[afi][safi] = 0;\n\n\t\t\t\tif (peer_active_nego(peer))\n\t\t\t\t\tbgp_clear_route(peer, afi, safi);\n\t\t\t\telse\n\t\t\t\t\treturn BGP_Stop;\n\t\t\t}\n\t\t} else {\n\t\t\tflog_warn(\n\t\t\t\tEC_BGP_UNRECOGNIZED_CAPABILITY,\n\t\t\t\t\"%s unrecognized capability code: %d - ignored\",\n\t\t\t\tpeer->host, hdr->code);\n\t\t}\n\t}\n\n\t/* No FSM action necessary */\n\treturn BGP_PACKET_NOOP;\n}", "func_hash": 113418745382629462505950696530283807291, "file_name": "bgp_packet.c", "file_hash": 315108406753805109859360755691559827205, "cwe": ["CWE-125"], "cve": "CVE-2022-37032", "cve_desc": "An out-of-bounds read in the BGP daemon of FRRouting FRR before 8.4 may lead to a segmentation fault and denial of service. This occurs in bgp_capability_msg_parse in bgpd/bgp_packet.c.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-37032", "file_path": "bgpd/bgp_packet.c"}
{"idx": 448562, "project": "frr", "commit_id": "ff6db1027f8f36df657ff2e5ea167773752537ed", "project_url": "https://github.com/FRRouting/frr", "commit_url": "https://github.com/FRRouting/frr/commit/ff6db1027f8f36df657ff2e5ea167773752537ed", "commit_message": "bgpd: Make sure hdr length is at a minimum of what is expected\n\nEnsure that if the capability length specified is enough data.\n\nSigned-off-by: Donald Sharp <sharpd@nvidia.com>", "target": 0, "func": "static int bgp_capability_msg_parse(struct peer *peer, uint8_t *pnt,\n\t\t\t\t    bgp_size_t length)\n{\n\tuint8_t *end;\n\tstruct capability_mp_data mpc;\n\tstruct capability_header *hdr;\n\tuint8_t action;\n\tiana_afi_t pkt_afi;\n\tafi_t afi;\n\tiana_safi_t pkt_safi;\n\tsafi_t safi;\n\n\tend = pnt + length;\n\n\twhile (pnt < end) {\n\t\t/* We need at least action, capability code and capability\n\t\t * length. */\n\t\tif (pnt + 3 > end) {\n\t\t\tzlog_info(\"%s Capability length error\", peer->host);\n\t\t\tbgp_notify_send(peer, BGP_NOTIFY_CEASE,\n\t\t\t\t\tBGP_NOTIFY_SUBCODE_UNSPECIFIC);\n\t\t\treturn BGP_Stop;\n\t\t}\n\t\taction = *pnt;\n\t\thdr = (struct capability_header *)(pnt + 1);\n\n\t\t/* Action value check.  */\n\t\tif (action != CAPABILITY_ACTION_SET\n\t\t    && action != CAPABILITY_ACTION_UNSET) {\n\t\t\tzlog_info(\"%s Capability Action Value error %d\",\n\t\t\t\t  peer->host, action);\n\t\t\tbgp_notify_send(peer, BGP_NOTIFY_CEASE,\n\t\t\t\t\tBGP_NOTIFY_SUBCODE_UNSPECIFIC);\n\t\t\treturn BGP_Stop;\n\t\t}\n\n\t\tif (bgp_debug_neighbor_events(peer))\n\t\t\tzlog_debug(\n\t\t\t\t\"%s CAPABILITY has action: %d, code: %u, length %u\",\n\t\t\t\tpeer->host, action, hdr->code, hdr->length);\n\n\t\tif (hdr->length < sizeof(struct capability_mp_data)) {\n\t\t\tzlog_info(\n\t\t\t\t\"%pBP Capability structure is not properly filled out, expected at least %zu bytes but header length specified is %d\",\n\t\t\t\tpeer, sizeof(struct capability_mp_data),\n\t\t\t\thdr->length);\n\t\t\treturn BGP_Stop;\n\t\t}\n\n\t\t/* Capability length check. */\n\t\tif ((pnt + hdr->length + 3) > end) {\n\t\t\tzlog_info(\"%s Capability length error\", peer->host);\n\t\t\tbgp_notify_send(peer, BGP_NOTIFY_CEASE,\n\t\t\t\t\tBGP_NOTIFY_SUBCODE_UNSPECIFIC);\n\t\t\treturn BGP_Stop;\n\t\t}\n\n\t\t/* Fetch structure to the byte stream. */\n\t\tmemcpy(&mpc, pnt + 3, sizeof(struct capability_mp_data));\n\t\tpnt += hdr->length + 3;\n\n\t\t/* We know MP Capability Code. */\n\t\tif (hdr->code == CAPABILITY_CODE_MP) {\n\t\t\tpkt_afi = ntohs(mpc.afi);\n\t\t\tpkt_safi = mpc.safi;\n\n\t\t\t/* Ignore capability when override-capability is set. */\n\t\t\tif (CHECK_FLAG(peer->flags,\n\t\t\t\t       PEER_FLAG_OVERRIDE_CAPABILITY))\n\t\t\t\tcontinue;\n\n\t\t\t/* Convert AFI, SAFI to internal values. */\n\t\t\tif (bgp_map_afi_safi_iana2int(pkt_afi, pkt_safi, &afi,\n\t\t\t\t\t\t      &safi)) {\n\t\t\t\tif (bgp_debug_neighbor_events(peer))\n\t\t\t\t\tzlog_debug(\n\t\t\t\t\t\t\"%s Dynamic Capability MP_EXT afi/safi invalid (%s/%s)\",\n\t\t\t\t\t\tpeer->host,\n\t\t\t\t\t\tiana_afi2str(pkt_afi),\n\t\t\t\t\t\tiana_safi2str(pkt_safi));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Address family check.  */\n\t\t\tif (bgp_debug_neighbor_events(peer))\n\t\t\t\tzlog_debug(\n\t\t\t\t\t\"%s CAPABILITY has %s MP_EXT CAP for afi/safi: %s/%s\",\n\t\t\t\t\tpeer->host,\n\t\t\t\t\taction == CAPABILITY_ACTION_SET\n\t\t\t\t\t\t? \"Advertising\"\n\t\t\t\t\t\t: \"Removing\",\n\t\t\t\t\tiana_afi2str(pkt_afi),\n\t\t\t\t\tiana_safi2str(pkt_safi));\n\n\t\t\tif (action == CAPABILITY_ACTION_SET) {\n\t\t\t\tpeer->afc_recv[afi][safi] = 1;\n\t\t\t\tif (peer->afc[afi][safi]) {\n\t\t\t\t\tpeer->afc_nego[afi][safi] = 1;\n\t\t\t\t\tbgp_announce_route(peer, afi, safi,\n\t\t\t\t\t\t\t   false);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpeer->afc_recv[afi][safi] = 0;\n\t\t\t\tpeer->afc_nego[afi][safi] = 0;\n\n\t\t\t\tif (peer_active_nego(peer))\n\t\t\t\t\tbgp_clear_route(peer, afi, safi);\n\t\t\t\telse\n\t\t\t\t\treturn BGP_Stop;\n\t\t\t}\n\t\t} else {\n\t\t\tflog_warn(\n\t\t\t\tEC_BGP_UNRECOGNIZED_CAPABILITY,\n\t\t\t\t\"%s unrecognized capability code: %d - ignored\",\n\t\t\t\tpeer->host, hdr->code);\n\t\t}\n\t}\n\n\t/* No FSM action necessary */\n\treturn BGP_PACKET_NOOP;\n}", "func_hash": 234942557373387642090168685106076449546, "file_name": "bgp_packet.c", "file_hash": 265694254173833717279647335030884275361, "cwe": ["CWE-125"], "cve": "CVE-2022-37032", "cve_desc": "An out-of-bounds read in the BGP daemon of FRRouting FRR before 8.4 may lead to a segmentation fault and denial of service. This occurs in bgp_capability_msg_parse in bgpd/bgp_packet.c.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-37032", "file_path": "bgpd/bgp_packet.c"}
{"idx": 211473, "project": "gdk-pixbuf", "commit_id": "4f0f465f991cd454d03189497f923eb40c170c22", "project_url": "http://git.gnome.org/browse/gdk-pixbuf", "commit_url": "http://git.gnome.org/browse/gdk-pixbuf/commit/?id=4f0f465f991cd454d03189497f923eb40c170c22", "commit_message": "Avoid an integer overflow in the xbm loader\n\nAt the same time, reject some silly input, such as negative\nwidth or height.\n\nhttps://bugzilla.gnome.org/show_bug.cgi?id=672811", "target": 1, "func": "read_bitmap_file_data (FILE    *fstream,\n\t\t       guint   *width, \n\t\t       guint   *height,\n\t\t       guchar **data,\n\t\t       int     *x_hot, \n\t\t       int     *y_hot)\n{\n\tguchar *bits = NULL;\t\t/* working variable */\n\tchar line[MAX_SIZE];\t\t/* input line from file */\n\tint size;\t\t\t/* number of bytes of data */\n\tchar name_and_type[MAX_SIZE];\t/* an input line */\n\tchar *type;\t\t\t/* for parsing */\n\tint value;\t\t\t/* from an input line */\n\tint version10p;\t\t\t/* boolean, old format */\n\tint padding;\t\t\t/* to handle alignment */\n\tint bytes_per_line;\t\t/* per scanline of data */\n\tguint ww = 0;\t\t\t/* width */\n\tguint hh = 0;\t\t\t/* height */\n\tint hx = -1;\t\t\t/* x hotspot */\n\tint hy = -1;\t\t\t/* y hotspot */\n\n\t/* first time initialization */\n\tif (!initialized) {\n\t\tinit_hex_table ();\n\t}\n\n\t/* error cleanup and return macro */\n#define\tRETURN(code) { g_free (bits); return code; }\n\n\twhile (fgets (line, MAX_SIZE, fstream)) {\n\t\tif (strlen (line) == MAX_SIZE-1)\n\t\t\tRETURN (FALSE);\n\t\tif (sscanf (line,\"#define %s %d\",name_and_type,&value) == 2) {\n\t\t\tif (!(type = strrchr (name_and_type, '_')))\n\t\t\t\ttype = name_and_type;\n\t\t\telse {\n\t\t\t\ttype++;\n\t\t\t}\n\n\t\t\tif (!strcmp (\"width\", type))\n\t\t\t\tww = (unsigned int) value;\n\t\t\tif (!strcmp (\"height\", type))\n\t\t\t\thh = (unsigned int) value;\n\t\t\tif (!strcmp (\"hot\", type)) {\n\t\t\t\tif (type-- == name_and_type\n\t\t\t\t    || type-- == name_and_type)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (!strcmp (\"x_hot\", type))\n\t\t\t\t\thx = value;\n\t\t\t\tif (!strcmp (\"y_hot\", type))\n\t\t\t\t\thy = value;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n    \n\t\tif (sscanf (line, \"static short %s = {\", name_and_type) == 1)\n\t\t\tversion10p = 1;\n\t\telse if (sscanf (line,\"static const unsigned char %s = {\",name_and_type) == 1)\n\t\t\tversion10p = 0;\n\t\telse if (sscanf (line,\"static unsigned char %s = {\",name_and_type) == 1)\n\t\t\tversion10p = 0;\n\t\telse if (sscanf (line, \"static const char %s = {\", name_and_type) == 1)\n\t\t\tversion10p = 0;\n\t\telse if (sscanf (line, \"static char %s = {\", name_and_type) == 1)\n\t\t\tversion10p = 0;\n\t\telse\n\t\t\tcontinue;\n\n\t\tif (!(type = strrchr (name_and_type, '_')))\n\t\t\ttype = name_and_type;\n\t\telse\n\t\t\ttype++;\n\n\t\tif (strcmp (\"bits[]\", type))\n\t\t\tcontinue;\n    \n\t\tif (!ww || !hh)\n\t\t\tRETURN (FALSE);\n\n\t\tif ((ww % 16) && ((ww % 16) < 9) && version10p)\n\t\t\tpadding = 1;\n\t\telse\n\t\t\tpadding = 0;\n\n\t\tbytes_per_line = (ww+7)/8 + padding;\n\n\t\tsize = bytes_per_line * hh;\n\t\tbits = g_malloc (size);\n\n\t\tif (version10p) {\n\t\t\tunsigned char *ptr;\n\t\t\tint bytes;\n\n\t\t\tfor (bytes = 0, ptr = bits; bytes < size; (bytes += 2)) {\n\t\t\t\tif ((value = next_int (fstream)) < 0)\n\t\t\t\t\tRETURN (FALSE);\n\t\t\t\t*(ptr++) = value;\n\t\t\t\tif (!padding || ((bytes+2) % bytes_per_line))\n\t\t\t\t\t*(ptr++) = value >> 8;\n\t\t\t}\n\t\t} else {\n\t\t\tunsigned char *ptr;\n\t\t\tint bytes;\n\n\t\t\tfor (bytes = 0, ptr = bits; bytes < size; bytes++, ptr++) {\n\t\t\t\tif ((value = next_int (fstream)) < 0) \n\t\t\t\t\tRETURN (FALSE);\n\t\t\t\t*ptr=value;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (!bits)\n\t\tRETURN (FALSE);\n\n\t*data = bits;\n\t*width = ww;\n\t*height = hh;\n\tif (x_hot)\n\t\t*x_hot = hx;\n\tif (y_hot)\n\t\t*y_hot = hy;\n\n\treturn TRUE;\n}", "func_hash": 243317071642584588963963288402776213734, "file_name": "io-xbm.c", "file_hash": 331454281510719411806234723168878735596, "cwe": ["CWE-189"], "cve": "CVE-2012-2370", "cve_desc": "Multiple integer overflows in the read_bitmap_file_data function in io-xbm.c in gdk-pixbuf before 2.26.1 allow remote attackers to cause a denial of service (application crash) via a negative (1) height or (2) width in an XBM file, which triggers a heap-based buffer overflow.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-2370", "file_path": "gdk-pixbuf/io-xbm.c"}
{"idx": 448584, "project": "gdk-pixbuf", "commit_id": "4f0f465f991cd454d03189497f923eb40c170c22", "project_url": "http://git.gnome.org/browse/gdk-pixbuf", "commit_url": "http://git.gnome.org/browse/gdk-pixbuf/commit/?id=4f0f465f991cd454d03189497f923eb40c170c22", "commit_message": "Avoid an integer overflow in the xbm loader\n\nAt the same time, reject some silly input, such as negative\nwidth or height.\n\nhttps://bugzilla.gnome.org/show_bug.cgi?id=672811", "target": 0, "func": "read_bitmap_file_data (FILE    *fstream,\n\t\t       guint   *width, \n\t\t       guint   *height,\n\t\t       guchar **data,\n\t\t       int     *x_hot, \n\t\t       int     *y_hot)\n{\n\tguchar *bits = NULL;\t\t/* working variable */\n\tchar line[MAX_SIZE];\t\t/* input line from file */\n\tint size;\t\t\t/* number of bytes of data */\n\tchar name_and_type[MAX_SIZE];\t/* an input line */\n\tchar *type;\t\t\t/* for parsing */\n\tint value;\t\t\t/* from an input line */\n\tint version10p;\t\t\t/* boolean, old format */\n\tint padding;\t\t\t/* to handle alignment */\n\tint bytes_per_line;\t\t/* per scanline of data */\n\tguint ww = 0;\t\t\t/* width */\n\tguint hh = 0;\t\t\t/* height */\n\tint hx = -1;\t\t\t/* x hotspot */\n\tint hy = -1;\t\t\t/* y hotspot */\n\n\t/* first time initialization */\n\tif (!initialized) {\n\t\tinit_hex_table ();\n\t}\n\n\t/* error cleanup and return macro */\n#define\tRETURN(code) { g_free (bits); return code; }\n\n\twhile (fgets (line, MAX_SIZE, fstream)) {\n\t\tif (strlen (line) == MAX_SIZE-1)\n\t\t\tRETURN (FALSE);\n\t\tif (sscanf (line,\"#define %s %d\",name_and_type,&value) == 2) {\n\t\t\tif (!(type = strrchr (name_and_type, '_')))\n\t\t\t\ttype = name_and_type;\n\t\t\telse {\n\t\t\t\ttype++;\n\t\t\t}\n\n\t\t\tif (!strcmp (\"width\", type)) {\n                                if (value <= 0)\n                                        RETURN (FALSE);\n\t\t\t\tww = (unsigned int) value;\n                        }\n\t\t\tif (!strcmp (\"height\", type)) {\n                                if (value <= 0)\n                                        RETURN (FALSE);\n\t\t\t\thh = (unsigned int) value;\n                        }\n\t\t\tif (!strcmp (\"hot\", type)) {\n\t\t\t\tif (type-- == name_and_type\n\t\t\t\t    || type-- == name_and_type)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (!strcmp (\"x_hot\", type))\n\t\t\t\t\thx = value;\n\t\t\t\tif (!strcmp (\"y_hot\", type))\n\t\t\t\t\thy = value;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n    \n\t\tif (sscanf (line, \"static short %s = {\", name_and_type) == 1)\n\t\t\tversion10p = 1;\n\t\telse if (sscanf (line,\"static const unsigned char %s = {\",name_and_type) == 1)\n\t\t\tversion10p = 0;\n\t\telse if (sscanf (line,\"static unsigned char %s = {\",name_and_type) == 1)\n\t\t\tversion10p = 0;\n\t\telse if (sscanf (line, \"static const char %s = {\", name_and_type) == 1)\n\t\t\tversion10p = 0;\n\t\telse if (sscanf (line, \"static char %s = {\", name_and_type) == 1)\n\t\t\tversion10p = 0;\n\t\telse\n\t\t\tcontinue;\n\n\t\tif (!(type = strrchr (name_and_type, '_')))\n\t\t\ttype = name_and_type;\n\t\telse\n\t\t\ttype++;\n\n\t\tif (strcmp (\"bits[]\", type))\n\t\t\tcontinue;\n    \n\t\tif (!ww || !hh)\n\t\t\tRETURN (FALSE);\n\n\t\tif ((ww % 16) && ((ww % 16) < 9) && version10p)\n\t\t\tpadding = 1;\n\t\telse\n\t\t\tpadding = 0;\n\n\t\tbytes_per_line = (ww+7)/8 + padding;\n\n\t\tsize = bytes_per_line * hh;\n                if (size / bytes_per_line != hh) /* overflow */\n                        RETURN (FALSE);\n\t\tbits = g_malloc (size);\n\n\t\tif (version10p) {\n\t\t\tunsigned char *ptr;\n\t\t\tint bytes;\n\n\t\t\tfor (bytes = 0, ptr = bits; bytes < size; (bytes += 2)) {\n\t\t\t\tif ((value = next_int (fstream)) < 0)\n\t\t\t\t\tRETURN (FALSE);\n\t\t\t\t*(ptr++) = value;\n\t\t\t\tif (!padding || ((bytes+2) % bytes_per_line))\n\t\t\t\t\t*(ptr++) = value >> 8;\n\t\t\t}\n\t\t} else {\n\t\t\tunsigned char *ptr;\n\t\t\tint bytes;\n\n\t\t\tfor (bytes = 0, ptr = bits; bytes < size; bytes++, ptr++) {\n\t\t\t\tif ((value = next_int (fstream)) < 0) \n\t\t\t\t\tRETURN (FALSE);\n\t\t\t\t*ptr=value;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (!bits)\n\t\tRETURN (FALSE);\n\n\t*data = bits;\n\t*width = ww;\n\t*height = hh;\n\tif (x_hot)\n\t\t*x_hot = hx;\n\tif (y_hot)\n\t\t*y_hot = hy;\n\n\treturn TRUE;\n}", "func_hash": 77339480051751804955061545708983319434, "file_name": "io-xbm.c", "file_hash": 72320400164573844701740100175045869458, "cwe": ["CWE-189"], "cve": "CVE-2012-2370", "cve_desc": "Multiple integer overflows in the read_bitmap_file_data function in io-xbm.c in gdk-pixbuf before 2.26.1 allow remote attackers to cause a denial of service (application crash) via a negative (1) height or (2) width in an XBM file, which triggers a heap-based buffer overflow.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-2370", "file_path": "gdk-pixbuf/io-xbm.c"}
{"idx": 211506, "project": "zlib", "commit_id": "eff308af425b67093bab25f80f1ae950166bece1", "project_url": "https://github.com/madler/zlib", "commit_url": "https://github.com/madler/zlib/commit/eff308af425b67093bab25f80f1ae950166bece1", "commit_message": "Fix a bug when getting a gzip header extra field with inflate().\n\nIf the extra field was larger than the space the user provided with\ninflateGetHeader(), and if multiple calls of inflate() delivered\nthe extra header data, then there could be a buffer overflow of the\nprovided space. This commit assures that provided space is not\nexceeded.", "target": 1, "func": "int ZEXPORT inflate(strm, flush)\nz_streamp strm;\nint flush;\n{\n    struct inflate_state FAR *state;\n    z_const unsigned char FAR *next;    /* next input */\n    unsigned char FAR *put;     /* next output */\n    unsigned have, left;        /* available input and output */\n    unsigned long hold;         /* bit buffer */\n    unsigned bits;              /* bits in bit buffer */\n    unsigned in, out;           /* save starting available input and output */\n    unsigned copy;              /* number of stored or match bytes to copy */\n    unsigned char FAR *from;    /* where to copy match bytes from */\n    code here;                  /* current decoding table entry */\n    code last;                  /* parent table entry */\n    unsigned len;               /* length to copy for repeats, bits to drop */\n    int ret;                    /* return code */\n#ifdef GUNZIP\n    unsigned char hbuf[4];      /* buffer for gzip header crc calculation */\n#endif\n    static const unsigned short order[19] = /* permutation of code lengths */\n        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};\n\n    if (inflateStateCheck(strm) || strm->next_out == Z_NULL ||\n        (strm->next_in == Z_NULL && strm->avail_in != 0))\n        return Z_STREAM_ERROR;\n\n    state = (struct inflate_state FAR *)strm->state;\n    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */\n    LOAD();\n    in = have;\n    out = left;\n    ret = Z_OK;\n    for (;;)\n        switch (state->mode) {\n        case HEAD:\n            if (state->wrap == 0) {\n                state->mode = TYPEDO;\n                break;\n            }\n            NEEDBITS(16);\n#ifdef GUNZIP\n            if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */\n                if (state->wbits == 0)\n                    state->wbits = 15;\n                state->check = crc32(0L, Z_NULL, 0);\n                CRC2(state->check, hold);\n                INITBITS();\n                state->mode = FLAGS;\n                break;\n            }\n            if (state->head != Z_NULL)\n                state->head->done = -1;\n            if (!(state->wrap & 1) ||   /* check if zlib header allowed */\n#else\n            if (\n#endif\n                ((BITS(8) << 8) + (hold >> 8)) % 31) {\n                strm->msg = (char *)\"incorrect header check\";\n                state->mode = BAD;\n                break;\n            }\n            if (BITS(4) != Z_DEFLATED) {\n                strm->msg = (char *)\"unknown compression method\";\n                state->mode = BAD;\n                break;\n            }\n            DROPBITS(4);\n            len = BITS(4) + 8;\n            if (state->wbits == 0)\n                state->wbits = len;\n            if (len > 15 || len > state->wbits) {\n                strm->msg = (char *)\"invalid window size\";\n                state->mode = BAD;\n                break;\n            }\n            state->dmax = 1U << len;\n            state->flags = 0;               /* indicate zlib header */\n            Tracev((stderr, \"inflate:   zlib header ok\\n\"));\n            strm->adler = state->check = adler32(0L, Z_NULL, 0);\n            state->mode = hold & 0x200 ? DICTID : TYPE;\n            INITBITS();\n            break;\n#ifdef GUNZIP\n        case FLAGS:\n            NEEDBITS(16);\n            state->flags = (int)(hold);\n            if ((state->flags & 0xff) != Z_DEFLATED) {\n                strm->msg = (char *)\"unknown compression method\";\n                state->mode = BAD;\n                break;\n            }\n            if (state->flags & 0xe000) {\n                strm->msg = (char *)\"unknown header flags set\";\n                state->mode = BAD;\n                break;\n            }\n            if (state->head != Z_NULL)\n                state->head->text = (int)((hold >> 8) & 1);\n            if ((state->flags & 0x0200) && (state->wrap & 4))\n                CRC2(state->check, hold);\n            INITBITS();\n            state->mode = TIME;\n                /* fallthrough */\n        case TIME:\n            NEEDBITS(32);\n            if (state->head != Z_NULL)\n                state->head->time = hold;\n            if ((state->flags & 0x0200) && (state->wrap & 4))\n                CRC4(state->check, hold);\n            INITBITS();\n            state->mode = OS;\n                /* fallthrough */\n        case OS:\n            NEEDBITS(16);\n            if (state->head != Z_NULL) {\n                state->head->xflags = (int)(hold & 0xff);\n                state->head->os = (int)(hold >> 8);\n            }\n            if ((state->flags & 0x0200) && (state->wrap & 4))\n                CRC2(state->check, hold);\n            INITBITS();\n            state->mode = EXLEN;\n                /* fallthrough */\n        case EXLEN:\n            if (state->flags & 0x0400) {\n                NEEDBITS(16);\n                state->length = (unsigned)(hold);\n                if (state->head != Z_NULL)\n                    state->head->extra_len = (unsigned)hold;\n                if ((state->flags & 0x0200) && (state->wrap & 4))\n                    CRC2(state->check, hold);\n                INITBITS();\n            }\n            else if (state->head != Z_NULL)\n                state->head->extra = Z_NULL;\n            state->mode = EXTRA;\n                /* fallthrough */\n        case EXTRA:\n            if (state->flags & 0x0400) {\n                copy = state->length;\n                if (copy > have) copy = have;\n                if (copy) {\n                    if (state->head != Z_NULL &&\n                        state->head->extra != Z_NULL) {\n                        len = state->head->extra_len - state->length;\n                        zmemcpy(state->head->extra + len, next,\n                                len + copy > state->head->extra_max ?\n                                state->head->extra_max - len : copy);\n                    }\n                    if ((state->flags & 0x0200) && (state->wrap & 4))\n                        state->check = crc32(state->check, next, copy);\n                    have -= copy;\n                    next += copy;\n                    state->length -= copy;\n                }\n                if (state->length) goto inf_leave;\n            }\n            state->length = 0;\n            state->mode = NAME;\n                /* fallthrough */\n        case NAME:\n            if (state->flags & 0x0800) {\n                if (have == 0) goto inf_leave;\n                copy = 0;\n                do {\n                    len = (unsigned)(next[copy++]);\n                    if (state->head != Z_NULL &&\n                            state->head->name != Z_NULL &&\n                            state->length < state->head->name_max)\n                        state->head->name[state->length++] = (Bytef)len;\n                } while (len && copy < have);\n                if ((state->flags & 0x0200) && (state->wrap & 4))\n                    state->check = crc32(state->check, next, copy);\n                have -= copy;\n                next += copy;\n                if (len) goto inf_leave;\n            }\n            else if (state->head != Z_NULL)\n                state->head->name = Z_NULL;\n            state->length = 0;\n            state->mode = COMMENT;\n                /* fallthrough */\n        case COMMENT:\n            if (state->flags & 0x1000) {\n                if (have == 0) goto inf_leave;\n                copy = 0;\n                do {\n                    len = (unsigned)(next[copy++]);\n                    if (state->head != Z_NULL &&\n                            state->head->comment != Z_NULL &&\n                            state->length < state->head->comm_max)\n                        state->head->comment[state->length++] = (Bytef)len;\n                } while (len && copy < have);\n                if ((state->flags & 0x0200) && (state->wrap & 4))\n                    state->check = crc32(state->check, next, copy);\n                have -= copy;\n                next += copy;\n                if (len) goto inf_leave;\n            }\n            else if (state->head != Z_NULL)\n                state->head->comment = Z_NULL;\n            state->mode = HCRC;\n                /* fallthrough */\n        case HCRC:\n            if (state->flags & 0x0200) {\n                NEEDBITS(16);\n                if ((state->wrap & 4) && hold != (state->check & 0xffff)) {\n                    strm->msg = (char *)\"header crc mismatch\";\n                    state->mode = BAD;\n                    break;\n                }\n                INITBITS();\n            }\n            if (state->head != Z_NULL) {\n                state->head->hcrc = (int)((state->flags >> 9) & 1);\n                state->head->done = 1;\n            }\n            strm->adler = state->check = crc32(0L, Z_NULL, 0);\n            state->mode = TYPE;\n            break;\n#endif\n        case DICTID:\n            NEEDBITS(32);\n            strm->adler = state->check = ZSWAP32(hold);\n            INITBITS();\n            state->mode = DICT;\n                /* fallthrough */\n        case DICT:\n            if (state->havedict == 0) {\n                RESTORE();\n                return Z_NEED_DICT;\n            }\n            strm->adler = state->check = adler32(0L, Z_NULL, 0);\n            state->mode = TYPE;\n                /* fallthrough */\n        case TYPE:\n            if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;\n                /* fallthrough */\n        case TYPEDO:\n            if (state->last) {\n                BYTEBITS();\n                state->mode = CHECK;\n                break;\n            }\n            NEEDBITS(3);\n            state->last = BITS(1);\n            DROPBITS(1);\n            switch (BITS(2)) {\n            case 0:                             /* stored block */\n                Tracev((stderr, \"inflate:     stored block%s\\n\",\n                        state->last ? \" (last)\" : \"\"));\n                state->mode = STORED;\n                break;\n            case 1:                             /* fixed block */\n                fixedtables(state);\n                Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n                        state->last ? \" (last)\" : \"\"));\n                state->mode = LEN_;             /* decode codes */\n                if (flush == Z_TREES) {\n                    DROPBITS(2);\n                    goto inf_leave;\n                }\n                break;\n            case 2:                             /* dynamic block */\n                Tracev((stderr, \"inflate:     dynamic codes block%s\\n\",\n                        state->last ? \" (last)\" : \"\"));\n                state->mode = TABLE;\n                break;\n            case 3:\n                strm->msg = (char *)\"invalid block type\";\n                state->mode = BAD;\n            }\n            DROPBITS(2);\n            break;\n        case STORED:\n            BYTEBITS();                         /* go to byte boundary */\n            NEEDBITS(32);\n            if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {\n                strm->msg = (char *)\"invalid stored block lengths\";\n                state->mode = BAD;\n                break;\n            }\n            state->length = (unsigned)hold & 0xffff;\n            Tracev((stderr, \"inflate:       stored length %u\\n\",\n                    state->length));\n            INITBITS();\n            state->mode = COPY_;\n            if (flush == Z_TREES) goto inf_leave;\n                /* fallthrough */\n        case COPY_:\n            state->mode = COPY;\n                /* fallthrough */\n        case COPY:\n            copy = state->length;\n            if (copy) {\n                if (copy > have) copy = have;\n                if (copy > left) copy = left;\n                if (copy == 0) goto inf_leave;\n                zmemcpy(put, next, copy);\n                have -= copy;\n                next += copy;\n                left -= copy;\n                put += copy;\n                state->length -= copy;\n                break;\n            }\n            Tracev((stderr, \"inflate:       stored end\\n\"));\n            state->mode = TYPE;\n            break;\n        case TABLE:\n            NEEDBITS(14);\n            state->nlen = BITS(5) + 257;\n            DROPBITS(5);\n            state->ndist = BITS(5) + 1;\n            DROPBITS(5);\n            state->ncode = BITS(4) + 4;\n            DROPBITS(4);\n#ifndef PKZIP_BUG_WORKAROUND\n            if (state->nlen > 286 || state->ndist > 30) {\n                strm->msg = (char *)\"too many length or distance symbols\";\n                state->mode = BAD;\n                break;\n            }\n#endif\n            Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n            state->have = 0;\n            state->mode = LENLENS;\n                /* fallthrough */\n        case LENLENS:\n            while (state->have < state->ncode) {\n                NEEDBITS(3);\n                state->lens[order[state->have++]] = (unsigned short)BITS(3);\n                DROPBITS(3);\n            }\n            while (state->have < 19)\n                state->lens[order[state->have++]] = 0;\n            state->next = state->codes;\n            state->lencode = (const code FAR *)(state->next);\n            state->lenbits = 7;\n            ret = inflate_table(CODES, state->lens, 19, &(state->next),\n                                &(state->lenbits), state->work);\n            if (ret) {\n                strm->msg = (char *)\"invalid code lengths set\";\n                state->mode = BAD;\n                break;\n            }\n            Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n            state->have = 0;\n            state->mode = CODELENS;\n                /* fallthrough */\n        case CODELENS:\n            while (state->have < state->nlen + state->ndist) {\n                for (;;) {\n                    here = state->lencode[BITS(state->lenbits)];\n                    if ((unsigned)(here.bits) <= bits) break;\n                    PULLBYTE();\n                }\n                if (here.val < 16) {\n                    DROPBITS(here.bits);\n                    state->lens[state->have++] = here.val;\n                }\n                else {\n                    if (here.val == 16) {\n                        NEEDBITS(here.bits + 2);\n                        DROPBITS(here.bits);\n                        if (state->have == 0) {\n                            strm->msg = (char *)\"invalid bit length repeat\";\n                            state->mode = BAD;\n                            break;\n                        }\n                        len = state->lens[state->have - 1];\n                        copy = 3 + BITS(2);\n                        DROPBITS(2);\n                    }\n                    else if (here.val == 17) {\n                        NEEDBITS(here.bits + 3);\n                        DROPBITS(here.bits);\n                        len = 0;\n                        copy = 3 + BITS(3);\n                        DROPBITS(3);\n                    }\n                    else {\n                        NEEDBITS(here.bits + 7);\n                        DROPBITS(here.bits);\n                        len = 0;\n                        copy = 11 + BITS(7);\n                        DROPBITS(7);\n                    }\n                    if (state->have + copy > state->nlen + state->ndist) {\n                        strm->msg = (char *)\"invalid bit length repeat\";\n                        state->mode = BAD;\n                        break;\n                    }\n                    while (copy--)\n                        state->lens[state->have++] = (unsigned short)len;\n                }\n            }\n\n            /* handle error breaks in while */\n            if (state->mode == BAD) break;\n\n            /* check for end-of-block code (better have one) */\n            if (state->lens[256] == 0) {\n                strm->msg = (char *)\"invalid code -- missing end-of-block\";\n                state->mode = BAD;\n                break;\n            }\n\n            /* build code tables -- note: do not change the lenbits or distbits\n               values here (9 and 6) without reading the comments in inftrees.h\n               concerning the ENOUGH constants, which depend on those values */\n            state->next = state->codes;\n            state->lencode = (const code FAR *)(state->next);\n            state->lenbits = 9;\n            ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),\n                                &(state->lenbits), state->work);\n            if (ret) {\n                strm->msg = (char *)\"invalid literal/lengths set\";\n                state->mode = BAD;\n                break;\n            }\n            state->distcode = (const code FAR *)(state->next);\n            state->distbits = 6;\n            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,\n                            &(state->next), &(state->distbits), state->work);\n            if (ret) {\n                strm->msg = (char *)\"invalid distances set\";\n                state->mode = BAD;\n                break;\n            }\n            Tracev((stderr, \"inflate:       codes ok\\n\"));\n            state->mode = LEN_;\n            if (flush == Z_TREES) goto inf_leave;\n                /* fallthrough */\n        case LEN_:\n            state->mode = LEN;\n                /* fallthrough */\n        case LEN:\n            if (have >= 6 && left >= 258) {\n                RESTORE();\n                inflate_fast(strm, out);\n                LOAD();\n                if (state->mode == TYPE)\n                    state->back = -1;\n                break;\n            }\n            state->back = 0;\n            for (;;) {\n                here = state->lencode[BITS(state->lenbits)];\n                if ((unsigned)(here.bits) <= bits) break;\n                PULLBYTE();\n            }\n            if (here.op && (here.op & 0xf0) == 0) {\n                last = here;\n                for (;;) {\n                    here = state->lencode[last.val +\n                            (BITS(last.bits + last.op) >> last.bits)];\n                    if ((unsigned)(last.bits + here.bits) <= bits) break;\n                    PULLBYTE();\n                }\n                DROPBITS(last.bits);\n                state->back += last.bits;\n            }\n            DROPBITS(here.bits);\n            state->back += here.bits;\n            state->length = (unsigned)here.val;\n            if ((int)(here.op) == 0) {\n                Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n                        \"inflate:         literal '%c'\\n\" :\n                        \"inflate:         literal 0x%02x\\n\", here.val));\n                state->mode = LIT;\n                break;\n            }\n            if (here.op & 32) {\n                Tracevv((stderr, \"inflate:         end of block\\n\"));\n                state->back = -1;\n                state->mode = TYPE;\n                break;\n            }\n            if (here.op & 64) {\n                strm->msg = (char *)\"invalid literal/length code\";\n                state->mode = BAD;\n                break;\n            }\n            state->extra = (unsigned)(here.op) & 15;\n            state->mode = LENEXT;\n                /* fallthrough */\n        case LENEXT:\n            if (state->extra) {\n                NEEDBITS(state->extra);\n                state->length += BITS(state->extra);\n                DROPBITS(state->extra);\n                state->back += state->extra;\n            }\n            Tracevv((stderr, \"inflate:         length %u\\n\", state->length));\n            state->was = state->length;\n            state->mode = DIST;\n                /* fallthrough */\n        case DIST:\n            for (;;) {\n                here = state->distcode[BITS(state->distbits)];\n                if ((unsigned)(here.bits) <= bits) break;\n                PULLBYTE();\n            }\n            if ((here.op & 0xf0) == 0) {\n                last = here;\n                for (;;) {\n                    here = state->distcode[last.val +\n                            (BITS(last.bits + last.op) >> last.bits)];\n                    if ((unsigned)(last.bits + here.bits) <= bits) break;\n                    PULLBYTE();\n                }\n                DROPBITS(last.bits);\n                state->back += last.bits;\n            }\n            DROPBITS(here.bits);\n            state->back += here.bits;\n            if (here.op & 64) {\n                strm->msg = (char *)\"invalid distance code\";\n                state->mode = BAD;\n                break;\n            }\n            state->offset = (unsigned)here.val;\n            state->extra = (unsigned)(here.op) & 15;\n            state->mode = DISTEXT;\n                /* fallthrough */\n        case DISTEXT:\n            if (state->extra) {\n                NEEDBITS(state->extra);\n                state->offset += BITS(state->extra);\n                DROPBITS(state->extra);\n                state->back += state->extra;\n            }\n#ifdef INFLATE_STRICT\n            if (state->offset > state->dmax) {\n                strm->msg = (char *)\"invalid distance too far back\";\n                state->mode = BAD;\n                break;\n            }\n#endif\n            Tracevv((stderr, \"inflate:         distance %u\\n\", state->offset));\n            state->mode = MATCH;\n                /* fallthrough */\n        case MATCH:\n            if (left == 0) goto inf_leave;\n            copy = out - left;\n            if (state->offset > copy) {         /* copy from window */\n                copy = state->offset - copy;\n                if (copy > state->whave) {\n                    if (state->sane) {\n                        strm->msg = (char *)\"invalid distance too far back\";\n                        state->mode = BAD;\n                        break;\n                    }\n#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n                    Trace((stderr, \"inflate.c too far\\n\"));\n                    copy -= state->whave;\n                    if (copy > state->length) copy = state->length;\n                    if (copy > left) copy = left;\n                    left -= copy;\n                    state->length -= copy;\n                    do {\n                        *put++ = 0;\n                    } while (--copy);\n                    if (state->length == 0) state->mode = LEN;\n                    break;\n#endif\n                }\n                if (copy > state->wnext) {\n                    copy -= state->wnext;\n                    from = state->window + (state->wsize - copy);\n                }\n                else\n                    from = state->window + (state->wnext - copy);\n                if (copy > state->length) copy = state->length;\n            }\n            else {                              /* copy from output */\n                from = put - state->offset;\n                copy = state->length;\n            }\n            if (copy > left) copy = left;\n            left -= copy;\n            state->length -= copy;\n            do {\n                *put++ = *from++;\n            } while (--copy);\n            if (state->length == 0) state->mode = LEN;\n            break;\n        case LIT:\n            if (left == 0) goto inf_leave;\n            *put++ = (unsigned char)(state->length);\n            left--;\n            state->mode = LEN;\n            break;\n        case CHECK:\n            if (state->wrap) {\n                NEEDBITS(32);\n                out -= left;\n                strm->total_out += out;\n                state->total += out;\n                if ((state->wrap & 4) && out)\n                    strm->adler = state->check =\n                        UPDATE_CHECK(state->check, put - out, out);\n                out = left;\n                if ((state->wrap & 4) && (\n#ifdef GUNZIP\n                     state->flags ? hold :\n#endif\n                     ZSWAP32(hold)) != state->check) {\n                    strm->msg = (char *)\"incorrect data check\";\n                    state->mode = BAD;\n                    break;\n                }\n                INITBITS();\n                Tracev((stderr, \"inflate:   check matches trailer\\n\"));\n            }\n#ifdef GUNZIP\n            state->mode = LENGTH;\n                /* fallthrough */\n        case LENGTH:\n            if (state->wrap && state->flags) {\n                NEEDBITS(32);\n                if ((state->wrap & 4) && hold != (state->total & 0xffffffff)) {\n                    strm->msg = (char *)\"incorrect length check\";\n                    state->mode = BAD;\n                    break;\n                }\n                INITBITS();\n                Tracev((stderr, \"inflate:   length matches trailer\\n\"));\n            }\n#endif\n            state->mode = DONE;\n                /* fallthrough */\n        case DONE:\n            ret = Z_STREAM_END;\n            goto inf_leave;\n        case BAD:\n            ret = Z_DATA_ERROR;\n            goto inf_leave;\n        case MEM:\n            return Z_MEM_ERROR;\n        case SYNC:\n                /* fallthrough */\n        default:\n            return Z_STREAM_ERROR;\n        }\n\n    /*\n       Return from inflate(), updating the total counts and the check value.\n       If there was no progress during the inflate() call, return a buffer\n       error.  Call updatewindow() to create and/or update the window state.\n       Note: a memory error from inflate() is non-recoverable.\n     */\n  inf_leave:\n    RESTORE();\n    if (state->wsize || (out != strm->avail_out && state->mode < BAD &&\n            (state->mode < CHECK || flush != Z_FINISH)))\n        if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {\n            state->mode = MEM;\n            return Z_MEM_ERROR;\n        }\n    in -= strm->avail_in;\n    out -= strm->avail_out;\n    strm->total_in += in;\n    strm->total_out += out;\n    state->total += out;\n    if ((state->wrap & 4) && out)\n        strm->adler = state->check =\n            UPDATE_CHECK(state->check, strm->next_out - out, out);\n    strm->data_type = (int)state->bits + (state->last ? 64 : 0) +\n                      (state->mode == TYPE ? 128 : 0) +\n                      (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);\n    if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)\n        ret = Z_BUF_ERROR;\n    return ret;\n}", "func_hash": 308042126203552622330885717948323954753, "file_name": "inflate.c", "file_hash": 13307216410875362203864420162564887753, "cwe": ["CWE-787"], "cve": "CVE-2022-37434", "cve_desc": "zlib through 1.2.12 has a heap-based buffer over-read or buffer overflow in inflate in inflate.c via a large gzip header extra field. NOTE: only applications that call inflateGetHeader are affected. Some common applications bundle the affected zlib source code but may be unable to call inflateGetHeader (e.g., see the nodejs/node reference).", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-37434", "file_path": "inflate.c"}
{"idx": 448912, "project": "zlib", "commit_id": "eff308af425b67093bab25f80f1ae950166bece1", "project_url": "https://github.com/madler/zlib", "commit_url": "https://github.com/madler/zlib/commit/eff308af425b67093bab25f80f1ae950166bece1", "commit_message": "Fix a bug when getting a gzip header extra field with inflate().\n\nIf the extra field was larger than the space the user provided with\ninflateGetHeader(), and if multiple calls of inflate() delivered\nthe extra header data, then there could be a buffer overflow of the\nprovided space. This commit assures that provided space is not\nexceeded.", "target": 0, "func": "int ZEXPORT inflate(strm, flush)\nz_streamp strm;\nint flush;\n{\n    struct inflate_state FAR *state;\n    z_const unsigned char FAR *next;    /* next input */\n    unsigned char FAR *put;     /* next output */\n    unsigned have, left;        /* available input and output */\n    unsigned long hold;         /* bit buffer */\n    unsigned bits;              /* bits in bit buffer */\n    unsigned in, out;           /* save starting available input and output */\n    unsigned copy;              /* number of stored or match bytes to copy */\n    unsigned char FAR *from;    /* where to copy match bytes from */\n    code here;                  /* current decoding table entry */\n    code last;                  /* parent table entry */\n    unsigned len;               /* length to copy for repeats, bits to drop */\n    int ret;                    /* return code */\n#ifdef GUNZIP\n    unsigned char hbuf[4];      /* buffer for gzip header crc calculation */\n#endif\n    static const unsigned short order[19] = /* permutation of code lengths */\n        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};\n\n    if (inflateStateCheck(strm) || strm->next_out == Z_NULL ||\n        (strm->next_in == Z_NULL && strm->avail_in != 0))\n        return Z_STREAM_ERROR;\n\n    state = (struct inflate_state FAR *)strm->state;\n    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */\n    LOAD();\n    in = have;\n    out = left;\n    ret = Z_OK;\n    for (;;)\n        switch (state->mode) {\n        case HEAD:\n            if (state->wrap == 0) {\n                state->mode = TYPEDO;\n                break;\n            }\n            NEEDBITS(16);\n#ifdef GUNZIP\n            if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */\n                if (state->wbits == 0)\n                    state->wbits = 15;\n                state->check = crc32(0L, Z_NULL, 0);\n                CRC2(state->check, hold);\n                INITBITS();\n                state->mode = FLAGS;\n                break;\n            }\n            if (state->head != Z_NULL)\n                state->head->done = -1;\n            if (!(state->wrap & 1) ||   /* check if zlib header allowed */\n#else\n            if (\n#endif\n                ((BITS(8) << 8) + (hold >> 8)) % 31) {\n                strm->msg = (char *)\"incorrect header check\";\n                state->mode = BAD;\n                break;\n            }\n            if (BITS(4) != Z_DEFLATED) {\n                strm->msg = (char *)\"unknown compression method\";\n                state->mode = BAD;\n                break;\n            }\n            DROPBITS(4);\n            len = BITS(4) + 8;\n            if (state->wbits == 0)\n                state->wbits = len;\n            if (len > 15 || len > state->wbits) {\n                strm->msg = (char *)\"invalid window size\";\n                state->mode = BAD;\n                break;\n            }\n            state->dmax = 1U << len;\n            state->flags = 0;               /* indicate zlib header */\n            Tracev((stderr, \"inflate:   zlib header ok\\n\"));\n            strm->adler = state->check = adler32(0L, Z_NULL, 0);\n            state->mode = hold & 0x200 ? DICTID : TYPE;\n            INITBITS();\n            break;\n#ifdef GUNZIP\n        case FLAGS:\n            NEEDBITS(16);\n            state->flags = (int)(hold);\n            if ((state->flags & 0xff) != Z_DEFLATED) {\n                strm->msg = (char *)\"unknown compression method\";\n                state->mode = BAD;\n                break;\n            }\n            if (state->flags & 0xe000) {\n                strm->msg = (char *)\"unknown header flags set\";\n                state->mode = BAD;\n                break;\n            }\n            if (state->head != Z_NULL)\n                state->head->text = (int)((hold >> 8) & 1);\n            if ((state->flags & 0x0200) && (state->wrap & 4))\n                CRC2(state->check, hold);\n            INITBITS();\n            state->mode = TIME;\n                /* fallthrough */\n        case TIME:\n            NEEDBITS(32);\n            if (state->head != Z_NULL)\n                state->head->time = hold;\n            if ((state->flags & 0x0200) && (state->wrap & 4))\n                CRC4(state->check, hold);\n            INITBITS();\n            state->mode = OS;\n                /* fallthrough */\n        case OS:\n            NEEDBITS(16);\n            if (state->head != Z_NULL) {\n                state->head->xflags = (int)(hold & 0xff);\n                state->head->os = (int)(hold >> 8);\n            }\n            if ((state->flags & 0x0200) && (state->wrap & 4))\n                CRC2(state->check, hold);\n            INITBITS();\n            state->mode = EXLEN;\n                /* fallthrough */\n        case EXLEN:\n            if (state->flags & 0x0400) {\n                NEEDBITS(16);\n                state->length = (unsigned)(hold);\n                if (state->head != Z_NULL)\n                    state->head->extra_len = (unsigned)hold;\n                if ((state->flags & 0x0200) && (state->wrap & 4))\n                    CRC2(state->check, hold);\n                INITBITS();\n            }\n            else if (state->head != Z_NULL)\n                state->head->extra = Z_NULL;\n            state->mode = EXTRA;\n                /* fallthrough */\n        case EXTRA:\n            if (state->flags & 0x0400) {\n                copy = state->length;\n                if (copy > have) copy = have;\n                if (copy) {\n                    len = state->head->extra_len - state->length;\n                    if (state->head != Z_NULL &&\n                        state->head->extra != Z_NULL &&\n                        len < state->head->extra_max) {\n                        zmemcpy(state->head->extra + len, next,\n                                len + copy > state->head->extra_max ?\n                                state->head->extra_max - len : copy);\n                    }\n                    if ((state->flags & 0x0200) && (state->wrap & 4))\n                        state->check = crc32(state->check, next, copy);\n                    have -= copy;\n                    next += copy;\n                    state->length -= copy;\n                }\n                if (state->length) goto inf_leave;\n            }\n            state->length = 0;\n            state->mode = NAME;\n                /* fallthrough */\n        case NAME:\n            if (state->flags & 0x0800) {\n                if (have == 0) goto inf_leave;\n                copy = 0;\n                do {\n                    len = (unsigned)(next[copy++]);\n                    if (state->head != Z_NULL &&\n                            state->head->name != Z_NULL &&\n                            state->length < state->head->name_max)\n                        state->head->name[state->length++] = (Bytef)len;\n                } while (len && copy < have);\n                if ((state->flags & 0x0200) && (state->wrap & 4))\n                    state->check = crc32(state->check, next, copy);\n                have -= copy;\n                next += copy;\n                if (len) goto inf_leave;\n            }\n            else if (state->head != Z_NULL)\n                state->head->name = Z_NULL;\n            state->length = 0;\n            state->mode = COMMENT;\n                /* fallthrough */\n        case COMMENT:\n            if (state->flags & 0x1000) {\n                if (have == 0) goto inf_leave;\n                copy = 0;\n                do {\n                    len = (unsigned)(next[copy++]);\n                    if (state->head != Z_NULL &&\n                            state->head->comment != Z_NULL &&\n                            state->length < state->head->comm_max)\n                        state->head->comment[state->length++] = (Bytef)len;\n                } while (len && copy < have);\n                if ((state->flags & 0x0200) && (state->wrap & 4))\n                    state->check = crc32(state->check, next, copy);\n                have -= copy;\n                next += copy;\n                if (len) goto inf_leave;\n            }\n            else if (state->head != Z_NULL)\n                state->head->comment = Z_NULL;\n            state->mode = HCRC;\n                /* fallthrough */\n        case HCRC:\n            if (state->flags & 0x0200) {\n                NEEDBITS(16);\n                if ((state->wrap & 4) && hold != (state->check & 0xffff)) {\n                    strm->msg = (char *)\"header crc mismatch\";\n                    state->mode = BAD;\n                    break;\n                }\n                INITBITS();\n            }\n            if (state->head != Z_NULL) {\n                state->head->hcrc = (int)((state->flags >> 9) & 1);\n                state->head->done = 1;\n            }\n            strm->adler = state->check = crc32(0L, Z_NULL, 0);\n            state->mode = TYPE;\n            break;\n#endif\n        case DICTID:\n            NEEDBITS(32);\n            strm->adler = state->check = ZSWAP32(hold);\n            INITBITS();\n            state->mode = DICT;\n                /* fallthrough */\n        case DICT:\n            if (state->havedict == 0) {\n                RESTORE();\n                return Z_NEED_DICT;\n            }\n            strm->adler = state->check = adler32(0L, Z_NULL, 0);\n            state->mode = TYPE;\n                /* fallthrough */\n        case TYPE:\n            if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;\n                /* fallthrough */\n        case TYPEDO:\n            if (state->last) {\n                BYTEBITS();\n                state->mode = CHECK;\n                break;\n            }\n            NEEDBITS(3);\n            state->last = BITS(1);\n            DROPBITS(1);\n            switch (BITS(2)) {\n            case 0:                             /* stored block */\n                Tracev((stderr, \"inflate:     stored block%s\\n\",\n                        state->last ? \" (last)\" : \"\"));\n                state->mode = STORED;\n                break;\n            case 1:                             /* fixed block */\n                fixedtables(state);\n                Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n                        state->last ? \" (last)\" : \"\"));\n                state->mode = LEN_;             /* decode codes */\n                if (flush == Z_TREES) {\n                    DROPBITS(2);\n                    goto inf_leave;\n                }\n                break;\n            case 2:                             /* dynamic block */\n                Tracev((stderr, \"inflate:     dynamic codes block%s\\n\",\n                        state->last ? \" (last)\" : \"\"));\n                state->mode = TABLE;\n                break;\n            case 3:\n                strm->msg = (char *)\"invalid block type\";\n                state->mode = BAD;\n            }\n            DROPBITS(2);\n            break;\n        case STORED:\n            BYTEBITS();                         /* go to byte boundary */\n            NEEDBITS(32);\n            if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {\n                strm->msg = (char *)\"invalid stored block lengths\";\n                state->mode = BAD;\n                break;\n            }\n            state->length = (unsigned)hold & 0xffff;\n            Tracev((stderr, \"inflate:       stored length %u\\n\",\n                    state->length));\n            INITBITS();\n            state->mode = COPY_;\n            if (flush == Z_TREES) goto inf_leave;\n                /* fallthrough */\n        case COPY_:\n            state->mode = COPY;\n                /* fallthrough */\n        case COPY:\n            copy = state->length;\n            if (copy) {\n                if (copy > have) copy = have;\n                if (copy > left) copy = left;\n                if (copy == 0) goto inf_leave;\n                zmemcpy(put, next, copy);\n                have -= copy;\n                next += copy;\n                left -= copy;\n                put += copy;\n                state->length -= copy;\n                break;\n            }\n            Tracev((stderr, \"inflate:       stored end\\n\"));\n            state->mode = TYPE;\n            break;\n        case TABLE:\n            NEEDBITS(14);\n            state->nlen = BITS(5) + 257;\n            DROPBITS(5);\n            state->ndist = BITS(5) + 1;\n            DROPBITS(5);\n            state->ncode = BITS(4) + 4;\n            DROPBITS(4);\n#ifndef PKZIP_BUG_WORKAROUND\n            if (state->nlen > 286 || state->ndist > 30) {\n                strm->msg = (char *)\"too many length or distance symbols\";\n                state->mode = BAD;\n                break;\n            }\n#endif\n            Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n            state->have = 0;\n            state->mode = LENLENS;\n                /* fallthrough */\n        case LENLENS:\n            while (state->have < state->ncode) {\n                NEEDBITS(3);\n                state->lens[order[state->have++]] = (unsigned short)BITS(3);\n                DROPBITS(3);\n            }\n            while (state->have < 19)\n                state->lens[order[state->have++]] = 0;\n            state->next = state->codes;\n            state->lencode = (const code FAR *)(state->next);\n            state->lenbits = 7;\n            ret = inflate_table(CODES, state->lens, 19, &(state->next),\n                                &(state->lenbits), state->work);\n            if (ret) {\n                strm->msg = (char *)\"invalid code lengths set\";\n                state->mode = BAD;\n                break;\n            }\n            Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n            state->have = 0;\n            state->mode = CODELENS;\n                /* fallthrough */\n        case CODELENS:\n            while (state->have < state->nlen + state->ndist) {\n                for (;;) {\n                    here = state->lencode[BITS(state->lenbits)];\n                    if ((unsigned)(here.bits) <= bits) break;\n                    PULLBYTE();\n                }\n                if (here.val < 16) {\n                    DROPBITS(here.bits);\n                    state->lens[state->have++] = here.val;\n                }\n                else {\n                    if (here.val == 16) {\n                        NEEDBITS(here.bits + 2);\n                        DROPBITS(here.bits);\n                        if (state->have == 0) {\n                            strm->msg = (char *)\"invalid bit length repeat\";\n                            state->mode = BAD;\n                            break;\n                        }\n                        len = state->lens[state->have - 1];\n                        copy = 3 + BITS(2);\n                        DROPBITS(2);\n                    }\n                    else if (here.val == 17) {\n                        NEEDBITS(here.bits + 3);\n                        DROPBITS(here.bits);\n                        len = 0;\n                        copy = 3 + BITS(3);\n                        DROPBITS(3);\n                    }\n                    else {\n                        NEEDBITS(here.bits + 7);\n                        DROPBITS(here.bits);\n                        len = 0;\n                        copy = 11 + BITS(7);\n                        DROPBITS(7);\n                    }\n                    if (state->have + copy > state->nlen + state->ndist) {\n                        strm->msg = (char *)\"invalid bit length repeat\";\n                        state->mode = BAD;\n                        break;\n                    }\n                    while (copy--)\n                        state->lens[state->have++] = (unsigned short)len;\n                }\n            }\n\n            /* handle error breaks in while */\n            if (state->mode == BAD) break;\n\n            /* check for end-of-block code (better have one) */\n            if (state->lens[256] == 0) {\n                strm->msg = (char *)\"invalid code -- missing end-of-block\";\n                state->mode = BAD;\n                break;\n            }\n\n            /* build code tables -- note: do not change the lenbits or distbits\n               values here (9 and 6) without reading the comments in inftrees.h\n               concerning the ENOUGH constants, which depend on those values */\n            state->next = state->codes;\n            state->lencode = (const code FAR *)(state->next);\n            state->lenbits = 9;\n            ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),\n                                &(state->lenbits), state->work);\n            if (ret) {\n                strm->msg = (char *)\"invalid literal/lengths set\";\n                state->mode = BAD;\n                break;\n            }\n            state->distcode = (const code FAR *)(state->next);\n            state->distbits = 6;\n            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,\n                            &(state->next), &(state->distbits), state->work);\n            if (ret) {\n                strm->msg = (char *)\"invalid distances set\";\n                state->mode = BAD;\n                break;\n            }\n            Tracev((stderr, \"inflate:       codes ok\\n\"));\n            state->mode = LEN_;\n            if (flush == Z_TREES) goto inf_leave;\n                /* fallthrough */\n        case LEN_:\n            state->mode = LEN;\n                /* fallthrough */\n        case LEN:\n            if (have >= 6 && left >= 258) {\n                RESTORE();\n                inflate_fast(strm, out);\n                LOAD();\n                if (state->mode == TYPE)\n                    state->back = -1;\n                break;\n            }\n            state->back = 0;\n            for (;;) {\n                here = state->lencode[BITS(state->lenbits)];\n                if ((unsigned)(here.bits) <= bits) break;\n                PULLBYTE();\n            }\n            if (here.op && (here.op & 0xf0) == 0) {\n                last = here;\n                for (;;) {\n                    here = state->lencode[last.val +\n                            (BITS(last.bits + last.op) >> last.bits)];\n                    if ((unsigned)(last.bits + here.bits) <= bits) break;\n                    PULLBYTE();\n                }\n                DROPBITS(last.bits);\n                state->back += last.bits;\n            }\n            DROPBITS(here.bits);\n            state->back += here.bits;\n            state->length = (unsigned)here.val;\n            if ((int)(here.op) == 0) {\n                Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n                        \"inflate:         literal '%c'\\n\" :\n                        \"inflate:         literal 0x%02x\\n\", here.val));\n                state->mode = LIT;\n                break;\n            }\n            if (here.op & 32) {\n                Tracevv((stderr, \"inflate:         end of block\\n\"));\n                state->back = -1;\n                state->mode = TYPE;\n                break;\n            }\n            if (here.op & 64) {\n                strm->msg = (char *)\"invalid literal/length code\";\n                state->mode = BAD;\n                break;\n            }\n            state->extra = (unsigned)(here.op) & 15;\n            state->mode = LENEXT;\n                /* fallthrough */\n        case LENEXT:\n            if (state->extra) {\n                NEEDBITS(state->extra);\n                state->length += BITS(state->extra);\n                DROPBITS(state->extra);\n                state->back += state->extra;\n            }\n            Tracevv((stderr, \"inflate:         length %u\\n\", state->length));\n            state->was = state->length;\n            state->mode = DIST;\n                /* fallthrough */\n        case DIST:\n            for (;;) {\n                here = state->distcode[BITS(state->distbits)];\n                if ((unsigned)(here.bits) <= bits) break;\n                PULLBYTE();\n            }\n            if ((here.op & 0xf0) == 0) {\n                last = here;\n                for (;;) {\n                    here = state->distcode[last.val +\n                            (BITS(last.bits + last.op) >> last.bits)];\n                    if ((unsigned)(last.bits + here.bits) <= bits) break;\n                    PULLBYTE();\n                }\n                DROPBITS(last.bits);\n                state->back += last.bits;\n            }\n            DROPBITS(here.bits);\n            state->back += here.bits;\n            if (here.op & 64) {\n                strm->msg = (char *)\"invalid distance code\";\n                state->mode = BAD;\n                break;\n            }\n            state->offset = (unsigned)here.val;\n            state->extra = (unsigned)(here.op) & 15;\n            state->mode = DISTEXT;\n                /* fallthrough */\n        case DISTEXT:\n            if (state->extra) {\n                NEEDBITS(state->extra);\n                state->offset += BITS(state->extra);\n                DROPBITS(state->extra);\n                state->back += state->extra;\n            }\n#ifdef INFLATE_STRICT\n            if (state->offset > state->dmax) {\n                strm->msg = (char *)\"invalid distance too far back\";\n                state->mode = BAD;\n                break;\n            }\n#endif\n            Tracevv((stderr, \"inflate:         distance %u\\n\", state->offset));\n            state->mode = MATCH;\n                /* fallthrough */\n        case MATCH:\n            if (left == 0) goto inf_leave;\n            copy = out - left;\n            if (state->offset > copy) {         /* copy from window */\n                copy = state->offset - copy;\n                if (copy > state->whave) {\n                    if (state->sane) {\n                        strm->msg = (char *)\"invalid distance too far back\";\n                        state->mode = BAD;\n                        break;\n                    }\n#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n                    Trace((stderr, \"inflate.c too far\\n\"));\n                    copy -= state->whave;\n                    if (copy > state->length) copy = state->length;\n                    if (copy > left) copy = left;\n                    left -= copy;\n                    state->length -= copy;\n                    do {\n                        *put++ = 0;\n                    } while (--copy);\n                    if (state->length == 0) state->mode = LEN;\n                    break;\n#endif\n                }\n                if (copy > state->wnext) {\n                    copy -= state->wnext;\n                    from = state->window + (state->wsize - copy);\n                }\n                else\n                    from = state->window + (state->wnext - copy);\n                if (copy > state->length) copy = state->length;\n            }\n            else {                              /* copy from output */\n                from = put - state->offset;\n                copy = state->length;\n            }\n            if (copy > left) copy = left;\n            left -= copy;\n            state->length -= copy;\n            do {\n                *put++ = *from++;\n            } while (--copy);\n            if (state->length == 0) state->mode = LEN;\n            break;\n        case LIT:\n            if (left == 0) goto inf_leave;\n            *put++ = (unsigned char)(state->length);\n            left--;\n            state->mode = LEN;\n            break;\n        case CHECK:\n            if (state->wrap) {\n                NEEDBITS(32);\n                out -= left;\n                strm->total_out += out;\n                state->total += out;\n                if ((state->wrap & 4) && out)\n                    strm->adler = state->check =\n                        UPDATE_CHECK(state->check, put - out, out);\n                out = left;\n                if ((state->wrap & 4) && (\n#ifdef GUNZIP\n                     state->flags ? hold :\n#endif\n                     ZSWAP32(hold)) != state->check) {\n                    strm->msg = (char *)\"incorrect data check\";\n                    state->mode = BAD;\n                    break;\n                }\n                INITBITS();\n                Tracev((stderr, \"inflate:   check matches trailer\\n\"));\n            }\n#ifdef GUNZIP\n            state->mode = LENGTH;\n                /* fallthrough */\n        case LENGTH:\n            if (state->wrap && state->flags) {\n                NEEDBITS(32);\n                if ((state->wrap & 4) && hold != (state->total & 0xffffffff)) {\n                    strm->msg = (char *)\"incorrect length check\";\n                    state->mode = BAD;\n                    break;\n                }\n                INITBITS();\n                Tracev((stderr, \"inflate:   length matches trailer\\n\"));\n            }\n#endif\n            state->mode = DONE;\n                /* fallthrough */\n        case DONE:\n            ret = Z_STREAM_END;\n            goto inf_leave;\n        case BAD:\n            ret = Z_DATA_ERROR;\n            goto inf_leave;\n        case MEM:\n            return Z_MEM_ERROR;\n        case SYNC:\n                /* fallthrough */\n        default:\n            return Z_STREAM_ERROR;\n        }\n\n    /*\n       Return from inflate(), updating the total counts and the check value.\n       If there was no progress during the inflate() call, return a buffer\n       error.  Call updatewindow() to create and/or update the window state.\n       Note: a memory error from inflate() is non-recoverable.\n     */\n  inf_leave:\n    RESTORE();\n    if (state->wsize || (out != strm->avail_out && state->mode < BAD &&\n            (state->mode < CHECK || flush != Z_FINISH)))\n        if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {\n            state->mode = MEM;\n            return Z_MEM_ERROR;\n        }\n    in -= strm->avail_in;\n    out -= strm->avail_out;\n    strm->total_in += in;\n    strm->total_out += out;\n    state->total += out;\n    if ((state->wrap & 4) && out)\n        strm->adler = state->check =\n            UPDATE_CHECK(state->check, strm->next_out - out, out);\n    strm->data_type = (int)state->bits + (state->last ? 64 : 0) +\n                      (state->mode == TYPE ? 128 : 0) +\n                      (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);\n    if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)\n        ret = Z_BUF_ERROR;\n    return ret;\n}", "func_hash": 77680460964707773234667939079956613143, "file_name": "inflate.c", "file_hash": 53439547439920310595361050781327807541, "cwe": ["CWE-787"], "cve": "CVE-2022-37434", "cve_desc": "zlib through 1.2.12 has a heap-based buffer over-read or buffer overflow in inflate in inflate.c via a large gzip header extra field. NOTE: only applications that call inflateGetHeader are affected. Some common applications bundle the affected zlib source code but may be unable to call inflateGetHeader (e.g., see the nodejs/node reference).", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-37434", "file_path": "inflate.c"}
{"idx": 211567, "project": "clamav-devel", "commit_id": "c6870a6c857dd722dffaf6d37ae52ec259d12492", "project_url": "https://github.com/vrtadmin/clamav-devel", "commit_url": "https://github.com/vrtadmin/clamav-devel/commit/c6870a6c857dd722dffaf6d37ae52ec259d12492", "commit_message": "bb #6808", "target": 1, "func": "static char *getsistring(FILE *f, uint32_t ptr, uint32_t len) {\n  char *name;\n  uint32_t i;\n\n  if (!len) return NULL;\n  if (len>400) len=400;\n  name = cli_malloc(len);\n  if (!name) {\n    cli_dbgmsg(\"SIS: OOM\\n\");\n    return NULL;\n  }\n  fseek(f, ptr, SEEK_SET);\n  if (fread(name, len, 1, f)!=1) {\n    cli_dbgmsg(\"SIS: Unable to read string\\n\");\n    free(name);\n    return NULL;\n  }\n  for (i = 0 ; i < len; i+=2) name[i/2] = name[i];\n  name[i/2]='\\0';\n  return name;\n}", "func_hash": 249475827060217450801946160071587171974, "file_name": "sis.c", "file_hash": 74416937580759661752528557759080505362, "cwe": ["CWE-189"], "cve": "CVE-2013-2020", "cve_desc": "Integer underflow in the cli_scanpe function in pe.c in ClamAV before 0.97.8 allows remote attackers to cause a denial of service (crash) via a skewed offset larger than the size of the PE section in a UPX packed executable, which triggers an out-of-bounds read.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-2020", "file_path": "libclamav/sis.c"}
{"idx": 449321, "project": "clamav-devel", "commit_id": "c6870a6c857dd722dffaf6d37ae52ec259d12492", "project_url": "https://github.com/vrtadmin/clamav-devel", "commit_url": "https://github.com/vrtadmin/clamav-devel/commit/c6870a6c857dd722dffaf6d37ae52ec259d12492", "commit_message": "bb #6808", "target": 0, "func": "static char *getsistring(FILE *f, uint32_t ptr, uint32_t len) {\n  char *name;\n  uint32_t i;\n\n  if (!len) return NULL;\n  if (len>400) len=400;\n  name = cli_malloc(len+1);\n  if (!name) {\n    cli_dbgmsg(\"SIS: OOM\\n\");\n    return NULL;\n  }\n  fseek(f, ptr, SEEK_SET);\n  if (fread(name, len, 1, f)!=1) {\n    cli_dbgmsg(\"SIS: Unable to read string\\n\");\n    free(name);\n    return NULL;\n  }\n  for (i = 0 ; i < len; i+=2) name[i/2] = name[i];\n  name[i/2]='\\0';\n  return name;\n}", "func_hash": 103287413099842266713052785251008739113, "file_name": "sis.c", "file_hash": 220725720240675887606122374077538393241, "cwe": ["CWE-189"], "cve": "CVE-2013-2020", "cve_desc": "Integer underflow in the cli_scanpe function in pe.c in ClamAV before 0.97.8 allows remote attackers to cause a denial of service (crash) via a skewed offset larger than the size of the PE section in a UPX packed executable, which triggers an out-of-bounds read.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-2020", "file_path": "libclamav/sis.c"}
{"idx": 211695, "project": "vim", "commit_id": "4c13e5e6763c6eb36a343a2b8235ea227202e952", "project_url": "https://github.com/vim/vim", "commit_url": "https://github.com/vim/vim/commit/4c13e5e6763c6eb36a343a2b8235ea227202e952", "commit_message": "patch 8.2.3949: using freed memory with /\\%V\n\nProblem:    Using freed memory with /\\%V.\nSolution:   Get the line again after getvvcol().", "target": 1, "func": "reg_match_visual(void)\n{\n    pos_T\ttop, bot;\n    linenr_T    lnum;\n    colnr_T\tcol;\n    win_T\t*wp = rex.reg_win == NULL ? curwin : rex.reg_win;\n    int\t\tmode;\n    colnr_T\tstart, end;\n    colnr_T\tstart2, end2;\n    colnr_T\tcols;\n    colnr_T\tcurswant;\n\n    // Check if the buffer is the current buffer.\n    if (rex.reg_buf != curbuf || VIsual.lnum == 0)\n\treturn FALSE;\n\n    if (VIsual_active)\n    {\n\tif (LT_POS(VIsual, wp->w_cursor))\n\t{\n\t    top = VIsual;\n\t    bot = wp->w_cursor;\n\t}\n\telse\n\t{\n\t    top = wp->w_cursor;\n\t    bot = VIsual;\n\t}\n\tmode = VIsual_mode;\n\tcurswant = wp->w_curswant;\n    }\n    else\n    {\n\tif (LT_POS(curbuf->b_visual.vi_start, curbuf->b_visual.vi_end))\n\t{\n\t    top = curbuf->b_visual.vi_start;\n\t    bot = curbuf->b_visual.vi_end;\n\t}\n\telse\n\t{\n\t    top = curbuf->b_visual.vi_end;\n\t    bot = curbuf->b_visual.vi_start;\n\t}\n\tmode = curbuf->b_visual.vi_mode;\n\tcurswant = curbuf->b_visual.vi_curswant;\n    }\n    lnum = rex.lnum + rex.reg_firstlnum;\n    if (lnum < top.lnum || lnum > bot.lnum)\n\treturn FALSE;\n\n    if (mode == 'v')\n    {\n\tcol = (colnr_T)(rex.input - rex.line);\n\tif ((lnum == top.lnum && col < top.col)\n\t\t|| (lnum == bot.lnum && col >= bot.col + (*p_sel != 'e')))\n\t    return FALSE;\n    }\n    else if (mode == Ctrl_V)\n    {\n\tgetvvcol(wp, &top, &start, NULL, &end);\n\tgetvvcol(wp, &bot, &start2, NULL, &end2);\n\tif (start2 < start)\n\t    start = start2;\n\tif (end2 > end)\n\t    end = end2;\n\tif (top.col == MAXCOL || bot.col == MAXCOL || curswant == MAXCOL)\n\t    end = MAXCOL;\n\tcols = win_linetabsize(wp, rex.line, (colnr_T)(rex.input - rex.line));\n\tif (cols < start || cols > end - (*p_sel == 'e'))\n\t    return FALSE;\n    }\n    return TRUE;\n}", "func_hash": 213127434587581742033304075177767787021, "file_name": "regexp.c", "file_hash": 154178765544405999260732501141990227321, "cwe": ["CWE-416"], "cve": "CVE-2021-4192", "cve_desc": "vim is vulnerable to Use After Free", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-4192", "file_path": "src/regexp.c"}
{"idx": 450764, "project": "vim", "commit_id": "4c13e5e6763c6eb36a343a2b8235ea227202e952", "project_url": "https://github.com/vim/vim", "commit_url": "https://github.com/vim/vim/commit/4c13e5e6763c6eb36a343a2b8235ea227202e952", "commit_message": "patch 8.2.3949: using freed memory with /\\%V\n\nProblem:    Using freed memory with /\\%V.\nSolution:   Get the line again after getvvcol().", "target": 0, "func": "reg_match_visual(void)\n{\n    pos_T\ttop, bot;\n    linenr_T    lnum;\n    colnr_T\tcol;\n    win_T\t*wp = rex.reg_win == NULL ? curwin : rex.reg_win;\n    int\t\tmode;\n    colnr_T\tstart, end;\n    colnr_T\tstart2, end2;\n    colnr_T\tcols;\n    colnr_T\tcurswant;\n\n    // Check if the buffer is the current buffer.\n    if (rex.reg_buf != curbuf || VIsual.lnum == 0)\n\treturn FALSE;\n\n    if (VIsual_active)\n    {\n\tif (LT_POS(VIsual, wp->w_cursor))\n\t{\n\t    top = VIsual;\n\t    bot = wp->w_cursor;\n\t}\n\telse\n\t{\n\t    top = wp->w_cursor;\n\t    bot = VIsual;\n\t}\n\tmode = VIsual_mode;\n\tcurswant = wp->w_curswant;\n    }\n    else\n    {\n\tif (LT_POS(curbuf->b_visual.vi_start, curbuf->b_visual.vi_end))\n\t{\n\t    top = curbuf->b_visual.vi_start;\n\t    bot = curbuf->b_visual.vi_end;\n\t}\n\telse\n\t{\n\t    top = curbuf->b_visual.vi_end;\n\t    bot = curbuf->b_visual.vi_start;\n\t}\n\tmode = curbuf->b_visual.vi_mode;\n\tcurswant = curbuf->b_visual.vi_curswant;\n    }\n    lnum = rex.lnum + rex.reg_firstlnum;\n    if (lnum < top.lnum || lnum > bot.lnum)\n\treturn FALSE;\n\n    col = (colnr_T)(rex.input - rex.line);\n    if (mode == 'v')\n    {\n\tif ((lnum == top.lnum && col < top.col)\n\t\t|| (lnum == bot.lnum && col >= bot.col + (*p_sel != 'e')))\n\t    return FALSE;\n    }\n    else if (mode == Ctrl_V)\n    {\n\tgetvvcol(wp, &top, &start, NULL, &end);\n\tgetvvcol(wp, &bot, &start2, NULL, &end2);\n\tif (start2 < start)\n\t    start = start2;\n\tif (end2 > end)\n\t    end = end2;\n\tif (top.col == MAXCOL || bot.col == MAXCOL || curswant == MAXCOL)\n\t    end = MAXCOL;\n\n\t// getvvcol() flushes rex.line, need to get it again\n\trex.line = reg_getline(rex.lnum);\n\trex.input = rex.line + col;\n\n\tcols = win_linetabsize(wp, rex.line, col);\n\tif (cols < start || cols > end - (*p_sel == 'e'))\n\t    return FALSE;\n    }\n    return TRUE;\n}", "func_hash": 273404837920170490390239404652231965596, "file_name": "regexp.c", "file_hash": 323022444375597496724509829879656182542, "cwe": ["CWE-416"], "cve": "CVE-2021-4192", "cve_desc": "vim is vulnerable to Use After Free", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-4192", "file_path": "src/regexp.c"}
