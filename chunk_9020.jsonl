{"idx": 210910, "project": "vim", "commit_id": "de05bb25733c3319e18dca44e9b59c6ee389eb26", "project_url": "https://github.com/vim/vim", "commit_url": "https://github.com/vim/vim/commit/de05bb25733c3319e18dca44e9b59c6ee389eb26", "commit_message": "patch 8.2.4074: going over the end of NameBuff\n\nProblem:    Going over the end of NameBuff.\nSolution:   Check length when appending a space.", "target": 1, "func": "win_redr_status(win_T *wp, int ignore_pum UNUSED)\n{\n    int\t\trow;\n    char_u\t*p;\n    int\t\tlen;\n    int\t\tfillchar;\n    int\t\tattr;\n    int\t\tthis_ru_col;\n    static int  busy = FALSE;\n\n    // It's possible to get here recursively when 'statusline' (indirectly)\n    // invokes \":redrawstatus\".  Simply ignore the call then.\n    if (busy)\n\treturn;\n    busy = TRUE;\n\n    row = statusline_row(wp);\n\n    wp->w_redr_status = FALSE;\n    if (wp->w_status_height == 0)\n    {\n\t// no status line, can only be last window\n\tredraw_cmdline = TRUE;\n    }\n    else if (!redrawing()\n\t    // don't update status line when popup menu is visible and may be\n\t    // drawn over it, unless it will be redrawn later\n\t    || (!ignore_pum && pum_visible()))\n    {\n\t// Don't redraw right now, do it later.\n\twp->w_redr_status = TRUE;\n    }\n#ifdef FEAT_STL_OPT\n    else if (*p_stl != NUL || *wp->w_p_stl != NUL)\n    {\n\t// redraw custom status line\n\tredraw_custom_statusline(wp);\n    }\n#endif\n    else\n    {\n\tfillchar = fillchar_status(&attr, wp);\n\n\tget_trans_bufname(wp->w_buffer);\n\tp = NameBuff;\n\tlen = (int)STRLEN(p);\n\n\tif (bt_help(wp->w_buffer)\n#ifdef FEAT_QUICKFIX\n\t\t|| wp->w_p_pvw\n#endif\n\t\t|| bufIsChanged(wp->w_buffer)\n\t\t|| wp->w_buffer->b_p_ro)\n\t    *(p + len++) = ' ';\n\tif (bt_help(wp->w_buffer))\n\t{\n\t    vim_snprintf((char *)p + len, MAXPATHL - len, \"%s\", _(\"[Help]\"));\n\t    len += (int)STRLEN(p + len);\n\t}\n#ifdef FEAT_QUICKFIX\n\tif (wp->w_p_pvw)\n\t{\n\t    vim_snprintf((char *)p + len, MAXPATHL - len, \"%s\", _(\"[Preview]\"));\n\t    len += (int)STRLEN(p + len);\n\t}\n#endif\n\tif (bufIsChanged(wp->w_buffer)\n#ifdef FEAT_TERMINAL\n\t\t&& !bt_terminal(wp->w_buffer)\n#endif\n\t\t)\n\t{\n\t    vim_snprintf((char *)p + len, MAXPATHL - len, \"%s\", \"[+]\");\n\t    len += (int)STRLEN(p + len);\n\t}\n\tif (wp->w_buffer->b_p_ro)\n\t{\n\t    vim_snprintf((char *)p + len, MAXPATHL - len, \"%s\", _(\"[RO]\"));\n\t    len += (int)STRLEN(p + len);\n\t}\n\n\tthis_ru_col = ru_col - (Columns - wp->w_width);\n\tif (this_ru_col < (wp->w_width + 1) / 2)\n\t    this_ru_col = (wp->w_width + 1) / 2;\n\tif (this_ru_col <= 1)\n\t{\n\t    p = (char_u *)\"<\";\t\t// No room for file name!\n\t    len = 1;\n\t}\n\telse if (has_mbyte)\n\t{\n\t    int\tclen = 0, i;\n\n\t    // Count total number of display cells.\n\t    clen = mb_string2cells(p, -1);\n\n\t    // Find first character that will fit.\n\t    // Going from start to end is much faster for DBCS.\n\t    for (i = 0; p[i] != NUL && clen >= this_ru_col - 1;\n\t\t    i += (*mb_ptr2len)(p + i))\n\t\tclen -= (*mb_ptr2cells)(p + i);\n\t    len = clen;\n\t    if (i > 0)\n\t    {\n\t\tp = p + i - 1;\n\t\t*p = '<';\n\t\t++len;\n\t    }\n\n\t}\n\telse if (len > this_ru_col - 1)\n\t{\n\t    p += len - (this_ru_col - 1);\n\t    *p = '<';\n\t    len = this_ru_col - 1;\n\t}\n\n\tscreen_puts(p, row, wp->w_wincol, attr);\n\tscreen_fill(row, row + 1, len + wp->w_wincol,\n\t\t\tthis_ru_col + wp->w_wincol, fillchar, fillchar, attr);\n\n\tif (get_keymap_str(wp, (char_u *)\"<%s>\", NameBuff, MAXPATHL)\n\t\t&& (int)(this_ru_col - len) > (int)(STRLEN(NameBuff) + 1))\n\t    screen_puts(NameBuff, row, (int)(this_ru_col - STRLEN(NameBuff)\n\t\t\t\t\t\t   - 1 + wp->w_wincol), attr);\n\n#ifdef FEAT_CMDL_INFO\n\twin_redr_ruler(wp, TRUE, ignore_pum);\n#endif\n    }\n\n    /*\n     * May need to draw the character below the vertical separator.\n     */\n    if (wp->w_vsep_width != 0 && wp->w_status_height != 0 && redrawing())\n    {\n\tif (stl_connected(wp))\n\t    fillchar = fillchar_status(&attr, wp);\n\telse\n\t    fillchar = fillchar_vsep(&attr);\n\tscreen_putchar(fillchar, row, W_ENDCOL(wp), attr);\n    }\n    busy = FALSE;\n}", "func_hash": 276232884514343858652101986950507308822, "file_name": "drawscreen.c", "file_hash": 10568928391803251582913255951861880853, "cwe": ["CWE-200"], "cve": "CVE-2022-0213", "cve_desc": "vim is vulnerable to Heap-based Buffer Overflow", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-0213", "file_path": "src/drawscreen.c"}
{"idx": 442959, "project": "vim", "commit_id": "de05bb25733c3319e18dca44e9b59c6ee389eb26", "project_url": "https://github.com/vim/vim", "commit_url": "https://github.com/vim/vim/commit/de05bb25733c3319e18dca44e9b59c6ee389eb26", "commit_message": "patch 8.2.4074: going over the end of NameBuff\n\nProblem:    Going over the end of NameBuff.\nSolution:   Check length when appending a space.", "target": 0, "func": "win_redr_status(win_T *wp, int ignore_pum UNUSED)\n{\n    int\t\trow;\n    char_u\t*p;\n    int\t\tlen;\n    int\t\tfillchar;\n    int\t\tattr;\n    int\t\tthis_ru_col;\n    static int  busy = FALSE;\n\n    // It's possible to get here recursively when 'statusline' (indirectly)\n    // invokes \":redrawstatus\".  Simply ignore the call then.\n    if (busy)\n\treturn;\n    busy = TRUE;\n\n    row = statusline_row(wp);\n\n    wp->w_redr_status = FALSE;\n    if (wp->w_status_height == 0)\n    {\n\t// no status line, can only be last window\n\tredraw_cmdline = TRUE;\n    }\n    else if (!redrawing()\n\t    // don't update status line when popup menu is visible and may be\n\t    // drawn over it, unless it will be redrawn later\n\t    || (!ignore_pum && pum_visible()))\n    {\n\t// Don't redraw right now, do it later.\n\twp->w_redr_status = TRUE;\n    }\n#ifdef FEAT_STL_OPT\n    else if (*p_stl != NUL || *wp->w_p_stl != NUL)\n    {\n\t// redraw custom status line\n\tredraw_custom_statusline(wp);\n    }\n#endif\n    else\n    {\n\tfillchar = fillchar_status(&attr, wp);\n\n\tget_trans_bufname(wp->w_buffer);\n\tp = NameBuff;\n\tlen = (int)STRLEN(p);\n\n\tif ((bt_help(wp->w_buffer)\n#ifdef FEAT_QUICKFIX\n\t\t    || wp->w_p_pvw\n#endif\n\t\t    || bufIsChanged(wp->w_buffer)\n\t\t    || wp->w_buffer->b_p_ro)\n\t\t&& len < MAXPATHL - 1)\n\t    *(p + len++) = ' ';\n\tif (bt_help(wp->w_buffer))\n\t{\n\t    vim_snprintf((char *)p + len, MAXPATHL - len, \"%s\", _(\"[Help]\"));\n\t    len += (int)STRLEN(p + len);\n\t}\n#ifdef FEAT_QUICKFIX\n\tif (wp->w_p_pvw)\n\t{\n\t    vim_snprintf((char *)p + len, MAXPATHL - len, \"%s\", _(\"[Preview]\"));\n\t    len += (int)STRLEN(p + len);\n\t}\n#endif\n\tif (bufIsChanged(wp->w_buffer)\n#ifdef FEAT_TERMINAL\n\t\t&& !bt_terminal(wp->w_buffer)\n#endif\n\t\t)\n\t{\n\t    vim_snprintf((char *)p + len, MAXPATHL - len, \"%s\", \"[+]\");\n\t    len += (int)STRLEN(p + len);\n\t}\n\tif (wp->w_buffer->b_p_ro)\n\t{\n\t    vim_snprintf((char *)p + len, MAXPATHL - len, \"%s\", _(\"[RO]\"));\n\t    len += (int)STRLEN(p + len);\n\t}\n\n\tthis_ru_col = ru_col - (Columns - wp->w_width);\n\tif (this_ru_col < (wp->w_width + 1) / 2)\n\t    this_ru_col = (wp->w_width + 1) / 2;\n\tif (this_ru_col <= 1)\n\t{\n\t    p = (char_u *)\"<\";\t\t// No room for file name!\n\t    len = 1;\n\t}\n\telse if (has_mbyte)\n\t{\n\t    int\tclen = 0, i;\n\n\t    // Count total number of display cells.\n\t    clen = mb_string2cells(p, -1);\n\n\t    // Find first character that will fit.\n\t    // Going from start to end is much faster for DBCS.\n\t    for (i = 0; p[i] != NUL && clen >= this_ru_col - 1;\n\t\t    i += (*mb_ptr2len)(p + i))\n\t\tclen -= (*mb_ptr2cells)(p + i);\n\t    len = clen;\n\t    if (i > 0)\n\t    {\n\t\tp = p + i - 1;\n\t\t*p = '<';\n\t\t++len;\n\t    }\n\n\t}\n\telse if (len > this_ru_col - 1)\n\t{\n\t    p += len - (this_ru_col - 1);\n\t    *p = '<';\n\t    len = this_ru_col - 1;\n\t}\n\n\tscreen_puts(p, row, wp->w_wincol, attr);\n\tscreen_fill(row, row + 1, len + wp->w_wincol,\n\t\t\tthis_ru_col + wp->w_wincol, fillchar, fillchar, attr);\n\n\tif (get_keymap_str(wp, (char_u *)\"<%s>\", NameBuff, MAXPATHL)\n\t\t&& (int)(this_ru_col - len) > (int)(STRLEN(NameBuff) + 1))\n\t    screen_puts(NameBuff, row, (int)(this_ru_col - STRLEN(NameBuff)\n\t\t\t\t\t\t   - 1 + wp->w_wincol), attr);\n\n#ifdef FEAT_CMDL_INFO\n\twin_redr_ruler(wp, TRUE, ignore_pum);\n#endif\n    }\n\n    /*\n     * May need to draw the character below the vertical separator.\n     */\n    if (wp->w_vsep_width != 0 && wp->w_status_height != 0 && redrawing())\n    {\n\tif (stl_connected(wp))\n\t    fillchar = fillchar_status(&attr, wp);\n\telse\n\t    fillchar = fillchar_vsep(&attr);\n\tscreen_putchar(fillchar, row, W_ENDCOL(wp), attr);\n    }\n    busy = FALSE;\n}", "func_hash": 176741267087496295201275228908142268974, "file_name": "drawscreen.c", "file_hash": 281263511995685251557666010606597186752, "cwe": ["CWE-200"], "cve": "CVE-2022-0213", "cve_desc": "vim is vulnerable to Heap-based Buffer Overflow", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-0213", "file_path": "src/drawscreen.c"}
{"idx": 210928, "project": "linux", "commit_id": "a53046291020ec41e09181396c1e829287b48d47", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/a53046291020ec41e09181396c1e829287b48d47", "commit_message": "jfs: prevent NULL deref in diFree\n\nAdd validation check for JFS_IP(ipimap)->i_imap to prevent a NULL deref\nin diFree since diFree uses it without do any validations.\nWhen function jfs_mount calls diMount to initialize fileset inode\nallocation map, it can fail and JFS_IP(ipimap)->i_imap won't be\ninitialized. Then it calls diFreeSpecial to close fileset inode allocation\nmap inode and it will flow into jfs_evict_inode. Function jfs_evict_inode\njust validates JFS_SBI(inode->i_sb)->ipimap, then calls diFree. diFree use\nJFS_IP(ipimap)->i_imap directly, then it will cause a NULL deref.\n\nReported-by: TCS Robot <tcs_robot@tencent.com>\nSigned-off-by: Haimin Zhang <tcs_kernel@tencent.com>\nSigned-off-by: Dave Kleikamp <dave.kleikamp@oracle.com>", "target": 1, "func": "void jfs_evict_inode(struct inode *inode)\n{\n\tstruct jfs_inode_info *ji = JFS_IP(inode);\n\n\tjfs_info(\"In jfs_evict_inode, inode = 0x%p\", inode);\n\n\tif (!inode->i_nlink && !is_bad_inode(inode)) {\n\t\tdquot_initialize(inode);\n\n\t\tif (JFS_IP(inode)->fileset == FILESYSTEM_I) {\n\t\t\ttruncate_inode_pages_final(&inode->i_data);\n\n\t\t\tif (test_cflag(COMMIT_Freewmap, inode))\n\t\t\t\tjfs_free_zero_link(inode);\n\n\t\t\tif (JFS_SBI(inode->i_sb)->ipimap)\n\t\t\t\tdiFree(inode);\n\n\t\t\t/*\n\t\t\t * Free the inode from the quota allocation.\n\t\t\t */\n\t\t\tdquot_free_inode(inode);\n\t\t}\n\t} else {\n\t\ttruncate_inode_pages_final(&inode->i_data);\n\t}\n\tclear_inode(inode);\n\tdquot_drop(inode);\n\n\tBUG_ON(!list_empty(&ji->anon_inode_list));\n\n\tspin_lock_irq(&ji->ag_lock);\n\tif (ji->active_ag != -1) {\n\t\tstruct bmap *bmap = JFS_SBI(inode->i_sb)->bmap;\n\t\tatomic_dec(&bmap->db_active[ji->active_ag]);\n\t\tji->active_ag = -1;\n\t}\n\tspin_unlock_irq(&ji->ag_lock);\n}", "func_hash": 20578307712540502105112089793785958875, "file_name": "inode.c", "file_hash": 290805170238030320123014907894669021558, "cwe": ["CWE-476"], "cve": "CVE-2022-3202", "cve_desc": "A NULL pointer dereference flaw in diFree in fs/jfs/inode.c in Journaled File System (JFS)in the Linux kernel. This could allow a local attacker to crash the system or leak kernel internal information.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-3202", "file_path": "fs/inode.c"}
{"idx": 443152, "project": "linux", "commit_id": "a53046291020ec41e09181396c1e829287b48d47", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/a53046291020ec41e09181396c1e829287b48d47", "commit_message": "jfs: prevent NULL deref in diFree\n\nAdd validation check for JFS_IP(ipimap)->i_imap to prevent a NULL deref\nin diFree since diFree uses it without do any validations.\nWhen function jfs_mount calls diMount to initialize fileset inode\nallocation map, it can fail and JFS_IP(ipimap)->i_imap won't be\ninitialized. Then it calls diFreeSpecial to close fileset inode allocation\nmap inode and it will flow into jfs_evict_inode. Function jfs_evict_inode\njust validates JFS_SBI(inode->i_sb)->ipimap, then calls diFree. diFree use\nJFS_IP(ipimap)->i_imap directly, then it will cause a NULL deref.\n\nReported-by: TCS Robot <tcs_robot@tencent.com>\nSigned-off-by: Haimin Zhang <tcs_kernel@tencent.com>\nSigned-off-by: Dave Kleikamp <dave.kleikamp@oracle.com>", "target": 0, "func": "void jfs_evict_inode(struct inode *inode)\n{\n\tstruct jfs_inode_info *ji = JFS_IP(inode);\n\n\tjfs_info(\"In jfs_evict_inode, inode = 0x%p\", inode);\n\n\tif (!inode->i_nlink && !is_bad_inode(inode)) {\n\t\tdquot_initialize(inode);\n\n\t\tif (JFS_IP(inode)->fileset == FILESYSTEM_I) {\n\t\t\tstruct inode *ipimap = JFS_SBI(inode->i_sb)->ipimap;\n\t\t\ttruncate_inode_pages_final(&inode->i_data);\n\n\t\t\tif (test_cflag(COMMIT_Freewmap, inode))\n\t\t\t\tjfs_free_zero_link(inode);\n\n\t\t\tif (ipimap && JFS_IP(ipimap)->i_imap)\n\t\t\t\tdiFree(inode);\n\n\t\t\t/*\n\t\t\t * Free the inode from the quota allocation.\n\t\t\t */\n\t\t\tdquot_free_inode(inode);\n\t\t}\n\t} else {\n\t\ttruncate_inode_pages_final(&inode->i_data);\n\t}\n\tclear_inode(inode);\n\tdquot_drop(inode);\n\n\tBUG_ON(!list_empty(&ji->anon_inode_list));\n\n\tspin_lock_irq(&ji->ag_lock);\n\tif (ji->active_ag != -1) {\n\t\tstruct bmap *bmap = JFS_SBI(inode->i_sb)->bmap;\n\t\tatomic_dec(&bmap->db_active[ji->active_ag]);\n\t\tji->active_ag = -1;\n\t}\n\tspin_unlock_irq(&ji->ag_lock);\n}", "func_hash": 19343683273845236904792229610406110241, "file_name": "inode.c", "file_hash": 328882647920718394331416110787337999080, "cwe": ["CWE-476"], "cve": "CVE-2022-3202", "cve_desc": "A NULL pointer dereference flaw in diFree in fs/jfs/inode.c in Journaled File System (JFS)in the Linux kernel. This could allow a local attacker to crash the system or leak kernel internal information.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-3202", "file_path": "fs/inode.c"}
{"idx": 210944, "project": "vim", "commit_id": "35d21c6830fc2d68aca838424a0e786821c5891c", "project_url": "https://github.com/vim/vim", "commit_url": "https://github.com/vim/vim/commit/35d21c6830fc2d68aca838424a0e786821c5891c", "commit_message": "patch 9.0.0360: crash when invalid line number on :for is ignored\n\nProblem:    Crash when invalid line number on :for is ignored.\nSolution:   Do not check breakpoint for non-existing line.", "target": 1, "func": "do_cmdline(\n    char_u\t*cmdline,\n    char_u\t*(*fgetline)(int, void *, int, getline_opt_T),\n    void\t*cookie,\t\t// argument for fgetline()\n    int\t\tflags)\n{\n    char_u\t*next_cmdline;\t\t// next cmd to execute\n    char_u\t*cmdline_copy = NULL;\t// copy of cmd line\n    int\t\tused_getline = FALSE;\t// used \"fgetline\" to obtain command\n    static int\trecursive = 0;\t\t// recursive depth\n    int\t\tmsg_didout_before_start = 0;\n    int\t\tcount = 0;\t\t// line number count\n    int\t\tdid_inc = FALSE;\t// incremented RedrawingDisabled\n    int\t\tretval = OK;\n#ifdef FEAT_EVAL\n    cstack_T\tcstack;\t\t\t// conditional stack\n    garray_T\tlines_ga;\t\t// keep lines for \":while\"/\":for\"\n    int\t\tcurrent_line = 0;\t// active line in lines_ga\n    int\t\tcurrent_line_before = 0;\n    char_u\t*fname = NULL;\t\t// function or script name\n    linenr_T\t*breakpoint = NULL;\t// ptr to breakpoint field in cookie\n    int\t\t*dbg_tick = NULL;\t// ptr to dbg_tick field in cookie\n    struct dbg_stuff debug_saved;\t// saved things for debug mode\n    int\t\tinitial_trylevel;\n    msglist_T\t**saved_msg_list = NULL;\n    msglist_T\t*private_msg_list = NULL;\n\n    // \"fgetline\" and \"cookie\" passed to do_one_cmd()\n    char_u\t*(*cmd_getline)(int, void *, int, getline_opt_T);\n    void\t*cmd_cookie;\n    struct loop_cookie cmd_loop_cookie;\n    void\t*real_cookie;\n    int\t\tgetline_is_func;\n#else\n# define cmd_getline fgetline\n# define cmd_cookie cookie\n#endif\n    static int\tcall_depth = 0;\t\t// recursiveness\n#ifdef FEAT_EVAL\n    // For every pair of do_cmdline()/do_one_cmd() calls, use an extra memory\n    // location for storing error messages to be converted to an exception.\n    // This ensures that the do_errthrow() call in do_one_cmd() does not\n    // combine the messages stored by an earlier invocation of do_one_cmd()\n    // with the command name of the later one.  This would happen when\n    // BufWritePost autocommands are executed after a write error.\n    saved_msg_list = msg_list;\n    msg_list = &private_msg_list;\n#endif\n\n    // It's possible to create an endless loop with \":execute\", catch that\n    // here.  The value of 200 allows nested function calls, \":source\", etc.\n    // Allow 200 or 'maxfuncdepth', whatever is larger.\n    if (call_depth >= 200\n#ifdef FEAT_EVAL\n\t    && call_depth >= p_mfd\n#endif\n\t    )\n    {\n\temsg(_(e_command_too_recursive));\n#ifdef FEAT_EVAL\n\t// When converting to an exception, we do not include the command name\n\t// since this is not an error of the specific command.\n\tdo_errthrow((cstack_T *)NULL, (char_u *)NULL);\n\tmsg_list = saved_msg_list;\n#endif\n\treturn FAIL;\n    }\n    ++call_depth;\n\n#ifdef FEAT_EVAL\n    CLEAR_FIELD(cstack);\n    cstack.cs_idx = -1;\n    ga_init2(&lines_ga, sizeof(wcmd_T), 10);\n\n    real_cookie = getline_cookie(fgetline, cookie);\n\n    // Inside a function use a higher nesting level.\n    getline_is_func = getline_equal(fgetline, cookie, get_func_line);\n    if (getline_is_func && ex_nesting_level == func_level(real_cookie))\n\t++ex_nesting_level;\n\n    // Get the function or script name and the address where the next breakpoint\n    // line and the debug tick for a function or script are stored.\n    if (getline_is_func)\n    {\n\tfname = func_name(real_cookie);\n\tbreakpoint = func_breakpoint(real_cookie);\n\tdbg_tick = func_dbg_tick(real_cookie);\n    }\n    else if (getline_equal(fgetline, cookie, getsourceline))\n    {\n\tfname = SOURCING_NAME;\n\tbreakpoint = source_breakpoint(real_cookie);\n\tdbg_tick = source_dbg_tick(real_cookie);\n    }\n\n    /*\n     * Initialize \"force_abort\"  and \"suppress_errthrow\" at the top level.\n     */\n    if (!recursive)\n    {\n\tforce_abort = FALSE;\n\tsuppress_errthrow = FALSE;\n    }\n\n    /*\n     * If requested, store and reset the global values controlling the\n     * exception handling (used when debugging).  Otherwise clear it to avoid\n     * a bogus compiler warning when the optimizer uses inline functions...\n     */\n    if (flags & DOCMD_EXCRESET)\n\tsave_dbg_stuff(&debug_saved);\n    else\n\tCLEAR_FIELD(debug_saved);\n\n    initial_trylevel = trylevel;\n\n    /*\n     * \"did_throw\" will be set to TRUE when an exception is being thrown.\n     */\n    did_throw = FALSE;\n#endif\n    /*\n     * \"did_emsg\" will be set to TRUE when emsg() is used, in which case we\n     * cancel the whole command line, and any if/endif or loop.\n     * If force_abort is set, we cancel everything.\n     */\n#ifdef FEAT_EVAL\n    did_emsg_cumul += did_emsg;\n#endif\n    did_emsg = FALSE;\n\n    /*\n     * KeyTyped is only set when calling vgetc().  Reset it here when not\n     * calling vgetc() (sourced command lines).\n     */\n    if (!(flags & DOCMD_KEYTYPED)\n\t\t\t       && !getline_equal(fgetline, cookie, getexline))\n\tKeyTyped = FALSE;\n\n    /*\n     * Continue executing command lines:\n     * - when inside an \":if\", \":while\" or \":for\"\n     * - for multiple commands on one line, separated with '|'\n     * - when repeating until there are no more lines (for \":source\")\n     */\n    next_cmdline = cmdline;\n    do\n    {\n#ifdef FEAT_EVAL\n\tgetline_is_func = getline_equal(fgetline, cookie, get_func_line);\n#endif\n\n\t// stop skipping cmds for an error msg after all endif/while/for\n\tif (next_cmdline == NULL\n#ifdef FEAT_EVAL\n\t\t&& !force_abort\n\t\t&& cstack.cs_idx < 0\n\t\t&& !(getline_is_func && func_has_abort(real_cookie))\n#endif\n\t\t\t\t\t\t\t)\n\t{\n#ifdef FEAT_EVAL\n\t    did_emsg_cumul += did_emsg;\n#endif\n\t    did_emsg = FALSE;\n\t}\n\n\t/*\n\t * 1. If repeating a line in a loop, get a line from lines_ga.\n\t * 2. If no line given: Get an allocated line with fgetline().\n\t * 3. If a line is given: Make a copy, so we can mess with it.\n\t */\n\n#ifdef FEAT_EVAL\n\t// 1. If repeating, get a previous line from lines_ga.\n\tif (cstack.cs_looplevel > 0 && current_line < lines_ga.ga_len)\n\t{\n\t    // Each '|' separated command is stored separately in lines_ga, to\n\t    // be able to jump to it.  Don't use next_cmdline now.\n\t    VIM_CLEAR(cmdline_copy);\n\n\t    // Check if a function has returned or, unless it has an unclosed\n\t    // try conditional, aborted.\n\t    if (getline_is_func)\n\t    {\n# ifdef FEAT_PROFILE\n\t\tif (do_profiling == PROF_YES)\n\t\t    func_line_end(real_cookie);\n# endif\n\t\tif (func_has_ended(real_cookie))\n\t\t{\n\t\t    retval = FAIL;\n\t\t    break;\n\t\t}\n\t    }\n#ifdef FEAT_PROFILE\n\t    else if (do_profiling == PROF_YES\n\t\t\t    && getline_equal(fgetline, cookie, getsourceline))\n\t\tscript_line_end();\n#endif\n\n\t    // Check if a sourced file hit a \":finish\" command.\n\t    if (source_finished(fgetline, cookie))\n\t    {\n\t\tretval = FAIL;\n\t\tbreak;\n\t    }\n\n\t    // If breakpoints have been added/deleted need to check for it.\n\t    if (breakpoint != NULL && dbg_tick != NULL\n\t\t\t\t\t\t   && *dbg_tick != debug_tick)\n\t    {\n\t\t*breakpoint = dbg_find_breakpoint(\n\t\t\t\tgetline_equal(fgetline, cookie, getsourceline),\n\t\t\t\t\t\t\tfname, SOURCING_LNUM);\n\t\t*dbg_tick = debug_tick;\n\t    }\n\n\t    next_cmdline = ((wcmd_T *)(lines_ga.ga_data))[current_line].line;\n\t    SOURCING_LNUM = ((wcmd_T *)(lines_ga.ga_data))[current_line].lnum;\n\n\t    // Did we encounter a breakpoint?\n\t    if (breakpoint != NULL && *breakpoint != 0\n\t\t\t\t\t      && *breakpoint <= SOURCING_LNUM)\n\t    {\n\t\tdbg_breakpoint(fname, SOURCING_LNUM);\n\t\t// Find next breakpoint.\n\t\t*breakpoint = dbg_find_breakpoint(\n\t\t\t       getline_equal(fgetline, cookie, getsourceline),\n\t\t\t\t\t\t\tfname, SOURCING_LNUM);\n\t\t*dbg_tick = debug_tick;\n\t    }\n# ifdef FEAT_PROFILE\n\t    if (do_profiling == PROF_YES)\n\t    {\n\t\tif (getline_is_func)\n\t\t    func_line_start(real_cookie, SOURCING_LNUM);\n\t\telse if (getline_equal(fgetline, cookie, getsourceline))\n\t\t    script_line_start();\n\t    }\n# endif\n\t}\n#endif\n\n\t// 2. If no line given, get an allocated line with fgetline().\n\tif (next_cmdline == NULL)\n\t{\n\t    /*\n\t     * Need to set msg_didout for the first line after an \":if\",\n\t     * otherwise the \":if\" will be overwritten.\n\t     */\n\t    if (count == 1 && getline_equal(fgetline, cookie, getexline))\n\t\tmsg_didout = TRUE;\n\t    if (fgetline == NULL || (next_cmdline = fgetline(':', cookie,\n#ifdef FEAT_EVAL\n\t\t    cstack.cs_idx < 0 ? 0 : (cstack.cs_idx + 1) * 2\n#else\n\t\t    0\n#endif\n\t\t    , in_vim9script() ? GETLINE_CONCAT_CONTBAR\n\t\t\t\t\t       : GETLINE_CONCAT_CONT)) == NULL)\n\t    {\n\t\t// Don't call wait_return() for aborted command line.  The NULL\n\t\t// returned for the end of a sourced file or executed function\n\t\t// doesn't do this.\n\t\tif (KeyTyped && !(flags & DOCMD_REPEAT))\n\t\t    need_wait_return = FALSE;\n\t\tretval = FAIL;\n\t\tbreak;\n\t    }\n\t    used_getline = TRUE;\n\n\t    /*\n\t     * Keep the first typed line.  Clear it when more lines are typed.\n\t     */\n\t    if (flags & DOCMD_KEEPLINE)\n\t    {\n\t\tvim_free(repeat_cmdline);\n\t\tif (count == 0)\n\t\t    repeat_cmdline = vim_strsave(next_cmdline);\n\t\telse\n\t\t    repeat_cmdline = NULL;\n\t    }\n\t}\n\n\t// 3. Make a copy of the command so we can mess with it.\n\telse if (cmdline_copy == NULL)\n\t{\n\t    next_cmdline = vim_strsave(next_cmdline);\n\t    if (next_cmdline == NULL)\n\t    {\n\t\temsg(_(e_out_of_memory));\n\t\tretval = FAIL;\n\t\tbreak;\n\t    }\n\t}\n\tcmdline_copy = next_cmdline;\n\n#ifdef FEAT_EVAL\n\t/*\n\t * Inside a while/for loop, and when the command looks like a \":while\"\n\t * or \":for\", the line is stored, because we may need it later when\n\t * looping.\n\t *\n\t * When there is a '|' and another command, it is stored separately,\n\t * because we need to be able to jump back to it from an\n\t * :endwhile/:endfor.\n\t *\n\t * Pass a different \"fgetline\" function to do_one_cmd() below,\n\t * that it stores lines in or reads them from \"lines_ga\".  Makes it\n\t * possible to define a function inside a while/for loop and handles\n\t * line continuation.\n\t */\n\tif ((cstack.cs_looplevel > 0 || has_loop_cmd(next_cmdline)))\n\t{\n\t    cmd_getline = get_loop_line;\n\t    cmd_cookie = (void *)&cmd_loop_cookie;\n\t    cmd_loop_cookie.lines_gap = &lines_ga;\n\t    cmd_loop_cookie.current_line = current_line;\n\t    cmd_loop_cookie.getline = fgetline;\n\t    cmd_loop_cookie.cookie = cookie;\n\t    cmd_loop_cookie.repeating = (current_line < lines_ga.ga_len);\n\n\t    // Save the current line when encountering it the first time.\n\t    if (current_line == lines_ga.ga_len\n\t\t    && store_loop_line(&lines_ga, next_cmdline) == FAIL)\n\t    {\n\t\tretval = FAIL;\n\t\tbreak;\n\t    }\n\t    current_line_before = current_line;\n\t}\n\telse\n\t{\n\t    cmd_getline = fgetline;\n\t    cmd_cookie = cookie;\n\t}\n\n\tdid_endif = FALSE;\n#endif\n\n\tif (count++ == 0)\n\t{\n\t    /*\n\t     * All output from the commands is put below each other, without\n\t     * waiting for a return. Don't do this when executing commands\n\t     * from a script or when being called recursive (e.g. for \":e\n\t     * +command file\").\n\t     */\n\t    if (!(flags & DOCMD_NOWAIT) && !recursive)\n\t    {\n\t\tmsg_didout_before_start = msg_didout;\n\t\tmsg_didany = FALSE; // no output yet\n\t\tmsg_start();\n\t\tmsg_scroll = TRUE;  // put messages below each other\n\t\t++no_wait_return;   // don't wait for return until finished\n\t\t++RedrawingDisabled;\n\t\tdid_inc = TRUE;\n\t    }\n\t}\n\n\tif ((p_verbose >= 15 && SOURCING_NAME != NULL) || p_verbose >= 16)\n\t    msg_verbose_cmd(SOURCING_LNUM, cmdline_copy);\n\n\t/*\n\t * 2. Execute one '|' separated command.\n\t *    do_one_cmd() will return NULL if there is no trailing '|'.\n\t *    \"cmdline_copy\" can change, e.g. for '%' and '#' expansion.\n\t */\n\t++recursive;\n\tnext_cmdline = do_one_cmd(&cmdline_copy, flags,\n#ifdef FEAT_EVAL\n\t\t\t\t&cstack,\n#endif\n\t\t\t\tcmd_getline, cmd_cookie);\n\t--recursive;\n\n#ifdef FEAT_EVAL\n\tif (cmd_cookie == (void *)&cmd_loop_cookie)\n\t    // Use \"current_line\" from \"cmd_loop_cookie\", it may have been\n\t    // incremented when defining a function.\n\t    current_line = cmd_loop_cookie.current_line;\n#endif\n\n\tif (next_cmdline == NULL)\n\t{\n\t    VIM_CLEAR(cmdline_copy);\n\n\t    /*\n\t     * If the command was typed, remember it for the ':' register.\n\t     * Do this AFTER executing the command to make :@: work.\n\t     */\n\t    if (getline_equal(fgetline, cookie, getexline)\n\t\t\t\t\t\t  && new_last_cmdline != NULL)\n\t    {\n\t\tvim_free(last_cmdline);\n\t\tlast_cmdline = new_last_cmdline;\n\t\tnew_last_cmdline = NULL;\n\t    }\n\t}\n\telse\n\t{\n\t    // need to copy the command after the '|' to cmdline_copy, for the\n\t    // next do_one_cmd()\n\t    STRMOVE(cmdline_copy, next_cmdline);\n\t    next_cmdline = cmdline_copy;\n\t}\n\n\n#ifdef FEAT_EVAL\n\t// reset did_emsg for a function that is not aborted by an error\n\tif (did_emsg && !force_abort\n\t\t&& getline_equal(fgetline, cookie, get_func_line)\n\t\t\t\t\t      && !func_has_abort(real_cookie))\n\t{\n\t    // did_emsg_cumul is not set here\n\t    did_emsg = FALSE;\n\t}\n\n\tif (cstack.cs_looplevel > 0)\n\t{\n\t    ++current_line;\n\n\t    /*\n\t     * An \":endwhile\", \":endfor\" and \":continue\" is handled here.\n\t     * If we were executing commands, jump back to the \":while\" or\n\t     * \":for\".\n\t     * If we were not executing commands, decrement cs_looplevel.\n\t     */\n\t    if (cstack.cs_lflags & (CSL_HAD_CONT | CSL_HAD_ENDLOOP))\n\t    {\n\t\tcstack.cs_lflags &= ~(CSL_HAD_CONT | CSL_HAD_ENDLOOP);\n\n\t\t// Jump back to the matching \":while\" or \":for\".  Be careful\n\t\t// not to use a cs_line[] from an entry that isn't a \":while\"\n\t\t// or \":for\": It would make \"current_line\" invalid and can\n\t\t// cause a crash.\n\t\tif (!did_emsg && !got_int && !did_throw\n\t\t\t&& cstack.cs_idx >= 0\n\t\t\t&& (cstack.cs_flags[cstack.cs_idx]\n\t\t\t\t\t\t      & (CSF_WHILE | CSF_FOR))\n\t\t\t&& cstack.cs_line[cstack.cs_idx] >= 0\n\t\t\t&& (cstack.cs_flags[cstack.cs_idx] & CSF_ACTIVE))\n\t\t{\n\t\t    current_line = cstack.cs_line[cstack.cs_idx];\n\t\t\t\t\t\t// remember we jumped there\n\t\t    cstack.cs_lflags |= CSL_HAD_LOOP;\n\t\t    line_breakcheck();\t\t// check if CTRL-C typed\n\n\t\t    // Check for the next breakpoint at or after the \":while\"\n\t\t    // or \":for\".\n\t\t    if (breakpoint != NULL)\n\t\t    {\n\t\t\t*breakpoint = dbg_find_breakpoint(\n\t\t\t       getline_equal(fgetline, cookie, getsourceline),\n\t\t\t\t\t\t\t\t\tfname,\n\t\t\t   ((wcmd_T *)lines_ga.ga_data)[current_line].lnum-1);\n\t\t\t*dbg_tick = debug_tick;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    // can only get here with \":endwhile\" or \":endfor\"\n\t\t    if (cstack.cs_idx >= 0)\n\t\t\trewind_conditionals(&cstack, cstack.cs_idx - 1,\n\t\t\t\t   CSF_WHILE | CSF_FOR, &cstack.cs_looplevel);\n\t\t}\n\t    }\n\n\t    /*\n\t     * For a \":while\" or \":for\" we need to remember the line number.\n\t     */\n\t    else if (cstack.cs_lflags & CSL_HAD_LOOP)\n\t    {\n\t\tcstack.cs_lflags &= ~CSL_HAD_LOOP;\n\t\tcstack.cs_line[cstack.cs_idx] = current_line_before;\n\t    }\n\t}\n\n\t// Check for the next breakpoint after a watchexpression\n\tif (breakpoint != NULL && has_watchexpr())\n\t{\n\t    *breakpoint = dbg_find_breakpoint(FALSE, fname, SOURCING_LNUM);\n\t    *dbg_tick = debug_tick;\n\t}\n\n\t/*\n\t * When not inside any \":while\" loop, clear remembered lines.\n\t */\n\tif (cstack.cs_looplevel == 0)\n\t{\n\t    if (lines_ga.ga_len > 0)\n\t    {\n\t\tSOURCING_LNUM =\n\t\t       ((wcmd_T *)lines_ga.ga_data)[lines_ga.ga_len - 1].lnum;\n\t\tfree_cmdlines(&lines_ga);\n\t    }\n\t    current_line = 0;\n\t}\n\n\t/*\n\t * A \":finally\" makes did_emsg, got_int, and did_throw pending for\n\t * being restored at the \":endtry\".  Reset them here and set the\n\t * ACTIVE and FINALLY flags, so that the finally clause gets executed.\n\t * This includes the case where a missing \":endif\", \":endwhile\" or\n\t * \":endfor\" was detected by the \":finally\" itself.\n\t */\n\tif (cstack.cs_lflags & CSL_HAD_FINA)\n\t{\n\t    cstack.cs_lflags &= ~CSL_HAD_FINA;\n\t    report_make_pending(cstack.cs_pending[cstack.cs_idx]\n\t\t    & (CSTP_ERROR | CSTP_INTERRUPT | CSTP_THROW),\n\t\t    did_throw ? (void *)current_exception : NULL);\n\t    did_emsg = got_int = did_throw = FALSE;\n\t    cstack.cs_flags[cstack.cs_idx] |= CSF_ACTIVE | CSF_FINALLY;\n\t}\n\n\t// Update global \"trylevel\" for recursive calls to do_cmdline() from\n\t// within this loop.\n\ttrylevel = initial_trylevel + cstack.cs_trylevel;\n\n\t/*\n\t * If the outermost try conditional (across function calls and sourced\n\t * files) is aborted because of an error, an interrupt, or an uncaught\n\t * exception, cancel everything.  If it is left normally, reset\n\t * force_abort to get the non-EH compatible abortion behavior for\n\t * the rest of the script.\n\t */\n\tif (trylevel == 0 && !did_emsg && !got_int && !did_throw)\n\t    force_abort = FALSE;\n\n\t// Convert an interrupt to an exception if appropriate.\n\t(void)do_intthrow(&cstack);\n#endif // FEAT_EVAL\n\n    }\n    /*\n     * Continue executing command lines when:\n     * - no CTRL-C typed, no aborting error, no exception thrown or try\n     *   conditionals need to be checked for executing finally clauses or\n     *   catching an interrupt exception\n     * - didn't get an error message or lines are not typed\n     * - there is a command after '|', inside a :if, :while, :for or :try, or\n     *   looping for \":source\" command or function call.\n     */\n    while (!((got_int\n#ifdef FEAT_EVAL\n\t\t    || (did_emsg && (force_abort || in_vim9script()))\n\t\t    || did_throw\n#endif\n\t     )\n#ifdef FEAT_EVAL\n\t\t&& cstack.cs_trylevel == 0\n#endif\n\t    )\n\t    && !(did_emsg\n#ifdef FEAT_EVAL\n\t\t// Keep going when inside try/catch, so that the error can be\n\t\t// deal with, except when it is a syntax error, it may cause\n\t\t// the :endtry to be missed.\n\t\t&& (cstack.cs_trylevel == 0 || did_emsg_syntax)\n#endif\n\t\t&& used_getline\n\t\t\t    && (getline_equal(fgetline, cookie, getexmodeline)\n\t\t\t       || getline_equal(fgetline, cookie, getexline)))\n\t    && (next_cmdline != NULL\n#ifdef FEAT_EVAL\n\t\t\t|| cstack.cs_idx >= 0\n#endif\n\t\t\t|| (flags & DOCMD_REPEAT)));\n\n    vim_free(cmdline_copy);\n    did_emsg_syntax = FALSE;\n#ifdef FEAT_EVAL\n    free_cmdlines(&lines_ga);\n    ga_clear(&lines_ga);\n\n    if (cstack.cs_idx >= 0)\n    {\n\t/*\n\t * If a sourced file or executed function ran to its end, report the\n\t * unclosed conditional.\n\t * In Vim9 script do not give a second error, executing aborts after\n\t * the first one.\n\t */\n\tif (!got_int && !did_throw && !aborting()\n\t\t&& !(did_emsg && in_vim9script())\n\t\t&& ((getline_equal(fgetline, cookie, getsourceline)\n\t\t\t&& !source_finished(fgetline, cookie))\n\t\t    || (getline_equal(fgetline, cookie, get_func_line)\n\t\t\t\t\t    && !func_has_ended(real_cookie))))\n\t{\n\t    if (cstack.cs_flags[cstack.cs_idx] & CSF_TRY)\n\t\temsg(_(e_missing_endtry));\n\t    else if (cstack.cs_flags[cstack.cs_idx] & CSF_WHILE)\n\t\temsg(_(e_missing_endwhile));\n\t    else if (cstack.cs_flags[cstack.cs_idx] & CSF_FOR)\n\t\temsg(_(e_missing_endfor));\n\t    else\n\t\temsg(_(e_missing_endif));\n\t}\n\n\t/*\n\t * Reset \"trylevel\" in case of a \":finish\" or \":return\" or a missing\n\t * \":endtry\" in a sourced file or executed function.  If the try\n\t * conditional is in its finally clause, ignore anything pending.\n\t * If it is in a catch clause, finish the caught exception.\n\t * Also cleanup any \"cs_forinfo\" structures.\n\t */\n\tdo\n\t{\n\t    int idx = cleanup_conditionals(&cstack, 0, TRUE);\n\n\t    if (idx >= 0)\n\t\t--idx;\t    // remove try block not in its finally clause\n\t    rewind_conditionals(&cstack, idx, CSF_WHILE | CSF_FOR,\n\t\t\t\t\t\t\t&cstack.cs_looplevel);\n\t}\n\twhile (cstack.cs_idx >= 0);\n\ttrylevel = initial_trylevel;\n    }\n\n    // If a missing \":endtry\", \":endwhile\", \":endfor\", or \":endif\" or a memory\n    // lack was reported above and the error message is to be converted to an\n    // exception, do this now after rewinding the cstack.\n    do_errthrow(&cstack, getline_equal(fgetline, cookie, get_func_line)\n\t\t\t\t  ? (char_u *)\"endfunction\" : (char_u *)NULL);\n\n    if (trylevel == 0)\n    {\n\t// Just in case did_throw got set but current_exception wasn't.\n\tif (current_exception == NULL)\n\t    did_throw = FALSE;\n\n\t/*\n\t * When an exception is being thrown out of the outermost try\n\t * conditional, discard the uncaught exception, disable the conversion\n\t * of interrupts or errors to exceptions, and ensure that no more\n\t * commands are executed.\n\t */\n\tif (did_throw)\n\t    handle_did_throw();\n\n\t/*\n\t * On an interrupt or an aborting error not converted to an exception,\n\t * disable the conversion of errors to exceptions.  (Interrupts are not\n\t * converted anymore, here.) This enables also the interrupt message\n\t * when force_abort is set and did_emsg unset in case of an interrupt\n\t * from a finally clause after an error.\n\t */\n\telse if (got_int || (did_emsg && force_abort))\n\t    suppress_errthrow = TRUE;\n    }\n\n    /*\n     * The current cstack will be freed when do_cmdline() returns.  An uncaught\n     * exception will have to be rethrown in the previous cstack.  If a function\n     * has just returned or a script file was just finished and the previous\n     * cstack belongs to the same function or, respectively, script file, it\n     * will have to be checked for finally clauses to be executed due to the\n     * \":return\" or \":finish\".  This is done in do_one_cmd().\n     */\n    if (did_throw)\n\tneed_rethrow = TRUE;\n    if ((getline_equal(fgetline, cookie, getsourceline)\n\t\t&& ex_nesting_level > source_level(real_cookie))\n\t    || (getline_equal(fgetline, cookie, get_func_line)\n\t\t&& ex_nesting_level > func_level(real_cookie) + 1))\n    {\n\tif (!did_throw)\n\t    check_cstack = TRUE;\n    }\n    else\n    {\n\t// When leaving a function, reduce nesting level.\n\tif (getline_equal(fgetline, cookie, get_func_line))\n\t    --ex_nesting_level;\n\t/*\n\t * Go to debug mode when returning from a function in which we are\n\t * single-stepping.\n\t */\n\tif ((getline_equal(fgetline, cookie, getsourceline)\n\t\t    || getline_equal(fgetline, cookie, get_func_line))\n\t\t&& ex_nesting_level + 1 <= debug_break_level)\n\t    do_debug(getline_equal(fgetline, cookie, getsourceline)\n\t\t    ? (char_u *)_(\"End of sourced file\")\n\t\t    : (char_u *)_(\"End of function\"));\n    }\n\n    /*\n     * Restore the exception environment (done after returning from the\n     * debugger).\n     */\n    if (flags & DOCMD_EXCRESET)\n\trestore_dbg_stuff(&debug_saved);\n\n    msg_list = saved_msg_list;\n\n    // Cleanup if \"cs_emsg_silent_list\" remains.\n    if (cstack.cs_emsg_silent_list != NULL)\n    {\n\teslist_T *elem, *temp;\n\n\tfor (elem = cstack.cs_emsg_silent_list; elem != NULL; elem = temp)\n\t{\n\t    temp = elem->next;\n\t    vim_free(elem);\n\t}\n    }\n#endif // FEAT_EVAL\n\n    /*\n     * If there was too much output to fit on the command line, ask the user to\n     * hit return before redrawing the screen. With the \":global\" command we do\n     * this only once after the command is finished.\n     */\n    if (did_inc)\n    {\n\t--RedrawingDisabled;\n\t--no_wait_return;\n\tmsg_scroll = FALSE;\n\n\t/*\n\t * When just finished an \":if\"-\":else\" which was typed, no need to\n\t * wait for hit-return.  Also for an error situation.\n\t */\n\tif (retval == FAIL\n#ifdef FEAT_EVAL\n\t\t|| (did_endif && KeyTyped && !did_emsg)\n#endif\n\t\t\t\t\t    )\n\t{\n\t    need_wait_return = FALSE;\n\t    msg_didany = FALSE;\t\t// don't wait when restarting edit\n\t}\n\telse if (need_wait_return)\n\t{\n\t    /*\n\t     * The msg_start() above clears msg_didout. The wait_return() we do\n\t     * here should not overwrite the command that may be shown before\n\t     * doing that.\n\t     */\n\t    msg_didout |= msg_didout_before_start;\n\t    wait_return(FALSE);\n\t}\n    }\n\n#ifdef FEAT_EVAL\n    did_endif = FALSE;  // in case do_cmdline used recursively\n#else\n    /*\n     * Reset if_level, in case a sourced script file contains more \":if\" than\n     * \":endif\" (could be \":if x | foo | endif\").\n     */\n    if_level = 0;\n#endif\n\n    --call_depth;\n    return retval;\n}", "func_hash": 18276376041085945144974490585203596149, "file_name": "ex_docmd.c", "file_hash": 295000933203185103325291624331253822836, "cwe": ["CWE-416"], "cve": "CVE-2022-3099", "cve_desc": "Use After Free in GitHub repository vim/vim prior to 9.0.0360.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-3099", "file_path": "src/ex_docmd.c"}
