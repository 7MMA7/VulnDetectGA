{"idx": 211699, "project": "gnulib", "commit_id": "2d1bd71ec70a31b01d01b734faa66bb1ed28961f", "project_url": "https://github.com/coreutils/gnulib", "commit_url": "http://git.savannah.gnu.org/cgit/gnulib.git/commit/?id=2d1bd71ec70a31b01d01b734faa66bb1ed28961f", "commit_message": "glob: fix heap buffer overflow\n\n* lib/glob.c (glob): Fix off-by-one error introduced into\nglibc in commit dd7d45e838a42b0ed470c44b55901ea98d0c2bab\ndated 1997-10-29 20:33:40.  Problem reported by Tim R\u00fchsen in:\nhttps://sourceware.org/bugzilla/show_bug.cgi?id=22320\nFix suggested by Bruno Haible.", "target": 1, "func": "glob (const char *pattern, int flags, int (*errfunc) (const char *, int),\n      glob_t *pglob)\n{\n  const char *filename;\n  char *dirname = NULL;\n  size_t dirlen;\n  int status;\n  size_t oldcount;\n  int meta;\n  int dirname_modified;\n  int malloc_dirname = 0;\n  glob_t dirs;\n  int retval = 0;\n  size_t alloca_used = 0;\n\n  if (pattern == NULL || pglob == NULL || (flags & ~__GLOB_FLAGS) != 0)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  /* POSIX requires all slashes to be matched.  This means that with\n     a trailing slash we must match only directories.  */\n  if (pattern[0] && pattern[strlen (pattern) - 1] == '/')\n    flags |= GLOB_ONLYDIR;\n\n  if (!(flags & GLOB_DOOFFS))\n    /* Have to do this so 'globfree' knows where to start freeing.  It\n       also makes all the code that uses gl_offs simpler. */\n    pglob->gl_offs = 0;\n\n  if (!(flags & GLOB_APPEND))\n    {\n      pglob->gl_pathc = 0;\n      if (!(flags & GLOB_DOOFFS))\n        pglob->gl_pathv = NULL;\n      else\n        {\n          size_t i;\n\n          if (pglob->gl_offs >= ~((size_t) 0) / sizeof (char *))\n            return GLOB_NOSPACE;\n\n          pglob->gl_pathv = (char **) malloc ((pglob->gl_offs + 1)\n                                              * sizeof (char *));\n          if (pglob->gl_pathv == NULL)\n            return GLOB_NOSPACE;\n\n          for (i = 0; i <= pglob->gl_offs; ++i)\n            pglob->gl_pathv[i] = NULL;\n        }\n    }\n\n  if (flags & GLOB_BRACE)\n    {\n      const char *begin;\n\n      if (flags & GLOB_NOESCAPE)\n        begin = strchr (pattern, '{');\n      else\n        {\n          begin = pattern;\n          while (1)\n            {\n              if (*begin == '\\0')\n                {\n                  begin = NULL;\n                  break;\n                }\n\n              if (*begin == '\\\\' && begin[1] != '\\0')\n                ++begin;\n              else if (*begin == '{')\n                break;\n\n              ++begin;\n            }\n        }\n\n      if (begin != NULL)\n        {\n          /* Allocate working buffer large enough for our work.  Note that\n             we have at least an opening and closing brace.  */\n          size_t firstc;\n          char *alt_start;\n          const char *p;\n          const char *next;\n          const char *rest;\n          size_t rest_len;\n          char *onealt;\n          size_t pattern_len = strlen (pattern) - 1;\n          int alloca_onealt = glob_use_alloca (alloca_used, pattern_len);\n          if (alloca_onealt)\n            onealt = alloca_account (pattern_len, alloca_used);\n          else\n            {\n              onealt = malloc (pattern_len);\n              if (onealt == NULL)\n                return GLOB_NOSPACE;\n            }\n\n          /* We know the prefix for all sub-patterns.  */\n          alt_start = mempcpy (onealt, pattern, begin - pattern);\n\n          /* Find the first sub-pattern and at the same time find the\n             rest after the closing brace.  */\n          next = next_brace_sub (begin + 1, flags);\n          if (next == NULL)\n            {\n              /* It is an invalid expression.  */\n            illegal_brace:\n              if (__glibc_unlikely (!alloca_onealt))\n                free (onealt);\n              flags &= ~GLOB_BRACE;\n              goto no_brace;\n            }\n\n          /* Now find the end of the whole brace expression.  */\n          rest = next;\n          while (*rest != '}')\n            {\n              rest = next_brace_sub (rest + 1, flags);\n              if (rest == NULL)\n                /* It is an illegal expression.  */\n                goto illegal_brace;\n            }\n          /* Please note that we now can be sure the brace expression\n             is well-formed.  */\n          rest_len = strlen (++rest) + 1;\n\n          /* We have a brace expression.  BEGIN points to the opening {,\n             NEXT points past the terminator of the first element, and END\n             points past the final }.  We will accumulate result names from\n             recursive runs for each brace alternative in the buffer using\n             GLOB_APPEND.  */\n          firstc = pglob->gl_pathc;\n\n          p = begin + 1;\n          while (1)\n            {\n              int result;\n\n              /* Construct the new glob expression.  */\n              mempcpy (mempcpy (alt_start, p, next - p), rest, rest_len);\n\n              result = glob (onealt,\n                             ((flags & ~(GLOB_NOCHECK | GLOB_NOMAGIC))\n                              | GLOB_APPEND), errfunc, pglob);\n\n              /* If we got an error, return it.  */\n              if (result && result != GLOB_NOMATCH)\n                {\n                  if (__glibc_unlikely (!alloca_onealt))\n                    free (onealt);\n                  if (!(flags & GLOB_APPEND))\n                    {\n                      globfree (pglob);\n                      pglob->gl_pathc = 0;\n                    }\n                  return result;\n                }\n\n              if (*next == '}')\n                /* We saw the last entry.  */\n                break;\n\n              p = next + 1;\n              next = next_brace_sub (p, flags);\n              assert (next != NULL);\n            }\n\n          if (__glibc_unlikely (!alloca_onealt))\n            free (onealt);\n\n          if (pglob->gl_pathc != firstc)\n            /* We found some entries.  */\n            return 0;\n          else if (!(flags & (GLOB_NOCHECK|GLOB_NOMAGIC)))\n            return GLOB_NOMATCH;\n        }\n    }\n\n no_brace:\n  oldcount = pglob->gl_pathc + pglob->gl_offs;\n\n  /* Find the filename.  */\n  filename = strrchr (pattern, '/');\n\n#if defined __MSDOS__ || defined WINDOWS32\n  /* The case of \"d:pattern\".  Since ':' is not allowed in\n     file names, we can safely assume that wherever it\n     happens in pattern, it signals the filename part.  This\n     is so we could some day support patterns like \"[a-z]:foo\".  */\n  if (filename == NULL)\n    filename = strchr (pattern, ':');\n#endif /* __MSDOS__ || WINDOWS32 */\n\n  dirname_modified = 0;\n  if (filename == NULL)\n    {\n      /* This can mean two things: a simple name or \"~name\".  The latter\n         case is nothing but a notation for a directory.  */\n      if ((flags & (GLOB_TILDE|GLOB_TILDE_CHECK)) && pattern[0] == '~')\n        {\n          dirname = (char *) pattern;\n          dirlen = strlen (pattern);\n\n          /* Set FILENAME to NULL as a special flag.  This is ugly but\n             other solutions would require much more code.  We test for\n             this special case below.  */\n          filename = NULL;\n        }\n      else\n        {\n          if (__glibc_unlikely (pattern[0] == '\\0'))\n            {\n              dirs.gl_pathv = NULL;\n              goto no_matches;\n            }\n\n          filename = pattern;\n          dirname = (char *) \".\";\n          dirlen = 0;\n        }\n    }\n  else if (filename == pattern\n           || (filename == pattern + 1 && pattern[0] == '\\\\'\n               && (flags & GLOB_NOESCAPE) == 0))\n    {\n      /* \"/pattern\" or \"\\\\/pattern\".  */\n      dirname = (char *) \"/\";\n      dirlen = 1;\n      ++filename;\n    }\n  else\n    {\n      char *newp;\n      dirlen = filename - pattern;\n\n#if defined __MSDOS__ || defined WINDOWS32\n      if (*filename == ':'\n          || (filename > pattern + 1 && filename[-1] == ':'))\n        {\n          char *drive_spec;\n\n          ++dirlen;\n          drive_spec = __alloca (dirlen + 1);\n          *((char *) mempcpy (drive_spec, pattern, dirlen)) = '\\0';\n          /* For now, disallow wildcards in the drive spec, to\n             prevent infinite recursion in glob.  */\n          if (__glob_pattern_p (drive_spec, !(flags & GLOB_NOESCAPE)))\n            return GLOB_NOMATCH;\n          /* If this is \"d:pattern\", we need to copy ':' to DIRNAME\n             as well.  If it's \"d:/pattern\", don't remove the slash\n             from \"d:/\", since \"d:\" and \"d:/\" are not the same.*/\n        }\n#endif\n\n      if (glob_use_alloca (alloca_used, dirlen + 1))\n        newp = alloca_account (dirlen + 1, alloca_used);\n      else\n        {\n          newp = malloc (dirlen + 1);\n          if (newp == NULL)\n            return GLOB_NOSPACE;\n          malloc_dirname = 1;\n        }\n      *((char *) mempcpy (newp, pattern, dirlen)) = '\\0';\n      dirname = newp;\n      ++filename;\n\n#if defined __MSDOS__ || defined WINDOWS32\n      bool drive_root = (dirlen > 1\n                         && (dirname[dirlen - 1] == ':'\n                             || (dirlen > 2 && dirname[dirlen - 2] == ':'\n                                 && dirname[dirlen - 1] == '/')));\n#else\n      bool drive_root = false;\n#endif\n\n      if (filename[0] == '\\0' && dirlen > 1 && !drive_root)\n        /* \"pattern/\".  Expand \"pattern\", appending slashes.  */\n        {\n          int orig_flags = flags;\n          if (!(flags & GLOB_NOESCAPE) && dirname[dirlen - 1] == '\\\\')\n            {\n              /* \"pattern\\\\/\".  Remove the final backslash if it hasn't\n                 been quoted.  */\n              char *p = (char *) &dirname[dirlen - 1];\n\n              while (p > dirname && p[-1] == '\\\\') --p;\n              if ((&dirname[dirlen] - p) & 1)\n                {\n                  *(char *) &dirname[--dirlen] = '\\0';\n                  flags &= ~(GLOB_NOCHECK | GLOB_NOMAGIC);\n                }\n            }\n          int val = glob (dirname, flags | GLOB_MARK, errfunc, pglob);\n          if (val == 0)\n            pglob->gl_flags = ((pglob->gl_flags & ~GLOB_MARK)\n                               | (flags & GLOB_MARK));\n          else if (val == GLOB_NOMATCH && flags != orig_flags)\n            {\n              /* Make sure globfree (&dirs); is a nop.  */\n              dirs.gl_pathv = NULL;\n              flags = orig_flags;\n              oldcount = pglob->gl_pathc + pglob->gl_offs;\n              goto no_matches;\n            }\n          retval = val;\n          goto out;\n        }\n    }\n\n  if ((flags & (GLOB_TILDE|GLOB_TILDE_CHECK)) && dirname[0] == '~')\n    {\n      if (dirname[1] == '\\0' || dirname[1] == '/'\n          || (!(flags & GLOB_NOESCAPE) && dirname[1] == '\\\\'\n              && (dirname[2] == '\\0' || dirname[2] == '/')))\n        {\n          /* Look up home directory.  */\n          char *home_dir = getenv (\"HOME\");\n          int malloc_home_dir = 0;\n          if (home_dir == NULL || home_dir[0] == '\\0')\n            {\n#ifdef WINDOWS32\n              /* Windows NT defines HOMEDRIVE and HOMEPATH.  But give\n                 preference to HOME, because the user can change HOME.  */\n              const char *home_drive = getenv (\"HOMEDRIVE\");\n              const char *home_path = getenv (\"HOMEPATH\");\n\n              if (home_drive != NULL && home_path != NULL)\n                {\n                  size_t home_drive_len = strlen (home_drive);\n                  size_t home_path_len = strlen (home_path);\n                  char *mem = alloca (home_drive_len + home_path_len + 1);\n\n                  memcpy (mem, home_drive, home_drive_len);\n                  memcpy (mem + home_drive_len, home_path, home_path_len + 1);\n                  home_dir = mem;\n                }\n              else\n                home_dir = \"c:/users/default\"; /* poor default */\n#else\n              int err;\n              struct passwd *p;\n              struct passwd pwbuf;\n              struct scratch_buffer s;\n              scratch_buffer_init (&s);\n              while (true)\n                {\n                  p = NULL;\n                  err = __getlogin_r (s.data, s.length);\n                  if (err == 0)\n                    {\n# if defined HAVE_GETPWNAM_R || defined _LIBC\n                      size_t ssize = strlen (s.data) + 1;\n                      err = getpwnam_r (s.data, &pwbuf, s.data + ssize,\n                                        s.length - ssize, &p);\n# else\n                      p = getpwnam (s.data);\n                      if (p == NULL)\n                        err = errno;\n# endif\n                    }\n                  if (err != ERANGE)\n                    break;\n                  if (!scratch_buffer_grow (&s))\n                    {\n                      retval = GLOB_NOSPACE;\n                      goto out;\n                    }\n                }\n              if (err == 0)\n                {\n                  home_dir = strdup (p->pw_dir);\n                  malloc_home_dir = 1;\n                }\n              scratch_buffer_free (&s);\n              if (err == 0 && home_dir == NULL)\n                {\n                  retval = GLOB_NOSPACE;\n                  goto out;\n                }\n#endif /* WINDOWS32 */\n            }\n          if (home_dir == NULL || home_dir[0] == '\\0')\n            {\n              if (__glibc_unlikely (malloc_home_dir))\n                free (home_dir);\n              if (flags & GLOB_TILDE_CHECK)\n                {\n                  retval = GLOB_NOMATCH;\n                  goto out;\n                }\n              else\n                {\n                  home_dir = (char *) \"~\"; /* No luck.  */\n                  malloc_home_dir = 0;\n                }\n            }\n          /* Now construct the full directory.  */\n          if (dirname[1] == '\\0')\n            {\n              if (__glibc_unlikely (malloc_dirname))\n                free (dirname);\n\n              dirname = home_dir;\n              dirlen = strlen (dirname);\n              malloc_dirname = malloc_home_dir;\n            }\n          else\n            {\n              char *newp;\n              size_t home_len = strlen (home_dir);\n              int use_alloca = glob_use_alloca (alloca_used, home_len + dirlen);\n              if (use_alloca)\n                newp = alloca_account (home_len + dirlen, alloca_used);\n              else\n                {\n                  newp = malloc (home_len + dirlen);\n                  if (newp == NULL)\n                    {\n                      if (__glibc_unlikely (malloc_home_dir))\n                        free (home_dir);\n                      retval = GLOB_NOSPACE;\n                      goto out;\n                    }\n                }\n\n              mempcpy (mempcpy (newp, home_dir, home_len),\n                       &dirname[1], dirlen);\n\n              if (__glibc_unlikely (malloc_dirname))\n                free (dirname);\n\n              dirname = newp;\n              dirlen += home_len - 1;\n              malloc_dirname = !use_alloca;\n\n              if (__glibc_unlikely (malloc_home_dir))\n                free (home_dir);\n            }\n          dirname_modified = 1;\n        }\n      else\n        {\n#ifndef WINDOWS32\n          char *end_name = strchr (dirname, '/');\n          char *user_name;\n          int malloc_user_name = 0;\n          char *unescape = NULL;\n\n          if (!(flags & GLOB_NOESCAPE))\n            {\n              if (end_name == NULL)\n                {\n                  unescape = strchr (dirname, '\\\\');\n                  if (unescape)\n                    end_name = strchr (unescape, '\\0');\n                }\n              else\n                unescape = memchr (dirname, '\\\\', end_name - dirname);\n            }\n          if (end_name == NULL)\n            user_name = dirname + 1;\n          else\n            {\n              char *newp;\n              if (glob_use_alloca (alloca_used, end_name - dirname))\n                newp = alloca_account (end_name - dirname, alloca_used);\n              else\n                {\n                  newp = malloc (end_name - dirname);\n                  if (newp == NULL)\n                    {\n                      retval = GLOB_NOSPACE;\n                      goto out;\n                    }\n                  malloc_user_name = 1;\n                }\n              if (unescape != NULL)\n                {\n                  char *p = mempcpy (newp, dirname + 1,\n                                     unescape - dirname - 1);\n                  char *q = unescape;\n                  while (*q != '\\0')\n                    {\n                      if (*q == '\\\\')\n                        {\n                          if (q[1] == '\\0')\n                            {\n                              /* \"~fo\\\\o\\\\\" unescape to user_name \"foo\\\\\",\n                                 but \"~fo\\\\o\\\\/\" unescape to user_name\n                                 \"foo\".  */\n                              if (filename == NULL)\n                                *p++ = '\\\\';\n                              break;\n                            }\n                          ++q;\n                        }\n                      *p++ = *q++;\n                    }\n                  *p = '\\0';\n                }\n              else\n                *((char *) mempcpy (newp, dirname + 1, end_name - dirname))\n                  = '\\0';\n              user_name = newp;\n            }\n\n          /* Look up specific user's home directory.  */\n          {\n            struct passwd *p;\n            struct scratch_buffer pwtmpbuf;\n            scratch_buffer_init (&pwtmpbuf);\n\n#  if defined HAVE_GETPWNAM_R || defined _LIBC\n            struct passwd pwbuf;\n\n            while (getpwnam_r (user_name, &pwbuf,\n                               pwtmpbuf.data, pwtmpbuf.length, &p)\n                   == ERANGE)\n              {\n                if (!scratch_buffer_grow (&pwtmpbuf))\n                  {\n                    retval = GLOB_NOSPACE;\n                    goto out;\n                  }\n              }\n#  else\n            p = getpwnam (user_name);\n#  endif\n\n            if (__glibc_unlikely (malloc_user_name))\n              free (user_name);\n\n            /* If we found a home directory use this.  */\n            if (p != NULL)\n              {\n                size_t home_len = strlen (p->pw_dir);\n                size_t rest_len = end_name == NULL ? 0 : strlen (end_name);\n                char *d;\n\n                if (__glibc_unlikely (malloc_dirname))\n                  free (dirname);\n                malloc_dirname = 0;\n\n                if (glob_use_alloca (alloca_used, home_len + rest_len + 1))\n                  dirname = alloca_account (home_len + rest_len + 1,\n                                            alloca_used);\n                else\n                  {\n                    dirname = malloc (home_len + rest_len + 1);\n                    if (dirname == NULL)\n                      {\n                        scratch_buffer_free (&pwtmpbuf);\n                        retval = GLOB_NOSPACE;\n                        goto out;\n                      }\n                    malloc_dirname = 1;\n                  }\n                d = mempcpy (dirname, p->pw_dir, home_len);\n                if (end_name != NULL)\n                  d = mempcpy (d, end_name, rest_len);\n                *d = '\\0';\n\n                dirlen = home_len + rest_len;\n                dirname_modified = 1;\n              }\n            else\n              {\n                if (flags & GLOB_TILDE_CHECK)\n                  {\n                    /* We have to regard it as an error if we cannot find the\n                       home directory.  */\n                    retval = GLOB_NOMATCH;\n                    goto out;\n                  }\n              }\n            scratch_buffer_free (&pwtmpbuf);\n          }\n#endif /* !WINDOWS32 */\n        }\n    }\n\n  /* Now test whether we looked for \"~\" or \"~NAME\".  In this case we\n     can give the answer now.  */\n  if (filename == NULL)\n    {\n      size_t newcount = pglob->gl_pathc + pglob->gl_offs;\n      char **new_gl_pathv;\n\n      if (newcount > SIZE_MAX / sizeof (char *) - 2)\n        {\n        nospace:\n          free (pglob->gl_pathv);\n          pglob->gl_pathv = NULL;\n          pglob->gl_pathc = 0;\n          retval = GLOB_NOSPACE;\n          goto out;\n        }\n\n      new_gl_pathv = realloc (pglob->gl_pathv,\n                              (newcount + 2) * sizeof (char *));\n      if (new_gl_pathv == NULL)\n        goto nospace;\n      pglob->gl_pathv = new_gl_pathv;\n\n      if (flags & GLOB_MARK && is_dir (dirname, flags, pglob))\n        {\n          char *p;\n          pglob->gl_pathv[newcount] = malloc (dirlen + 2);\n          if (pglob->gl_pathv[newcount] == NULL)\n            goto nospace;\n          p = mempcpy (pglob->gl_pathv[newcount], dirname, dirlen);\n          p[0] = '/';\n          p[1] = '\\0';\n          if (__glibc_unlikely (malloc_dirname))\n            free (dirname);\n        }\n      else\n        {\n          if (__glibc_unlikely (malloc_dirname))\n            pglob->gl_pathv[newcount] = dirname;\n          else\n            {\n              pglob->gl_pathv[newcount] = strdup (dirname);\n              if (pglob->gl_pathv[newcount] == NULL)\n                goto nospace;\n            }\n        }\n      pglob->gl_pathv[++newcount] = NULL;\n      ++pglob->gl_pathc;\n      pglob->gl_flags = flags;\n\n      return 0;\n    }\n\n  meta = __glob_pattern_type (dirname, !(flags & GLOB_NOESCAPE));\n  /* meta is 1 if correct glob pattern containing metacharacters.\n     If meta has bit (1 << 2) set, it means there was an unterminated\n     [ which we handle the same, using fnmatch.  Broken unterminated\n     pattern bracket expressions ought to be rare enough that it is\n     not worth special casing them, fnmatch will do the right thing.  */\n  if (meta & (GLOBPAT_SPECIAL | GLOBPAT_BRACKET))\n    {\n      /* The directory name contains metacharacters, so we\n         have to glob for the directory, and then glob for\n         the pattern in each directory found.  */\n      size_t i;\n\n      if (!(flags & GLOB_NOESCAPE) && dirlen > 0 && dirname[dirlen - 1] == '\\\\')\n        {\n          /* \"foo\\\\/bar\".  Remove the final backslash from dirname\n             if it has not been quoted.  */\n          char *p = (char *) &dirname[dirlen - 1];\n\n          while (p > dirname && p[-1] == '\\\\') --p;\n          if ((&dirname[dirlen] - p) & 1)\n            *(char *) &dirname[--dirlen] = '\\0';\n        }\n\n      if (__glibc_unlikely ((flags & GLOB_ALTDIRFUNC) != 0))\n        {\n          /* Use the alternative access functions also in the recursive\n             call.  */\n          dirs.gl_opendir = pglob->gl_opendir;\n          dirs.gl_readdir = pglob->gl_readdir;\n          dirs.gl_closedir = pglob->gl_closedir;\n          dirs.gl_stat = pglob->gl_stat;\n          dirs.gl_lstat = pglob->gl_lstat;\n        }\n\n      status = glob (dirname,\n                     ((flags & (GLOB_ERR | GLOB_NOESCAPE\n                                | GLOB_ALTDIRFUNC))\n                      | GLOB_NOSORT | GLOB_ONLYDIR),\n                     errfunc, &dirs);\n      if (status != 0)\n        {\n          if ((flags & GLOB_NOCHECK) == 0 || status != GLOB_NOMATCH)\n            {\n              retval = status;\n              goto out;\n            }\n          goto no_matches;\n        }\n\n      /* We have successfully globbed the preceding directory name.\n         For each name we found, call glob_in_dir on it and FILENAME,\n         appending the results to PGLOB.  */\n      for (i = 0; i < dirs.gl_pathc; ++i)\n        {\n          size_t old_pathc;\n\n          old_pathc = pglob->gl_pathc;\n          status = glob_in_dir (filename, dirs.gl_pathv[i],\n                                ((flags | GLOB_APPEND)\n                                 & ~(GLOB_NOCHECK | GLOB_NOMAGIC)),\n                                errfunc, pglob, alloca_used);\n          if (status == GLOB_NOMATCH)\n            /* No matches in this directory.  Try the next.  */\n            continue;\n\n          if (status != 0)\n            {\n              globfree (&dirs);\n              globfree (pglob);\n              pglob->gl_pathc = 0;\n              retval = status;\n              goto out;\n            }\n\n          /* Stick the directory on the front of each name.  */\n          if (prefix_array (dirs.gl_pathv[i],\n                            &pglob->gl_pathv[old_pathc + pglob->gl_offs],\n                            pglob->gl_pathc - old_pathc))\n            {\n              globfree (&dirs);\n              globfree (pglob);\n              pglob->gl_pathc = 0;\n              retval = GLOB_NOSPACE;\n              goto out;\n            }\n        }\n\n      flags |= GLOB_MAGCHAR;\n\n      /* We have ignored the GLOB_NOCHECK flag in the 'glob_in_dir' calls.\n         But if we have not found any matching entry and the GLOB_NOCHECK\n         flag was set we must return the input pattern itself.  */\n      if (pglob->gl_pathc + pglob->gl_offs == oldcount)\n        {\n        no_matches:\n          /* No matches.  */\n          if (flags & GLOB_NOCHECK)\n            {\n              size_t newcount = pglob->gl_pathc + pglob->gl_offs;\n              char **new_gl_pathv;\n\n              if (newcount > SIZE_MAX / sizeof (char *) - 2)\n                {\n                nospace2:\n                  globfree (&dirs);\n                  retval = GLOB_NOSPACE;\n                  goto out;\n                }\n\n              new_gl_pathv = realloc (pglob->gl_pathv,\n                                      (newcount + 2) * sizeof (char *));\n              if (new_gl_pathv == NULL)\n                goto nospace2;\n              pglob->gl_pathv = new_gl_pathv;\n\n              pglob->gl_pathv[newcount] = strdup (pattern);\n              if (pglob->gl_pathv[newcount] == NULL)\n                {\n                  globfree (&dirs);\n                  globfree (pglob);\n                  pglob->gl_pathc = 0;\n                  retval = GLOB_NOSPACE;\n                  goto out;\n                }\n\n              ++pglob->gl_pathc;\n              ++newcount;\n\n              pglob->gl_pathv[newcount] = NULL;\n              pglob->gl_flags = flags;\n            }\n          else\n            {\n              globfree (&dirs);\n              retval = GLOB_NOMATCH;\n              goto out;\n            }\n        }\n\n      globfree (&dirs);\n    }\n  else\n    {\n      size_t old_pathc = pglob->gl_pathc;\n      int orig_flags = flags;\n\n      if (meta & GLOBPAT_BACKSLASH)\n        {\n          char *p = strchr (dirname, '\\\\'), *q;\n          /* We need to unescape the dirname string.  It is certainly\n             allocated by alloca, as otherwise filename would be NULL\n             or dirname wouldn't contain backslashes.  */\n          q = p;\n          do\n            {\n              if (*p == '\\\\')\n                {\n                  *q = *++p;\n                  --dirlen;\n                }\n              else\n                *q = *p;\n              ++q;\n            }\n          while (*p++ != '\\0');\n          dirname_modified = 1;\n        }\n      if (dirname_modified)\n        flags &= ~(GLOB_NOCHECK | GLOB_NOMAGIC);\n      status = glob_in_dir (filename, dirname, flags, errfunc, pglob,\n                            alloca_used);\n      if (status != 0)\n        {\n          if (status == GLOB_NOMATCH && flags != orig_flags\n              && pglob->gl_pathc + pglob->gl_offs == oldcount)\n            {\n              /* Make sure globfree (&dirs); is a nop.  */\n              dirs.gl_pathv = NULL;\n              flags = orig_flags;\n              goto no_matches;\n            }\n          retval = status;\n          goto out;\n        }\n\n      if (dirlen > 0)\n        {\n          /* Stick the directory on the front of each name.  */\n          if (prefix_array (dirname,\n                            &pglob->gl_pathv[old_pathc + pglob->gl_offs],\n                            pglob->gl_pathc - old_pathc))\n            {\n              globfree (pglob);\n              pglob->gl_pathc = 0;\n              retval = GLOB_NOSPACE;\n              goto out;\n            }\n        }\n    }\n\n  if (flags & GLOB_MARK)\n    {\n      /* Append slashes to directory names.  */\n      size_t i;\n\n      for (i = oldcount; i < pglob->gl_pathc + pglob->gl_offs; ++i)\n        if (is_dir (pglob->gl_pathv[i], flags, pglob))\n          {\n            size_t len = strlen (pglob->gl_pathv[i]) + 2;\n            char *new = realloc (pglob->gl_pathv[i], len);\n            if (new == NULL)\n              {\n                globfree (pglob);\n                pglob->gl_pathc = 0;\n                retval = GLOB_NOSPACE;\n                goto out;\n              }\n            strcpy (&new[len - 2], \"/\");\n            pglob->gl_pathv[i] = new;\n          }\n    }\n\n  if (!(flags & GLOB_NOSORT))\n    {\n      /* Sort the vector.  */\n      qsort (&pglob->gl_pathv[oldcount],\n             pglob->gl_pathc + pglob->gl_offs - oldcount,\n             sizeof (char *), collated_compare);\n    }\n\n out:\n  if (__glibc_unlikely (malloc_dirname))\n    free (dirname);\n\n  return retval;\n}", "func_hash": 298881576183169213772402868020196569538, "file_name": "glob.c", "file_hash": 266244104923592097115880749593499653391, "cwe": ["CWE-119"], "cve": "CVE-2017-15670", "cve_desc": "The GNU C Library (aka glibc or libc6) before 2.27 contains an off-by-one error leading to a heap-based buffer overflow in the glob function in glob.c, related to the processing of home directories using the ~ operator followed by a long string.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-15670", "file_path": "lib/glob.c"}
{"idx": 450812, "project": "gnulib", "commit_id": "2d1bd71ec70a31b01d01b734faa66bb1ed28961f", "project_url": "https://github.com/coreutils/gnulib", "commit_url": "http://git.savannah.gnu.org/cgit/gnulib.git/commit/?id=2d1bd71ec70a31b01d01b734faa66bb1ed28961f", "commit_message": "glob: fix heap buffer overflow\n\n* lib/glob.c (glob): Fix off-by-one error introduced into\nglibc in commit dd7d45e838a42b0ed470c44b55901ea98d0c2bab\ndated 1997-10-29 20:33:40.  Problem reported by Tim R\u00fchsen in:\nhttps://sourceware.org/bugzilla/show_bug.cgi?id=22320\nFix suggested by Bruno Haible.", "target": 0, "func": "glob (const char *pattern, int flags, int (*errfunc) (const char *, int),\n      glob_t *pglob)\n{\n  const char *filename;\n  char *dirname = NULL;\n  size_t dirlen;\n  int status;\n  size_t oldcount;\n  int meta;\n  int dirname_modified;\n  int malloc_dirname = 0;\n  glob_t dirs;\n  int retval = 0;\n  size_t alloca_used = 0;\n\n  if (pattern == NULL || pglob == NULL || (flags & ~__GLOB_FLAGS) != 0)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  /* POSIX requires all slashes to be matched.  This means that with\n     a trailing slash we must match only directories.  */\n  if (pattern[0] && pattern[strlen (pattern) - 1] == '/')\n    flags |= GLOB_ONLYDIR;\n\n  if (!(flags & GLOB_DOOFFS))\n    /* Have to do this so 'globfree' knows where to start freeing.  It\n       also makes all the code that uses gl_offs simpler. */\n    pglob->gl_offs = 0;\n\n  if (!(flags & GLOB_APPEND))\n    {\n      pglob->gl_pathc = 0;\n      if (!(flags & GLOB_DOOFFS))\n        pglob->gl_pathv = NULL;\n      else\n        {\n          size_t i;\n\n          if (pglob->gl_offs >= ~((size_t) 0) / sizeof (char *))\n            return GLOB_NOSPACE;\n\n          pglob->gl_pathv = (char **) malloc ((pglob->gl_offs + 1)\n                                              * sizeof (char *));\n          if (pglob->gl_pathv == NULL)\n            return GLOB_NOSPACE;\n\n          for (i = 0; i <= pglob->gl_offs; ++i)\n            pglob->gl_pathv[i] = NULL;\n        }\n    }\n\n  if (flags & GLOB_BRACE)\n    {\n      const char *begin;\n\n      if (flags & GLOB_NOESCAPE)\n        begin = strchr (pattern, '{');\n      else\n        {\n          begin = pattern;\n          while (1)\n            {\n              if (*begin == '\\0')\n                {\n                  begin = NULL;\n                  break;\n                }\n\n              if (*begin == '\\\\' && begin[1] != '\\0')\n                ++begin;\n              else if (*begin == '{')\n                break;\n\n              ++begin;\n            }\n        }\n\n      if (begin != NULL)\n        {\n          /* Allocate working buffer large enough for our work.  Note that\n             we have at least an opening and closing brace.  */\n          size_t firstc;\n          char *alt_start;\n          const char *p;\n          const char *next;\n          const char *rest;\n          size_t rest_len;\n          char *onealt;\n          size_t pattern_len = strlen (pattern) - 1;\n          int alloca_onealt = glob_use_alloca (alloca_used, pattern_len);\n          if (alloca_onealt)\n            onealt = alloca_account (pattern_len, alloca_used);\n          else\n            {\n              onealt = malloc (pattern_len);\n              if (onealt == NULL)\n                return GLOB_NOSPACE;\n            }\n\n          /* We know the prefix for all sub-patterns.  */\n          alt_start = mempcpy (onealt, pattern, begin - pattern);\n\n          /* Find the first sub-pattern and at the same time find the\n             rest after the closing brace.  */\n          next = next_brace_sub (begin + 1, flags);\n          if (next == NULL)\n            {\n              /* It is an invalid expression.  */\n            illegal_brace:\n              if (__glibc_unlikely (!alloca_onealt))\n                free (onealt);\n              flags &= ~GLOB_BRACE;\n              goto no_brace;\n            }\n\n          /* Now find the end of the whole brace expression.  */\n          rest = next;\n          while (*rest != '}')\n            {\n              rest = next_brace_sub (rest + 1, flags);\n              if (rest == NULL)\n                /* It is an illegal expression.  */\n                goto illegal_brace;\n            }\n          /* Please note that we now can be sure the brace expression\n             is well-formed.  */\n          rest_len = strlen (++rest) + 1;\n\n          /* We have a brace expression.  BEGIN points to the opening {,\n             NEXT points past the terminator of the first element, and END\n             points past the final }.  We will accumulate result names from\n             recursive runs for each brace alternative in the buffer using\n             GLOB_APPEND.  */\n          firstc = pglob->gl_pathc;\n\n          p = begin + 1;\n          while (1)\n            {\n              int result;\n\n              /* Construct the new glob expression.  */\n              mempcpy (mempcpy (alt_start, p, next - p), rest, rest_len);\n\n              result = glob (onealt,\n                             ((flags & ~(GLOB_NOCHECK | GLOB_NOMAGIC))\n                              | GLOB_APPEND), errfunc, pglob);\n\n              /* If we got an error, return it.  */\n              if (result && result != GLOB_NOMATCH)\n                {\n                  if (__glibc_unlikely (!alloca_onealt))\n                    free (onealt);\n                  if (!(flags & GLOB_APPEND))\n                    {\n                      globfree (pglob);\n                      pglob->gl_pathc = 0;\n                    }\n                  return result;\n                }\n\n              if (*next == '}')\n                /* We saw the last entry.  */\n                break;\n\n              p = next + 1;\n              next = next_brace_sub (p, flags);\n              assert (next != NULL);\n            }\n\n          if (__glibc_unlikely (!alloca_onealt))\n            free (onealt);\n\n          if (pglob->gl_pathc != firstc)\n            /* We found some entries.  */\n            return 0;\n          else if (!(flags & (GLOB_NOCHECK|GLOB_NOMAGIC)))\n            return GLOB_NOMATCH;\n        }\n    }\n\n no_brace:\n  oldcount = pglob->gl_pathc + pglob->gl_offs;\n\n  /* Find the filename.  */\n  filename = strrchr (pattern, '/');\n\n#if defined __MSDOS__ || defined WINDOWS32\n  /* The case of \"d:pattern\".  Since ':' is not allowed in\n     file names, we can safely assume that wherever it\n     happens in pattern, it signals the filename part.  This\n     is so we could some day support patterns like \"[a-z]:foo\".  */\n  if (filename == NULL)\n    filename = strchr (pattern, ':');\n#endif /* __MSDOS__ || WINDOWS32 */\n\n  dirname_modified = 0;\n  if (filename == NULL)\n    {\n      /* This can mean two things: a simple name or \"~name\".  The latter\n         case is nothing but a notation for a directory.  */\n      if ((flags & (GLOB_TILDE|GLOB_TILDE_CHECK)) && pattern[0] == '~')\n        {\n          dirname = (char *) pattern;\n          dirlen = strlen (pattern);\n\n          /* Set FILENAME to NULL as a special flag.  This is ugly but\n             other solutions would require much more code.  We test for\n             this special case below.  */\n          filename = NULL;\n        }\n      else\n        {\n          if (__glibc_unlikely (pattern[0] == '\\0'))\n            {\n              dirs.gl_pathv = NULL;\n              goto no_matches;\n            }\n\n          filename = pattern;\n          dirname = (char *) \".\";\n          dirlen = 0;\n        }\n    }\n  else if (filename == pattern\n           || (filename == pattern + 1 && pattern[0] == '\\\\'\n               && (flags & GLOB_NOESCAPE) == 0))\n    {\n      /* \"/pattern\" or \"\\\\/pattern\".  */\n      dirname = (char *) \"/\";\n      dirlen = 1;\n      ++filename;\n    }\n  else\n    {\n      char *newp;\n      dirlen = filename - pattern;\n\n#if defined __MSDOS__ || defined WINDOWS32\n      if (*filename == ':'\n          || (filename > pattern + 1 && filename[-1] == ':'))\n        {\n          char *drive_spec;\n\n          ++dirlen;\n          drive_spec = __alloca (dirlen + 1);\n          *((char *) mempcpy (drive_spec, pattern, dirlen)) = '\\0';\n          /* For now, disallow wildcards in the drive spec, to\n             prevent infinite recursion in glob.  */\n          if (__glob_pattern_p (drive_spec, !(flags & GLOB_NOESCAPE)))\n            return GLOB_NOMATCH;\n          /* If this is \"d:pattern\", we need to copy ':' to DIRNAME\n             as well.  If it's \"d:/pattern\", don't remove the slash\n             from \"d:/\", since \"d:\" and \"d:/\" are not the same.*/\n        }\n#endif\n\n      if (glob_use_alloca (alloca_used, dirlen + 1))\n        newp = alloca_account (dirlen + 1, alloca_used);\n      else\n        {\n          newp = malloc (dirlen + 1);\n          if (newp == NULL)\n            return GLOB_NOSPACE;\n          malloc_dirname = 1;\n        }\n      *((char *) mempcpy (newp, pattern, dirlen)) = '\\0';\n      dirname = newp;\n      ++filename;\n\n#if defined __MSDOS__ || defined WINDOWS32\n      bool drive_root = (dirlen > 1\n                         && (dirname[dirlen - 1] == ':'\n                             || (dirlen > 2 && dirname[dirlen - 2] == ':'\n                                 && dirname[dirlen - 1] == '/')));\n#else\n      bool drive_root = false;\n#endif\n\n      if (filename[0] == '\\0' && dirlen > 1 && !drive_root)\n        /* \"pattern/\".  Expand \"pattern\", appending slashes.  */\n        {\n          int orig_flags = flags;\n          if (!(flags & GLOB_NOESCAPE) && dirname[dirlen - 1] == '\\\\')\n            {\n              /* \"pattern\\\\/\".  Remove the final backslash if it hasn't\n                 been quoted.  */\n              char *p = (char *) &dirname[dirlen - 1];\n\n              while (p > dirname && p[-1] == '\\\\') --p;\n              if ((&dirname[dirlen] - p) & 1)\n                {\n                  *(char *) &dirname[--dirlen] = '\\0';\n                  flags &= ~(GLOB_NOCHECK | GLOB_NOMAGIC);\n                }\n            }\n          int val = glob (dirname, flags | GLOB_MARK, errfunc, pglob);\n          if (val == 0)\n            pglob->gl_flags = ((pglob->gl_flags & ~GLOB_MARK)\n                               | (flags & GLOB_MARK));\n          else if (val == GLOB_NOMATCH && flags != orig_flags)\n            {\n              /* Make sure globfree (&dirs); is a nop.  */\n              dirs.gl_pathv = NULL;\n              flags = orig_flags;\n              oldcount = pglob->gl_pathc + pglob->gl_offs;\n              goto no_matches;\n            }\n          retval = val;\n          goto out;\n        }\n    }\n\n  if ((flags & (GLOB_TILDE|GLOB_TILDE_CHECK)) && dirname[0] == '~')\n    {\n      if (dirname[1] == '\\0' || dirname[1] == '/'\n          || (!(flags & GLOB_NOESCAPE) && dirname[1] == '\\\\'\n              && (dirname[2] == '\\0' || dirname[2] == '/')))\n        {\n          /* Look up home directory.  */\n          char *home_dir = getenv (\"HOME\");\n          int malloc_home_dir = 0;\n          if (home_dir == NULL || home_dir[0] == '\\0')\n            {\n#ifdef WINDOWS32\n              /* Windows NT defines HOMEDRIVE and HOMEPATH.  But give\n                 preference to HOME, because the user can change HOME.  */\n              const char *home_drive = getenv (\"HOMEDRIVE\");\n              const char *home_path = getenv (\"HOMEPATH\");\n\n              if (home_drive != NULL && home_path != NULL)\n                {\n                  size_t home_drive_len = strlen (home_drive);\n                  size_t home_path_len = strlen (home_path);\n                  char *mem = alloca (home_drive_len + home_path_len + 1);\n\n                  memcpy (mem, home_drive, home_drive_len);\n                  memcpy (mem + home_drive_len, home_path, home_path_len + 1);\n                  home_dir = mem;\n                }\n              else\n                home_dir = \"c:/users/default\"; /* poor default */\n#else\n              int err;\n              struct passwd *p;\n              struct passwd pwbuf;\n              struct scratch_buffer s;\n              scratch_buffer_init (&s);\n              while (true)\n                {\n                  p = NULL;\n                  err = __getlogin_r (s.data, s.length);\n                  if (err == 0)\n                    {\n# if defined HAVE_GETPWNAM_R || defined _LIBC\n                      size_t ssize = strlen (s.data) + 1;\n                      err = getpwnam_r (s.data, &pwbuf, s.data + ssize,\n                                        s.length - ssize, &p);\n# else\n                      p = getpwnam (s.data);\n                      if (p == NULL)\n                        err = errno;\n# endif\n                    }\n                  if (err != ERANGE)\n                    break;\n                  if (!scratch_buffer_grow (&s))\n                    {\n                      retval = GLOB_NOSPACE;\n                      goto out;\n                    }\n                }\n              if (err == 0)\n                {\n                  home_dir = strdup (p->pw_dir);\n                  malloc_home_dir = 1;\n                }\n              scratch_buffer_free (&s);\n              if (err == 0 && home_dir == NULL)\n                {\n                  retval = GLOB_NOSPACE;\n                  goto out;\n                }\n#endif /* WINDOWS32 */\n            }\n          if (home_dir == NULL || home_dir[0] == '\\0')\n            {\n              if (__glibc_unlikely (malloc_home_dir))\n                free (home_dir);\n              if (flags & GLOB_TILDE_CHECK)\n                {\n                  retval = GLOB_NOMATCH;\n                  goto out;\n                }\n              else\n                {\n                  home_dir = (char *) \"~\"; /* No luck.  */\n                  malloc_home_dir = 0;\n                }\n            }\n          /* Now construct the full directory.  */\n          if (dirname[1] == '\\0')\n            {\n              if (__glibc_unlikely (malloc_dirname))\n                free (dirname);\n\n              dirname = home_dir;\n              dirlen = strlen (dirname);\n              malloc_dirname = malloc_home_dir;\n            }\n          else\n            {\n              char *newp;\n              size_t home_len = strlen (home_dir);\n              int use_alloca = glob_use_alloca (alloca_used, home_len + dirlen);\n              if (use_alloca)\n                newp = alloca_account (home_len + dirlen, alloca_used);\n              else\n                {\n                  newp = malloc (home_len + dirlen);\n                  if (newp == NULL)\n                    {\n                      if (__glibc_unlikely (malloc_home_dir))\n                        free (home_dir);\n                      retval = GLOB_NOSPACE;\n                      goto out;\n                    }\n                }\n\n              mempcpy (mempcpy (newp, home_dir, home_len),\n                       &dirname[1], dirlen);\n\n              if (__glibc_unlikely (malloc_dirname))\n                free (dirname);\n\n              dirname = newp;\n              dirlen += home_len - 1;\n              malloc_dirname = !use_alloca;\n\n              if (__glibc_unlikely (malloc_home_dir))\n                free (home_dir);\n            }\n          dirname_modified = 1;\n        }\n      else\n        {\n#ifndef WINDOWS32\n          char *end_name = strchr (dirname, '/');\n          char *user_name;\n          int malloc_user_name = 0;\n          char *unescape = NULL;\n\n          if (!(flags & GLOB_NOESCAPE))\n            {\n              if (end_name == NULL)\n                {\n                  unescape = strchr (dirname, '\\\\');\n                  if (unescape)\n                    end_name = strchr (unescape, '\\0');\n                }\n              else\n                unescape = memchr (dirname, '\\\\', end_name - dirname);\n            }\n          if (end_name == NULL)\n            user_name = dirname + 1;\n          else\n            {\n              char *newp;\n              if (glob_use_alloca (alloca_used, end_name - dirname))\n                newp = alloca_account (end_name - dirname, alloca_used);\n              else\n                {\n                  newp = malloc (end_name - dirname);\n                  if (newp == NULL)\n                    {\n                      retval = GLOB_NOSPACE;\n                      goto out;\n                    }\n                  malloc_user_name = 1;\n                }\n              if (unescape != NULL)\n                {\n                  char *p = mempcpy (newp, dirname + 1,\n                                     unescape - dirname - 1);\n                  char *q = unescape;\n                  while (*q != '\\0')\n                    {\n                      if (*q == '\\\\')\n                        {\n                          if (q[1] == '\\0')\n                            {\n                              /* \"~fo\\\\o\\\\\" unescape to user_name \"foo\\\\\",\n                                 but \"~fo\\\\o\\\\/\" unescape to user_name\n                                 \"foo\".  */\n                              if (filename == NULL)\n                                *p++ = '\\\\';\n                              break;\n                            }\n                          ++q;\n                        }\n                      *p++ = *q++;\n                    }\n                  *p = '\\0';\n                }\n              else\n                *((char *) mempcpy (newp, dirname + 1, end_name - dirname - 1))\n                  = '\\0';\n              user_name = newp;\n            }\n\n          /* Look up specific user's home directory.  */\n          {\n            struct passwd *p;\n            struct scratch_buffer pwtmpbuf;\n            scratch_buffer_init (&pwtmpbuf);\n\n#  if defined HAVE_GETPWNAM_R || defined _LIBC\n            struct passwd pwbuf;\n\n            while (getpwnam_r (user_name, &pwbuf,\n                               pwtmpbuf.data, pwtmpbuf.length, &p)\n                   == ERANGE)\n              {\n                if (!scratch_buffer_grow (&pwtmpbuf))\n                  {\n                    retval = GLOB_NOSPACE;\n                    goto out;\n                  }\n              }\n#  else\n            p = getpwnam (user_name);\n#  endif\n\n            if (__glibc_unlikely (malloc_user_name))\n              free (user_name);\n\n            /* If we found a home directory use this.  */\n            if (p != NULL)\n              {\n                size_t home_len = strlen (p->pw_dir);\n                size_t rest_len = end_name == NULL ? 0 : strlen (end_name);\n                char *d;\n\n                if (__glibc_unlikely (malloc_dirname))\n                  free (dirname);\n                malloc_dirname = 0;\n\n                if (glob_use_alloca (alloca_used, home_len + rest_len + 1))\n                  dirname = alloca_account (home_len + rest_len + 1,\n                                            alloca_used);\n                else\n                  {\n                    dirname = malloc (home_len + rest_len + 1);\n                    if (dirname == NULL)\n                      {\n                        scratch_buffer_free (&pwtmpbuf);\n                        retval = GLOB_NOSPACE;\n                        goto out;\n                      }\n                    malloc_dirname = 1;\n                  }\n                d = mempcpy (dirname, p->pw_dir, home_len);\n                if (end_name != NULL)\n                  d = mempcpy (d, end_name, rest_len);\n                *d = '\\0';\n\n                dirlen = home_len + rest_len;\n                dirname_modified = 1;\n              }\n            else\n              {\n                if (flags & GLOB_TILDE_CHECK)\n                  {\n                    /* We have to regard it as an error if we cannot find the\n                       home directory.  */\n                    retval = GLOB_NOMATCH;\n                    goto out;\n                  }\n              }\n            scratch_buffer_free (&pwtmpbuf);\n          }\n#endif /* !WINDOWS32 */\n        }\n    }\n\n  /* Now test whether we looked for \"~\" or \"~NAME\".  In this case we\n     can give the answer now.  */\n  if (filename == NULL)\n    {\n      size_t newcount = pglob->gl_pathc + pglob->gl_offs;\n      char **new_gl_pathv;\n\n      if (newcount > SIZE_MAX / sizeof (char *) - 2)\n        {\n        nospace:\n          free (pglob->gl_pathv);\n          pglob->gl_pathv = NULL;\n          pglob->gl_pathc = 0;\n          retval = GLOB_NOSPACE;\n          goto out;\n        }\n\n      new_gl_pathv = realloc (pglob->gl_pathv,\n                              (newcount + 2) * sizeof (char *));\n      if (new_gl_pathv == NULL)\n        goto nospace;\n      pglob->gl_pathv = new_gl_pathv;\n\n      if (flags & GLOB_MARK && is_dir (dirname, flags, pglob))\n        {\n          char *p;\n          pglob->gl_pathv[newcount] = malloc (dirlen + 2);\n          if (pglob->gl_pathv[newcount] == NULL)\n            goto nospace;\n          p = mempcpy (pglob->gl_pathv[newcount], dirname, dirlen);\n          p[0] = '/';\n          p[1] = '\\0';\n          if (__glibc_unlikely (malloc_dirname))\n            free (dirname);\n        }\n      else\n        {\n          if (__glibc_unlikely (malloc_dirname))\n            pglob->gl_pathv[newcount] = dirname;\n          else\n            {\n              pglob->gl_pathv[newcount] = strdup (dirname);\n              if (pglob->gl_pathv[newcount] == NULL)\n                goto nospace;\n            }\n        }\n      pglob->gl_pathv[++newcount] = NULL;\n      ++pglob->gl_pathc;\n      pglob->gl_flags = flags;\n\n      return 0;\n    }\n\n  meta = __glob_pattern_type (dirname, !(flags & GLOB_NOESCAPE));\n  /* meta is 1 if correct glob pattern containing metacharacters.\n     If meta has bit (1 << 2) set, it means there was an unterminated\n     [ which we handle the same, using fnmatch.  Broken unterminated\n     pattern bracket expressions ought to be rare enough that it is\n     not worth special casing them, fnmatch will do the right thing.  */\n  if (meta & (GLOBPAT_SPECIAL | GLOBPAT_BRACKET))\n    {\n      /* The directory name contains metacharacters, so we\n         have to glob for the directory, and then glob for\n         the pattern in each directory found.  */\n      size_t i;\n\n      if (!(flags & GLOB_NOESCAPE) && dirlen > 0 && dirname[dirlen - 1] == '\\\\')\n        {\n          /* \"foo\\\\/bar\".  Remove the final backslash from dirname\n             if it has not been quoted.  */\n          char *p = (char *) &dirname[dirlen - 1];\n\n          while (p > dirname && p[-1] == '\\\\') --p;\n          if ((&dirname[dirlen] - p) & 1)\n            *(char *) &dirname[--dirlen] = '\\0';\n        }\n\n      if (__glibc_unlikely ((flags & GLOB_ALTDIRFUNC) != 0))\n        {\n          /* Use the alternative access functions also in the recursive\n             call.  */\n          dirs.gl_opendir = pglob->gl_opendir;\n          dirs.gl_readdir = pglob->gl_readdir;\n          dirs.gl_closedir = pglob->gl_closedir;\n          dirs.gl_stat = pglob->gl_stat;\n          dirs.gl_lstat = pglob->gl_lstat;\n        }\n\n      status = glob (dirname,\n                     ((flags & (GLOB_ERR | GLOB_NOESCAPE\n                                | GLOB_ALTDIRFUNC))\n                      | GLOB_NOSORT | GLOB_ONLYDIR),\n                     errfunc, &dirs);\n      if (status != 0)\n        {\n          if ((flags & GLOB_NOCHECK) == 0 || status != GLOB_NOMATCH)\n            {\n              retval = status;\n              goto out;\n            }\n          goto no_matches;\n        }\n\n      /* We have successfully globbed the preceding directory name.\n         For each name we found, call glob_in_dir on it and FILENAME,\n         appending the results to PGLOB.  */\n      for (i = 0; i < dirs.gl_pathc; ++i)\n        {\n          size_t old_pathc;\n\n          old_pathc = pglob->gl_pathc;\n          status = glob_in_dir (filename, dirs.gl_pathv[i],\n                                ((flags | GLOB_APPEND)\n                                 & ~(GLOB_NOCHECK | GLOB_NOMAGIC)),\n                                errfunc, pglob, alloca_used);\n          if (status == GLOB_NOMATCH)\n            /* No matches in this directory.  Try the next.  */\n            continue;\n\n          if (status != 0)\n            {\n              globfree (&dirs);\n              globfree (pglob);\n              pglob->gl_pathc = 0;\n              retval = status;\n              goto out;\n            }\n\n          /* Stick the directory on the front of each name.  */\n          if (prefix_array (dirs.gl_pathv[i],\n                            &pglob->gl_pathv[old_pathc + pglob->gl_offs],\n                            pglob->gl_pathc - old_pathc))\n            {\n              globfree (&dirs);\n              globfree (pglob);\n              pglob->gl_pathc = 0;\n              retval = GLOB_NOSPACE;\n              goto out;\n            }\n        }\n\n      flags |= GLOB_MAGCHAR;\n\n      /* We have ignored the GLOB_NOCHECK flag in the 'glob_in_dir' calls.\n         But if we have not found any matching entry and the GLOB_NOCHECK\n         flag was set we must return the input pattern itself.  */\n      if (pglob->gl_pathc + pglob->gl_offs == oldcount)\n        {\n        no_matches:\n          /* No matches.  */\n          if (flags & GLOB_NOCHECK)\n            {\n              size_t newcount = pglob->gl_pathc + pglob->gl_offs;\n              char **new_gl_pathv;\n\n              if (newcount > SIZE_MAX / sizeof (char *) - 2)\n                {\n                nospace2:\n                  globfree (&dirs);\n                  retval = GLOB_NOSPACE;\n                  goto out;\n                }\n\n              new_gl_pathv = realloc (pglob->gl_pathv,\n                                      (newcount + 2) * sizeof (char *));\n              if (new_gl_pathv == NULL)\n                goto nospace2;\n              pglob->gl_pathv = new_gl_pathv;\n\n              pglob->gl_pathv[newcount] = strdup (pattern);\n              if (pglob->gl_pathv[newcount] == NULL)\n                {\n                  globfree (&dirs);\n                  globfree (pglob);\n                  pglob->gl_pathc = 0;\n                  retval = GLOB_NOSPACE;\n                  goto out;\n                }\n\n              ++pglob->gl_pathc;\n              ++newcount;\n\n              pglob->gl_pathv[newcount] = NULL;\n              pglob->gl_flags = flags;\n            }\n          else\n            {\n              globfree (&dirs);\n              retval = GLOB_NOMATCH;\n              goto out;\n            }\n        }\n\n      globfree (&dirs);\n    }\n  else\n    {\n      size_t old_pathc = pglob->gl_pathc;\n      int orig_flags = flags;\n\n      if (meta & GLOBPAT_BACKSLASH)\n        {\n          char *p = strchr (dirname, '\\\\'), *q;\n          /* We need to unescape the dirname string.  It is certainly\n             allocated by alloca, as otherwise filename would be NULL\n             or dirname wouldn't contain backslashes.  */\n          q = p;\n          do\n            {\n              if (*p == '\\\\')\n                {\n                  *q = *++p;\n                  --dirlen;\n                }\n              else\n                *q = *p;\n              ++q;\n            }\n          while (*p++ != '\\0');\n          dirname_modified = 1;\n        }\n      if (dirname_modified)\n        flags &= ~(GLOB_NOCHECK | GLOB_NOMAGIC);\n      status = glob_in_dir (filename, dirname, flags, errfunc, pglob,\n                            alloca_used);\n      if (status != 0)\n        {\n          if (status == GLOB_NOMATCH && flags != orig_flags\n              && pglob->gl_pathc + pglob->gl_offs == oldcount)\n            {\n              /* Make sure globfree (&dirs); is a nop.  */\n              dirs.gl_pathv = NULL;\n              flags = orig_flags;\n              goto no_matches;\n            }\n          retval = status;\n          goto out;\n        }\n\n      if (dirlen > 0)\n        {\n          /* Stick the directory on the front of each name.  */\n          if (prefix_array (dirname,\n                            &pglob->gl_pathv[old_pathc + pglob->gl_offs],\n                            pglob->gl_pathc - old_pathc))\n            {\n              globfree (pglob);\n              pglob->gl_pathc = 0;\n              retval = GLOB_NOSPACE;\n              goto out;\n            }\n        }\n    }\n\n  if (flags & GLOB_MARK)\n    {\n      /* Append slashes to directory names.  */\n      size_t i;\n\n      for (i = oldcount; i < pglob->gl_pathc + pglob->gl_offs; ++i)\n        if (is_dir (pglob->gl_pathv[i], flags, pglob))\n          {\n            size_t len = strlen (pglob->gl_pathv[i]) + 2;\n            char *new = realloc (pglob->gl_pathv[i], len);\n            if (new == NULL)\n              {\n                globfree (pglob);\n                pglob->gl_pathc = 0;\n                retval = GLOB_NOSPACE;\n                goto out;\n              }\n            strcpy (&new[len - 2], \"/\");\n            pglob->gl_pathv[i] = new;\n          }\n    }\n\n  if (!(flags & GLOB_NOSORT))\n    {\n      /* Sort the vector.  */\n      qsort (&pglob->gl_pathv[oldcount],\n             pglob->gl_pathc + pglob->gl_offs - oldcount,\n             sizeof (char *), collated_compare);\n    }\n\n out:\n  if (__glibc_unlikely (malloc_dirname))\n    free (dirname);\n\n  return retval;\n}", "func_hash": 117294583205769293929285722462366033294, "file_name": "glob.c", "file_hash": 86657842076081720969928155936908511288, "cwe": ["CWE-119"], "cve": "CVE-2017-15670", "cve_desc": "The GNU C Library (aka glibc or libc6) before 2.27 contains an off-by-one error leading to a heap-based buffer overflow in the glob function in glob.c, related to the processing of home directories using the ~ operator followed by a long string.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-15670", "file_path": "lib/glob.c"}
{"idx": 211700, "project": "linux", "commit_id": "4fbcc1a4cb20fe26ad0225679c536c80f1648221", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/4fbcc1a4cb20fe26ad0225679c536c80f1648221", "commit_message": "nfc: st21nfca: Fix potential buffer overflows in EVT_TRANSACTION\n\nIt appears that there are some buffer overflows in EVT_TRANSACTION.\nThis happens because the length parameters that are passed to memcpy\ncome directly from skb->data and are not guarded in any way.\n\nSigned-off-by: Jordy Zomer <jordy@pwning.systems>\nReviewed-by: Krzysztof Kozlowski <krzysztof.kozlowski@canonical.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "target": 1, "func": "int st21nfca_connectivity_event_received(struct nfc_hci_dev *hdev, u8 host,\n\t\t\t\tu8 event, struct sk_buff *skb)\n{\n\tint r = 0;\n\tstruct device *dev = &hdev->ndev->dev;\n\tstruct nfc_evt_transaction *transaction;\n\n\tpr_debug(\"connectivity gate event: %x\\n\", event);\n\n\tswitch (event) {\n\tcase ST21NFCA_EVT_CONNECTIVITY:\n\t\tr = nfc_se_connectivity(hdev->ndev, host);\n\tbreak;\n\tcase ST21NFCA_EVT_TRANSACTION:\n\t\t/*\n\t\t * According to specification etsi 102 622\n\t\t * 11.2.2.4 EVT_TRANSACTION Table 52\n\t\t * Description\tTag\tLength\n\t\t * AID\t\t81\t5 to 16\n\t\t * PARAMETERS\t82\t0 to 255\n\t\t */\n\t\tif (skb->len < NFC_MIN_AID_LENGTH + 2 &&\n\t\t    skb->data[0] != NFC_EVT_TRANSACTION_AID_TAG)\n\t\t\treturn -EPROTO;\n\n\t\ttransaction = devm_kzalloc(dev, skb->len - 2, GFP_KERNEL);\n\t\tif (!transaction)\n\t\t\treturn -ENOMEM;\n\n\t\ttransaction->aid_len = skb->data[1];\n\t\tmemcpy(transaction->aid, &skb->data[2],\n\t\t       transaction->aid_len);\n\n\t\t/* Check next byte is PARAMETERS tag (82) */\n\t\tif (skb->data[transaction->aid_len + 2] !=\n\t\t    NFC_EVT_TRANSACTION_PARAMS_TAG)\n\t\t\treturn -EPROTO;\n\n\t\ttransaction->params_len = skb->data[transaction->aid_len + 3];\n\t\tmemcpy(transaction->params, skb->data +\n\t\t       transaction->aid_len + 4, transaction->params_len);\n\n\t\tr = nfc_se_transaction(hdev->ndev, host, transaction);\n\tbreak;\n\tdefault:\n\t\tnfc_err(&hdev->ndev->dev, \"Unexpected event on connectivity gate\\n\");\n\t\treturn 1;\n\t}\n\tkfree_skb(skb);\n\treturn r;\n}", "func_hash": 253634808738614127513017365541725702270, "file_name": "se.c", "file_hash": 262088554020527485810277505080130104803, "cwe": ["CWE-120"], "cve": "CVE-2022-26490", "cve_desc": "st21nfca_connectivity_event_received in drivers/nfc/st21nfca/se.c in the Linux kernel through 5.16.12 has EVT_TRANSACTION buffer overflows because of untrusted length parameters.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-26490", "file_path": "drivers/nfc/st-nci/se.c"}
{"idx": 450830, "project": "linux", "commit_id": "4fbcc1a4cb20fe26ad0225679c536c80f1648221", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/4fbcc1a4cb20fe26ad0225679c536c80f1648221", "commit_message": "nfc: st21nfca: Fix potential buffer overflows in EVT_TRANSACTION\n\nIt appears that there are some buffer overflows in EVT_TRANSACTION.\nThis happens because the length parameters that are passed to memcpy\ncome directly from skb->data and are not guarded in any way.\n\nSigned-off-by: Jordy Zomer <jordy@pwning.systems>\nReviewed-by: Krzysztof Kozlowski <krzysztof.kozlowski@canonical.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "target": 0, "func": "int st21nfca_connectivity_event_received(struct nfc_hci_dev *hdev, u8 host,\n\t\t\t\tu8 event, struct sk_buff *skb)\n{\n\tint r = 0;\n\tstruct device *dev = &hdev->ndev->dev;\n\tstruct nfc_evt_transaction *transaction;\n\n\tpr_debug(\"connectivity gate event: %x\\n\", event);\n\n\tswitch (event) {\n\tcase ST21NFCA_EVT_CONNECTIVITY:\n\t\tr = nfc_se_connectivity(hdev->ndev, host);\n\tbreak;\n\tcase ST21NFCA_EVT_TRANSACTION:\n\t\t/*\n\t\t * According to specification etsi 102 622\n\t\t * 11.2.2.4 EVT_TRANSACTION Table 52\n\t\t * Description\tTag\tLength\n\t\t * AID\t\t81\t5 to 16\n\t\t * PARAMETERS\t82\t0 to 255\n\t\t */\n\t\tif (skb->len < NFC_MIN_AID_LENGTH + 2 &&\n\t\t    skb->data[0] != NFC_EVT_TRANSACTION_AID_TAG)\n\t\t\treturn -EPROTO;\n\n\t\ttransaction = devm_kzalloc(dev, skb->len - 2, GFP_KERNEL);\n\t\tif (!transaction)\n\t\t\treturn -ENOMEM;\n\n\t\ttransaction->aid_len = skb->data[1];\n\n\t\t/* Checking if the length of the AID is valid */\n\t\tif (transaction->aid_len > sizeof(transaction->aid))\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(transaction->aid, &skb->data[2],\n\t\t       transaction->aid_len);\n\n\t\t/* Check next byte is PARAMETERS tag (82) */\n\t\tif (skb->data[transaction->aid_len + 2] !=\n\t\t    NFC_EVT_TRANSACTION_PARAMS_TAG)\n\t\t\treturn -EPROTO;\n\n\t\ttransaction->params_len = skb->data[transaction->aid_len + 3];\n\n\t\t/* Total size is allocated (skb->len - 2) minus fixed array members */\n\t\tif (transaction->params_len > ((skb->len - 2) - sizeof(struct nfc_evt_transaction)))\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(transaction->params, skb->data +\n\t\t       transaction->aid_len + 4, transaction->params_len);\n\n\t\tr = nfc_se_transaction(hdev->ndev, host, transaction);\n\tbreak;\n\tdefault:\n\t\tnfc_err(&hdev->ndev->dev, \"Unexpected event on connectivity gate\\n\");\n\t\treturn 1;\n\t}\n\tkfree_skb(skb);\n\treturn r;\n}", "func_hash": 192395528803862067074725666985010866676, "file_name": "se.c", "file_hash": 50941829261793889476158524684428564511, "cwe": ["CWE-120"], "cve": "CVE-2022-26490", "cve_desc": "st21nfca_connectivity_event_received in drivers/nfc/st21nfca/se.c in the Linux kernel through 5.16.12 has EVT_TRANSACTION buffer overflows because of untrusted length parameters.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-26490", "file_path": "drivers/nfc/st-nci/se.c"}
{"idx": 211773, "project": "ntp", "commit_id": "07a5b8141e354a998a52994c3c9cd547927e56ce", "project_url": "https://github.com/ntp-project/ntp", "commit_url": "https://github.com/ntp-project/ntp/commit/07a5b8141e354a998a52994c3c9cd547927e56ce", "commit_message": "[TALOS-CAN-0063] avoid buffer overrun in ntpq", "target": 1, "func": "cookedprint(\n\tint datatype,\n\tint length,\n\tconst char *data,\n\tint status,\n\tint quiet,\n\tFILE *fp\n\t)\n{\n\tchar *name;\n\tchar *value;\n\tchar output_raw;\n\tint fmt;\n\tl_fp lfp;\n\tsockaddr_u hval;\n\tu_long uval;\n\tint narr;\n\tsize_t len;\n\tl_fp lfparr[8];\n\tchar b[12];\n\tchar bn[2 * MAXVARLEN];\n\tchar bv[2 * MAXVALLEN];\n\n\tUNUSED_ARG(datatype);\n\n\tif (!quiet)\n\t\tfprintf(fp, \"status=%04x %s,\\n\", status,\n\t\t\tstatustoa(datatype, status));\n\n\tstartoutput();\n\twhile (nextvar(&length, &data, &name, &value)) {\n\t\tfmt = varfmt(name);\n\t\toutput_raw = 0;\n\t\tswitch (fmt) {\n\n\t\tcase PADDING:\n\t\t\toutput_raw = '*';\n\t\t\tbreak;\n\n\t\tcase TS:\n\t\t\tif (!decodets(value, &lfp))\n\t\t\t\toutput_raw = '?';\n\t\t\telse\n\t\t\t\toutput(fp, name, prettydate(&lfp));\n\t\t\tbreak;\n\n\t\tcase HA:\t/* fallthru */\n\t\tcase NA:\n\t\t\tif (!decodenetnum(value, &hval)) {\n\t\t\t\toutput_raw = '?';\n\t\t\t} else if (fmt == HA){\n\t\t\t\toutput(fp, name, nntohost(&hval));\n\t\t\t} else {\n\t\t\t\toutput(fp, name, stoa(&hval));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase RF:\n\t\t\tif (decodenetnum(value, &hval)) {\n\t\t\t\tif (ISREFCLOCKADR(&hval))\n\t\t\t\t\toutput(fp, name,\n\t\t\t\t\t       refnumtoa(&hval));\n\t\t\t\telse\n\t\t\t\t\toutput(fp, name, stoa(&hval));\n\t\t\t} else if (strlen(value) <= 4) {\n\t\t\t\toutput(fp, name, value);\n\t\t\t} else {\n\t\t\t\toutput_raw = '?';\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase LP:\n\t\t\tif (!decodeuint(value, &uval) || uval > 3) {\n\t\t\t\toutput_raw = '?';\n\t\t\t} else {\n\t\t\t\tb[0] = (0x2 & uval)\n\t\t\t\t\t   ? '1'\n\t\t\t\t\t   : '0';\n\t\t\t\tb[1] = (0x1 & uval)\n\t\t\t\t\t   ? '1'\n\t\t\t\t\t   : '0';\n\t\t\t\tb[2] = '\\0';\n\t\t\t\toutput(fp, name, b);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase OC:\n\t\t\tif (!decodeuint(value, &uval)) {\n\t\t\t\toutput_raw = '?';\n\t\t\t} else {\n\t\t\t\tsnprintf(b, sizeof(b), \"%03lo\", uval);\n\t\t\t\toutput(fp, name, b);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase AR:\n\t\t\tif (!decodearr(value, &narr, lfparr))\n\t\t\t\toutput_raw = '?';\n\t\t\telse\n\t\t\t\toutputarr(fp, name, narr, lfparr);\n\t\t\tbreak;\n\n\t\tcase FX:\n\t\t\tif (!decodeuint(value, &uval))\n\t\t\t\toutput_raw = '?';\n\t\t\telse\n\t\t\t\toutput(fp, name, tstflags(uval));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Internal error in cookedprint, %s=%s, fmt %d\\n\",\n\t\t\t\tname, value, fmt);\n\t\t\toutput_raw = '?';\n\t\t\tbreak;\n\t\t}\n\n\t\tif (output_raw != 0) {\n\t\t\tatoascii(name, MAXVARLEN, bn, sizeof(bn));\n\t\t\tatoascii(value, MAXVALLEN, bv, sizeof(bv));\n\t\t\tif (output_raw != '*') {\n\t\t\t\tlen = strlen(bv);\n\t\t\t\tbv[len] = output_raw;\n\t\t\t\tbv[len+1] = '\\0';\n\t\t\t}\n\t\t\toutput(fp, bn, bv);\n\t\t}\n\t}\n\tendoutput(fp);\n}", "func_hash": 117019892599870517074003591750988787973, "file_name": "ntpq.c", "file_hash": 263164452008239257044928277190655422420, "cwe": ["CWE-20"], "cve": "CVE-2015-7852", "cve_desc": "ntpq in NTP 4.2.x before 4.2.8p4, and 4.3.x before 4.3.77 allows remote attackers to cause a denial of service (crash) via crafted mode 6 response packets.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-7852", "file_path": "ntpq/ntpq.c"}
{"idx": 451731, "project": "ntp", "commit_id": "07a5b8141e354a998a52994c3c9cd547927e56ce", "project_url": "https://github.com/ntp-project/ntp", "commit_url": "https://github.com/ntp-project/ntp/commit/07a5b8141e354a998a52994c3c9cd547927e56ce", "commit_message": "[TALOS-CAN-0063] avoid buffer overrun in ntpq", "target": 0, "func": "cookedprint(\n\tint datatype,\n\tint length,\n\tconst char *data,\n\tint status,\n\tint quiet,\n\tFILE *fp\n\t)\n{\n\tchar *name;\n\tchar *value;\n\tchar output_raw;\n\tint fmt;\n\tl_fp lfp;\n\tsockaddr_u hval;\n\tu_long uval;\n\tint narr;\n\tsize_t len;\n\tl_fp lfparr[8];\n\tchar b[12];\n\tchar bn[2 * MAXVARLEN];\n\tchar bv[2 * MAXVALLEN];\n\n\tUNUSED_ARG(datatype);\n\n\tif (!quiet)\n\t\tfprintf(fp, \"status=%04x %s,\\n\", status,\n\t\t\tstatustoa(datatype, status));\n\n\tstartoutput();\n\twhile (nextvar(&length, &data, &name, &value)) {\n\t\tfmt = varfmt(name);\n\t\toutput_raw = 0;\n\t\tswitch (fmt) {\n\n\t\tcase PADDING:\n\t\t\toutput_raw = '*';\n\t\t\tbreak;\n\n\t\tcase TS:\n\t\t\tif (!decodets(value, &lfp))\n\t\t\t\toutput_raw = '?';\n\t\t\telse\n\t\t\t\toutput(fp, name, prettydate(&lfp));\n\t\t\tbreak;\n\n\t\tcase HA:\t/* fallthru */\n\t\tcase NA:\n\t\t\tif (!decodenetnum(value, &hval)) {\n\t\t\t\toutput_raw = '?';\n\t\t\t} else if (fmt == HA){\n\t\t\t\toutput(fp, name, nntohost(&hval));\n\t\t\t} else {\n\t\t\t\toutput(fp, name, stoa(&hval));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase RF:\n\t\t\tif (decodenetnum(value, &hval)) {\n\t\t\t\tif (ISREFCLOCKADR(&hval))\n\t\t\t\t\toutput(fp, name,\n\t\t\t\t\t       refnumtoa(&hval));\n\t\t\t\telse\n\t\t\t\t\toutput(fp, name, stoa(&hval));\n\t\t\t} else if (strlen(value) <= 4) {\n\t\t\t\toutput(fp, name, value);\n\t\t\t} else {\n\t\t\t\toutput_raw = '?';\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase LP:\n\t\t\tif (!decodeuint(value, &uval) || uval > 3) {\n\t\t\t\toutput_raw = '?';\n\t\t\t} else {\n\t\t\t\tb[0] = (0x2 & uval)\n\t\t\t\t\t   ? '1'\n\t\t\t\t\t   : '0';\n\t\t\t\tb[1] = (0x1 & uval)\n\t\t\t\t\t   ? '1'\n\t\t\t\t\t   : '0';\n\t\t\t\tb[2] = '\\0';\n\t\t\t\toutput(fp, name, b);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase OC:\n\t\t\tif (!decodeuint(value, &uval)) {\n\t\t\t\toutput_raw = '?';\n\t\t\t} else {\n\t\t\t\tsnprintf(b, sizeof(b), \"%03lo\", uval);\n\t\t\t\toutput(fp, name, b);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase AR:\n\t\t\tif (!decodearr(value, &narr, lfparr))\n\t\t\t\toutput_raw = '?';\n\t\t\telse\n\t\t\t\toutputarr(fp, name, narr, lfparr);\n\t\t\tbreak;\n\n\t\tcase FX:\n\t\t\tif (!decodeuint(value, &uval))\n\t\t\t\toutput_raw = '?';\n\t\t\telse\n\t\t\t\toutput(fp, name, tstflags(uval));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Internal error in cookedprint, %s=%s, fmt %d\\n\",\n\t\t\t\tname, value, fmt);\n\t\t\toutput_raw = '?';\n\t\t\tbreak;\n\t\t}\n\n\t\tif (output_raw != 0) {\n\t\t\t/* TALOS-CAN-0063: avoid buffer overrun */\n\t\t\tatoascii(name, MAXVARLEN, bn, sizeof(bn));\n\t\t\tif (output_raw != '*') {\n\t\t\t\tatoascii(value, MAXVALLEN,\n\t\t\t\t\t bv, sizeof(bv) - 1);\n\t\t\t\tlen = strlen(bv);\n\t\t\t\tbv[len] = output_raw;\n\t\t\t\tbv[len+1] = '\\0';\n\t\t\t} else {\n\t\t\t\tatoascii(value, MAXVALLEN,\n\t\t\t\t\t bv, sizeof(bv));\n\t\t\t}\n\t\t\toutput(fp, bn, bv);\n\t\t}\n\t}\n\tendoutput(fp);\n}", "func_hash": 286888330459003026331284434605345848005, "file_name": "ntpq.c", "file_hash": 291788569529258980351890148746025724022, "cwe": ["CWE-20"], "cve": "CVE-2015-7852", "cve_desc": "ntpq in NTP 4.2.x before 4.2.8p4, and 4.3.x before 4.3.77 allows remote attackers to cause a denial of service (crash) via crafted mode 6 response packets.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-7852", "file_path": "ntpq/ntpq.c"}
{"idx": 211785, "project": "jasper", "commit_id": "4cd52b5daac62b00a0a328451544807ddecf775f", "project_url": "https://github.com/mdadams/jasper", "commit_url": "https://github.com/jasper-software/jasper/commit/4cd52b5daac62b00a0a328451544807ddecf775f", "commit_message": "Avoid maxrlvls more than upper bound to cause heap-buffer-overflow", "target": 1, "func": "static jpc_enc_cp_t *cp_create(const char *optstr, jas_image_t *image)\n{\n\tjpc_enc_cp_t *cp;\n\tjas_tvparser_t *tvp;\n\tint ret;\n\tint numilyrrates;\n\tdouble *ilyrrates;\n\tint i;\n\tint tagid;\n\tjpc_enc_tcp_t *tcp;\n\tjpc_enc_tccp_t *tccp;\n\tjpc_enc_ccp_t *ccp;\n\tuint_fast16_t rlvlno;\n\tuint_fast16_t prcwidthexpn;\n\tuint_fast16_t prcheightexpn;\n\tbool enablemct;\n\tuint_fast32_t jp2overhead;\n\tuint_fast16_t lyrno;\n\tuint_fast32_t hsteplcm;\n\tuint_fast32_t vsteplcm;\n\tbool mctvalid;\n\n\ttvp = 0;\n\tcp = 0;\n\tilyrrates = 0;\n\tnumilyrrates = 0;\n\n\tif (!(cp = jas_malloc(sizeof(jpc_enc_cp_t)))) {\n\t\tgoto error;\n\t}\n\n\tprcwidthexpn = 15;\n\tprcheightexpn = 15;\n\tenablemct = true;\n\tjp2overhead = 0;\n\n\tcp->ccps = 0;\n\tcp->debug = 0;\n\tcp->imgareatlx = UINT_FAST32_MAX;\n\tcp->imgareatly = UINT_FAST32_MAX;\n\tcp->refgrdwidth = 0;\n\tcp->refgrdheight = 0;\n\tcp->tilegrdoffx = UINT_FAST32_MAX;\n\tcp->tilegrdoffy = UINT_FAST32_MAX;\n\tcp->tilewidth = 0;\n\tcp->tileheight = 0;\n\tcp->numcmpts = jas_image_numcmpts(image);\n\n\thsteplcm = 1;\n\tvsteplcm = 1;\n\tfor (unsigned cmptno = 0; cmptno < jas_image_numcmpts(image); ++cmptno) {\n\t\tif (jas_image_cmptbrx(image, cmptno) + jas_image_cmpthstep(image, cmptno) <=\n\t\t  jas_image_brx(image) || jas_image_cmptbry(image, cmptno) +\n\t\t  jas_image_cmptvstep(image, cmptno) <= jas_image_bry(image)) {\n\t\t\tjas_eprintf(\"unsupported image type\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\t/* Note: We ought to be calculating the LCMs here.  Fix some day. */\n\t\thsteplcm *= jas_image_cmpthstep(image, cmptno);\n\t\tvsteplcm *= jas_image_cmptvstep(image, cmptno);\n\t}\n\n\tif (!(cp->ccps = jas_alloc2(cp->numcmpts, sizeof(jpc_enc_ccp_t)))) {\n\t\tgoto error;\n\t}\n\tunsigned cmptno;\n\tfor (cmptno = 0, ccp = cp->ccps; cmptno < cp->numcmpts; ++cmptno,\n\t  ++ccp) {\n\t\tccp->sampgrdstepx = jas_image_cmpthstep(image, cmptno);\n\t\tccp->sampgrdstepy = jas_image_cmptvstep(image, cmptno);\n\t\t/* XXX - this isn't quite correct for more general image */\n\t\tccp->sampgrdsubstepx = 0;\n\t\tccp->sampgrdsubstepx = 0;\n\t\tccp->prec = jas_image_cmptprec(image, cmptno);\n\t\tccp->sgnd = jas_image_cmptsgnd(image, cmptno);\n\t\tccp->numstepsizes = 0;\n\t\tmemset(ccp->stepsizes, 0, sizeof(ccp->stepsizes));\n\t}\n\n\tcp->rawsize = jas_image_rawsize(image);\n\tif (cp->rawsize == 0) {\n\t\t/* prevent division by zero in cp_create() */\n\t\tgoto error;\n\t}\n\tcp->totalsize = UINT_FAST32_MAX;\n\n\ttcp = &cp->tcp;\n\ttcp->csty = 0;\n\ttcp->intmode = true;\n\ttcp->prg = JPC_COD_LRCPPRG;\n\ttcp->numlyrs = 1;\n\ttcp->ilyrrates = 0;\n\n\ttccp = &cp->tccp;\n\ttccp->csty = 0;\n\ttccp->maxrlvls = 6;\n\ttccp->cblkwidthexpn = 6;\n\ttccp->cblkheightexpn = 6;\n\ttccp->cblksty = 0;\n\ttccp->numgbits = 2;\n\n\tif (!(tvp = jas_tvparser_create(optstr ? optstr : \"\"))) {\n\t\tgoto error;\n\t}\n\n\twhile (!(ret = jas_tvparser_next(tvp))) {\n\t\tswitch (jas_taginfo_nonull(jas_taginfos_lookup(encopts,\n\t\t  jas_tvparser_gettag(tvp)))->id) {\n\t\tcase OPT_DEBUG:\n\t\t\tcp->debug = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_IMGAREAOFFX:\n\t\t\tcp->imgareatlx = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_IMGAREAOFFY:\n\t\t\tcp->imgareatly = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEGRDOFFX:\n\t\t\tcp->tilegrdoffx = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEGRDOFFY:\n\t\t\tcp->tilegrdoffy = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEWIDTH:\n\t\t\tcp->tilewidth = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEHEIGHT:\n\t\t\tcp->tileheight = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_PRCWIDTH:\n\t\t\tprcwidthexpn = jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_PRCHEIGHT:\n\t\t\tprcheightexpn = jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_CBLKWIDTH:\n\t\t\ttccp->cblkwidthexpn =\n\t\t\t  jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_CBLKHEIGHT:\n\t\t\ttccp->cblkheightexpn =\n\t\t\t  jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_MODE:\n\t\t\tif ((tagid = jas_taginfo_nonull(jas_taginfos_lookup(modetab,\n\t\t\t  jas_tvparser_getval(tvp)))->id) < 0) {\n\t\t\t\tjas_eprintf(\"ignoring invalid mode %s\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t} else {\n\t\t\t\ttcp->intmode = (tagid == MODE_INT);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_PRG:\n\t\t\tif ((tagid = jas_taginfo_nonull(jas_taginfos_lookup(prgordtab,\n\t\t\t  jas_tvparser_getval(tvp)))->id) < 0) {\n\t\t\t\tjas_eprintf(\"ignoring invalid progression order %s\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t} else {\n\t\t\t\ttcp->prg = tagid;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_NOMCT:\n\t\t\tenablemct = false;\n\t\t\tbreak;\n\t\tcase OPT_MAXRLVLS:\n\t\t\ttccp->maxrlvls = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_SOP:\n\t\t\tcp->tcp.csty |= JPC_COD_SOP;\n\t\t\tbreak;\n\t\tcase OPT_EPH:\n\t\t\tcp->tcp.csty |= JPC_COD_EPH;\n\t\t\tbreak;\n\t\tcase OPT_LAZY:\n\t\t\ttccp->cblksty |= JPC_COX_LAZY;\n\t\t\tbreak;\n\t\tcase OPT_TERMALL:\n\t\t\ttccp->cblksty |= JPC_COX_TERMALL;\n\t\t\tbreak;\n\t\tcase OPT_SEGSYM:\n\t\t\ttccp->cblksty |= JPC_COX_SEGSYM;\n\t\t\tbreak;\n\t\tcase OPT_VCAUSAL:\n\t\t\ttccp->cblksty |= JPC_COX_VSC;\n\t\t\tbreak;\n\t\tcase OPT_RESET:\n\t\t\ttccp->cblksty |= JPC_COX_RESET;\n\t\t\tbreak;\n\t\tcase OPT_PTERM:\n\t\t\ttccp->cblksty |= JPC_COX_PTERM;\n\t\t\tbreak;\n\t\tcase OPT_NUMGBITS:\n\t\t\tcp->tccp.numgbits = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_RATE:\n\t\t\tif (ratestrtosize(jas_tvparser_getval(tvp), cp->rawsize,\n\t\t\t  &cp->totalsize)) {\n\t\t\t\tjas_eprintf(\"ignoring bad rate specifier %s\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_ILYRRATES:\n\t\t\tif (jpc_atoaf(jas_tvparser_getval(tvp), &numilyrrates,\n\t\t\t  &ilyrrates)) {\n\t\t\t\tjas_eprintf(\"warning: invalid intermediate layer rates specifier ignored (%s)\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase OPT_JP2OVERHEAD:\n\t\t\tjp2overhead = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tjas_eprintf(\"warning: ignoring invalid option %s\\n\",\n\t\t\t jas_tvparser_gettag(tvp));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tjas_tvparser_destroy(tvp);\n\ttvp = 0;\n\n\tif (cp->totalsize != UINT_FAST32_MAX) {\n\t\tcp->totalsize = (cp->totalsize > jp2overhead) ?\n\t\t  (cp->totalsize - jp2overhead) : 0;\n\t}\n\n\tif (cp->imgareatlx == UINT_FAST32_MAX) {\n\t\tcp->imgareatlx = 0;\n\t} else {\n\t\tif (hsteplcm != 1) {\n\t\t\tjas_eprintf(\"warning: overriding imgareatlx value\\n\");\n\t\t}\n\t\tcp->imgareatlx *= hsteplcm;\n\t}\n\tif (cp->imgareatly == UINT_FAST32_MAX) {\n\t\tcp->imgareatly = 0;\n\t} else {\n\t\tif (vsteplcm != 1) {\n\t\t\tjas_eprintf(\"warning: overriding imgareatly value\\n\");\n\t\t}\n\t\tcp->imgareatly *= vsteplcm;\n\t}\n\tcp->refgrdwidth = cp->imgareatlx + jas_image_width(image);\n\tcp->refgrdheight = cp->imgareatly + jas_image_height(image);\n\tif (cp->tilegrdoffx == UINT_FAST32_MAX) {\n\t\tcp->tilegrdoffx = cp->imgareatlx;\n\t}\n\tif (cp->tilegrdoffy == UINT_FAST32_MAX) {\n\t\tcp->tilegrdoffy = cp->imgareatly;\n\t}\n\tif (!cp->tilewidth) {\n\t\tcp->tilewidth = cp->refgrdwidth - cp->tilegrdoffx;\n\t}\n\tif (!cp->tileheight) {\n\t\tcp->tileheight = cp->refgrdheight - cp->tilegrdoffy;\n\t}\n\n\tif (cp->numcmpts == 3) {\n\t\tmctvalid = true;\n\t\tfor (cmptno = 0; cmptno < jas_image_numcmpts(image); ++cmptno) {\n\t\t\tif (jas_image_cmptprec(image, cmptno) != jas_image_cmptprec(image, 0) ||\n\t\t\t  jas_image_cmptsgnd(image, cmptno) != jas_image_cmptsgnd(image, 0) ||\n\t\t\t  jas_image_cmptwidth(image, cmptno) != jas_image_cmptwidth(image, 0) ||\n\t\t\t  jas_image_cmptheight(image, cmptno) != jas_image_cmptheight(image, 0)) {\n\t\t\t\tmctvalid = false;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tmctvalid = false;\n\t}\n\tif (mctvalid && enablemct && jas_clrspc_fam(jas_image_clrspc(image)) != JAS_CLRSPC_FAM_RGB) {\n\t\tjas_eprintf(\"warning: color space apparently not RGB\\n\");\n\t}\n\tif (mctvalid && enablemct && jas_clrspc_fam(jas_image_clrspc(image)) == JAS_CLRSPC_FAM_RGB) {\n\t\ttcp->mctid = (tcp->intmode) ? (JPC_MCT_RCT) : (JPC_MCT_ICT);\n\t} else {\n\t\ttcp->mctid = JPC_MCT_NONE;\n\t}\n\ttccp->qmfbid = (tcp->intmode) ? (JPC_COX_RFT) : (JPC_COX_INS);\n\n\tfor (rlvlno = 0; rlvlno < tccp->maxrlvls; ++rlvlno) {\n\t\ttccp->prcwidthexpns[rlvlno] = prcwidthexpn;\n\t\ttccp->prcheightexpns[rlvlno] = prcheightexpn;\n\t}\n\tif (prcwidthexpn != 15 || prcheightexpn != 15) {\n\t\ttccp->csty |= JPC_COX_PRT;\n\t}\n\n\t/* Ensure that the tile width and height is valid. */\n\tif (!cp->tilewidth) {\n\t\tjas_eprintf(\"invalid tile width %lu\\n\", (unsigned long)\n\t\t  cp->tilewidth);\n\t\tgoto error;\n\t}\n\tif (!cp->tileheight) {\n\t\tjas_eprintf(\"invalid tile height %lu\\n\", (unsigned long)\n\t\t  cp->tileheight);\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the tile grid offset is valid. */\n\tif (cp->tilegrdoffx > cp->imgareatlx ||\n\t  cp->tilegrdoffy > cp->imgareatly ||\n\t  cp->tilegrdoffx + cp->tilewidth < cp->imgareatlx ||\n\t  cp->tilegrdoffy + cp->tileheight < cp->imgareatly) {\n\t\tjas_eprintf(\"invalid tile grid offset (%lu, %lu)\\n\",\n\t\t  (unsigned long) cp->tilegrdoffx, (unsigned long)\n\t\t  cp->tilegrdoffy);\n\t\tgoto error;\n\t}\n\n\tcp->numhtiles = JPC_CEILDIV(cp->refgrdwidth - cp->tilegrdoffx,\n\t  cp->tilewidth);\n\tcp->numvtiles = JPC_CEILDIV(cp->refgrdheight - cp->tilegrdoffy,\n\t  cp->tileheight);\n\tcp->numtiles = cp->numhtiles * cp->numvtiles;\n\n\tif (ilyrrates && numilyrrates > 0) {\n\t\ttcp->numlyrs = numilyrrates + 1;\n\t\tif (!(tcp->ilyrrates = jas_alloc2((tcp->numlyrs - 1),\n\t\t  sizeof(jpc_fix_t)))) {\n\t\t\tgoto error;\n\t\t}\n\t\tfor (i = 0; i < JAS_CAST(int, tcp->numlyrs - 1); ++i) {\n\t\t\ttcp->ilyrrates[i] = jpc_dbltofix(ilyrrates[i]);\n\t\t}\n\t}\n\n\t/* Ensure that the integer mode is used in the case of lossless\n\t  coding. */\n\tif (cp->totalsize == UINT_FAST32_MAX && (!cp->tcp.intmode)) {\n\t\tjas_eprintf(\"cannot use real mode for lossless coding\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the precinct width is valid. */\n\tif (prcwidthexpn > 15) {\n\t\tjas_eprintf(\"invalid precinct width\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the precinct height is valid. */\n\tif (prcheightexpn > 15) {\n\t\tjas_eprintf(\"invalid precinct height\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the code block width is valid. */\n\tif (cp->tccp.cblkwidthexpn < 2 || cp->tccp.cblkwidthexpn > 12) {\n\t\tjas_eprintf(\"invalid code block width %d\\n\",\n\t\t  JPC_POW2(cp->tccp.cblkwidthexpn));\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the code block height is valid. */\n\tif (cp->tccp.cblkheightexpn < 2 || cp->tccp.cblkheightexpn > 12) {\n\t\tjas_eprintf(\"invalid code block height %d\\n\",\n\t\t  JPC_POW2(cp->tccp.cblkheightexpn));\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the code block size is not too large. */\n\tif (cp->tccp.cblkwidthexpn + cp->tccp.cblkheightexpn > 12) {\n\t\tjas_eprintf(\"code block size too large\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the number of layers is valid. */\n\tif (cp->tcp.numlyrs > 16384) {\n\t\tjas_eprintf(\"too many layers\\n\");\n\t\tgoto error;\n\t}\n\n\t/* There must be at least one resolution level. */\n\tif (cp->tccp.maxrlvls < 1) {\n\t\tjas_eprintf(\"must be at least one resolution level\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the number of guard bits is valid. */\n\tif (cp->tccp.numgbits > 8) {\n\t\tjas_eprintf(\"invalid number of guard bits\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the rate is within the legal range. */\n\tif (cp->totalsize != UINT_FAST32_MAX && cp->totalsize > cp->rawsize) {\n\t\tjas_eprintf(\"warning: specified rate is unreasonably large (%lu > %lu)\\n\", (unsigned long) cp->totalsize, (unsigned long) cp->rawsize);\n\t}\n\n\t/* Ensure that the intermediate layer rates are valid. */\n\tif (tcp->numlyrs > 1) {\n\t\t/* The intermediate layers rates must increase monotonically. */\n\t\tfor (lyrno = 0; lyrno + 2 < tcp->numlyrs; ++lyrno) {\n\t\t\tif (tcp->ilyrrates[lyrno] >= tcp->ilyrrates[lyrno + 1]) {\n\t\t\t\tjas_eprintf(\"intermediate layer rates must increase monotonically\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\t/* The intermediate layer rates must be less than the overall rate. */\n\t\tif (cp->totalsize != UINT_FAST32_MAX) {\n\t\t\tfor (lyrno = 0; lyrno < tcp->numlyrs - 1; ++lyrno) {\n\t\t\t\tif (jpc_fixtodbl(tcp->ilyrrates[lyrno]) > ((double) cp->totalsize)\n\t\t\t\t  / cp->rawsize) {\n\t\t\t\t\tjas_eprintf(\"warning: intermediate layer rates must be less than overall rate\\n\");\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ilyrrates) {\n\t\tjas_free(ilyrrates);\n\t}\n\n\treturn cp;\n\nerror:\n\n\tif (ilyrrates) {\n\t\tjas_free(ilyrrates);\n\t}\n\tif (tvp) {\n\t\tjas_tvparser_destroy(tvp);\n\t}\n\tif (cp) {\n\t\tjpc_enc_cp_destroy(cp);\n\t}\n\treturn 0;\n}", "func_hash": 179213511260070262932724370978685731129, "file_name": "jpc_enc.c", "file_hash": 285191290025689593258555638021323781658, "cwe": ["CWE-20"], "cve": "CVE-2020-27828", "cve_desc": "There's a flaw in jasper's jpc encoder in versions prior to 2.0.23. Crafted input provided to jasper by an attacker could cause an arbitrary out-of-bounds write. This could potentially affect data confidentiality, integrity, or application availability.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2020-27828", "file_path": "src/libjasper/jpc/jpc_enc.c"}
{"idx": 451888, "project": "jasper", "commit_id": "4cd52b5daac62b00a0a328451544807ddecf775f", "project_url": "https://github.com/mdadams/jasper", "commit_url": "https://github.com/jasper-software/jasper/commit/4cd52b5daac62b00a0a328451544807ddecf775f", "commit_message": "Avoid maxrlvls more than upper bound to cause heap-buffer-overflow", "target": 0, "func": "static jpc_enc_cp_t *cp_create(const char *optstr, jas_image_t *image)\n{\n\tjpc_enc_cp_t *cp;\n\tjas_tvparser_t *tvp;\n\tint ret;\n\tint numilyrrates;\n\tdouble *ilyrrates;\n\tint i;\n\tint tagid;\n\tjpc_enc_tcp_t *tcp;\n\tjpc_enc_tccp_t *tccp;\n\tjpc_enc_ccp_t *ccp;\n\tuint_fast16_t rlvlno;\n\tuint_fast16_t prcwidthexpn;\n\tuint_fast16_t prcheightexpn;\n\tbool enablemct;\n\tuint_fast32_t jp2overhead;\n\tuint_fast16_t lyrno;\n\tuint_fast32_t hsteplcm;\n\tuint_fast32_t vsteplcm;\n\tbool mctvalid;\n\n\ttvp = 0;\n\tcp = 0;\n\tilyrrates = 0;\n\tnumilyrrates = 0;\n\n\tif (!(cp = jas_malloc(sizeof(jpc_enc_cp_t)))) {\n\t\tgoto error;\n\t}\n\n\tprcwidthexpn = 15;\n\tprcheightexpn = 15;\n\tenablemct = true;\n\tjp2overhead = 0;\n\n\tcp->ccps = 0;\n\tcp->debug = 0;\n\tcp->imgareatlx = UINT_FAST32_MAX;\n\tcp->imgareatly = UINT_FAST32_MAX;\n\tcp->refgrdwidth = 0;\n\tcp->refgrdheight = 0;\n\tcp->tilegrdoffx = UINT_FAST32_MAX;\n\tcp->tilegrdoffy = UINT_FAST32_MAX;\n\tcp->tilewidth = 0;\n\tcp->tileheight = 0;\n\tcp->numcmpts = jas_image_numcmpts(image);\n\n\thsteplcm = 1;\n\tvsteplcm = 1;\n\tfor (unsigned cmptno = 0; cmptno < jas_image_numcmpts(image); ++cmptno) {\n\t\tif (jas_image_cmptbrx(image, cmptno) + jas_image_cmpthstep(image, cmptno) <=\n\t\t  jas_image_brx(image) || jas_image_cmptbry(image, cmptno) +\n\t\t  jas_image_cmptvstep(image, cmptno) <= jas_image_bry(image)) {\n\t\t\tjas_eprintf(\"unsupported image type\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\t/* Note: We ought to be calculating the LCMs here.  Fix some day. */\n\t\thsteplcm *= jas_image_cmpthstep(image, cmptno);\n\t\tvsteplcm *= jas_image_cmptvstep(image, cmptno);\n\t}\n\n\tif (!(cp->ccps = jas_alloc2(cp->numcmpts, sizeof(jpc_enc_ccp_t)))) {\n\t\tgoto error;\n\t}\n\tunsigned cmptno;\n\tfor (cmptno = 0, ccp = cp->ccps; cmptno < cp->numcmpts; ++cmptno,\n\t  ++ccp) {\n\t\tccp->sampgrdstepx = jas_image_cmpthstep(image, cmptno);\n\t\tccp->sampgrdstepy = jas_image_cmptvstep(image, cmptno);\n\t\t/* XXX - this isn't quite correct for more general image */\n\t\tccp->sampgrdsubstepx = 0;\n\t\tccp->sampgrdsubstepx = 0;\n\t\tccp->prec = jas_image_cmptprec(image, cmptno);\n\t\tccp->sgnd = jas_image_cmptsgnd(image, cmptno);\n\t\tccp->numstepsizes = 0;\n\t\tmemset(ccp->stepsizes, 0, sizeof(ccp->stepsizes));\n\t}\n\n\tcp->rawsize = jas_image_rawsize(image);\n\tif (cp->rawsize == 0) {\n\t\t/* prevent division by zero in cp_create() */\n\t\tgoto error;\n\t}\n\tcp->totalsize = UINT_FAST32_MAX;\n\n\ttcp = &cp->tcp;\n\ttcp->csty = 0;\n\ttcp->intmode = true;\n\ttcp->prg = JPC_COD_LRCPPRG;\n\ttcp->numlyrs = 1;\n\ttcp->ilyrrates = 0;\n\n\ttccp = &cp->tccp;\n\ttccp->csty = 0;\n\ttccp->maxrlvls = 6;\n\ttccp->cblkwidthexpn = 6;\n\ttccp->cblkheightexpn = 6;\n\ttccp->cblksty = 0;\n\ttccp->numgbits = 2;\n\n\tif (!(tvp = jas_tvparser_create(optstr ? optstr : \"\"))) {\n\t\tgoto error;\n\t}\n\n\twhile (!(ret = jas_tvparser_next(tvp))) {\n\t\tswitch (jas_taginfo_nonull(jas_taginfos_lookup(encopts,\n\t\t  jas_tvparser_gettag(tvp)))->id) {\n\t\tcase OPT_DEBUG:\n\t\t\tcp->debug = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_IMGAREAOFFX:\n\t\t\tcp->imgareatlx = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_IMGAREAOFFY:\n\t\t\tcp->imgareatly = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEGRDOFFX:\n\t\t\tcp->tilegrdoffx = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEGRDOFFY:\n\t\t\tcp->tilegrdoffy = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEWIDTH:\n\t\t\tcp->tilewidth = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEHEIGHT:\n\t\t\tcp->tileheight = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_PRCWIDTH:\n\t\t\tprcwidthexpn = jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_PRCHEIGHT:\n\t\t\tprcheightexpn = jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_CBLKWIDTH:\n\t\t\ttccp->cblkwidthexpn =\n\t\t\t  jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_CBLKHEIGHT:\n\t\t\ttccp->cblkheightexpn =\n\t\t\t  jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_MODE:\n\t\t\tif ((tagid = jas_taginfo_nonull(jas_taginfos_lookup(modetab,\n\t\t\t  jas_tvparser_getval(tvp)))->id) < 0) {\n\t\t\t\tjas_eprintf(\"ignoring invalid mode %s\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t} else {\n\t\t\t\ttcp->intmode = (tagid == MODE_INT);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_PRG:\n\t\t\tif ((tagid = jas_taginfo_nonull(jas_taginfos_lookup(prgordtab,\n\t\t\t  jas_tvparser_getval(tvp)))->id) < 0) {\n\t\t\t\tjas_eprintf(\"ignoring invalid progression order %s\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t} else {\n\t\t\t\ttcp->prg = tagid;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_NOMCT:\n\t\t\tenablemct = false;\n\t\t\tbreak;\n\t\tcase OPT_MAXRLVLS:\n\t\t\ttccp->maxrlvls = atoi(jas_tvparser_getval(tvp));\n\t\t\tif(tccp->maxrlvls > JPC_MAXRLVLS) {\n\t\t\t\tjas_eprintf(\"invalid number of resolution levels upper than %d\\n\",JPC_MAXRLVLS);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_SOP:\n\t\t\tcp->tcp.csty |= JPC_COD_SOP;\n\t\t\tbreak;\n\t\tcase OPT_EPH:\n\t\t\tcp->tcp.csty |= JPC_COD_EPH;\n\t\t\tbreak;\n\t\tcase OPT_LAZY:\n\t\t\ttccp->cblksty |= JPC_COX_LAZY;\n\t\t\tbreak;\n\t\tcase OPT_TERMALL:\n\t\t\ttccp->cblksty |= JPC_COX_TERMALL;\n\t\t\tbreak;\n\t\tcase OPT_SEGSYM:\n\t\t\ttccp->cblksty |= JPC_COX_SEGSYM;\n\t\t\tbreak;\n\t\tcase OPT_VCAUSAL:\n\t\t\ttccp->cblksty |= JPC_COX_VSC;\n\t\t\tbreak;\n\t\tcase OPT_RESET:\n\t\t\ttccp->cblksty |= JPC_COX_RESET;\n\t\t\tbreak;\n\t\tcase OPT_PTERM:\n\t\t\ttccp->cblksty |= JPC_COX_PTERM;\n\t\t\tbreak;\n\t\tcase OPT_NUMGBITS:\n\t\t\tcp->tccp.numgbits = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_RATE:\n\t\t\tif (ratestrtosize(jas_tvparser_getval(tvp), cp->rawsize,\n\t\t\t  &cp->totalsize)) {\n\t\t\t\tjas_eprintf(\"ignoring bad rate specifier %s\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_ILYRRATES:\n\t\t\tif (jpc_atoaf(jas_tvparser_getval(tvp), &numilyrrates,\n\t\t\t  &ilyrrates)) {\n\t\t\t\tjas_eprintf(\"warning: invalid intermediate layer rates specifier ignored (%s)\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase OPT_JP2OVERHEAD:\n\t\t\tjp2overhead = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tjas_eprintf(\"warning: ignoring invalid option %s\\n\",\n\t\t\t jas_tvparser_gettag(tvp));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tjas_tvparser_destroy(tvp);\n\ttvp = 0;\n\n\tif (cp->totalsize != UINT_FAST32_MAX) {\n\t\tcp->totalsize = (cp->totalsize > jp2overhead) ?\n\t\t  (cp->totalsize - jp2overhead) : 0;\n\t}\n\n\tif (cp->imgareatlx == UINT_FAST32_MAX) {\n\t\tcp->imgareatlx = 0;\n\t} else {\n\t\tif (hsteplcm != 1) {\n\t\t\tjas_eprintf(\"warning: overriding imgareatlx value\\n\");\n\t\t}\n\t\tcp->imgareatlx *= hsteplcm;\n\t}\n\tif (cp->imgareatly == UINT_FAST32_MAX) {\n\t\tcp->imgareatly = 0;\n\t} else {\n\t\tif (vsteplcm != 1) {\n\t\t\tjas_eprintf(\"warning: overriding imgareatly value\\n\");\n\t\t}\n\t\tcp->imgareatly *= vsteplcm;\n\t}\n\tcp->refgrdwidth = cp->imgareatlx + jas_image_width(image);\n\tcp->refgrdheight = cp->imgareatly + jas_image_height(image);\n\tif (cp->tilegrdoffx == UINT_FAST32_MAX) {\n\t\tcp->tilegrdoffx = cp->imgareatlx;\n\t}\n\tif (cp->tilegrdoffy == UINT_FAST32_MAX) {\n\t\tcp->tilegrdoffy = cp->imgareatly;\n\t}\n\tif (!cp->tilewidth) {\n\t\tcp->tilewidth = cp->refgrdwidth - cp->tilegrdoffx;\n\t}\n\tif (!cp->tileheight) {\n\t\tcp->tileheight = cp->refgrdheight - cp->tilegrdoffy;\n\t}\n\n\tif (cp->numcmpts == 3) {\n\t\tmctvalid = true;\n\t\tfor (cmptno = 0; cmptno < jas_image_numcmpts(image); ++cmptno) {\n\t\t\tif (jas_image_cmptprec(image, cmptno) != jas_image_cmptprec(image, 0) ||\n\t\t\t  jas_image_cmptsgnd(image, cmptno) != jas_image_cmptsgnd(image, 0) ||\n\t\t\t  jas_image_cmptwidth(image, cmptno) != jas_image_cmptwidth(image, 0) ||\n\t\t\t  jas_image_cmptheight(image, cmptno) != jas_image_cmptheight(image, 0)) {\n\t\t\t\tmctvalid = false;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tmctvalid = false;\n\t}\n\tif (mctvalid && enablemct && jas_clrspc_fam(jas_image_clrspc(image)) != JAS_CLRSPC_FAM_RGB) {\n\t\tjas_eprintf(\"warning: color space apparently not RGB\\n\");\n\t}\n\tif (mctvalid && enablemct && jas_clrspc_fam(jas_image_clrspc(image)) == JAS_CLRSPC_FAM_RGB) {\n\t\ttcp->mctid = (tcp->intmode) ? (JPC_MCT_RCT) : (JPC_MCT_ICT);\n\t} else {\n\t\ttcp->mctid = JPC_MCT_NONE;\n\t}\n\ttccp->qmfbid = (tcp->intmode) ? (JPC_COX_RFT) : (JPC_COX_INS);\n\n\tfor (rlvlno = 0; rlvlno < tccp->maxrlvls; ++rlvlno) {\n\t\ttccp->prcwidthexpns[rlvlno] = prcwidthexpn;\n\t\ttccp->prcheightexpns[rlvlno] = prcheightexpn;\n\t}\n\tif (prcwidthexpn != 15 || prcheightexpn != 15) {\n\t\ttccp->csty |= JPC_COX_PRT;\n\t}\n\n\t/* Ensure that the tile width and height is valid. */\n\tif (!cp->tilewidth) {\n\t\tjas_eprintf(\"invalid tile width %lu\\n\", (unsigned long)\n\t\t  cp->tilewidth);\n\t\tgoto error;\n\t}\n\tif (!cp->tileheight) {\n\t\tjas_eprintf(\"invalid tile height %lu\\n\", (unsigned long)\n\t\t  cp->tileheight);\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the tile grid offset is valid. */\n\tif (cp->tilegrdoffx > cp->imgareatlx ||\n\t  cp->tilegrdoffy > cp->imgareatly ||\n\t  cp->tilegrdoffx + cp->tilewidth < cp->imgareatlx ||\n\t  cp->tilegrdoffy + cp->tileheight < cp->imgareatly) {\n\t\tjas_eprintf(\"invalid tile grid offset (%lu, %lu)\\n\",\n\t\t  (unsigned long) cp->tilegrdoffx, (unsigned long)\n\t\t  cp->tilegrdoffy);\n\t\tgoto error;\n\t}\n\n\tcp->numhtiles = JPC_CEILDIV(cp->refgrdwidth - cp->tilegrdoffx,\n\t  cp->tilewidth);\n\tcp->numvtiles = JPC_CEILDIV(cp->refgrdheight - cp->tilegrdoffy,\n\t  cp->tileheight);\n\tcp->numtiles = cp->numhtiles * cp->numvtiles;\n\n\tif (ilyrrates && numilyrrates > 0) {\n\t\ttcp->numlyrs = numilyrrates + 1;\n\t\tif (!(tcp->ilyrrates = jas_alloc2((tcp->numlyrs - 1),\n\t\t  sizeof(jpc_fix_t)))) {\n\t\t\tgoto error;\n\t\t}\n\t\tfor (i = 0; i < JAS_CAST(int, tcp->numlyrs - 1); ++i) {\n\t\t\ttcp->ilyrrates[i] = jpc_dbltofix(ilyrrates[i]);\n\t\t}\n\t}\n\n\t/* Ensure that the integer mode is used in the case of lossless\n\t  coding. */\n\tif (cp->totalsize == UINT_FAST32_MAX && (!cp->tcp.intmode)) {\n\t\tjas_eprintf(\"cannot use real mode for lossless coding\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the precinct width is valid. */\n\tif (prcwidthexpn > 15) {\n\t\tjas_eprintf(\"invalid precinct width\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the precinct height is valid. */\n\tif (prcheightexpn > 15) {\n\t\tjas_eprintf(\"invalid precinct height\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the code block width is valid. */\n\tif (cp->tccp.cblkwidthexpn < 2 || cp->tccp.cblkwidthexpn > 12) {\n\t\tjas_eprintf(\"invalid code block width %d\\n\",\n\t\t  JPC_POW2(cp->tccp.cblkwidthexpn));\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the code block height is valid. */\n\tif (cp->tccp.cblkheightexpn < 2 || cp->tccp.cblkheightexpn > 12) {\n\t\tjas_eprintf(\"invalid code block height %d\\n\",\n\t\t  JPC_POW2(cp->tccp.cblkheightexpn));\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the code block size is not too large. */\n\tif (cp->tccp.cblkwidthexpn + cp->tccp.cblkheightexpn > 12) {\n\t\tjas_eprintf(\"code block size too large\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the number of layers is valid. */\n\tif (cp->tcp.numlyrs > 16384) {\n\t\tjas_eprintf(\"too many layers\\n\");\n\t\tgoto error;\n\t}\n\n\t/* There must be at least one resolution level. */\n\tif (cp->tccp.maxrlvls < 1) {\n\t\tjas_eprintf(\"must be at least one resolution level\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the number of guard bits is valid. */\n\tif (cp->tccp.numgbits > 8) {\n\t\tjas_eprintf(\"invalid number of guard bits\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the rate is within the legal range. */\n\tif (cp->totalsize != UINT_FAST32_MAX && cp->totalsize > cp->rawsize) {\n\t\tjas_eprintf(\"warning: specified rate is unreasonably large (%lu > %lu)\\n\", (unsigned long) cp->totalsize, (unsigned long) cp->rawsize);\n\t}\n\n\t/* Ensure that the intermediate layer rates are valid. */\n\tif (tcp->numlyrs > 1) {\n\t\t/* The intermediate layers rates must increase monotonically. */\n\t\tfor (lyrno = 0; lyrno + 2 < tcp->numlyrs; ++lyrno) {\n\t\t\tif (tcp->ilyrrates[lyrno] >= tcp->ilyrrates[lyrno + 1]) {\n\t\t\t\tjas_eprintf(\"intermediate layer rates must increase monotonically\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\t/* The intermediate layer rates must be less than the overall rate. */\n\t\tif (cp->totalsize != UINT_FAST32_MAX) {\n\t\t\tfor (lyrno = 0; lyrno < tcp->numlyrs - 1; ++lyrno) {\n\t\t\t\tif (jpc_fixtodbl(tcp->ilyrrates[lyrno]) > ((double) cp->totalsize)\n\t\t\t\t  / cp->rawsize) {\n\t\t\t\t\tjas_eprintf(\"warning: intermediate layer rates must be less than overall rate\\n\");\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ilyrrates) {\n\t\tjas_free(ilyrrates);\n\t}\n\n\treturn cp;\n\nerror:\n\n\tif (ilyrrates) {\n\t\tjas_free(ilyrrates);\n\t}\n\tif (tvp) {\n\t\tjas_tvparser_destroy(tvp);\n\t}\n\tif (cp) {\n\t\tjpc_enc_cp_destroy(cp);\n\t}\n\treturn 0;\n}", "func_hash": 258879101783368514234166952366199989021, "file_name": "jpc_enc.c", "file_hash": 134316338883827501672124248295180144242, "cwe": ["CWE-20"], "cve": "CVE-2020-27828", "cve_desc": "There's a flaw in jasper's jpc encoder in versions prior to 2.0.23. Crafted input provided to jasper by an attacker could cause an arbitrary out-of-bounds write. This could potentially affect data confidentiality, integrity, or application availability.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2020-27828", "file_path": "src/libjasper/jpc/jpc_enc.c"}
{"idx": 211842, "project": "vim", "commit_id": "4e889f98e95ac05d7c8bd3ee933ab4d47820fdfa", "project_url": "https://github.com/vim/vim", "commit_url": "https://github.com/vim/vim/commit/4e889f98e95ac05d7c8bd3ee933ab4d47820fdfa", "commit_message": "patch 8.2.4436: crash with weird 'vartabstop' value\n\nProblem:    Crash with weird 'vartabstop' value.\nSolution:   Check for running into the end of the line.", "target": 1, "func": "change_indent(\n    int\t\ttype,\n    int\t\tamount,\n    int\t\tround,\n    int\t\treplaced,\t// replaced character, put on replace stack\n    int\t\tcall_changed_bytes)\t// call changed_bytes()\n{\n    int\t\tvcol;\n    int\t\tlast_vcol;\n    int\t\tinsstart_less;\t\t// reduction for Insstart.col\n    int\t\tnew_cursor_col;\n    int\t\ti;\n    char_u\t*ptr;\n    int\t\tsave_p_list;\n    int\t\tstart_col;\n    colnr_T\tvc;\n    colnr_T\torig_col = 0;\t\t// init for GCC\n    char_u\t*new_line, *orig_line = NULL;\t// init for GCC\n\n    // VREPLACE mode needs to know what the line was like before changing\n    if (State & VREPLACE_FLAG)\n    {\n\torig_line = vim_strsave(ml_get_curline());  // Deal with NULL below\n\torig_col = curwin->w_cursor.col;\n    }\n\n    // for the following tricks we don't want list mode\n    save_p_list = curwin->w_p_list;\n    curwin->w_p_list = FALSE;\n    vc = getvcol_nolist(&curwin->w_cursor);\n    vcol = vc;\n\n    // For Replace mode we need to fix the replace stack later, which is only\n    // possible when the cursor is in the indent.  Remember the number of\n    // characters before the cursor if it's possible.\n    start_col = curwin->w_cursor.col;\n\n    // determine offset from first non-blank\n    new_cursor_col = curwin->w_cursor.col;\n    beginline(BL_WHITE);\n    new_cursor_col -= curwin->w_cursor.col;\n\n    insstart_less = curwin->w_cursor.col;\n\n    // If the cursor is in the indent, compute how many screen columns the\n    // cursor is to the left of the first non-blank.\n    if (new_cursor_col < 0)\n\tvcol = get_indent() - vcol;\n\n    if (new_cursor_col > 0)\t    // can't fix replace stack\n\tstart_col = -1;\n\n    // Set the new indent.  The cursor will be put on the first non-blank.\n    if (type == INDENT_SET)\n\t(void)set_indent(amount, call_changed_bytes ? SIN_CHANGED : 0);\n    else\n    {\n\tint\tsave_State = State;\n\n\t// Avoid being called recursively.\n\tif (State & VREPLACE_FLAG)\n\t    State = INSERT;\n\tshift_line(type == INDENT_DEC, round, 1, call_changed_bytes);\n\tState = save_State;\n    }\n    insstart_less -= curwin->w_cursor.col;\n\n    // Try to put cursor on same character.\n    // If the cursor is at or after the first non-blank in the line,\n    // compute the cursor column relative to the column of the first\n    // non-blank character.\n    // If we are not in insert mode, leave the cursor on the first non-blank.\n    // If the cursor is before the first non-blank, position it relative\n    // to the first non-blank, counted in screen columns.\n    if (new_cursor_col >= 0)\n    {\n\t// When changing the indent while the cursor is touching it, reset\n\t// Insstart_col to 0.\n\tif (new_cursor_col == 0)\n\t    insstart_less = MAXCOL;\n\tnew_cursor_col += curwin->w_cursor.col;\n    }\n    else if (!(State & INSERT))\n\tnew_cursor_col = curwin->w_cursor.col;\n    else\n    {\n\t// Compute the screen column where the cursor should be.\n\tvcol = get_indent() - vcol;\n\tcurwin->w_virtcol = (colnr_T)((vcol < 0) ? 0 : vcol);\n\n\t// Advance the cursor until we reach the right screen column.\n\tvcol = last_vcol = 0;\n\tnew_cursor_col = -1;\n\tptr = ml_get_curline();\n\twhile (vcol <= (int)curwin->w_virtcol)\n\t{\n\t    last_vcol = vcol;\n\t    if (has_mbyte && new_cursor_col >= 0)\n\t\tnew_cursor_col += (*mb_ptr2len)(ptr + new_cursor_col);\n\t    else\n\t\t++new_cursor_col;\n\t    vcol += lbr_chartabsize(ptr, ptr + new_cursor_col, (colnr_T)vcol);\n\t}\n\tvcol = last_vcol;\n\n\t// May need to insert spaces to be able to position the cursor on\n\t// the right screen column.\n\tif (vcol != (int)curwin->w_virtcol)\n\t{\n\t    curwin->w_cursor.col = (colnr_T)new_cursor_col;\n\t    i = (int)curwin->w_virtcol - vcol;\n\t    ptr = alloc(i + 1);\n\t    if (ptr != NULL)\n\t    {\n\t\tnew_cursor_col += i;\n\t\tptr[i] = NUL;\n\t\twhile (--i >= 0)\n\t\t    ptr[i] = ' ';\n\t\tins_str(ptr);\n\t\tvim_free(ptr);\n\t    }\n\t}\n\n\t// When changing the indent while the cursor is in it, reset\n\t// Insstart_col to 0.\n\tinsstart_less = MAXCOL;\n    }\n\n    curwin->w_p_list = save_p_list;\n\n    if (new_cursor_col <= 0)\n\tcurwin->w_cursor.col = 0;\n    else\n\tcurwin->w_cursor.col = (colnr_T)new_cursor_col;\n    curwin->w_set_curswant = TRUE;\n    changed_cline_bef_curs();\n\n    // May have to adjust the start of the insert.\n    if (State & INSERT)\n    {\n\tif (curwin->w_cursor.lnum == Insstart.lnum && Insstart.col != 0)\n\t{\n\t    if ((int)Insstart.col <= insstart_less)\n\t\tInsstart.col = 0;\n\t    else\n\t\tInsstart.col -= insstart_less;\n\t}\n\tif ((int)ai_col <= insstart_less)\n\t    ai_col = 0;\n\telse\n\t    ai_col -= insstart_less;\n    }\n\n    // For REPLACE mode, may have to fix the replace stack, if it's possible.\n    // If the number of characters before the cursor decreased, need to pop a\n    // few characters from the replace stack.\n    // If the number of characters before the cursor increased, need to push a\n    // few NULs onto the replace stack.\n    if (REPLACE_NORMAL(State) && start_col >= 0)\n    {\n\twhile (start_col > (int)curwin->w_cursor.col)\n\t{\n\t    replace_join(0);\t    // remove a NUL from the replace stack\n\t    --start_col;\n\t}\n\twhile (start_col < (int)curwin->w_cursor.col || replaced)\n\t{\n\t    replace_push(NUL);\n\t    if (replaced)\n\t    {\n\t\treplace_push(replaced);\n\t\treplaced = NUL;\n\t    }\n\t    ++start_col;\n\t}\n    }\n\n    // For VREPLACE mode, we also have to fix the replace stack.  In this case\n    // it is always possible because we backspace over the whole line and then\n    // put it back again the way we wanted it.\n    if (State & VREPLACE_FLAG)\n    {\n\t// If orig_line didn't allocate, just return.  At least we did the job,\n\t// even if you can't backspace.\n\tif (orig_line == NULL)\n\t    return;\n\n\t// Save new line\n\tnew_line = vim_strsave(ml_get_curline());\n\tif (new_line == NULL)\n\t    return;\n\n\t// We only put back the new line up to the cursor\n\tnew_line[curwin->w_cursor.col] = NUL;\n\n\t// Put back original line\n\tml_replace(curwin->w_cursor.lnum, orig_line, FALSE);\n\tcurwin->w_cursor.col = orig_col;\n\n\t// Backspace from cursor to start of line\n\tbackspace_until_column(0);\n\n\t// Insert new stuff into line again\n\tins_bytes(new_line);\n\n\tvim_free(new_line);\n    }\n}", "func_hash": 104434622616430304167109103842435027722, "file_name": "indent.c", "file_hash": 225104819640164774379021828754456921804, "cwe": ["CWE-787"], "cve": "CVE-2022-0714", "cve_desc": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.4436.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-0714", "file_path": "src/indent.c"}
{"idx": 452377, "project": "vim", "commit_id": "4e889f98e95ac05d7c8bd3ee933ab4d47820fdfa", "project_url": "https://github.com/vim/vim", "commit_url": "https://github.com/vim/vim/commit/4e889f98e95ac05d7c8bd3ee933ab4d47820fdfa", "commit_message": "patch 8.2.4436: crash with weird 'vartabstop' value\n\nProblem:    Crash with weird 'vartabstop' value.\nSolution:   Check for running into the end of the line.", "target": 0, "func": "change_indent(\n    int\t\ttype,\n    int\t\tamount,\n    int\t\tround,\n    int\t\treplaced,\t// replaced character, put on replace stack\n    int\t\tcall_changed_bytes)\t// call changed_bytes()\n{\n    int\t\tvcol;\n    int\t\tlast_vcol;\n    int\t\tinsstart_less;\t\t// reduction for Insstart.col\n    int\t\tnew_cursor_col;\n    int\t\ti;\n    char_u\t*ptr;\n    int\t\tsave_p_list;\n    int\t\tstart_col;\n    colnr_T\tvc;\n    colnr_T\torig_col = 0;\t\t// init for GCC\n    char_u\t*new_line, *orig_line = NULL;\t// init for GCC\n\n    // VREPLACE mode needs to know what the line was like before changing\n    if (State & VREPLACE_FLAG)\n    {\n\torig_line = vim_strsave(ml_get_curline());  // Deal with NULL below\n\torig_col = curwin->w_cursor.col;\n    }\n\n    // for the following tricks we don't want list mode\n    save_p_list = curwin->w_p_list;\n    curwin->w_p_list = FALSE;\n    vc = getvcol_nolist(&curwin->w_cursor);\n    vcol = vc;\n\n    // For Replace mode we need to fix the replace stack later, which is only\n    // possible when the cursor is in the indent.  Remember the number of\n    // characters before the cursor if it's possible.\n    start_col = curwin->w_cursor.col;\n\n    // determine offset from first non-blank\n    new_cursor_col = curwin->w_cursor.col;\n    beginline(BL_WHITE);\n    new_cursor_col -= curwin->w_cursor.col;\n\n    insstart_less = curwin->w_cursor.col;\n\n    // If the cursor is in the indent, compute how many screen columns the\n    // cursor is to the left of the first non-blank.\n    if (new_cursor_col < 0)\n\tvcol = get_indent() - vcol;\n\n    if (new_cursor_col > 0)\t    // can't fix replace stack\n\tstart_col = -1;\n\n    // Set the new indent.  The cursor will be put on the first non-blank.\n    if (type == INDENT_SET)\n\t(void)set_indent(amount, call_changed_bytes ? SIN_CHANGED : 0);\n    else\n    {\n\tint\tsave_State = State;\n\n\t// Avoid being called recursively.\n\tif (State & VREPLACE_FLAG)\n\t    State = INSERT;\n\tshift_line(type == INDENT_DEC, round, 1, call_changed_bytes);\n\tState = save_State;\n    }\n    insstart_less -= curwin->w_cursor.col;\n\n    // Try to put cursor on same character.\n    // If the cursor is at or after the first non-blank in the line,\n    // compute the cursor column relative to the column of the first\n    // non-blank character.\n    // If we are not in insert mode, leave the cursor on the first non-blank.\n    // If the cursor is before the first non-blank, position it relative\n    // to the first non-blank, counted in screen columns.\n    if (new_cursor_col >= 0)\n    {\n\t// When changing the indent while the cursor is touching it, reset\n\t// Insstart_col to 0.\n\tif (new_cursor_col == 0)\n\t    insstart_less = MAXCOL;\n\tnew_cursor_col += curwin->w_cursor.col;\n    }\n    else if (!(State & INSERT))\n\tnew_cursor_col = curwin->w_cursor.col;\n    else\n    {\n\t// Compute the screen column where the cursor should be.\n\tvcol = get_indent() - vcol;\n\tcurwin->w_virtcol = (colnr_T)((vcol < 0) ? 0 : vcol);\n\n\t// Advance the cursor until we reach the right screen column.\n\tvcol = last_vcol = 0;\n\tnew_cursor_col = -1;\n\tptr = ml_get_curline();\n\twhile (vcol <= (int)curwin->w_virtcol)\n\t{\n\t    last_vcol = vcol;\n\t    if (has_mbyte && new_cursor_col >= 0)\n\t\tnew_cursor_col += (*mb_ptr2len)(ptr + new_cursor_col);\n\t    else\n\t\t++new_cursor_col;\n\t    if (ptr[new_cursor_col] == NUL)\n\t\tbreak;\n\t    vcol += lbr_chartabsize(ptr, ptr + new_cursor_col, (colnr_T)vcol);\n\t}\n\tvcol = last_vcol;\n\n\t// May need to insert spaces to be able to position the cursor on\n\t// the right screen column.\n\tif (vcol != (int)curwin->w_virtcol)\n\t{\n\t    curwin->w_cursor.col = (colnr_T)new_cursor_col;\n\t    i = (int)curwin->w_virtcol - vcol;\n\t    ptr = alloc(i + 1);\n\t    if (ptr != NULL)\n\t    {\n\t\tnew_cursor_col += i;\n\t\tptr[i] = NUL;\n\t\twhile (--i >= 0)\n\t\t    ptr[i] = ' ';\n\t\tins_str(ptr);\n\t\tvim_free(ptr);\n\t    }\n\t}\n\n\t// When changing the indent while the cursor is in it, reset\n\t// Insstart_col to 0.\n\tinsstart_less = MAXCOL;\n    }\n\n    curwin->w_p_list = save_p_list;\n\n    if (new_cursor_col <= 0)\n\tcurwin->w_cursor.col = 0;\n    else\n\tcurwin->w_cursor.col = (colnr_T)new_cursor_col;\n    curwin->w_set_curswant = TRUE;\n    changed_cline_bef_curs();\n\n    // May have to adjust the start of the insert.\n    if (State & INSERT)\n    {\n\tif (curwin->w_cursor.lnum == Insstart.lnum && Insstart.col != 0)\n\t{\n\t    if ((int)Insstart.col <= insstart_less)\n\t\tInsstart.col = 0;\n\t    else\n\t\tInsstart.col -= insstart_less;\n\t}\n\tif ((int)ai_col <= insstart_less)\n\t    ai_col = 0;\n\telse\n\t    ai_col -= insstart_less;\n    }\n\n    // For REPLACE mode, may have to fix the replace stack, if it's possible.\n    // If the number of characters before the cursor decreased, need to pop a\n    // few characters from the replace stack.\n    // If the number of characters before the cursor increased, need to push a\n    // few NULs onto the replace stack.\n    if (REPLACE_NORMAL(State) && start_col >= 0)\n    {\n\twhile (start_col > (int)curwin->w_cursor.col)\n\t{\n\t    replace_join(0);\t    // remove a NUL from the replace stack\n\t    --start_col;\n\t}\n\twhile (start_col < (int)curwin->w_cursor.col || replaced)\n\t{\n\t    replace_push(NUL);\n\t    if (replaced)\n\t    {\n\t\treplace_push(replaced);\n\t\treplaced = NUL;\n\t    }\n\t    ++start_col;\n\t}\n    }\n\n    // For VREPLACE mode, we also have to fix the replace stack.  In this case\n    // it is always possible because we backspace over the whole line and then\n    // put it back again the way we wanted it.\n    if (State & VREPLACE_FLAG)\n    {\n\t// If orig_line didn't allocate, just return.  At least we did the job,\n\t// even if you can't backspace.\n\tif (orig_line == NULL)\n\t    return;\n\n\t// Save new line\n\tnew_line = vim_strsave(ml_get_curline());\n\tif (new_line == NULL)\n\t    return;\n\n\t// We only put back the new line up to the cursor\n\tnew_line[curwin->w_cursor.col] = NUL;\n\n\t// Put back original line\n\tml_replace(curwin->w_cursor.lnum, orig_line, FALSE);\n\tcurwin->w_cursor.col = orig_col;\n\n\t// Backspace from cursor to start of line\n\tbackspace_until_column(0);\n\n\t// Insert new stuff into line again\n\tins_bytes(new_line);\n\n\tvim_free(new_line);\n    }\n}", "func_hash": 281315459122812097070130024816280546627, "file_name": "indent.c", "file_hash": 175343284041603087029849272826009468440, "cwe": ["CWE-787"], "cve": "CVE-2022-0714", "cve_desc": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.4436.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-0714", "file_path": "src/indent.c"}
{"idx": 211845, "project": "ImageMagick6", "commit_id": "1aea203eb36409ce6903b9e41fe7cb70030e8750", "project_url": "https://github.com/ImageMagick/ImageMagick6", "commit_url": "https://github.com/ImageMagick/ImageMagick6/commit/1aea203eb36409ce6903b9e41fe7cb70030e8750", "commit_message": "squash heap-buffer-overflow, PoC TIFF from Hardik", "target": 1, "func": "static Image *ReadTIFFImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n#define MaxPixelChannels  32\n#define ThrowTIFFException(severity,message) \\\n{ \\\n  if (pixel_info != (MemoryInfo *) NULL) \\\n    pixel_info=RelinquishVirtualMemory(pixel_info); \\\n  if (quantum_info != (QuantumInfo *) NULL) \\\n    quantum_info=DestroyQuantumInfo(quantum_info); \\\n  TIFFClose(tiff); \\\n  ThrowReaderException(severity,message); \\\n}\n\n  const char\n    *option;\n\n  float\n    *chromaticity = (float *) NULL,\n    x_position,\n    y_position,\n    x_resolution,\n    y_resolution;\n\n  Image\n    *image;\n\n  int\n    tiff_status = 0;\n\n  MagickBooleanType\n    more_frames;\n\n  MagickStatusType\n    status;\n\n  MemoryInfo\n    *pixel_info = (MemoryInfo *) NULL;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  size_t\n    number_pixels;\n\n  ssize_t\n    i,\n    scanline_size,\n    y;\n\n  TIFF\n    *tiff;\n\n  TIFFMethodType\n    method;\n\n  uint16\n    compress_tag = 0,\n    bits_per_sample = 0,\n    endian = 0,\n    extra_samples = 0,\n    interlace = 0,\n    max_sample_value = 0,\n    min_sample_value = 0,\n    orientation = 0,\n    pages = 0,\n    photometric = 0,\n    *sample_info = NULL,\n    sample_format = 0,\n    samples_per_pixel = 0,\n    units = 0,\n    value = 0;\n\n  uint32\n    height,\n    rows_per_strip,\n    width;\n\n  unsigned char\n    *pixels;\n\n  void\n    *sans[8] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };\n\n  /*\n    Open image.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) SetMagickThreadValue(tiff_exception,exception);\n  tiff=TIFFClientOpen(image->filename,\"rb\",(thandle_t) image,TIFFReadBlob,\n    TIFFWriteBlob,TIFFSeekBlob,TIFFCloseBlob,TIFFGetBlobSize,TIFFMapBlob,\n    TIFFUnmapBlob);\n  if (tiff == (TIFF *) NULL)\n    {\n      if (exception->severity == UndefinedException)\n        ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (exception->severity > ErrorException)\n    {\n      TIFFClose(tiff);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (image_info->number_scenes != 0)\n    {\n      /*\n        Generate blank images for subimage specification (e.g. image.tif[4].\n        We need to check the number of directores because it is possible that\n        the subimage(s) are stored in the photoshop profile.\n      */\n      if (image_info->scene < (size_t)TIFFNumberOfDirectories(tiff))\n        {\n          for (i=0; i < (ssize_t) image_info->scene; i++)\n          {\n            status=TIFFReadDirectory(tiff) != 0 ? MagickTrue : MagickFalse;\n            if (status == MagickFalse)\n              {\n                TIFFClose(tiff);\n                image=DestroyImageList(image);\n                return((Image *) NULL);\n              }\n            AcquireNextImage(image_info,image);\n            if (GetNextImageInList(image) == (Image *) NULL)\n              {\n                TIFFClose(tiff);\n                image=DestroyImageList(image);\n                return((Image *) NULL);\n              }\n            image=SyncNextImageInList(image);\n          }\n        }\n    }\n  more_frames=MagickTrue;\n  do\n  {\n    /* TIFFPrintDirectory(tiff,stdout,MagickFalse); */\n    photometric=PHOTOMETRIC_RGB;\n    if ((TIFFGetField(tiff,TIFFTAG_IMAGEWIDTH,&width) != 1) ||\n        (TIFFGetField(tiff,TIFFTAG_IMAGELENGTH,&height) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_PHOTOMETRIC,&photometric,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_COMPRESSION,&compress_tag,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_FILLORDER,&endian,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_PLANARCONFIG,&interlace,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLESPERPIXEL,&samples_per_pixel,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,&bits_per_sample,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLEFORMAT,&sample_format,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_MINSAMPLEVALUE,&min_sample_value,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_MAXSAMPLEVALUE,&max_sample_value,sans) != 1))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n    if (((sample_format != SAMPLEFORMAT_IEEEFP) || (bits_per_sample != 64)) &&\n        ((bits_per_sample <= 0) || (bits_per_sample > 32)))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CorruptImageError,\"UnsupportedBitsPerPixel\");\n      }\n    if (samples_per_pixel > MaxPixelChannels)\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CorruptImageError,\"MaximumChannelsExceeded\");\n      }\n    if (sample_format == SAMPLEFORMAT_IEEEFP)\n      (void) SetImageProperty(image,\"quantum:format\",\"floating-point\");\n    switch (photometric)\n    {\n      case PHOTOMETRIC_MINISBLACK:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"min-is-black\");\n        break;\n      }\n      case PHOTOMETRIC_MINISWHITE:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"min-is-white\");\n        break;\n      }\n      case PHOTOMETRIC_PALETTE:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"palette\");\n        break;\n      }\n      case PHOTOMETRIC_RGB:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"RGB\");\n        break;\n      }\n      case PHOTOMETRIC_CIELAB:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"CIELAB\");\n        break;\n      }\n      case PHOTOMETRIC_LOGL:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"CIE Log2(L)\");\n        break;\n      }\n      case PHOTOMETRIC_LOGLUV:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"LOGLUV\");\n        break;\n      }\n#if defined(PHOTOMETRIC_MASK)\n      case PHOTOMETRIC_MASK:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"MASK\");\n        break;\n      }\n#endif\n      case PHOTOMETRIC_SEPARATED:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"separated\");\n        break;\n      }\n      case PHOTOMETRIC_YCBCR:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"YCBCR\");\n        break;\n      }\n      default:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"unknown\");\n        break;\n      }\n    }\n    if (image->debug != MagickFalse)\n      {\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Geometry: %ux%u\",\n          (unsigned int) width,(unsigned int) height);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Interlace: %u\",\n          interlace);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Bits per sample: %u\",bits_per_sample);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Min sample value: %u\",min_sample_value);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Max sample value: %u\",max_sample_value);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Photometric \"\n          \"interpretation: %s\",GetImageProperty(image,\"tiff:photometric\"));\n      }\n    image->columns=(size_t) width;\n    image->rows=(size_t) height;\n    image->depth=(size_t) bits_per_sample;\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Image depth: %.20g\",\n        (double) image->depth);\n    image->endian=MSBEndian;\n    if (endian == FILLORDER_LSB2MSB)\n      image->endian=LSBEndian;\n#if defined(MAGICKCORE_HAVE_TIFFISBIGENDIAN)\n    if (TIFFIsBigEndian(tiff) == 0)\n      {\n        (void) SetImageProperty(image,\"tiff:endian\",\"lsb\");\n        image->endian=LSBEndian;\n      }\n    else\n      {\n        (void) SetImageProperty(image,\"tiff:endian\",\"msb\");\n        image->endian=MSBEndian;\n      }\n#endif\n    if ((photometric == PHOTOMETRIC_MINISBLACK) ||\n        (photometric == PHOTOMETRIC_MINISWHITE))\n      image->colorspace=GRAYColorspace;\n    if (photometric == PHOTOMETRIC_SEPARATED)\n      image->colorspace=CMYKColorspace;\n    if (photometric == PHOTOMETRIC_CIELAB)\n      image->colorspace=LabColorspace;\n    if ((photometric == PHOTOMETRIC_YCBCR) &&\n        (compress_tag != COMPRESSION_OJPEG) &&\n        (compress_tag != COMPRESSION_JPEG))\n      image->colorspace=YCbCrColorspace;\n    status=TIFFGetProfiles(tiff,image);\n    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    status=TIFFGetProperties(tiff,image);\n    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    option=GetImageOption(image_info,\"tiff:exif-properties\");\n    if ((option == (const char *) NULL) ||\n        (IsMagickTrue(option) != MagickFalse))\n      (void) TIFFGetEXIFProperties(tiff,image);\n    option=GetImageOption(image_info,\"tiff:gps-properties\");\n    if ((option == (const char *) NULL) ||\n        (IsMagickTrue(option) != MagickFalse))\n      (void) TIFFGetGPSProperties(tiff,image);\n    if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XRESOLUTION,&x_resolution,sans) == 1) &&\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_YRESOLUTION,&y_resolution,sans) == 1))\n      {\n        image->x_resolution=x_resolution;\n        image->y_resolution=y_resolution;\n      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_RESOLUTIONUNIT,&units,sans,sans) == 1)\n      {\n        if (units == RESUNIT_INCH)\n          image->units=PixelsPerInchResolution;\n        if (units == RESUNIT_CENTIMETER)\n          image->units=PixelsPerCentimeterResolution;\n      }\n    if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XPOSITION,&x_position,sans) == 1) &&\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_YPOSITION,&y_position,sans) == 1))\n      {\n        image->page.x=CastDoubleToLong(ceil(x_position*\n          image->x_resolution-0.5));\n        image->page.y=CastDoubleToLong(ceil(y_position*\n          image->y_resolution-0.5));\n      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_ORIENTATION,&orientation,sans) == 1)\n      image->orientation=(OrientationType) orientation;\n    if (TIFFGetField(tiff,TIFFTAG_WHITEPOINT,&chromaticity) == 1)\n      {\n        if ((chromaticity != (float *) NULL) && (*chromaticity != 0.0))\n          {\n            image->chromaticity.white_point.x=chromaticity[0];\n            image->chromaticity.white_point.y=chromaticity[1];\n          }\n      }\n    if (TIFFGetField(tiff,TIFFTAG_PRIMARYCHROMATICITIES,&chromaticity) == 1)\n      {\n        if ((chromaticity != (float *) NULL) && (*chromaticity != 0.0))\n          {\n            image->chromaticity.red_primary.x=chromaticity[0];\n            image->chromaticity.red_primary.y=chromaticity[1];\n            image->chromaticity.green_primary.x=chromaticity[2];\n            image->chromaticity.green_primary.y=chromaticity[3];\n            image->chromaticity.blue_primary.x=chromaticity[4];\n            image->chromaticity.blue_primary.y=chromaticity[5];\n          }\n      }\n#if defined(MAGICKCORE_HAVE_TIFFISCODECCONFIGURED) || (TIFFLIB_VERSION > 20040919)\n    if ((compress_tag != COMPRESSION_NONE) &&\n        (TIFFIsCODECConfigured(compress_tag) == 0))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CoderError,\"CompressNotSupported\");\n      }\n#endif\n    switch (compress_tag)\n    {\n      case COMPRESSION_NONE: image->compression=NoCompression; break;\n      case COMPRESSION_CCITTFAX3: image->compression=FaxCompression; break;\n      case COMPRESSION_CCITTFAX4: image->compression=Group4Compression; break;\n      case COMPRESSION_JPEG:\n      {\n         image->compression=JPEGCompression;\n#if defined(JPEG_SUPPORT)\n         {\n           char\n             sampling_factor[MaxTextExtent];\n\n           int\n             tiff_status;\n\n           uint16\n             horizontal,\n             vertical;\n\n           tiff_status=TIFFGetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,&horizontal,\n             &vertical);\n           if (tiff_status == 1)\n             {\n               (void) FormatLocaleString(sampling_factor,MaxTextExtent,\"%dx%d\",\n                 horizontal,vertical);\n               (void) SetImageProperty(image,\"jpeg:sampling-factor\",\n                 sampling_factor);\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"Sampling Factors: %s\",sampling_factor);\n             }\n         }\n#endif\n        break;\n      }\n      case COMPRESSION_OJPEG: image->compression=JPEGCompression; break;\n#if defined(COMPRESSION_LZMA)\n      case COMPRESSION_LZMA: image->compression=LZMACompression; break;\n#endif\n      case COMPRESSION_LZW: image->compression=LZWCompression; break;\n      case COMPRESSION_DEFLATE: image->compression=ZipCompression; break;\n      case COMPRESSION_ADOBE_DEFLATE: image->compression=ZipCompression; break;\n#if defined(COMPRESSION_WEBP)\n      case COMPRESSION_WEBP: image->compression=WebPCompression; break;\n#endif\n#if defined(COMPRESSION_ZSTD)\n      case COMPRESSION_ZSTD: image->compression=ZstdCompression; break;\n#endif\n      default: image->compression=RLECompression; break;\n    }\n    quantum_info=(QuantumInfo *) NULL;\n    if ((photometric == PHOTOMETRIC_PALETTE) &&\n        (pow(2.0,1.0*bits_per_sample) <= MaxColormapSize))\n      {\n        size_t\n          colors;\n\n        colors=(size_t) GetQuantumRange(bits_per_sample)+1;\n        if (AcquireImageColormap(image,colors) == MagickFalse)\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_PAGENUMBER,&value,&pages,sans) == 1)\n      image->scene=value;\n    if (image->storage_class == PseudoClass)\n      {\n        int\n          tiff_status;\n\n        size_t\n          range;\n\n        uint16\n          *blue_colormap = (uint16 *) NULL,\n          *green_colormap = (uint16 *) NULL,\n          *red_colormap = (uint16 *) NULL;\n\n        /*\n          Initialize colormap.\n        */\n        tiff_status=TIFFGetField(tiff,TIFFTAG_COLORMAP,&red_colormap,\n          &green_colormap,&blue_colormap);\n        if (tiff_status == 1)\n          {\n            if ((red_colormap != (uint16 *) NULL) &&\n                (green_colormap != (uint16 *) NULL) &&\n                (blue_colormap != (uint16 *) NULL))\n              {\n                range=255;  /* might be old style 8-bit colormap */\n                for (i=0; i < (ssize_t) image->colors; i++)\n                  if ((red_colormap[i] >= 256) || (green_colormap[i] >= 256) ||\n                      (blue_colormap[i] >= 256))\n                    {\n                      range=65535;\n                      break;\n                    }\n                for (i=0; i < (ssize_t) image->colors; i++)\n                {\n                  image->colormap[i].red=ClampToQuantum(((double)\n                    QuantumRange*red_colormap[i])/range);\n                  image->colormap[i].green=ClampToQuantum(((double)\n                    QuantumRange*green_colormap[i])/range);\n                  image->colormap[i].blue=ClampToQuantum(((double)\n                    QuantumRange*blue_colormap[i])/range);\n                }\n              }\n          }\n      }\n    if (image_info->ping != MagickFalse)\n      {\n        if (image_info->number_scenes != 0)\n          if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n            break;\n        goto next_tiff_frame;\n      }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    status=SetImageColorspace(image,image->colorspace);\n    status&=ResetImagePixels(image,exception);\n    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    /*\n      Allocate memory for the image and pixel buffer.\n    */\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if (sample_format == SAMPLEFORMAT_UINT)\n      status=SetQuantumFormat(image,quantum_info,UnsignedQuantumFormat);\n    if (sample_format == SAMPLEFORMAT_INT)\n      status=SetQuantumFormat(image,quantum_info,SignedQuantumFormat);\n    if (sample_format == SAMPLEFORMAT_IEEEFP)\n      status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);\n    if (status == MagickFalse)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n    status=MagickTrue;\n    switch (photometric)\n    {\n      case PHOTOMETRIC_MINISBLACK:\n      {\n        quantum_info->min_is_white=MagickFalse;\n        break;\n      }\n      case PHOTOMETRIC_MINISWHITE:\n      {\n        quantum_info->min_is_white=MagickTrue;\n        break;\n      }\n      default:\n        break;\n    }\n    extra_samples=0;\n    tiff_status=TIFFGetFieldDefaulted(tiff,TIFFTAG_EXTRASAMPLES,&extra_samples,\n      &sample_info,sans);\n    if (tiff_status == 1)\n      {\n        (void) SetImageProperty(image,\"tiff:alpha\",\"unspecified\");\n        if (extra_samples == 0)\n          {\n            if ((samples_per_pixel == 4) && (photometric == PHOTOMETRIC_RGB))\n              image->matte=MagickTrue;\n          }\n        else\n          for (i=0; i < extra_samples; i++)\n          {\n            image->matte=MagickTrue;\n            if (sample_info[i] == EXTRASAMPLE_ASSOCALPHA)\n              {\n                SetQuantumAlphaType(quantum_info,AssociatedQuantumAlpha);\n                (void) SetImageProperty(image,\"tiff:alpha\",\"associated\");\n              }\n            else\n              if (sample_info[i] == EXTRASAMPLE_UNASSALPHA)\n                {\n                  SetQuantumAlphaType(quantum_info,DisassociatedQuantumAlpha);\n                  (void) SetImageProperty(image,\"tiff:alpha\",\"unassociated\");\n                }\n          }\n      }\n    if (image->matte != MagickFalse)\n      (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);\n    method=ReadGenericMethod;\n    rows_per_strip=(uint32) image->rows;\n    if (TIFFGetField(tiff,TIFFTAG_ROWSPERSTRIP,&rows_per_strip) == 1)\n      {\n        char\n          value[MaxTextExtent];\n\n        (void) FormatLocaleString(value,MaxTextExtent,\"%u\",(unsigned int)\n          rows_per_strip);\n        (void) SetImageProperty(image,\"tiff:rows-per-strip\",value);\n        method=ReadStripMethod;\n        if (rows_per_strip > (uint32) image->rows)\n          rows_per_strip=(uint32) image->rows;\n      }\n    if (TIFFIsTiled(tiff) != MagickFalse)\n      {\n        uint32\n          columns,\n          rows;\n\n        if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns) != 1) ||\n            (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))\n          ThrowTIFFException(CoderError,\"ImageIsNotTiled\");\n        if ((AcquireMagickResource(WidthResource,columns) == MagickFalse) ||\n            (AcquireMagickResource(HeightResource,rows) == MagickFalse))\n          ThrowTIFFException(ImageError,\"WidthOrHeightExceedsLimit\");\n        method=ReadTileMethod;\n      }\n    if ((photometric == PHOTOMETRIC_LOGLUV) ||\n        (compress_tag == COMPRESSION_CCITTFAX3))\n      method=ReadGenericMethod;\n    if (image->compression == JPEGCompression)\n      method=GetJPEGMethod(image,tiff,photometric,bits_per_sample,\n        samples_per_pixel);\n    quantum_info->endian=LSBEndian;\n    scanline_size=TIFFScanlineSize(tiff);\n    if (scanline_size <= 0)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n    number_pixels=MagickMax((MagickSizeType) image->columns*samples_per_pixel*\n      pow(2.0,ceil(log(bits_per_sample)/log(2.0))),image->columns*\n      rows_per_strip);\n    if ((double) scanline_size > 1.5*number_pixels)\n      ThrowTIFFException(CorruptImageError,\"CorruptImage\");\n    number_pixels=MagickMax((MagickSizeType) scanline_size,number_pixels);\n    pixel_info=AcquireVirtualMemory(number_pixels,sizeof(uint32));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    (void) ResetMagickMemory(pixels,0,number_pixels*sizeof(uint32));\n    quantum_type=GrayQuantum;\n    if (image->storage_class == PseudoClass)\n      quantum_type=IndexQuantum;\n    if (interlace != PLANARCONFIG_SEPARATE)\n      {\n        size_t\n          pad;\n\n        pad=(size_t) MagickMax((ssize_t) samples_per_pixel-1,0);\n        if (image->matte != MagickFalse)\n          {\n            if (image->storage_class == PseudoClass)\n              quantum_type=IndexAlphaQuantum;\n            else\n              quantum_type=samples_per_pixel == 1 ? AlphaQuantum :\n                GrayAlphaQuantum;\n          }\n        if ((samples_per_pixel > 2) && (interlace != PLANARCONFIG_SEPARATE))\n          {\n            quantum_type=RGBQuantum;\n            pad=(size_t) MagickMax((ssize_t) samples_per_pixel+\n              extra_samples-3,0);\n            if (image->matte != MagickFalse)\n              {\n                quantum_type=RGBAQuantum;\n                pad=(size_t) MagickMax((ssize_t) samples_per_pixel+\n                  extra_samples-4,0);\n              }\n            if (image->colorspace == CMYKColorspace)\n              {\n                quantum_type=CMYKQuantum;\n                pad=(size_t) MagickMax((ssize_t) samples_per_pixel+\n                  extra_samples-4,0);\n                if (image->matte != MagickFalse)\n                  {\n                    quantum_type=CMYKAQuantum;\n                    pad=(size_t) MagickMax((ssize_t) samples_per_pixel+\n                      extra_samples-5,0);\n                  }\n              }\n            status=SetQuantumPad(image,quantum_info,pad*((bits_per_sample+7) >>\n              3));\n            if (status == MagickFalse)\n              ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n      }\n    switch (method)\n    {\n      case ReadYCCKMethod:\n      {\n        /*\n          Convert YCC TIFF image.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          int\n            status;\n\n          IndexPacket\n            *indexes;\n\n          PixelPacket\n            *magick_restrict q;\n\n          ssize_t\n            x;\n\n          unsigned char\n            *p;\n\n          status=TIFFReadPixels(tiff,0,y,(char *) pixels);\n          if (status == -1)\n            break;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          indexes=GetAuthenticIndexQueue(image);\n          p=pixels;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelCyan(q,ScaleCharToQuantum(ClampYCC((double) *p+\n              (1.402*(double) *(p+2))-179.456)));\n            SetPixelMagenta(q,ScaleCharToQuantum(ClampYCC((double) *p-\n              (0.34414*(double) *(p+1))-(0.71414*(double ) *(p+2))+\n              135.45984)));\n            SetPixelYellow(q,ScaleCharToQuantum(ClampYCC((double) *p+\n              (1.772*(double) *(p+1))-226.816)));\n            SetPixelBlack(indexes+x,ScaleCharToQuantum((unsigned char)*(p+3)));\n            q++;\n            p+=4;\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case ReadStripMethod:\n      {\n        unsigned char\n          *p;\n\n        size_t\n          extent;\n\n        ssize_t\n          stride,\n          strip_id;\n\n        tsize_t\n          strip_size;\n\n        unsigned char\n          *strip_pixels;\n\n        /*\n          Convert stripped TIFF image.\n        */\n        extent=4*(samples_per_pixel+1)*TIFFStripSize(tiff);\n        strip_pixels=(unsigned char *) AcquireQuantumMemory(extent,\n          sizeof(*strip_pixels));\n        if (strip_pixels == (unsigned char *) NULL)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) memset(strip_pixels,0,extent*sizeof(*strip_pixels));\n        stride=TIFFVStripSize(tiff,1);\n        strip_id=0;\n        p=strip_pixels;\n        for (i=0; i < (ssize_t) samples_per_pixel; i++)\n        {\n          size_t\n            rows_remaining;\n\n          switch (i)\n          {\n            case 0: break;\n            case 1: quantum_type=GreenQuantum; break;\n            case 2: quantum_type=BlueQuantum; break;\n            case 3:\n            {\n              quantum_type=AlphaQuantum;\n              if (image->colorspace == CMYKColorspace)\n                quantum_type=BlackQuantum;\n              break;\n            }\n            case 4: quantum_type=AlphaQuantum; break;\n            default: break;\n          }\n          rows_remaining=0;\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            PixelPacket\n              *magick_restrict q;\n\n            q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (PixelPacket *) NULL)\n              break;\n            if (rows_remaining == 0)\n              {\n                strip_size=TIFFReadEncodedStrip(tiff,strip_id,strip_pixels,\n                  TIFFStripSize(tiff));\n                if (strip_size == -1)\n                  break;\n                rows_remaining=rows_per_strip;\n                if ((y+rows_per_strip) > (ssize_t) image->rows)\n                  rows_remaining=(rows_per_strip-(y+rows_per_strip-\n                    image->rows));\n                p=strip_pixels;\n                strip_id++;\n              }\n            (void) ImportQuantumPixels(image,(CacheView *) NULL,\n              quantum_info,quantum_type,p,exception);\n            p+=stride;\n            rows_remaining--;\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                  image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n         if ((samples_per_pixel > 1) && (interlace != PLANARCONFIG_SEPARATE))\n            break;\n        }\n        strip_pixels=(unsigned char *) RelinquishMagickMemory(strip_pixels);\n        break;\n      }\n      case ReadTileMethod:\n      {\n        unsigned char\n          *p;\n\n        size_t\n          extent;\n\n        uint32\n          columns,\n          rows;\n\n        unsigned char\n          *tile_pixels;\n\n        /*\n          Convert tiled TIFF image.\n        */\n        if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns) != 1) ||\n            (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))\n          ThrowTIFFException(CoderError,\"ImageIsNotTiled\");\n        number_pixels=(MagickSizeType) columns*rows;\n        if (HeapOverflowSanityCheck(rows,sizeof(*tile_pixels)) != MagickFalse)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        extent=4*(samples_per_pixel+1)*MagickMax(rows*TIFFTileRowSize(tiff),\n          TIFFTileSize(tiff));\n        tile_pixels=(unsigned char *) AcquireQuantumMemory(extent,\n          sizeof(*tile_pixels));\n        if (tile_pixels == (unsigned char *) NULL)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) memset(tile_pixels,0,extent*sizeof(*tile_pixels));\n        for (i=0; i < (ssize_t) samples_per_pixel; i++)\n        {\n          switch (i)\n          {\n            case 0: break;\n            case 1: quantum_type=GreenQuantum; break;\n            case 2: quantum_type=BlueQuantum; break;\n            case 3:\n            {\n              quantum_type=AlphaQuantum;\n              if (image->colorspace == CMYKColorspace)\n                quantum_type=BlackQuantum;\n              break;\n            }\n            case 4: quantum_type=AlphaQuantum; break;\n            default: break;\n          }\n          for (y=0; y < (ssize_t) image->rows; y+=rows)\n          {\n            ssize_t\n              x;\n\n            size_t\n              rows_remaining;\n\n            rows_remaining=image->rows-y;\n            if ((ssize_t) (y+rows) < (ssize_t) image->rows)\n              rows_remaining=rows;\n            for (x=0; x < (ssize_t) image->columns; x+=columns)\n            {\n              size_t\n                columns_remaining,\n                row;\n\n              columns_remaining=image->columns-x;\n              if ((ssize_t) (x+columns) < (ssize_t) image->columns)\n                columns_remaining=columns;\n              tiff_status=TIFFReadTile(tiff,tile_pixels,(uint32) x,(uint32) y,\n                0,i);\n              if (tiff_status == -1)\n                break;\n              p=tile_pixels;\n              for (row=0; row < rows_remaining; row++)\n              {\n                PixelPacket\n                  *magick_restrict q;\n\n                q=GetAuthenticPixels(image,x,y+row,columns_remaining,1,\n                  exception);\n                if (q == (PixelPacket *) NULL)\n                  break;\n                (void) ImportQuantumPixels(image,(CacheView *) NULL,\n                  quantum_info,quantum_type,p,exception);\n                p+=TIFFTileRowSize(tiff);\n                if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                  break;\n              }\n            }\n          }\n          if ((samples_per_pixel > 1) && (interlace != PLANARCONFIG_SEPARATE))\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) i,\n                samples_per_pixel);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        tile_pixels=(unsigned char *) RelinquishMagickMemory(tile_pixels);\n        break;\n      }\n      case ReadGenericMethod:\n      default:\n      {\n        MemoryInfo\n          *generic_info = (MemoryInfo *) NULL;\n\n        uint32\n          *p;\n\n        uint32\n          *pixels;\n\n        /*\n          Convert generic TIFF image.\n        */\n        if (HeapOverflowSanityCheck(image->rows,sizeof(*pixels)) != MagickFalse)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        number_pixels=(MagickSizeType) image->columns*image->rows;\n        generic_info=AcquireVirtualMemory(number_pixels,sizeof(*pixels));\n        if (generic_info == (MemoryInfo *) NULL)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        pixels=(uint32 *) GetVirtualMemoryBlob(generic_info);\n        tiff_status=TIFFReadRGBAImage(tiff,(uint32) image->columns,(uint32)\n          image->rows,(uint32 *) pixels,0);\n        if (tiff_status == -1)\n          {\n            generic_info=RelinquishVirtualMemory(generic_info);\n            break;\n          }\n        p=pixels+(image->columns*image->rows)-1;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          ssize_t\n            x;\n\n          PixelPacket\n            *magick_restrict q;\n\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          q+=image->columns-1;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(q,ScaleCharToQuantum((unsigned char) TIFFGetR(*p)));\n            SetPixelGreen(q,ScaleCharToQuantum((unsigned char) TIFFGetG(*p)));\n            SetPixelBlue(q,ScaleCharToQuantum((unsigned char) TIFFGetB(*p)));\n            if (image->matte == MagickFalse)\n              SetPixelOpacity(q,OpaqueOpacity);\n            else\n              SetPixelAlpha(q,ScaleCharToQuantum((unsigned char) TIFFGetA(*p)));\n            p--;\n            q--;\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        generic_info=RelinquishVirtualMemory(generic_info);\n        break;\n      }\n    }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    SetQuantumImageType(image,quantum_type);\n  next_tiff_frame:\n    if (quantum_info != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n    if (tiff_status == -1)\n      {\n        status=MagickFalse;\n        break;\n      }\n    if (photometric == PHOTOMETRIC_CIELAB)\n      DecodeLabImage(image,exception);\n    if ((photometric == PHOTOMETRIC_LOGL) ||\n        (photometric == PHOTOMETRIC_MINISBLACK) ||\n        (photometric == PHOTOMETRIC_MINISWHITE))\n      {\n        image->type=GrayscaleType;\n        if (bits_per_sample == 1)\n          image->type=BilevelType;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    more_frames=TIFFReadDirectory(tiff) != 0 ? MagickTrue : MagickFalse;\n    if (more_frames != MagickFalse)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            status=MagickFalse;\n            break;\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,image->scene-1,\n          image->scene);\n        if (status == MagickFalse)\n          break;\n      }\n  } while ((status != MagickFalse) && (more_frames != MagickFalse));\n  TIFFClose(tiff);\n  if ((image_info->number_scenes != 0) &&\n      (image_info->scene >= GetImageListLength(image)))\n    status=MagickFalse;\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  TIFFReadPhotoshopLayers(image_info,image,exception);\n  return(GetFirstImageInList(image));\n}", "func_hash": 282124666378195634578988553119839535376, "file_name": "tiff.c", "file_hash": 94999311171482042296542443921541591860, "cwe": ["CWE-787"], "cve": "CVE-2022-3213", "cve_desc": "A heap buffer overflow issue was found in ImageMagick. When an application processes a malformed TIFF file, it could lead to undefined behavior or a crash causing a denial of service.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-3213", "file_path": "coders/tiff.c"}
{"idx": 452391, "project": "ImageMagick6", "commit_id": "1aea203eb36409ce6903b9e41fe7cb70030e8750", "project_url": "https://github.com/ImageMagick/ImageMagick6", "commit_url": "https://github.com/ImageMagick/ImageMagick6/commit/1aea203eb36409ce6903b9e41fe7cb70030e8750", "commit_message": "squash heap-buffer-overflow, PoC TIFF from Hardik", "target": 0, "func": "static Image *ReadTIFFImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n#define MaxPixelChannels  32\n#define ThrowTIFFException(severity,message) \\\n{ \\\n  if (pixel_info != (MemoryInfo *) NULL) \\\n    pixel_info=RelinquishVirtualMemory(pixel_info); \\\n  if (quantum_info != (QuantumInfo *) NULL) \\\n    quantum_info=DestroyQuantumInfo(quantum_info); \\\n  TIFFClose(tiff); \\\n  ThrowReaderException(severity,message); \\\n}\n\n  const char\n    *option;\n\n  float\n    *chromaticity = (float *) NULL,\n    x_position,\n    y_position,\n    x_resolution,\n    y_resolution;\n\n  Image\n    *image;\n\n  int\n    tiff_status = 0;\n\n  MagickBooleanType\n    more_frames;\n\n  MagickStatusType\n    status;\n\n  MemoryInfo\n    *pixel_info = (MemoryInfo *) NULL;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  size_t\n    number_pixels;\n\n  ssize_t\n    i,\n    scanline_size,\n    y;\n\n  TIFF\n    *tiff;\n\n  TIFFMethodType\n    method;\n\n  uint16\n    compress_tag = 0,\n    bits_per_sample = 0,\n    endian = 0,\n    extra_samples = 0,\n    interlace = 0,\n    max_sample_value = 0,\n    min_sample_value = 0,\n    orientation = 0,\n    pages = 0,\n    photometric = 0,\n    *sample_info = NULL,\n    sample_format = 0,\n    samples_per_pixel = 0,\n    units = 0,\n    value = 0;\n\n  uint32\n    height,\n    rows_per_strip,\n    width;\n\n  unsigned char\n    *pixels;\n\n  void\n    *sans[8] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };\n\n  /*\n    Open image.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) SetMagickThreadValue(tiff_exception,exception);\n  tiff=TIFFClientOpen(image->filename,\"rb\",(thandle_t) image,TIFFReadBlob,\n    TIFFWriteBlob,TIFFSeekBlob,TIFFCloseBlob,TIFFGetBlobSize,TIFFMapBlob,\n    TIFFUnmapBlob);\n  if (tiff == (TIFF *) NULL)\n    {\n      if (exception->severity == UndefinedException)\n        ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (exception->severity > ErrorException)\n    {\n      TIFFClose(tiff);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (image_info->number_scenes != 0)\n    {\n      /*\n        Generate blank images for subimage specification (e.g. image.tif[4].\n        We need to check the number of directores because it is possible that\n        the subimage(s) are stored in the photoshop profile.\n      */\n      if (image_info->scene < (size_t)TIFFNumberOfDirectories(tiff))\n        {\n          for (i=0; i < (ssize_t) image_info->scene; i++)\n          {\n            status=TIFFReadDirectory(tiff) != 0 ? MagickTrue : MagickFalse;\n            if (status == MagickFalse)\n              {\n                TIFFClose(tiff);\n                image=DestroyImageList(image);\n                return((Image *) NULL);\n              }\n            AcquireNextImage(image_info,image);\n            if (GetNextImageInList(image) == (Image *) NULL)\n              {\n                TIFFClose(tiff);\n                image=DestroyImageList(image);\n                return((Image *) NULL);\n              }\n            image=SyncNextImageInList(image);\n          }\n        }\n    }\n  more_frames=MagickTrue;\n  do\n  {\n    /* TIFFPrintDirectory(tiff,stdout,MagickFalse); */\n    photometric=PHOTOMETRIC_RGB;\n    if ((TIFFGetField(tiff,TIFFTAG_IMAGEWIDTH,&width) != 1) ||\n        (TIFFGetField(tiff,TIFFTAG_IMAGELENGTH,&height) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_PHOTOMETRIC,&photometric,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_COMPRESSION,&compress_tag,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_FILLORDER,&endian,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_PLANARCONFIG,&interlace,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLESPERPIXEL,&samples_per_pixel,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,&bits_per_sample,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLEFORMAT,&sample_format,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_MINSAMPLEVALUE,&min_sample_value,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_MAXSAMPLEVALUE,&max_sample_value,sans) != 1))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n    if (((sample_format != SAMPLEFORMAT_IEEEFP) || (bits_per_sample != 64)) &&\n        ((bits_per_sample <= 0) || (bits_per_sample > 32)))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CorruptImageError,\"UnsupportedBitsPerPixel\");\n      }\n    if (samples_per_pixel > MaxPixelChannels)\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CorruptImageError,\"MaximumChannelsExceeded\");\n      }\n    if (sample_format == SAMPLEFORMAT_IEEEFP)\n      (void) SetImageProperty(image,\"quantum:format\",\"floating-point\");\n    switch (photometric)\n    {\n      case PHOTOMETRIC_MINISBLACK:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"min-is-black\");\n        break;\n      }\n      case PHOTOMETRIC_MINISWHITE:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"min-is-white\");\n        break;\n      }\n      case PHOTOMETRIC_PALETTE:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"palette\");\n        break;\n      }\n      case PHOTOMETRIC_RGB:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"RGB\");\n        break;\n      }\n      case PHOTOMETRIC_CIELAB:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"CIELAB\");\n        break;\n      }\n      case PHOTOMETRIC_LOGL:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"CIE Log2(L)\");\n        break;\n      }\n      case PHOTOMETRIC_LOGLUV:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"LOGLUV\");\n        break;\n      }\n#if defined(PHOTOMETRIC_MASK)\n      case PHOTOMETRIC_MASK:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"MASK\");\n        break;\n      }\n#endif\n      case PHOTOMETRIC_SEPARATED:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"separated\");\n        break;\n      }\n      case PHOTOMETRIC_YCBCR:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"YCBCR\");\n        break;\n      }\n      default:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"unknown\");\n        break;\n      }\n    }\n    if (image->debug != MagickFalse)\n      {\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Geometry: %ux%u\",\n          (unsigned int) width,(unsigned int) height);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Interlace: %u\",\n          interlace);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Bits per sample: %u\",bits_per_sample);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Min sample value: %u\",min_sample_value);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Max sample value: %u\",max_sample_value);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Photometric \"\n          \"interpretation: %s\",GetImageProperty(image,\"tiff:photometric\"));\n      }\n    image->columns=(size_t) width;\n    image->rows=(size_t) height;\n    image->depth=(size_t) bits_per_sample;\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Image depth: %.20g\",\n        (double) image->depth);\n    image->endian=MSBEndian;\n    if (endian == FILLORDER_LSB2MSB)\n      image->endian=LSBEndian;\n#if defined(MAGICKCORE_HAVE_TIFFISBIGENDIAN)\n    if (TIFFIsBigEndian(tiff) == 0)\n      {\n        (void) SetImageProperty(image,\"tiff:endian\",\"lsb\");\n        image->endian=LSBEndian;\n      }\n    else\n      {\n        (void) SetImageProperty(image,\"tiff:endian\",\"msb\");\n        image->endian=MSBEndian;\n      }\n#endif\n    if ((photometric == PHOTOMETRIC_MINISBLACK) ||\n        (photometric == PHOTOMETRIC_MINISWHITE))\n      image->colorspace=GRAYColorspace;\n    if (photometric == PHOTOMETRIC_SEPARATED)\n      image->colorspace=CMYKColorspace;\n    if (photometric == PHOTOMETRIC_CIELAB)\n      image->colorspace=LabColorspace;\n    if ((photometric == PHOTOMETRIC_YCBCR) &&\n        (compress_tag != COMPRESSION_OJPEG) &&\n        (compress_tag != COMPRESSION_JPEG))\n      image->colorspace=YCbCrColorspace;\n    status=TIFFGetProfiles(tiff,image);\n    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    status=TIFFGetProperties(tiff,image);\n    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    option=GetImageOption(image_info,\"tiff:exif-properties\");\n    if ((option == (const char *) NULL) ||\n        (IsMagickTrue(option) != MagickFalse))\n      (void) TIFFGetEXIFProperties(tiff,image);\n    option=GetImageOption(image_info,\"tiff:gps-properties\");\n    if ((option == (const char *) NULL) ||\n        (IsMagickTrue(option) != MagickFalse))\n      (void) TIFFGetGPSProperties(tiff,image);\n    if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XRESOLUTION,&x_resolution,sans) == 1) &&\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_YRESOLUTION,&y_resolution,sans) == 1))\n      {\n        image->x_resolution=x_resolution;\n        image->y_resolution=y_resolution;\n      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_RESOLUTIONUNIT,&units,sans,sans) == 1)\n      {\n        if (units == RESUNIT_INCH)\n          image->units=PixelsPerInchResolution;\n        if (units == RESUNIT_CENTIMETER)\n          image->units=PixelsPerCentimeterResolution;\n      }\n    if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XPOSITION,&x_position,sans) == 1) &&\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_YPOSITION,&y_position,sans) == 1))\n      {\n        image->page.x=CastDoubleToLong(ceil(x_position*\n          image->x_resolution-0.5));\n        image->page.y=CastDoubleToLong(ceil(y_position*\n          image->y_resolution-0.5));\n      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_ORIENTATION,&orientation,sans) == 1)\n      image->orientation=(OrientationType) orientation;\n    if (TIFFGetField(tiff,TIFFTAG_WHITEPOINT,&chromaticity) == 1)\n      {\n        if ((chromaticity != (float *) NULL) && (*chromaticity != 0.0))\n          {\n            image->chromaticity.white_point.x=chromaticity[0];\n            image->chromaticity.white_point.y=chromaticity[1];\n          }\n      }\n    if (TIFFGetField(tiff,TIFFTAG_PRIMARYCHROMATICITIES,&chromaticity) == 1)\n      {\n        if ((chromaticity != (float *) NULL) && (*chromaticity != 0.0))\n          {\n            image->chromaticity.red_primary.x=chromaticity[0];\n            image->chromaticity.red_primary.y=chromaticity[1];\n            image->chromaticity.green_primary.x=chromaticity[2];\n            image->chromaticity.green_primary.y=chromaticity[3];\n            image->chromaticity.blue_primary.x=chromaticity[4];\n            image->chromaticity.blue_primary.y=chromaticity[5];\n          }\n      }\n#if defined(MAGICKCORE_HAVE_TIFFISCODECCONFIGURED) || (TIFFLIB_VERSION > 20040919)\n    if ((compress_tag != COMPRESSION_NONE) &&\n        (TIFFIsCODECConfigured(compress_tag) == 0))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CoderError,\"CompressNotSupported\");\n      }\n#endif\n    switch (compress_tag)\n    {\n      case COMPRESSION_NONE: image->compression=NoCompression; break;\n      case COMPRESSION_CCITTFAX3: image->compression=FaxCompression; break;\n      case COMPRESSION_CCITTFAX4: image->compression=Group4Compression; break;\n      case COMPRESSION_JPEG:\n      {\n         image->compression=JPEGCompression;\n#if defined(JPEG_SUPPORT)\n         {\n           char\n             sampling_factor[MaxTextExtent];\n\n           int\n             tiff_status;\n\n           uint16\n             horizontal,\n             vertical;\n\n           tiff_status=TIFFGetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,&horizontal,\n             &vertical);\n           if (tiff_status == 1)\n             {\n               (void) FormatLocaleString(sampling_factor,MaxTextExtent,\"%dx%d\",\n                 horizontal,vertical);\n               (void) SetImageProperty(image,\"jpeg:sampling-factor\",\n                 sampling_factor);\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"Sampling Factors: %s\",sampling_factor);\n             }\n         }\n#endif\n        break;\n      }\n      case COMPRESSION_OJPEG: image->compression=JPEGCompression; break;\n#if defined(COMPRESSION_LZMA)\n      case COMPRESSION_LZMA: image->compression=LZMACompression; break;\n#endif\n      case COMPRESSION_LZW: image->compression=LZWCompression; break;\n      case COMPRESSION_DEFLATE: image->compression=ZipCompression; break;\n      case COMPRESSION_ADOBE_DEFLATE: image->compression=ZipCompression; break;\n#if defined(COMPRESSION_WEBP)\n      case COMPRESSION_WEBP: image->compression=WebPCompression; break;\n#endif\n#if defined(COMPRESSION_ZSTD)\n      case COMPRESSION_ZSTD: image->compression=ZstdCompression; break;\n#endif\n      default: image->compression=RLECompression; break;\n    }\n    quantum_info=(QuantumInfo *) NULL;\n    if ((photometric == PHOTOMETRIC_PALETTE) &&\n        (pow(2.0,1.0*bits_per_sample) <= MaxColormapSize))\n      {\n        size_t\n          colors;\n\n        colors=(size_t) GetQuantumRange(bits_per_sample)+1;\n        if (AcquireImageColormap(image,colors) == MagickFalse)\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_PAGENUMBER,&value,&pages,sans) == 1)\n      image->scene=value;\n    if (image->storage_class == PseudoClass)\n      {\n        int\n          tiff_status;\n\n        size_t\n          range;\n\n        uint16\n          *blue_colormap = (uint16 *) NULL,\n          *green_colormap = (uint16 *) NULL,\n          *red_colormap = (uint16 *) NULL;\n\n        /*\n          Initialize colormap.\n        */\n        tiff_status=TIFFGetField(tiff,TIFFTAG_COLORMAP,&red_colormap,\n          &green_colormap,&blue_colormap);\n        if (tiff_status == 1)\n          {\n            if ((red_colormap != (uint16 *) NULL) &&\n                (green_colormap != (uint16 *) NULL) &&\n                (blue_colormap != (uint16 *) NULL))\n              {\n                range=255;  /* might be old style 8-bit colormap */\n                for (i=0; i < (ssize_t) image->colors; i++)\n                  if ((red_colormap[i] >= 256) || (green_colormap[i] >= 256) ||\n                      (blue_colormap[i] >= 256))\n                    {\n                      range=65535;\n                      break;\n                    }\n                for (i=0; i < (ssize_t) image->colors; i++)\n                {\n                  image->colormap[i].red=ClampToQuantum(((double)\n                    QuantumRange*red_colormap[i])/range);\n                  image->colormap[i].green=ClampToQuantum(((double)\n                    QuantumRange*green_colormap[i])/range);\n                  image->colormap[i].blue=ClampToQuantum(((double)\n                    QuantumRange*blue_colormap[i])/range);\n                }\n              }\n          }\n      }\n    if (image_info->ping != MagickFalse)\n      {\n        if (image_info->number_scenes != 0)\n          if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n            break;\n        goto next_tiff_frame;\n      }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    status=SetImageColorspace(image,image->colorspace);\n    status&=ResetImagePixels(image,exception);\n    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    /*\n      Allocate memory for the image and pixel buffer.\n    */\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if (sample_format == SAMPLEFORMAT_UINT)\n      status=SetQuantumFormat(image,quantum_info,UnsignedQuantumFormat);\n    if (sample_format == SAMPLEFORMAT_INT)\n      status=SetQuantumFormat(image,quantum_info,SignedQuantumFormat);\n    if (sample_format == SAMPLEFORMAT_IEEEFP)\n      status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);\n    if (status == MagickFalse)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n    status=MagickTrue;\n    switch (photometric)\n    {\n      case PHOTOMETRIC_MINISBLACK:\n      {\n        quantum_info->min_is_white=MagickFalse;\n        break;\n      }\n      case PHOTOMETRIC_MINISWHITE:\n      {\n        quantum_info->min_is_white=MagickTrue;\n        break;\n      }\n      default:\n        break;\n    }\n    extra_samples=0;\n    tiff_status=TIFFGetFieldDefaulted(tiff,TIFFTAG_EXTRASAMPLES,&extra_samples,\n      &sample_info,sans);\n    if (tiff_status == 1)\n      {\n        (void) SetImageProperty(image,\"tiff:alpha\",\"unspecified\");\n        if (extra_samples == 0)\n          {\n            if ((samples_per_pixel == 4) && (photometric == PHOTOMETRIC_RGB))\n              image->matte=MagickTrue;\n          }\n        else\n          for (i=0; i < extra_samples; i++)\n          {\n            image->matte=MagickTrue;\n            if (sample_info[i] == EXTRASAMPLE_ASSOCALPHA)\n              {\n                SetQuantumAlphaType(quantum_info,AssociatedQuantumAlpha);\n                (void) SetImageProperty(image,\"tiff:alpha\",\"associated\");\n              }\n            else\n              if (sample_info[i] == EXTRASAMPLE_UNASSALPHA)\n                {\n                  SetQuantumAlphaType(quantum_info,DisassociatedQuantumAlpha);\n                  (void) SetImageProperty(image,\"tiff:alpha\",\"unassociated\");\n                }\n          }\n      }\n    if (image->matte != MagickFalse)\n      (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);\n    method=ReadGenericMethod;\n    rows_per_strip=(uint32) image->rows;\n    if (TIFFGetField(tiff,TIFFTAG_ROWSPERSTRIP,&rows_per_strip) == 1)\n      {\n        char\n          value[MaxTextExtent];\n\n        (void) FormatLocaleString(value,MaxTextExtent,\"%u\",(unsigned int)\n          rows_per_strip);\n        (void) SetImageProperty(image,\"tiff:rows-per-strip\",value);\n        method=ReadStripMethod;\n        if (rows_per_strip > (uint32) image->rows)\n          rows_per_strip=(uint32) image->rows;\n      }\n    if (TIFFIsTiled(tiff) != MagickFalse)\n      {\n        uint32\n          columns,\n          rows;\n\n        if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns) != 1) ||\n            (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))\n          ThrowTIFFException(CoderError,\"ImageIsNotTiled\");\n        if ((AcquireMagickResource(WidthResource,columns) == MagickFalse) ||\n            (AcquireMagickResource(HeightResource,rows) == MagickFalse))\n          ThrowTIFFException(ImageError,\"WidthOrHeightExceedsLimit\");\n        method=ReadTileMethod;\n      }\n    if ((photometric == PHOTOMETRIC_LOGLUV) ||\n        (compress_tag == COMPRESSION_CCITTFAX3))\n      method=ReadGenericMethod;\n    if (image->compression == JPEGCompression)\n      method=GetJPEGMethod(image,tiff,photometric,bits_per_sample,\n        samples_per_pixel);\n    quantum_info->endian=LSBEndian;\n    scanline_size=TIFFScanlineSize(tiff);\n    if (scanline_size <= 0)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n    number_pixels=MagickMax((MagickSizeType) image->columns*samples_per_pixel*\n      pow(2.0,ceil(log(bits_per_sample)/log(2.0))),image->columns*\n      rows_per_strip);\n    if ((double) scanline_size > 1.5*number_pixels)\n      ThrowTIFFException(CorruptImageError,\"CorruptImage\");\n    number_pixels=MagickMax((MagickSizeType) scanline_size,number_pixels);\n    pixel_info=AcquireVirtualMemory(number_pixels,sizeof(uint32));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    (void) ResetMagickMemory(pixels,0,number_pixels*sizeof(uint32));\n    quantum_type=GrayQuantum;\n    if (image->storage_class == PseudoClass)\n      quantum_type=IndexQuantum;\n    if (interlace != PLANARCONFIG_SEPARATE)\n      {\n        size_t\n          pad;\n\n        pad=(size_t) MagickMax((ssize_t) samples_per_pixel-1,0);\n        if (image->matte != MagickFalse)\n          {\n            if (image->storage_class == PseudoClass)\n              quantum_type=IndexAlphaQuantum;\n            else\n              quantum_type=samples_per_pixel == 1 ? AlphaQuantum :\n                GrayAlphaQuantum;\n          }\n        if ((samples_per_pixel > 2) && (interlace != PLANARCONFIG_SEPARATE))\n          {\n            quantum_type=RGBQuantum;\n            pad=(size_t) MagickMax((ssize_t) samples_per_pixel+\n              extra_samples-3,0);\n            if (image->matte != MagickFalse)\n              {\n                quantum_type=RGBAQuantum;\n                pad=(size_t) MagickMax((ssize_t) samples_per_pixel+\n                  extra_samples-4,0);\n              }\n            if (image->colorspace == CMYKColorspace)\n              {\n                quantum_type=CMYKQuantum;\n                pad=(size_t) MagickMax((ssize_t) samples_per_pixel+\n                  extra_samples-4,0);\n                if (image->matte != MagickFalse)\n                  {\n                    quantum_type=CMYKAQuantum;\n                    pad=(size_t) MagickMax((ssize_t) samples_per_pixel+\n                      extra_samples-5,0);\n                  }\n              }\n            status=SetQuantumPad(image,quantum_info,pad*((bits_per_sample+7) >>\n              3));\n            if (status == MagickFalse)\n              ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n      }\n    switch (method)\n    {\n      case ReadYCCKMethod:\n      {\n        /*\n          Convert YCC TIFF image.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          int\n            status;\n\n          IndexPacket\n            *indexes;\n\n          PixelPacket\n            *magick_restrict q;\n\n          ssize_t\n            x;\n\n          unsigned char\n            *p;\n\n          status=TIFFReadPixels(tiff,0,y,(char *) pixels);\n          if (status == -1)\n            break;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          indexes=GetAuthenticIndexQueue(image);\n          p=pixels;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelCyan(q,ScaleCharToQuantum(ClampYCC((double) *p+\n              (1.402*(double) *(p+2))-179.456)));\n            SetPixelMagenta(q,ScaleCharToQuantum(ClampYCC((double) *p-\n              (0.34414*(double) *(p+1))-(0.71414*(double ) *(p+2))+\n              135.45984)));\n            SetPixelYellow(q,ScaleCharToQuantum(ClampYCC((double) *p+\n              (1.772*(double) *(p+1))-226.816)));\n            SetPixelBlack(indexes+x,ScaleCharToQuantum((unsigned char)*(p+3)));\n            q++;\n            p+=4;\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case ReadStripMethod:\n      {\n        unsigned char\n          *p;\n\n        size_t\n          extent;\n\n        ssize_t\n          stride,\n          strip_id;\n\n        tsize_t\n          strip_size;\n\n        unsigned char\n          *strip_pixels;\n\n        /*\n          Convert stripped TIFF image.\n        */\n        extent=4*((image->depth+7)/8)*(samples_per_pixel+1)*TIFFStripSize(tiff);\n        strip_pixels=(unsigned char *) AcquireQuantumMemory(extent,\n          sizeof(*strip_pixels));\n        if (strip_pixels == (unsigned char *) NULL)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) memset(strip_pixels,0,extent*sizeof(*strip_pixels));\n        stride=TIFFVStripSize(tiff,1);\n        strip_id=0;\n        p=strip_pixels;\n        for (i=0; i < (ssize_t) samples_per_pixel; i++)\n        {\n          size_t\n            rows_remaining;\n\n          switch (i)\n          {\n            case 0: break;\n            case 1: quantum_type=GreenQuantum; break;\n            case 2: quantum_type=BlueQuantum; break;\n            case 3:\n            {\n              quantum_type=AlphaQuantum;\n              if (image->colorspace == CMYKColorspace)\n                quantum_type=BlackQuantum;\n              break;\n            }\n            case 4: quantum_type=AlphaQuantum; break;\n            default: break;\n          }\n          rows_remaining=0;\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            PixelPacket\n              *magick_restrict q;\n\n            q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (PixelPacket *) NULL)\n              break;\n            if (rows_remaining == 0)\n              {\n                strip_size=TIFFReadEncodedStrip(tiff,strip_id,strip_pixels,\n                  TIFFStripSize(tiff));\n                if (strip_size == -1)\n                  break;\n                rows_remaining=rows_per_strip;\n                if ((y+rows_per_strip) > (ssize_t) image->rows)\n                  rows_remaining=(rows_per_strip-(y+rows_per_strip-\n                    image->rows));\n                p=strip_pixels;\n                strip_id++;\n              }\n            (void) ImportQuantumPixels(image,(CacheView *) NULL,\n              quantum_info,quantum_type,p,exception);\n            p+=stride;\n            rows_remaining--;\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                  image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n         if ((samples_per_pixel > 1) && (interlace != PLANARCONFIG_SEPARATE))\n            break;\n        }\n        strip_pixels=(unsigned char *) RelinquishMagickMemory(strip_pixels);\n        break;\n      }\n      case ReadTileMethod:\n      {\n        unsigned char\n          *p;\n\n        size_t\n          extent;\n\n        uint32\n          columns,\n          rows;\n\n        unsigned char\n          *tile_pixels;\n\n        /*\n          Convert tiled TIFF image.\n        */\n        if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns) != 1) ||\n            (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))\n          ThrowTIFFException(CoderError,\"ImageIsNotTiled\");\n        number_pixels=(MagickSizeType) columns*rows;\n        if (HeapOverflowSanityCheck(rows,sizeof(*tile_pixels)) != MagickFalse)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        extent=4*(samples_per_pixel+1)*MagickMax(rows*TIFFTileRowSize(tiff),\n          TIFFTileSize(tiff));\n        tile_pixels=(unsigned char *) AcquireQuantumMemory(extent,\n          sizeof(*tile_pixels));\n        if (tile_pixels == (unsigned char *) NULL)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) memset(tile_pixels,0,extent*sizeof(*tile_pixels));\n        for (i=0; i < (ssize_t) samples_per_pixel; i++)\n        {\n          switch (i)\n          {\n            case 0: break;\n            case 1: quantum_type=GreenQuantum; break;\n            case 2: quantum_type=BlueQuantum; break;\n            case 3:\n            {\n              quantum_type=AlphaQuantum;\n              if (image->colorspace == CMYKColorspace)\n                quantum_type=BlackQuantum;\n              break;\n            }\n            case 4: quantum_type=AlphaQuantum; break;\n            default: break;\n          }\n          for (y=0; y < (ssize_t) image->rows; y+=rows)\n          {\n            ssize_t\n              x;\n\n            size_t\n              rows_remaining;\n\n            rows_remaining=image->rows-y;\n            if ((ssize_t) (y+rows) < (ssize_t) image->rows)\n              rows_remaining=rows;\n            for (x=0; x < (ssize_t) image->columns; x+=columns)\n            {\n              size_t\n                columns_remaining,\n                row;\n\n              columns_remaining=image->columns-x;\n              if ((ssize_t) (x+columns) < (ssize_t) image->columns)\n                columns_remaining=columns;\n              tiff_status=TIFFReadTile(tiff,tile_pixels,(uint32) x,(uint32) y,\n                0,i);\n              if (tiff_status == -1)\n                break;\n              p=tile_pixels;\n              for (row=0; row < rows_remaining; row++)\n              {\n                PixelPacket\n                  *magick_restrict q;\n\n                q=GetAuthenticPixels(image,x,y+row,columns_remaining,1,\n                  exception);\n                if (q == (PixelPacket *) NULL)\n                  break;\n                (void) ImportQuantumPixels(image,(CacheView *) NULL,\n                  quantum_info,quantum_type,p,exception);\n                p+=TIFFTileRowSize(tiff);\n                if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                  break;\n              }\n            }\n          }\n          if ((samples_per_pixel > 1) && (interlace != PLANARCONFIG_SEPARATE))\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) i,\n                samples_per_pixel);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        tile_pixels=(unsigned char *) RelinquishMagickMemory(tile_pixels);\n        break;\n      }\n      case ReadGenericMethod:\n      default:\n      {\n        MemoryInfo\n          *generic_info = (MemoryInfo *) NULL;\n\n        uint32\n          *p;\n\n        uint32\n          *pixels;\n\n        /*\n          Convert generic TIFF image.\n        */\n        if (HeapOverflowSanityCheck(image->rows,sizeof(*pixels)) != MagickFalse)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        number_pixels=(MagickSizeType) image->columns*image->rows;\n        generic_info=AcquireVirtualMemory(number_pixels,sizeof(*pixels));\n        if (generic_info == (MemoryInfo *) NULL)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        pixels=(uint32 *) GetVirtualMemoryBlob(generic_info);\n        tiff_status=TIFFReadRGBAImage(tiff,(uint32) image->columns,(uint32)\n          image->rows,(uint32 *) pixels,0);\n        if (tiff_status == -1)\n          {\n            generic_info=RelinquishVirtualMemory(generic_info);\n            break;\n          }\n        p=pixels+(image->columns*image->rows)-1;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          ssize_t\n            x;\n\n          PixelPacket\n            *magick_restrict q;\n\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          q+=image->columns-1;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(q,ScaleCharToQuantum((unsigned char) TIFFGetR(*p)));\n            SetPixelGreen(q,ScaleCharToQuantum((unsigned char) TIFFGetG(*p)));\n            SetPixelBlue(q,ScaleCharToQuantum((unsigned char) TIFFGetB(*p)));\n            if (image->matte == MagickFalse)\n              SetPixelOpacity(q,OpaqueOpacity);\n            else\n              SetPixelAlpha(q,ScaleCharToQuantum((unsigned char) TIFFGetA(*p)));\n            p--;\n            q--;\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        generic_info=RelinquishVirtualMemory(generic_info);\n        break;\n      }\n    }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    SetQuantumImageType(image,quantum_type);\n  next_tiff_frame:\n    if (quantum_info != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n    if (tiff_status == -1)\n      {\n        status=MagickFalse;\n        break;\n      }\n    if (photometric == PHOTOMETRIC_CIELAB)\n      DecodeLabImage(image,exception);\n    if ((photometric == PHOTOMETRIC_LOGL) ||\n        (photometric == PHOTOMETRIC_MINISBLACK) ||\n        (photometric == PHOTOMETRIC_MINISWHITE))\n      {\n        image->type=GrayscaleType;\n        if (bits_per_sample == 1)\n          image->type=BilevelType;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    more_frames=TIFFReadDirectory(tiff) != 0 ? MagickTrue : MagickFalse;\n    if (more_frames != MagickFalse)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            status=MagickFalse;\n            break;\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,image->scene-1,\n          image->scene);\n        if (status == MagickFalse)\n          break;\n      }\n  } while ((status != MagickFalse) && (more_frames != MagickFalse));\n  TIFFClose(tiff);\n  if ((image_info->number_scenes != 0) &&\n      (image_info->scene >= GetImageListLength(image)))\n    status=MagickFalse;\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  TIFFReadPhotoshopLayers(image_info,image,exception);\n  return(GetFirstImageInList(image));\n}", "func_hash": 299907120858996373991818547886083873911, "file_name": "tiff.c", "file_hash": 106627250122948436089504190965714390547, "cwe": ["CWE-787"], "cve": "CVE-2022-3213", "cve_desc": "A heap buffer overflow issue was found in ImageMagick. When an application processes a malformed TIFF file, it could lead to undefined behavior or a crash causing a denial of service.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-3213", "file_path": "coders/tiff.c"}
{"idx": 211877, "project": "libexpat", "commit_id": "a2fe525e660badd64b6c557c2b1ec26ddc07f6e4", "project_url": "https://github.com/libexpat/libexpat", "commit_url": "https://github.com/libexpat/libexpat/commit/a2fe525e660badd64b6c557c2b1ec26ddc07f6e4", "commit_message": "lib: Protect against malicious namespace declarations (CVE-2022-25236)", "target": 1, "func": "addBinding(XML_Parser parser, PREFIX *prefix, const ATTRIBUTE_ID *attId,\n           const XML_Char *uri, BINDING **bindingsPtr) {\n  static const XML_Char xmlNamespace[]\n      = {ASCII_h,      ASCII_t,     ASCII_t,     ASCII_p,      ASCII_COLON,\n         ASCII_SLASH,  ASCII_SLASH, ASCII_w,     ASCII_w,      ASCII_w,\n         ASCII_PERIOD, ASCII_w,     ASCII_3,     ASCII_PERIOD, ASCII_o,\n         ASCII_r,      ASCII_g,     ASCII_SLASH, ASCII_X,      ASCII_M,\n         ASCII_L,      ASCII_SLASH, ASCII_1,     ASCII_9,      ASCII_9,\n         ASCII_8,      ASCII_SLASH, ASCII_n,     ASCII_a,      ASCII_m,\n         ASCII_e,      ASCII_s,     ASCII_p,     ASCII_a,      ASCII_c,\n         ASCII_e,      '\\0'};\n  static const int xmlLen = (int)sizeof(xmlNamespace) / sizeof(XML_Char) - 1;\n  static const XML_Char xmlnsNamespace[]\n      = {ASCII_h,     ASCII_t,      ASCII_t, ASCII_p, ASCII_COLON,  ASCII_SLASH,\n         ASCII_SLASH, ASCII_w,      ASCII_w, ASCII_w, ASCII_PERIOD, ASCII_w,\n         ASCII_3,     ASCII_PERIOD, ASCII_o, ASCII_r, ASCII_g,      ASCII_SLASH,\n         ASCII_2,     ASCII_0,      ASCII_0, ASCII_0, ASCII_SLASH,  ASCII_x,\n         ASCII_m,     ASCII_l,      ASCII_n, ASCII_s, ASCII_SLASH,  '\\0'};\n  static const int xmlnsLen\n      = (int)sizeof(xmlnsNamespace) / sizeof(XML_Char) - 1;\n\n  XML_Bool mustBeXML = XML_FALSE;\n  XML_Bool isXML = XML_TRUE;\n  XML_Bool isXMLNS = XML_TRUE;\n\n  BINDING *b;\n  int len;\n\n  /* empty URI is only valid for default namespace per XML NS 1.0 (not 1.1) */\n  if (*uri == XML_T('\\0') && prefix->name)\n    return XML_ERROR_UNDECLARING_PREFIX;\n\n  if (prefix->name && prefix->name[0] == XML_T(ASCII_x)\n      && prefix->name[1] == XML_T(ASCII_m)\n      && prefix->name[2] == XML_T(ASCII_l)) {\n    /* Not allowed to bind xmlns */\n    if (prefix->name[3] == XML_T(ASCII_n) && prefix->name[4] == XML_T(ASCII_s)\n        && prefix->name[5] == XML_T('\\0'))\n      return XML_ERROR_RESERVED_PREFIX_XMLNS;\n\n    if (prefix->name[3] == XML_T('\\0'))\n      mustBeXML = XML_TRUE;\n  }\n\n  for (len = 0; uri[len]; len++) {\n    if (isXML && (len > xmlLen || uri[len] != xmlNamespace[len]))\n      isXML = XML_FALSE;\n\n    if (! mustBeXML && isXMLNS\n        && (len > xmlnsLen || uri[len] != xmlnsNamespace[len]))\n      isXMLNS = XML_FALSE;\n  }\n  isXML = isXML && len == xmlLen;\n  isXMLNS = isXMLNS && len == xmlnsLen;\n\n  if (mustBeXML != isXML)\n    return mustBeXML ? XML_ERROR_RESERVED_PREFIX_XML\n                     : XML_ERROR_RESERVED_NAMESPACE_URI;\n\n  if (isXMLNS)\n    return XML_ERROR_RESERVED_NAMESPACE_URI;\n\n  if (parser->m_namespaceSeparator)\n    len++;\n  if (parser->m_freeBindingList) {\n    b = parser->m_freeBindingList;\n    if (len > b->uriAlloc) {\n      /* Detect and prevent integer overflow */\n      if (len > INT_MAX - EXPAND_SPARE) {\n        return XML_ERROR_NO_MEMORY;\n      }\n\n      /* Detect and prevent integer overflow.\n       * The preprocessor guard addresses the \"always false\" warning\n       * from -Wtype-limits on platforms where\n       * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */\n#if UINT_MAX >= SIZE_MAX\n      if ((unsigned)(len + EXPAND_SPARE) > (size_t)(-1) / sizeof(XML_Char)) {\n        return XML_ERROR_NO_MEMORY;\n      }\n#endif\n\n      XML_Char *temp = (XML_Char *)REALLOC(\n          parser, b->uri, sizeof(XML_Char) * (len + EXPAND_SPARE));\n      if (temp == NULL)\n        return XML_ERROR_NO_MEMORY;\n      b->uri = temp;\n      b->uriAlloc = len + EXPAND_SPARE;\n    }\n    parser->m_freeBindingList = b->nextTagBinding;\n  } else {\n    b = (BINDING *)MALLOC(parser, sizeof(BINDING));\n    if (! b)\n      return XML_ERROR_NO_MEMORY;\n\n    /* Detect and prevent integer overflow */\n    if (len > INT_MAX - EXPAND_SPARE) {\n      return XML_ERROR_NO_MEMORY;\n    }\n    /* Detect and prevent integer overflow.\n     * The preprocessor guard addresses the \"always false\" warning\n     * from -Wtype-limits on platforms where\n     * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */\n#if UINT_MAX >= SIZE_MAX\n    if ((unsigned)(len + EXPAND_SPARE) > (size_t)(-1) / sizeof(XML_Char)) {\n      return XML_ERROR_NO_MEMORY;\n    }\n#endif\n\n    b->uri\n        = (XML_Char *)MALLOC(parser, sizeof(XML_Char) * (len + EXPAND_SPARE));\n    if (! b->uri) {\n      FREE(parser, b);\n      return XML_ERROR_NO_MEMORY;\n    }\n    b->uriAlloc = len + EXPAND_SPARE;\n  }\n  b->uriLen = len;\n  memcpy(b->uri, uri, len * sizeof(XML_Char));\n  if (parser->m_namespaceSeparator)\n    b->uri[len - 1] = parser->m_namespaceSeparator;\n  b->prefix = prefix;\n  b->attId = attId;\n  b->prevPrefixBinding = prefix->binding;\n  /* NULL binding when default namespace undeclared */\n  if (*uri == XML_T('\\0') && prefix == &parser->m_dtd->defaultPrefix)\n    prefix->binding = NULL;\n  else\n    prefix->binding = b;\n  b->nextTagBinding = *bindingsPtr;\n  *bindingsPtr = b;\n  /* if attId == NULL then we are not starting a namespace scope */\n  if (attId && parser->m_startNamespaceDeclHandler)\n    parser->m_startNamespaceDeclHandler(parser->m_handlerArg, prefix->name,\n                                        prefix->binding ? uri : 0);\n  return XML_ERROR_NONE;\n}", "func_hash": 22295362737021887331084829836677682659, "file_name": "xmlparse.c", "file_hash": 64970761866861782031621044957132437337, "cwe": ["CWE-668"], "cve": "CVE-2022-25236", "cve_desc": "xmlparse.c in Expat (aka libexpat) before 2.4.5 allows attackers to insert namespace-separator characters into namespace URIs.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-25236", "file_path": "expat/lib/xmlparse.c"}
{"idx": 453109, "project": "libexpat", "commit_id": "a2fe525e660badd64b6c557c2b1ec26ddc07f6e4", "project_url": "https://github.com/libexpat/libexpat", "commit_url": "https://github.com/libexpat/libexpat/commit/a2fe525e660badd64b6c557c2b1ec26ddc07f6e4", "commit_message": "lib: Protect against malicious namespace declarations (CVE-2022-25236)", "target": 0, "func": "addBinding(XML_Parser parser, PREFIX *prefix, const ATTRIBUTE_ID *attId,\n           const XML_Char *uri, BINDING **bindingsPtr) {\n  static const XML_Char xmlNamespace[]\n      = {ASCII_h,      ASCII_t,     ASCII_t,     ASCII_p,      ASCII_COLON,\n         ASCII_SLASH,  ASCII_SLASH, ASCII_w,     ASCII_w,      ASCII_w,\n         ASCII_PERIOD, ASCII_w,     ASCII_3,     ASCII_PERIOD, ASCII_o,\n         ASCII_r,      ASCII_g,     ASCII_SLASH, ASCII_X,      ASCII_M,\n         ASCII_L,      ASCII_SLASH, ASCII_1,     ASCII_9,      ASCII_9,\n         ASCII_8,      ASCII_SLASH, ASCII_n,     ASCII_a,      ASCII_m,\n         ASCII_e,      ASCII_s,     ASCII_p,     ASCII_a,      ASCII_c,\n         ASCII_e,      '\\0'};\n  static const int xmlLen = (int)sizeof(xmlNamespace) / sizeof(XML_Char) - 1;\n  static const XML_Char xmlnsNamespace[]\n      = {ASCII_h,     ASCII_t,      ASCII_t, ASCII_p, ASCII_COLON,  ASCII_SLASH,\n         ASCII_SLASH, ASCII_w,      ASCII_w, ASCII_w, ASCII_PERIOD, ASCII_w,\n         ASCII_3,     ASCII_PERIOD, ASCII_o, ASCII_r, ASCII_g,      ASCII_SLASH,\n         ASCII_2,     ASCII_0,      ASCII_0, ASCII_0, ASCII_SLASH,  ASCII_x,\n         ASCII_m,     ASCII_l,      ASCII_n, ASCII_s, ASCII_SLASH,  '\\0'};\n  static const int xmlnsLen\n      = (int)sizeof(xmlnsNamespace) / sizeof(XML_Char) - 1;\n\n  XML_Bool mustBeXML = XML_FALSE;\n  XML_Bool isXML = XML_TRUE;\n  XML_Bool isXMLNS = XML_TRUE;\n\n  BINDING *b;\n  int len;\n\n  /* empty URI is only valid for default namespace per XML NS 1.0 (not 1.1) */\n  if (*uri == XML_T('\\0') && prefix->name)\n    return XML_ERROR_UNDECLARING_PREFIX;\n\n  if (prefix->name && prefix->name[0] == XML_T(ASCII_x)\n      && prefix->name[1] == XML_T(ASCII_m)\n      && prefix->name[2] == XML_T(ASCII_l)) {\n    /* Not allowed to bind xmlns */\n    if (prefix->name[3] == XML_T(ASCII_n) && prefix->name[4] == XML_T(ASCII_s)\n        && prefix->name[5] == XML_T('\\0'))\n      return XML_ERROR_RESERVED_PREFIX_XMLNS;\n\n    if (prefix->name[3] == XML_T('\\0'))\n      mustBeXML = XML_TRUE;\n  }\n\n  for (len = 0; uri[len]; len++) {\n    if (isXML && (len > xmlLen || uri[len] != xmlNamespace[len]))\n      isXML = XML_FALSE;\n\n    if (! mustBeXML && isXMLNS\n        && (len > xmlnsLen || uri[len] != xmlnsNamespace[len]))\n      isXMLNS = XML_FALSE;\n\n    // NOTE: While Expat does not validate namespace URIs against RFC 3986,\n    //       we have to at least make sure that the XML processor on top of\n    //       Expat (that is splitting tag names by namespace separator into\n    //       2- or 3-tuples (uri-local or uri-local-prefix)) cannot be confused\n    //       by an attacker putting additional namespace separator characters\n    //       into namespace declarations.  That would be ambiguous and not to\n    //       be expected.\n    if (parser->m_ns && (uri[len] == parser->m_namespaceSeparator)) {\n      return XML_ERROR_SYNTAX;\n    }\n  }\n  isXML = isXML && len == xmlLen;\n  isXMLNS = isXMLNS && len == xmlnsLen;\n\n  if (mustBeXML != isXML)\n    return mustBeXML ? XML_ERROR_RESERVED_PREFIX_XML\n                     : XML_ERROR_RESERVED_NAMESPACE_URI;\n\n  if (isXMLNS)\n    return XML_ERROR_RESERVED_NAMESPACE_URI;\n\n  if (parser->m_namespaceSeparator)\n    len++;\n  if (parser->m_freeBindingList) {\n    b = parser->m_freeBindingList;\n    if (len > b->uriAlloc) {\n      /* Detect and prevent integer overflow */\n      if (len > INT_MAX - EXPAND_SPARE) {\n        return XML_ERROR_NO_MEMORY;\n      }\n\n      /* Detect and prevent integer overflow.\n       * The preprocessor guard addresses the \"always false\" warning\n       * from -Wtype-limits on platforms where\n       * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */\n#if UINT_MAX >= SIZE_MAX\n      if ((unsigned)(len + EXPAND_SPARE) > (size_t)(-1) / sizeof(XML_Char)) {\n        return XML_ERROR_NO_MEMORY;\n      }\n#endif\n\n      XML_Char *temp = (XML_Char *)REALLOC(\n          parser, b->uri, sizeof(XML_Char) * (len + EXPAND_SPARE));\n      if (temp == NULL)\n        return XML_ERROR_NO_MEMORY;\n      b->uri = temp;\n      b->uriAlloc = len + EXPAND_SPARE;\n    }\n    parser->m_freeBindingList = b->nextTagBinding;\n  } else {\n    b = (BINDING *)MALLOC(parser, sizeof(BINDING));\n    if (! b)\n      return XML_ERROR_NO_MEMORY;\n\n    /* Detect and prevent integer overflow */\n    if (len > INT_MAX - EXPAND_SPARE) {\n      return XML_ERROR_NO_MEMORY;\n    }\n    /* Detect and prevent integer overflow.\n     * The preprocessor guard addresses the \"always false\" warning\n     * from -Wtype-limits on platforms where\n     * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */\n#if UINT_MAX >= SIZE_MAX\n    if ((unsigned)(len + EXPAND_SPARE) > (size_t)(-1) / sizeof(XML_Char)) {\n      return XML_ERROR_NO_MEMORY;\n    }\n#endif\n\n    b->uri\n        = (XML_Char *)MALLOC(parser, sizeof(XML_Char) * (len + EXPAND_SPARE));\n    if (! b->uri) {\n      FREE(parser, b);\n      return XML_ERROR_NO_MEMORY;\n    }\n    b->uriAlloc = len + EXPAND_SPARE;\n  }\n  b->uriLen = len;\n  memcpy(b->uri, uri, len * sizeof(XML_Char));\n  if (parser->m_namespaceSeparator)\n    b->uri[len - 1] = parser->m_namespaceSeparator;\n  b->prefix = prefix;\n  b->attId = attId;\n  b->prevPrefixBinding = prefix->binding;\n  /* NULL binding when default namespace undeclared */\n  if (*uri == XML_T('\\0') && prefix == &parser->m_dtd->defaultPrefix)\n    prefix->binding = NULL;\n  else\n    prefix->binding = b;\n  b->nextTagBinding = *bindingsPtr;\n  *bindingsPtr = b;\n  /* if attId == NULL then we are not starting a namespace scope */\n  if (attId && parser->m_startNamespaceDeclHandler)\n    parser->m_startNamespaceDeclHandler(parser->m_handlerArg, prefix->name,\n                                        prefix->binding ? uri : 0);\n  return XML_ERROR_NONE;\n}", "func_hash": 180909609780994811991308792390157424153, "file_name": "xmlparse.c", "file_hash": 39872007825496999526918942248087494728, "cwe": ["CWE-668"], "cve": "CVE-2022-25236", "cve_desc": "xmlparse.c in Expat (aka libexpat) before 2.4.5 allows attackers to insert namespace-separator characters into namespace URIs.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-25236", "file_path": "expat/lib/xmlparse.c"}
{"idx": 211915, "project": "jasper", "commit_id": "839b1bcf0450ff036c28e8db40a7abf886e02891", "project_url": "https://github.com/mdadams/jasper", "commit_url": "https://github.com/jasper-software/jasper/commit/839b1bcf0450ff036c28e8db40a7abf886e02891", "commit_message": "jp2_dec: fix `numchans` mixup\n\nWhen iterating over `dec->cdef->data.cdef.ents`, we need to use its\n`numchans` variable, not the one in `jp2_dec_t`.\n\nFixes CVE-2018-19543\nFixes CVE-2017-9782\n\nCloses https://github.com/jasper-maint/jasper/issues/13\nCloses https://github.com/jasper-maint/jasper/issues/18\nCloses https://github.com/mdadams/jasper/issues/140\nCloses https://github.com/mdadams/jasper/issues/182", "target": 1, "func": "jas_image_t *jp2_decode(jas_stream_t *in, const char *optstr)\n{\n\tjp2_box_t *box;\n\tint found;\n\tjas_image_t *image;\n\tjp2_dec_t *dec;\n\tbool samedtype;\n\tint dtype;\n\tunsigned int i;\n\tjp2_cmap_t *cmapd;\n\tjp2_pclr_t *pclrd;\n\tjp2_cdef_t *cdefd;\n\tunsigned int channo;\n\tint newcmptno;\n\tint_fast32_t *lutents;\n#if 0\n\tjp2_cdefchan_t *cdefent;\n\tint cmptno;\n#endif\n\tjp2_cmapent_t *cmapent;\n\tjas_icchdr_t icchdr;\n\tjas_iccprof_t *iccprof;\n\n\tdec = 0;\n\tbox = 0;\n\timage = 0;\n\n\tJAS_DBGLOG(100, (\"jp2_decode(%p, \\\"%s\\\")\\n\", in, optstr));\n\n\tif (!(dec = jp2_dec_create())) {\n\t\tgoto error;\n\t}\n\n\t/* Get the first box.  This should be a JP box. */\n\tif (!(box = jp2_box_get(in))) {\n\t\tjas_eprintf(\"error: cannot get box\\n\");\n\t\tgoto error;\n\t}\n\tif (box->type != JP2_BOX_JP) {\n\t\tjas_eprintf(\"error: expecting signature box\\n\");\n\t\tgoto error;\n\t}\n\tif (box->data.jp.magic != JP2_JP_MAGIC) {\n\t\tjas_eprintf(\"incorrect magic number\\n\");\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/* Get the second box.  This should be a FTYP box. */\n\tif (!(box = jp2_box_get(in))) {\n\t\tgoto error;\n\t}\n\tif (box->type != JP2_BOX_FTYP) {\n\t\tjas_eprintf(\"expecting file type box\\n\");\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/* Get more boxes... */\n\tfound = 0;\n\twhile ((box = jp2_box_get(in))) {\n\t\tif (jas_getdbglevel() >= 1) {\n\t\t\tjas_eprintf(\"got box type %s\\n\", box->info->name);\n\t\t}\n\t\tswitch (box->type) {\n\t\tcase JP2_BOX_JP2C:\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\tcase JP2_BOX_IHDR:\n\t\t\tif (!dec->ihdr) {\n\t\t\t\tdec->ihdr = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_BPCC:\n\t\t\tif (!dec->bpcc) {\n\t\t\t\tdec->bpcc = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_CDEF:\n\t\t\tif (!dec->cdef) {\n\t\t\t\tdec->cdef = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_PCLR:\n\t\t\tif (!dec->pclr) {\n\t\t\t\tdec->pclr = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_CMAP:\n\t\t\tif (!dec->cmap) {\n\t\t\t\tdec->cmap = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_COLR:\n\t\t\tif (!dec->colr) {\n\t\t\t\tdec->colr = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (box) {\n\t\t\tjp2_box_destroy(box);\n\t\t\tbox = 0;\n\t\t}\n\t\tif (found) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tjas_eprintf(\"error: no code stream found\\n\");\n\t\tgoto error;\n\t}\n\n\tif (!(dec->image = jpc_decode(in, optstr))) {\n\t\tjas_eprintf(\"error: cannot decode code stream\\n\");\n\t\tgoto error;\n\t}\n\n\t/* An IHDR box must be present. */\n\tif (!dec->ihdr) {\n\t\tjas_eprintf(\"error: missing IHDR box\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Does the number of components indicated in the IHDR box match\n\t  the value specified in the code stream? */\n\tif (dec->ihdr->data.ihdr.numcmpts != JAS_CAST(jas_uint,\n\t  jas_image_numcmpts(dec->image))) {\n\t\tjas_eprintf(\"warning: number of components mismatch\\n\");\n\t}\n\n\t/* At least one component must be present. */\n\tif (!jas_image_numcmpts(dec->image)) {\n\t\tjas_eprintf(\"error: no components\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Determine if all components have the same data type. */\n\tsamedtype = true;\n\tdtype = jas_image_cmptdtype(dec->image, 0);\n\tfor (i = 1; i < JAS_CAST(jas_uint, jas_image_numcmpts(dec->image)); ++i) {\n\t\tif (jas_image_cmptdtype(dec->image, i) != dtype) {\n\t\t\tsamedtype = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Is the component data type indicated in the IHDR box consistent\n\t  with the data in the code stream? */\n\tif ((samedtype && dec->ihdr->data.ihdr.bpc != JP2_DTYPETOBPC(dtype)) ||\n\t  (!samedtype && dec->ihdr->data.ihdr.bpc != JP2_IHDR_BPCNULL)) {\n\t\tjas_eprintf(\"warning: component data type mismatch\\n\");\n\t}\n\n\t/* Is the compression type supported? */\n\tif (dec->ihdr->data.ihdr.comptype != JP2_IHDR_COMPTYPE) {\n\t\tjas_eprintf(\"error: unsupported compression type\\n\");\n\t\tgoto error;\n\t}\n\n\tif (dec->bpcc) {\n\t\t/* Is the number of components indicated in the BPCC box\n\t\t  consistent with the code stream data? */\n\t\tif (dec->bpcc->data.bpcc.numcmpts != JAS_CAST(jas_uint, jas_image_numcmpts(\n\t\t  dec->image))) {\n\t\t\tjas_eprintf(\"warning: number of components mismatch\\n\");\n\t\t}\n\t\t/* Is the component data type information indicated in the BPCC\n\t\t  box consistent with the code stream data? */\n\t\tif (!samedtype) {\n\t\t\tfor (i = 0; i < JAS_CAST(jas_uint, jas_image_numcmpts(dec->image));\n\t\t\t  ++i) {\n\t\t\t\tif (jas_image_cmptdtype(dec->image, i) !=\n\t\t\t\t  JP2_BPCTODTYPE(dec->bpcc->data.bpcc.bpcs[i])) {\n\t\t\t\t\tjas_eprintf(\"warning: component data type mismatch\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tjas_eprintf(\"warning: superfluous BPCC box\\n\");\n\t\t}\n\t}\n\n\t/* A COLR box must be present. */\n\tif (!dec->colr) {\n\t\tjas_eprintf(\"error: no COLR box\\n\");\n\t\tgoto error;\n\t}\n\n\tswitch (dec->colr->data.colr.method) {\n\tcase JP2_COLR_ENUM:\n\t\tjas_image_setclrspc(dec->image, jp2_getcs(&dec->colr->data.colr));\n\t\tbreak;\n\tcase JP2_COLR_ICC:\n\t\ticcprof = jas_iccprof_createfrombuf(dec->colr->data.colr.iccp,\n\t\t  dec->colr->data.colr.iccplen);\n\t\tif (!iccprof) {\n\t\t\tjas_eprintf(\"error: failed to parse ICC profile\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tjas_iccprof_gethdr(iccprof, &icchdr);\n\t\tjas_eprintf(\"ICC Profile CS %08x\\n\", icchdr.colorspc);\n\t\tjas_image_setclrspc(dec->image, fromiccpcs(icchdr.colorspc));\n\t\tdec->image->cmprof_ = jas_cmprof_createfromiccprof(iccprof);\n\t\tassert(dec->image->cmprof_);\n\t\tjas_iccprof_destroy(iccprof);\n\t\tbreak;\n\t}\n\n\t/* If a CMAP box is present, a PCLR box must also be present. */\n\tif (dec->cmap && !dec->pclr) {\n\t\tjas_eprintf(\"warning: missing PCLR box or superfluous CMAP box\\n\");\n\t\tjp2_box_destroy(dec->cmap);\n\t\tdec->cmap = 0;\n\t}\n\n\t/* If a CMAP box is not present, a PCLR box must not be present. */\n\tif (!dec->cmap && dec->pclr) {\n\t\tjas_eprintf(\"warning: missing CMAP box or superfluous PCLR box\\n\");\n\t\tjp2_box_destroy(dec->pclr);\n\t\tdec->pclr = 0;\n\t}\n\n\t/* Determine the number of channels (which is essentially the number\n\t  of components after any palette mappings have been applied). */\n\tdec->numchans = dec->cmap ? dec->cmap->data.cmap.numchans :\n\t  JAS_CAST(jas_uint, jas_image_numcmpts(dec->image));\n\n\t/* Perform a basic sanity check on the CMAP box if present. */\n\tif (dec->cmap) {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\t/* Is the component number reasonable? */\n\t\t\tif (dec->cmap->data.cmap.ents[i].cmptno >= JAS_CAST(jas_uint,\n\t\t\t  jas_image_numcmpts(dec->image))) {\n\t\t\t\tjas_eprintf(\"error: invalid component number in CMAP box\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\t/* Is the LUT index reasonable? */\n\t\t\tif (dec->cmap->data.cmap.ents[i].pcol >=\n\t\t\t  dec->pclr->data.pclr.numchans) {\n\t\t\t\tjas_eprintf(\"error: invalid CMAP LUT index\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Allocate space for the channel-number to component-number LUT. */\n\tif (!(dec->chantocmptlut = jas_alloc2(dec->numchans,\n\t  sizeof(uint_fast16_t)))) {\n\t\tjas_eprintf(\"error: no memory\\n\");\n\t\tgoto error;\n\t}\n\n\tif (!dec->cmap) {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\tdec->chantocmptlut[i] = i;\n\t\t}\n\t} else {\n\t\tcmapd = &dec->cmap->data.cmap;\n\t\tpclrd = &dec->pclr->data.pclr;\n\t\tcdefd = &dec->cdef->data.cdef;\n\t\tfor (channo = 0; channo < cmapd->numchans; ++channo) {\n\t\t\tcmapent = &cmapd->ents[channo];\n\t\t\tif (cmapent->map == JP2_CMAP_DIRECT) {\n\t\t\t\tdec->chantocmptlut[channo] = channo;\n\t\t\t} else if (cmapent->map == JP2_CMAP_PALETTE) {\n\t\t\t\tlutents = jas_alloc2(pclrd->numlutents, sizeof(int_fast32_t));\n\t\t\t\tfor (i = 0; i < pclrd->numlutents; ++i) {\n\t\t\t\t\tlutents[i] = pclrd->lutdata[cmapent->pcol + i * pclrd->numchans];\n\t\t\t\t}\n\t\t\t\tnewcmptno = jas_image_numcmpts(dec->image);\n\t\t\t\tjas_image_depalettize(dec->image, cmapent->cmptno,\n\t\t\t\t  pclrd->numlutents, lutents,\n\t\t\t\t  JP2_BPCTODTYPE(pclrd->bpc[cmapent->pcol]), newcmptno);\n\t\t\t\tdec->chantocmptlut[channo] = newcmptno;\n\t\t\t\tjas_free(lutents);\n#if 0\n\t\t\t\tif (dec->cdef) {\n\t\t\t\t\tcdefent = jp2_cdef_lookup(cdefd, channo);\n\t\t\t\t\tif (!cdefent) {\n\t\t\t\t\t\tabort();\n\t\t\t\t\t}\n\t\t\t\tjas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), cdefent->type, cdefent->assoc));\n\t\t\t\t} else {\n\t\t\t\tjas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), 0, channo + 1));\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Mark all components as being of unknown type. */\n\n\tfor (i = 0; i < JAS_CAST(jas_uint, jas_image_numcmpts(dec->image)); ++i) {\n\t\tjas_image_setcmpttype(dec->image, i, JAS_IMAGE_CT_UNKNOWN);\n\t}\n\n\t/* Determine the type of each component. */\n\tif (dec->cdef) {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\t/* Is the channel number reasonable? */\n\t\t\tif (dec->cdef->data.cdef.ents[i].channo >= dec->numchans) {\n\t\t\t\tjas_eprintf(\"error: invalid channel number in CDEF box\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tjas_image_setcmpttype(dec->image,\n\t\t\t  dec->chantocmptlut[dec->cdef->data.cdef.ents[i].channo],\n\t\t\t  jp2_getct(jas_image_clrspc(dec->image),\n\t\t\t  dec->cdef->data.cdef.ents[i].type,\n\t\t\t  dec->cdef->data.cdef.ents[i].assoc));\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\tjas_image_setcmpttype(dec->image, dec->chantocmptlut[i],\n\t\t\t  jp2_getct(jas_image_clrspc(dec->image), 0, i + 1));\n\t\t}\n\t}\n\n\t/* Delete any components that are not of interest. */\n\tfor (i = jas_image_numcmpts(dec->image); i > 0; --i) {\n\t\tif (jas_image_cmpttype(dec->image, i - 1) == JAS_IMAGE_CT_UNKNOWN) {\n\t\t\tjas_image_delcmpt(dec->image, i - 1);\n\t\t}\n\t}\n\n\t/* Ensure that some components survived. */\n\tif (!jas_image_numcmpts(dec->image)) {\n\t\tjas_eprintf(\"error: no components\\n\");\n\t\tgoto error;\n\t}\n#if 0\njas_eprintf(\"no of components is %d\\n\", jas_image_numcmpts(dec->image));\n#endif\n\n\t/* Prevent the image from being destroyed later. */\n\timage = dec->image;\n\tdec->image = 0;\n\n\tjp2_dec_destroy(dec);\n\n\treturn image;\n\nerror:\n\tif (box) {\n\t\tjp2_box_destroy(box);\n\t}\n\tif (dec) {\n\t\tjp2_dec_destroy(dec);\n\t}\n\treturn 0;\n}", "func_hash": 59868521314205020877993173661951509362, "file_name": "jp2_dec.c", "file_hash": 93955147082917127962057718477708272955, "cwe": ["CWE-125"], "cve": "CVE-2017-9782", "cve_desc": "JasPer 2.0.12 allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted image, related to the jp2_decode function in libjasper/jp2/jp2_dec.c.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-9782", "file_path": "src/libjasper/jp2/jp2_dec.c"}
{"idx": 453265, "project": "jasper", "commit_id": "839b1bcf0450ff036c28e8db40a7abf886e02891", "project_url": "https://github.com/mdadams/jasper", "commit_url": "https://github.com/jasper-software/jasper/commit/839b1bcf0450ff036c28e8db40a7abf886e02891", "commit_message": "jp2_dec: fix `numchans` mixup\n\nWhen iterating over `dec->cdef->data.cdef.ents`, we need to use its\n`numchans` variable, not the one in `jp2_dec_t`.\n\nFixes CVE-2018-19543\nFixes CVE-2017-9782\n\nCloses https://github.com/jasper-maint/jasper/issues/13\nCloses https://github.com/jasper-maint/jasper/issues/18\nCloses https://github.com/mdadams/jasper/issues/140\nCloses https://github.com/mdadams/jasper/issues/182", "target": 0, "func": "jas_image_t *jp2_decode(jas_stream_t *in, const char *optstr)\n{\n\tjp2_box_t *box;\n\tint found;\n\tjas_image_t *image;\n\tjp2_dec_t *dec;\n\tbool samedtype;\n\tint dtype;\n\tunsigned int i;\n\tjp2_cmap_t *cmapd;\n\tjp2_pclr_t *pclrd;\n\tjp2_cdef_t *cdefd;\n\tunsigned int channo;\n\tint newcmptno;\n\tint_fast32_t *lutents;\n#if 0\n\tjp2_cdefchan_t *cdefent;\n\tint cmptno;\n#endif\n\tjp2_cmapent_t *cmapent;\n\tjas_icchdr_t icchdr;\n\tjas_iccprof_t *iccprof;\n\n\tdec = 0;\n\tbox = 0;\n\timage = 0;\n\n\tJAS_DBGLOG(100, (\"jp2_decode(%p, \\\"%s\\\")\\n\", in, optstr));\n\n\tif (!(dec = jp2_dec_create())) {\n\t\tgoto error;\n\t}\n\n\t/* Get the first box.  This should be a JP box. */\n\tif (!(box = jp2_box_get(in))) {\n\t\tjas_eprintf(\"error: cannot get box\\n\");\n\t\tgoto error;\n\t}\n\tif (box->type != JP2_BOX_JP) {\n\t\tjas_eprintf(\"error: expecting signature box\\n\");\n\t\tgoto error;\n\t}\n\tif (box->data.jp.magic != JP2_JP_MAGIC) {\n\t\tjas_eprintf(\"incorrect magic number\\n\");\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/* Get the second box.  This should be a FTYP box. */\n\tif (!(box = jp2_box_get(in))) {\n\t\tgoto error;\n\t}\n\tif (box->type != JP2_BOX_FTYP) {\n\t\tjas_eprintf(\"expecting file type box\\n\");\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/* Get more boxes... */\n\tfound = 0;\n\twhile ((box = jp2_box_get(in))) {\n\t\tif (jas_getdbglevel() >= 1) {\n\t\t\tjas_eprintf(\"got box type %s\\n\", box->info->name);\n\t\t}\n\t\tswitch (box->type) {\n\t\tcase JP2_BOX_JP2C:\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\tcase JP2_BOX_IHDR:\n\t\t\tif (!dec->ihdr) {\n\t\t\t\tdec->ihdr = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_BPCC:\n\t\t\tif (!dec->bpcc) {\n\t\t\t\tdec->bpcc = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_CDEF:\n\t\t\tif (!dec->cdef) {\n\t\t\t\tdec->cdef = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_PCLR:\n\t\t\tif (!dec->pclr) {\n\t\t\t\tdec->pclr = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_CMAP:\n\t\t\tif (!dec->cmap) {\n\t\t\t\tdec->cmap = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_COLR:\n\t\t\tif (!dec->colr) {\n\t\t\t\tdec->colr = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (box) {\n\t\t\tjp2_box_destroy(box);\n\t\t\tbox = 0;\n\t\t}\n\t\tif (found) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tjas_eprintf(\"error: no code stream found\\n\");\n\t\tgoto error;\n\t}\n\n\tif (!(dec->image = jpc_decode(in, optstr))) {\n\t\tjas_eprintf(\"error: cannot decode code stream\\n\");\n\t\tgoto error;\n\t}\n\n\t/* An IHDR box must be present. */\n\tif (!dec->ihdr) {\n\t\tjas_eprintf(\"error: missing IHDR box\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Does the number of components indicated in the IHDR box match\n\t  the value specified in the code stream? */\n\tif (dec->ihdr->data.ihdr.numcmpts != JAS_CAST(jas_uint,\n\t  jas_image_numcmpts(dec->image))) {\n\t\tjas_eprintf(\"warning: number of components mismatch\\n\");\n\t}\n\n\t/* At least one component must be present. */\n\tif (!jas_image_numcmpts(dec->image)) {\n\t\tjas_eprintf(\"error: no components\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Determine if all components have the same data type. */\n\tsamedtype = true;\n\tdtype = jas_image_cmptdtype(dec->image, 0);\n\tfor (i = 1; i < JAS_CAST(jas_uint, jas_image_numcmpts(dec->image)); ++i) {\n\t\tif (jas_image_cmptdtype(dec->image, i) != dtype) {\n\t\t\tsamedtype = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Is the component data type indicated in the IHDR box consistent\n\t  with the data in the code stream? */\n\tif ((samedtype && dec->ihdr->data.ihdr.bpc != JP2_DTYPETOBPC(dtype)) ||\n\t  (!samedtype && dec->ihdr->data.ihdr.bpc != JP2_IHDR_BPCNULL)) {\n\t\tjas_eprintf(\"warning: component data type mismatch\\n\");\n\t}\n\n\t/* Is the compression type supported? */\n\tif (dec->ihdr->data.ihdr.comptype != JP2_IHDR_COMPTYPE) {\n\t\tjas_eprintf(\"error: unsupported compression type\\n\");\n\t\tgoto error;\n\t}\n\n\tif (dec->bpcc) {\n\t\t/* Is the number of components indicated in the BPCC box\n\t\t  consistent with the code stream data? */\n\t\tif (dec->bpcc->data.bpcc.numcmpts != JAS_CAST(jas_uint, jas_image_numcmpts(\n\t\t  dec->image))) {\n\t\t\tjas_eprintf(\"warning: number of components mismatch\\n\");\n\t\t}\n\t\t/* Is the component data type information indicated in the BPCC\n\t\t  box consistent with the code stream data? */\n\t\tif (!samedtype) {\n\t\t\tfor (i = 0; i < JAS_CAST(jas_uint, jas_image_numcmpts(dec->image));\n\t\t\t  ++i) {\n\t\t\t\tif (jas_image_cmptdtype(dec->image, i) !=\n\t\t\t\t  JP2_BPCTODTYPE(dec->bpcc->data.bpcc.bpcs[i])) {\n\t\t\t\t\tjas_eprintf(\"warning: component data type mismatch\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tjas_eprintf(\"warning: superfluous BPCC box\\n\");\n\t\t}\n\t}\n\n\t/* A COLR box must be present. */\n\tif (!dec->colr) {\n\t\tjas_eprintf(\"error: no COLR box\\n\");\n\t\tgoto error;\n\t}\n\n\tswitch (dec->colr->data.colr.method) {\n\tcase JP2_COLR_ENUM:\n\t\tjas_image_setclrspc(dec->image, jp2_getcs(&dec->colr->data.colr));\n\t\tbreak;\n\tcase JP2_COLR_ICC:\n\t\ticcprof = jas_iccprof_createfrombuf(dec->colr->data.colr.iccp,\n\t\t  dec->colr->data.colr.iccplen);\n\t\tif (!iccprof) {\n\t\t\tjas_eprintf(\"error: failed to parse ICC profile\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tjas_iccprof_gethdr(iccprof, &icchdr);\n\t\tjas_eprintf(\"ICC Profile CS %08x\\n\", icchdr.colorspc);\n\t\tjas_image_setclrspc(dec->image, fromiccpcs(icchdr.colorspc));\n\t\tdec->image->cmprof_ = jas_cmprof_createfromiccprof(iccprof);\n\t\tassert(dec->image->cmprof_);\n\t\tjas_iccprof_destroy(iccprof);\n\t\tbreak;\n\t}\n\n\t/* If a CMAP box is present, a PCLR box must also be present. */\n\tif (dec->cmap && !dec->pclr) {\n\t\tjas_eprintf(\"warning: missing PCLR box or superfluous CMAP box\\n\");\n\t\tjp2_box_destroy(dec->cmap);\n\t\tdec->cmap = 0;\n\t}\n\n\t/* If a CMAP box is not present, a PCLR box must not be present. */\n\tif (!dec->cmap && dec->pclr) {\n\t\tjas_eprintf(\"warning: missing CMAP box or superfluous PCLR box\\n\");\n\t\tjp2_box_destroy(dec->pclr);\n\t\tdec->pclr = 0;\n\t}\n\n\t/* Determine the number of channels (which is essentially the number\n\t  of components after any palette mappings have been applied). */\n\tdec->numchans = dec->cmap ? dec->cmap->data.cmap.numchans :\n\t  JAS_CAST(jas_uint, jas_image_numcmpts(dec->image));\n\n\t/* Perform a basic sanity check on the CMAP box if present. */\n\tif (dec->cmap) {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\t/* Is the component number reasonable? */\n\t\t\tif (dec->cmap->data.cmap.ents[i].cmptno >= JAS_CAST(jas_uint,\n\t\t\t  jas_image_numcmpts(dec->image))) {\n\t\t\t\tjas_eprintf(\"error: invalid component number in CMAP box\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\t/* Is the LUT index reasonable? */\n\t\t\tif (dec->cmap->data.cmap.ents[i].pcol >=\n\t\t\t  dec->pclr->data.pclr.numchans) {\n\t\t\t\tjas_eprintf(\"error: invalid CMAP LUT index\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Allocate space for the channel-number to component-number LUT. */\n\tif (!(dec->chantocmptlut = jas_alloc2(dec->numchans,\n\t  sizeof(uint_fast16_t)))) {\n\t\tjas_eprintf(\"error: no memory\\n\");\n\t\tgoto error;\n\t}\n\n\tif (!dec->cmap) {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\tdec->chantocmptlut[i] = i;\n\t\t}\n\t} else {\n\t\tcmapd = &dec->cmap->data.cmap;\n\t\tpclrd = &dec->pclr->data.pclr;\n\t\tcdefd = &dec->cdef->data.cdef;\n\t\tfor (channo = 0; channo < cmapd->numchans; ++channo) {\n\t\t\tcmapent = &cmapd->ents[channo];\n\t\t\tif (cmapent->map == JP2_CMAP_DIRECT) {\n\t\t\t\tdec->chantocmptlut[channo] = channo;\n\t\t\t} else if (cmapent->map == JP2_CMAP_PALETTE) {\n\t\t\t\tlutents = jas_alloc2(pclrd->numlutents, sizeof(int_fast32_t));\n\t\t\t\tfor (i = 0; i < pclrd->numlutents; ++i) {\n\t\t\t\t\tlutents[i] = pclrd->lutdata[cmapent->pcol + i * pclrd->numchans];\n\t\t\t\t}\n\t\t\t\tnewcmptno = jas_image_numcmpts(dec->image);\n\t\t\t\tjas_image_depalettize(dec->image, cmapent->cmptno,\n\t\t\t\t  pclrd->numlutents, lutents,\n\t\t\t\t  JP2_BPCTODTYPE(pclrd->bpc[cmapent->pcol]), newcmptno);\n\t\t\t\tdec->chantocmptlut[channo] = newcmptno;\n\t\t\t\tjas_free(lutents);\n#if 0\n\t\t\t\tif (dec->cdef) {\n\t\t\t\t\tcdefent = jp2_cdef_lookup(cdefd, channo);\n\t\t\t\t\tif (!cdefent) {\n\t\t\t\t\t\tabort();\n\t\t\t\t\t}\n\t\t\t\tjas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), cdefent->type, cdefent->assoc));\n\t\t\t\t} else {\n\t\t\t\tjas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), 0, channo + 1));\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Mark all components as being of unknown type. */\n\n\tfor (i = 0; i < JAS_CAST(jas_uint, jas_image_numcmpts(dec->image)); ++i) {\n\t\tjas_image_setcmpttype(dec->image, i, JAS_IMAGE_CT_UNKNOWN);\n\t}\n\n\t/* Determine the type of each component. */\n\tif (dec->cdef) {\n\t\tfor (i = 0; i < dec->cdef->data.cdef.numchans; ++i) {\n\t\t\t/* Is the channel number reasonable? */\n\t\t\tif (dec->cdef->data.cdef.ents[i].channo >= dec->numchans) {\n\t\t\t\tjas_eprintf(\"error: invalid channel number in CDEF box\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tjas_image_setcmpttype(dec->image,\n\t\t\t  dec->chantocmptlut[dec->cdef->data.cdef.ents[i].channo],\n\t\t\t  jp2_getct(jas_image_clrspc(dec->image),\n\t\t\t  dec->cdef->data.cdef.ents[i].type,\n\t\t\t  dec->cdef->data.cdef.ents[i].assoc));\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\tjas_image_setcmpttype(dec->image, dec->chantocmptlut[i],\n\t\t\t  jp2_getct(jas_image_clrspc(dec->image), 0, i + 1));\n\t\t}\n\t}\n\n\t/* Delete any components that are not of interest. */\n\tfor (i = jas_image_numcmpts(dec->image); i > 0; --i) {\n\t\tif (jas_image_cmpttype(dec->image, i - 1) == JAS_IMAGE_CT_UNKNOWN) {\n\t\t\tjas_image_delcmpt(dec->image, i - 1);\n\t\t}\n\t}\n\n\t/* Ensure that some components survived. */\n\tif (!jas_image_numcmpts(dec->image)) {\n\t\tjas_eprintf(\"error: no components\\n\");\n\t\tgoto error;\n\t}\n#if 0\njas_eprintf(\"no of components is %d\\n\", jas_image_numcmpts(dec->image));\n#endif\n\n\t/* Prevent the image from being destroyed later. */\n\timage = dec->image;\n\tdec->image = 0;\n\n\tjp2_dec_destroy(dec);\n\n\treturn image;\n\nerror:\n\tif (box) {\n\t\tjp2_box_destroy(box);\n\t}\n\tif (dec) {\n\t\tjp2_dec_destroy(dec);\n\t}\n\treturn 0;\n}", "func_hash": 125813963803436339336182748178269813866, "file_name": "jp2_dec.c", "file_hash": 163023647028726236156493371179237582578, "cwe": ["CWE-125"], "cve": "CVE-2017-9782", "cve_desc": "JasPer 2.0.12 allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted image, related to the jp2_decode function in libjasper/jp2/jp2_dec.c.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-9782", "file_path": "src/libjasper/jp2/jp2_dec.c"}
{"idx": 212083, "project": "linux", "commit_id": "690b2549b19563ec5ad53e5c82f6a944d910086e", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/690b2549b19563ec5ad53e5c82f6a944d910086e", "commit_message": "i2c: ismt: prevent memory corruption in ismt_access()\n\nThe \"data->block[0]\" variable comes from the user and is a number\nbetween 0-255.  It needs to be capped to prevent writing beyond the end\nof dma_buffer[].\n\nFixes: 5e9a97b1f449 (\"i2c: ismt: Adding support for I2C_SMBUS_BLOCK_PROC_CALL\")\nReported-and-tested-by: Zheyu Ma <zheyuma97@gmail.com>\nSigned-off-by: Dan Carpenter <dan.carpenter@oracle.com>\nReviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "target": 1, "func": "static int ismt_access(struct i2c_adapter *adap, u16 addr,\n\t\t       unsigned short flags, char read_write, u8 command,\n\t\t       int size, union i2c_smbus_data *data)\n{\n\tint ret;\n\tunsigned long time_left;\n\tdma_addr_t dma_addr = 0; /* address of the data buffer */\n\tu8 dma_size = 0;\n\tenum dma_data_direction dma_direction = 0;\n\tstruct ismt_desc *desc;\n\tstruct ismt_priv *priv = i2c_get_adapdata(adap);\n\tstruct device *dev = &priv->pci_dev->dev;\n\tu8 *dma_buffer = PTR_ALIGN(&priv->buffer[0], 16);\n\n\tdesc = &priv->hw[priv->head];\n\n\t/* Initialize the DMA buffer */\n\tmemset(priv->buffer, 0, sizeof(priv->buffer));\n\n\t/* Initialize the descriptor */\n\tmemset(desc, 0, sizeof(struct ismt_desc));\n\tdesc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, read_write);\n\n\t/* Always clear the log entries */\n\tmemset(priv->log, 0, ISMT_LOG_ENTRIES * sizeof(u32));\n\n\t/* Initialize common control bits */\n\tif (likely(pci_dev_msi_enabled(priv->pci_dev)))\n\t\tdesc->control = ISMT_DESC_INT | ISMT_DESC_FAIR;\n\telse\n\t\tdesc->control = ISMT_DESC_FAIR;\n\n\tif ((flags & I2C_CLIENT_PEC) && (size != I2C_SMBUS_QUICK)\n\t    && (size != I2C_SMBUS_I2C_BLOCK_DATA))\n\t\tdesc->control |= ISMT_DESC_PEC;\n\n\tswitch (size) {\n\tcase I2C_SMBUS_QUICK:\n\t\tdev_dbg(dev, \"I2C_SMBUS_QUICK\\n\");\n\t\tbreak;\n\n\tcase I2C_SMBUS_BYTE:\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\t/*\n\t\t\t * Send Byte\n\t\t\t * The command field contains the write data\n\t\t\t */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE:  WRITE\\n\");\n\t\t\tdesc->control |= ISMT_DESC_CWRL;\n\t\t\tdesc->wr_len_cmd = command;\n\t\t} else {\n\t\t\t/* Receive Byte */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE:  READ\\n\");\n\t\t\tdma_size = 1;\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t\tdesc->rd_len = 1;\n\t\t}\n\t\tbreak;\n\n\tcase I2C_SMBUS_BYTE_DATA:\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\t/*\n\t\t\t * Write Byte\n\t\t\t * Command plus 1 data byte\n\t\t\t */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE_DATA:  WRITE\\n\");\n\t\t\tdesc->wr_len_cmd = 2;\n\t\t\tdma_size = 2;\n\t\t\tdma_direction = DMA_TO_DEVICE;\n\t\t\tdma_buffer[0] = command;\n\t\t\tdma_buffer[1] = data->byte;\n\t\t} else {\n\t\t\t/* Read Byte */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE_DATA:  READ\\n\");\n\t\t\tdesc->control |= ISMT_DESC_CWRL;\n\t\t\tdesc->wr_len_cmd = command;\n\t\t\tdesc->rd_len = 1;\n\t\t\tdma_size = 1;\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t}\n\t\tbreak;\n\n\tcase I2C_SMBUS_WORD_DATA:\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\t/* Write Word */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_WORD_DATA:  WRITE\\n\");\n\t\t\tdesc->wr_len_cmd = 3;\n\t\t\tdma_size = 3;\n\t\t\tdma_direction = DMA_TO_DEVICE;\n\t\t\tdma_buffer[0] = command;\n\t\t\tdma_buffer[1] = data->word & 0xff;\n\t\t\tdma_buffer[2] = data->word >> 8;\n\t\t} else {\n\t\t\t/* Read Word */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_WORD_DATA:  READ\\n\");\n\t\t\tdesc->wr_len_cmd = command;\n\t\t\tdesc->control |= ISMT_DESC_CWRL;\n\t\t\tdesc->rd_len = 2;\n\t\t\tdma_size = 2;\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t}\n\t\tbreak;\n\n\tcase I2C_SMBUS_PROC_CALL:\n\t\tdev_dbg(dev, \"I2C_SMBUS_PROC_CALL\\n\");\n\t\tdesc->wr_len_cmd = 3;\n\t\tdesc->rd_len = 2;\n\t\tdma_size = 3;\n\t\tdma_direction = DMA_BIDIRECTIONAL;\n\t\tdma_buffer[0] = command;\n\t\tdma_buffer[1] = data->word & 0xff;\n\t\tdma_buffer[2] = data->word >> 8;\n\t\tbreak;\n\n\tcase I2C_SMBUS_BLOCK_DATA:\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\t/* Block Write */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BLOCK_DATA:  WRITE\\n\");\n\t\t\tdma_size = data->block[0] + 1;\n\t\t\tdma_direction = DMA_TO_DEVICE;\n\t\t\tdesc->wr_len_cmd = dma_size;\n\t\t\tdesc->control |= ISMT_DESC_BLK;\n\t\t\tdma_buffer[0] = command;\n\t\t\tmemcpy(&dma_buffer[1], &data->block[1], dma_size - 1);\n\t\t} else {\n\t\t\t/* Block Read */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BLOCK_DATA:  READ\\n\");\n\t\t\tdma_size = I2C_SMBUS_BLOCK_MAX;\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t\tdesc->rd_len = dma_size;\n\t\t\tdesc->wr_len_cmd = command;\n\t\t\tdesc->control |= (ISMT_DESC_BLK | ISMT_DESC_CWRL);\n\t\t}\n\t\tbreak;\n\n\tcase I2C_SMBUS_BLOCK_PROC_CALL:\n\t\tdev_dbg(dev, \"I2C_SMBUS_BLOCK_PROC_CALL\\n\");\n\t\tdma_size = I2C_SMBUS_BLOCK_MAX;\n\t\tdesc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, 1);\n\t\tdesc->wr_len_cmd = data->block[0] + 1;\n\t\tdesc->rd_len = dma_size;\n\t\tdesc->control |= ISMT_DESC_BLK;\n\t\tdma_direction = DMA_BIDIRECTIONAL;\n\t\tdma_buffer[0] = command;\n\t\tmemcpy(&dma_buffer[1], &data->block[1], data->block[0]);\n\t\tbreak;\n\n\tcase I2C_SMBUS_I2C_BLOCK_DATA:\n\t\t/* Make sure the length is valid */\n\t\tif (data->block[0] < 1)\n\t\t\tdata->block[0] = 1;\n\n\t\tif (data->block[0] > I2C_SMBUS_BLOCK_MAX)\n\t\t\tdata->block[0] = I2C_SMBUS_BLOCK_MAX;\n\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\t/* i2c Block Write */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_I2C_BLOCK_DATA:  WRITE\\n\");\n\t\t\tdma_size = data->block[0] + 1;\n\t\t\tdma_direction = DMA_TO_DEVICE;\n\t\t\tdesc->wr_len_cmd = dma_size;\n\t\t\tdesc->control |= ISMT_DESC_I2C;\n\t\t\tdma_buffer[0] = command;\n\t\t\tmemcpy(&dma_buffer[1], &data->block[1], dma_size - 1);\n\t\t} else {\n\t\t\t/* i2c Block Read */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_I2C_BLOCK_DATA:  READ\\n\");\n\t\t\tdma_size = data->block[0];\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t\tdesc->rd_len = dma_size;\n\t\t\tdesc->wr_len_cmd = command;\n\t\t\tdesc->control |= (ISMT_DESC_I2C | ISMT_DESC_CWRL);\n\t\t\t/*\n\t\t\t * Per the \"Table 15-15. I2C Commands\",\n\t\t\t * in the External Design Specification (EDS),\n\t\t\t * (Document Number: 508084, Revision: 2.0),\n\t\t\t * the _rw bit must be 0\n\t\t\t */\n\t\t\tdesc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, 0);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"Unsupported transaction %d\\n\",\n\t\t\tsize);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t/* map the data buffer */\n\tif (dma_size != 0) {\n\t\tdev_dbg(dev, \" dev=%p\\n\", dev);\n\t\tdev_dbg(dev, \" data=%p\\n\", data);\n\t\tdev_dbg(dev, \" dma_buffer=%p\\n\", dma_buffer);\n\t\tdev_dbg(dev, \" dma_size=%d\\n\", dma_size);\n\t\tdev_dbg(dev, \" dma_direction=%d\\n\", dma_direction);\n\n\t\tdma_addr = dma_map_single(dev,\n\t\t\t\t      dma_buffer,\n\t\t\t\t      dma_size,\n\t\t\t\t      dma_direction);\n\n\t\tif (dma_mapping_error(dev, dma_addr)) {\n\t\t\tdev_err(dev, \"Error in mapping dma buffer %p\\n\",\n\t\t\t\tdma_buffer);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tdev_dbg(dev, \" dma_addr = %pad\\n\", &dma_addr);\n\n\t\tdesc->dptr_low = lower_32_bits(dma_addr);\n\t\tdesc->dptr_high = upper_32_bits(dma_addr);\n\t}\n\n\treinit_completion(&priv->cmp);\n\n\t/* Add the descriptor */\n\tismt_submit_desc(priv);\n\n\t/* Now we wait for interrupt completion, 1s */\n\ttime_left = wait_for_completion_timeout(&priv->cmp, HZ*1);\n\n\t/* unmap the data buffer */\n\tif (dma_size != 0)\n\t\tdma_unmap_single(dev, dma_addr, dma_size, dma_direction);\n\n\tif (unlikely(!time_left)) {\n\t\tdev_err(dev, \"completion wait timed out\\n\");\n\t\tret = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\n\t/* do any post processing of the descriptor here */\n\tret = ismt_process_desc(desc, data, priv, size, read_write);\n\nout:\n\t/* Update the ring pointer */\n\tpriv->head++;\n\tpriv->head %= ISMT_DESC_ENTRIES;\n\n\treturn ret;\n}", "func_hash": 91513236317351842038056466223233835211, "file_name": "i2c-ismt.c", "file_hash": 22364513944485151173045885792643538357, "cwe": ["CWE-703"], "cve": "CVE-2022-3077", "cve_desc": "A buffer overflow vulnerability was found in the Linux kernel Intel\u2019s iSMT SMBus host controller driver in the way it handled the I2C_SMBUS_BLOCK_PROC_CALL case (via the ioctl I2C_SMBUS) with malicious input data. This flaw could allow a local user to crash the system.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-3077", "file_path": "drivers/i2c/busses/i2c-ismt.c"}
{"idx": 454759, "project": "linux", "commit_id": "690b2549b19563ec5ad53e5c82f6a944d910086e", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/690b2549b19563ec5ad53e5c82f6a944d910086e", "commit_message": "i2c: ismt: prevent memory corruption in ismt_access()\n\nThe \"data->block[0]\" variable comes from the user and is a number\nbetween 0-255.  It needs to be capped to prevent writing beyond the end\nof dma_buffer[].\n\nFixes: 5e9a97b1f449 (\"i2c: ismt: Adding support for I2C_SMBUS_BLOCK_PROC_CALL\")\nReported-and-tested-by: Zheyu Ma <zheyuma97@gmail.com>\nSigned-off-by: Dan Carpenter <dan.carpenter@oracle.com>\nReviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "target": 0, "func": "static int ismt_access(struct i2c_adapter *adap, u16 addr,\n\t\t       unsigned short flags, char read_write, u8 command,\n\t\t       int size, union i2c_smbus_data *data)\n{\n\tint ret;\n\tunsigned long time_left;\n\tdma_addr_t dma_addr = 0; /* address of the data buffer */\n\tu8 dma_size = 0;\n\tenum dma_data_direction dma_direction = 0;\n\tstruct ismt_desc *desc;\n\tstruct ismt_priv *priv = i2c_get_adapdata(adap);\n\tstruct device *dev = &priv->pci_dev->dev;\n\tu8 *dma_buffer = PTR_ALIGN(&priv->buffer[0], 16);\n\n\tdesc = &priv->hw[priv->head];\n\n\t/* Initialize the DMA buffer */\n\tmemset(priv->buffer, 0, sizeof(priv->buffer));\n\n\t/* Initialize the descriptor */\n\tmemset(desc, 0, sizeof(struct ismt_desc));\n\tdesc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, read_write);\n\n\t/* Always clear the log entries */\n\tmemset(priv->log, 0, ISMT_LOG_ENTRIES * sizeof(u32));\n\n\t/* Initialize common control bits */\n\tif (likely(pci_dev_msi_enabled(priv->pci_dev)))\n\t\tdesc->control = ISMT_DESC_INT | ISMT_DESC_FAIR;\n\telse\n\t\tdesc->control = ISMT_DESC_FAIR;\n\n\tif ((flags & I2C_CLIENT_PEC) && (size != I2C_SMBUS_QUICK)\n\t    && (size != I2C_SMBUS_I2C_BLOCK_DATA))\n\t\tdesc->control |= ISMT_DESC_PEC;\n\n\tswitch (size) {\n\tcase I2C_SMBUS_QUICK:\n\t\tdev_dbg(dev, \"I2C_SMBUS_QUICK\\n\");\n\t\tbreak;\n\n\tcase I2C_SMBUS_BYTE:\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\t/*\n\t\t\t * Send Byte\n\t\t\t * The command field contains the write data\n\t\t\t */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE:  WRITE\\n\");\n\t\t\tdesc->control |= ISMT_DESC_CWRL;\n\t\t\tdesc->wr_len_cmd = command;\n\t\t} else {\n\t\t\t/* Receive Byte */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE:  READ\\n\");\n\t\t\tdma_size = 1;\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t\tdesc->rd_len = 1;\n\t\t}\n\t\tbreak;\n\n\tcase I2C_SMBUS_BYTE_DATA:\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\t/*\n\t\t\t * Write Byte\n\t\t\t * Command plus 1 data byte\n\t\t\t */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE_DATA:  WRITE\\n\");\n\t\t\tdesc->wr_len_cmd = 2;\n\t\t\tdma_size = 2;\n\t\t\tdma_direction = DMA_TO_DEVICE;\n\t\t\tdma_buffer[0] = command;\n\t\t\tdma_buffer[1] = data->byte;\n\t\t} else {\n\t\t\t/* Read Byte */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE_DATA:  READ\\n\");\n\t\t\tdesc->control |= ISMT_DESC_CWRL;\n\t\t\tdesc->wr_len_cmd = command;\n\t\t\tdesc->rd_len = 1;\n\t\t\tdma_size = 1;\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t}\n\t\tbreak;\n\n\tcase I2C_SMBUS_WORD_DATA:\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\t/* Write Word */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_WORD_DATA:  WRITE\\n\");\n\t\t\tdesc->wr_len_cmd = 3;\n\t\t\tdma_size = 3;\n\t\t\tdma_direction = DMA_TO_DEVICE;\n\t\t\tdma_buffer[0] = command;\n\t\t\tdma_buffer[1] = data->word & 0xff;\n\t\t\tdma_buffer[2] = data->word >> 8;\n\t\t} else {\n\t\t\t/* Read Word */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_WORD_DATA:  READ\\n\");\n\t\t\tdesc->wr_len_cmd = command;\n\t\t\tdesc->control |= ISMT_DESC_CWRL;\n\t\t\tdesc->rd_len = 2;\n\t\t\tdma_size = 2;\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t}\n\t\tbreak;\n\n\tcase I2C_SMBUS_PROC_CALL:\n\t\tdev_dbg(dev, \"I2C_SMBUS_PROC_CALL\\n\");\n\t\tdesc->wr_len_cmd = 3;\n\t\tdesc->rd_len = 2;\n\t\tdma_size = 3;\n\t\tdma_direction = DMA_BIDIRECTIONAL;\n\t\tdma_buffer[0] = command;\n\t\tdma_buffer[1] = data->word & 0xff;\n\t\tdma_buffer[2] = data->word >> 8;\n\t\tbreak;\n\n\tcase I2C_SMBUS_BLOCK_DATA:\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\t/* Block Write */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BLOCK_DATA:  WRITE\\n\");\n\t\t\tdma_size = data->block[0] + 1;\n\t\t\tdma_direction = DMA_TO_DEVICE;\n\t\t\tdesc->wr_len_cmd = dma_size;\n\t\t\tdesc->control |= ISMT_DESC_BLK;\n\t\t\tdma_buffer[0] = command;\n\t\t\tmemcpy(&dma_buffer[1], &data->block[1], dma_size - 1);\n\t\t} else {\n\t\t\t/* Block Read */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BLOCK_DATA:  READ\\n\");\n\t\t\tdma_size = I2C_SMBUS_BLOCK_MAX;\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t\tdesc->rd_len = dma_size;\n\t\t\tdesc->wr_len_cmd = command;\n\t\t\tdesc->control |= (ISMT_DESC_BLK | ISMT_DESC_CWRL);\n\t\t}\n\t\tbreak;\n\n\tcase I2C_SMBUS_BLOCK_PROC_CALL:\n\t\tdev_dbg(dev, \"I2C_SMBUS_BLOCK_PROC_CALL\\n\");\n\t\tif (data->block[0] > I2C_SMBUS_BLOCK_MAX)\n\t\t\treturn -EINVAL;\n\n\t\tdma_size = I2C_SMBUS_BLOCK_MAX;\n\t\tdesc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, 1);\n\t\tdesc->wr_len_cmd = data->block[0] + 1;\n\t\tdesc->rd_len = dma_size;\n\t\tdesc->control |= ISMT_DESC_BLK;\n\t\tdma_direction = DMA_BIDIRECTIONAL;\n\t\tdma_buffer[0] = command;\n\t\tmemcpy(&dma_buffer[1], &data->block[1], data->block[0]);\n\t\tbreak;\n\n\tcase I2C_SMBUS_I2C_BLOCK_DATA:\n\t\t/* Make sure the length is valid */\n\t\tif (data->block[0] < 1)\n\t\t\tdata->block[0] = 1;\n\n\t\tif (data->block[0] > I2C_SMBUS_BLOCK_MAX)\n\t\t\tdata->block[0] = I2C_SMBUS_BLOCK_MAX;\n\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\t/* i2c Block Write */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_I2C_BLOCK_DATA:  WRITE\\n\");\n\t\t\tdma_size = data->block[0] + 1;\n\t\t\tdma_direction = DMA_TO_DEVICE;\n\t\t\tdesc->wr_len_cmd = dma_size;\n\t\t\tdesc->control |= ISMT_DESC_I2C;\n\t\t\tdma_buffer[0] = command;\n\t\t\tmemcpy(&dma_buffer[1], &data->block[1], dma_size - 1);\n\t\t} else {\n\t\t\t/* i2c Block Read */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_I2C_BLOCK_DATA:  READ\\n\");\n\t\t\tdma_size = data->block[0];\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t\tdesc->rd_len = dma_size;\n\t\t\tdesc->wr_len_cmd = command;\n\t\t\tdesc->control |= (ISMT_DESC_I2C | ISMT_DESC_CWRL);\n\t\t\t/*\n\t\t\t * Per the \"Table 15-15. I2C Commands\",\n\t\t\t * in the External Design Specification (EDS),\n\t\t\t * (Document Number: 508084, Revision: 2.0),\n\t\t\t * the _rw bit must be 0\n\t\t\t */\n\t\t\tdesc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, 0);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"Unsupported transaction %d\\n\",\n\t\t\tsize);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t/* map the data buffer */\n\tif (dma_size != 0) {\n\t\tdev_dbg(dev, \" dev=%p\\n\", dev);\n\t\tdev_dbg(dev, \" data=%p\\n\", data);\n\t\tdev_dbg(dev, \" dma_buffer=%p\\n\", dma_buffer);\n\t\tdev_dbg(dev, \" dma_size=%d\\n\", dma_size);\n\t\tdev_dbg(dev, \" dma_direction=%d\\n\", dma_direction);\n\n\t\tdma_addr = dma_map_single(dev,\n\t\t\t\t      dma_buffer,\n\t\t\t\t      dma_size,\n\t\t\t\t      dma_direction);\n\n\t\tif (dma_mapping_error(dev, dma_addr)) {\n\t\t\tdev_err(dev, \"Error in mapping dma buffer %p\\n\",\n\t\t\t\tdma_buffer);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tdev_dbg(dev, \" dma_addr = %pad\\n\", &dma_addr);\n\n\t\tdesc->dptr_low = lower_32_bits(dma_addr);\n\t\tdesc->dptr_high = upper_32_bits(dma_addr);\n\t}\n\n\treinit_completion(&priv->cmp);\n\n\t/* Add the descriptor */\n\tismt_submit_desc(priv);\n\n\t/* Now we wait for interrupt completion, 1s */\n\ttime_left = wait_for_completion_timeout(&priv->cmp, HZ*1);\n\n\t/* unmap the data buffer */\n\tif (dma_size != 0)\n\t\tdma_unmap_single(dev, dma_addr, dma_size, dma_direction);\n\n\tif (unlikely(!time_left)) {\n\t\tdev_err(dev, \"completion wait timed out\\n\");\n\t\tret = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\n\t/* do any post processing of the descriptor here */\n\tret = ismt_process_desc(desc, data, priv, size, read_write);\n\nout:\n\t/* Update the ring pointer */\n\tpriv->head++;\n\tpriv->head %= ISMT_DESC_ENTRIES;\n\n\treturn ret;\n}", "func_hash": 337152422880524025166312472003442952073, "file_name": "i2c-ismt.c", "file_hash": 51244111268212170404918431081464078764, "cwe": ["CWE-703"], "cve": "CVE-2022-3077", "cve_desc": "A buffer overflow vulnerability was found in the Linux kernel Intel\u2019s iSMT SMBus host controller driver in the way it handled the I2C_SMBUS_BLOCK_PROC_CALL case (via the ioctl I2C_SMBUS) with malicious input data. This flaw could allow a local user to crash the system.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-3077", "file_path": "drivers/i2c/busses/i2c-ismt.c"}
{"idx": 212144, "project": "libmobi", "commit_id": "c78e186739b50d156cb3da5d08d70294f0490853", "project_url": "https://github.com/bfabiszewski/libmobi", "commit_url": "https://github.com/bfabiszewski/libmobi/commit/c78e186739b50d156cb3da5d08d70294f0490853", "commit_message": "Fix potential out-of-buffer read while parsing corrupt file, closes #38", "target": 1, "func": "MOBI_RET mobi_parse_huffdic(const MOBIData *m, MOBIHuffCdic *huffcdic) {\n    MOBI_RET ret;\n    const size_t offset = mobi_get_kf8offset(m);\n    if (m->mh == NULL || m->mh->huff_rec_index == NULL || m->mh->huff_rec_count == NULL) {\n        debug_print(\"%s\", \"HUFF/CDIC records metadata not found in MOBI header\\n\");\n        return MOBI_DATA_CORRUPT;\n    }\n    const size_t huff_rec_index = *m->mh->huff_rec_index + offset;\n    const size_t huff_rec_count = *m->mh->huff_rec_count;\n    if (huff_rec_count > HUFF_RECORD_MAXCNT) {\n        debug_print(\"Too many HUFF record (%zu)\\n\", huff_rec_count);\n        return MOBI_DATA_CORRUPT;\n    }\n    const MOBIPdbRecord *curr = mobi_get_record_by_seqnumber(m, huff_rec_index);\n    if (curr == NULL || huff_rec_count < 2) {\n        debug_print(\"%s\", \"HUFF/CDIC record not found\\n\");\n        return MOBI_DATA_CORRUPT;\n    }\n    if (curr->size < HUFF_RECORD_MINSIZE) {\n        debug_print(\"HUFF record too short (%zu b)\\n\", curr->size);\n        return MOBI_DATA_CORRUPT;\n    }\n    ret = mobi_parse_huff(huffcdic, curr);\n    if (ret != MOBI_SUCCESS) {\n        debug_print(\"%s\", \"HUFF parsing failed\\n\");\n        return ret;\n    }\n    curr = curr->next;\n    /* allocate memory for symbols data in each CDIC record */\n    huffcdic->symbols = malloc((huff_rec_count - 1) * sizeof(*huffcdic->symbols));\n    if (huffcdic->symbols == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    /* get following CDIC records */\n    size_t i = 0;\n    while (i < huff_rec_count - 1) {\n        if (curr == NULL) {\n            debug_print(\"%s\\n\", \"CDIC record not found\");\n            return MOBI_DATA_CORRUPT;\n        }\n        ret = mobi_parse_cdic(huffcdic, curr, i++);\n        if (ret != MOBI_SUCCESS) {\n            debug_print(\"%s\", \"CDIC parsing failed\\n\");\n            return ret;\n        }\n        curr = curr->next;\n    }\n    return MOBI_SUCCESS;\n}", "func_hash": 272789865299199789225315738205107270064, "file_name": "read.c", "file_hash": 34500817876088764790813749563983010190, "cwe": ["CWE-119"], "cve": "CVE-2021-3888", "cve_desc": "libmobi is vulnerable to Use of Out-of-range Pointer Offset", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-3888", "file_path": "src/read.c"}
{"idx": 455177, "project": "libmobi", "commit_id": "c78e186739b50d156cb3da5d08d70294f0490853", "project_url": "https://github.com/bfabiszewski/libmobi", "commit_url": "https://github.com/bfabiszewski/libmobi/commit/c78e186739b50d156cb3da5d08d70294f0490853", "commit_message": "Fix potential out-of-buffer read while parsing corrupt file, closes #38", "target": 0, "func": "MOBI_RET mobi_parse_huffdic(const MOBIData *m, MOBIHuffCdic *huffcdic) {\n    MOBI_RET ret;\n    const size_t offset = mobi_get_kf8offset(m);\n    if (m->mh == NULL || m->mh->huff_rec_index == NULL || m->mh->huff_rec_count == NULL) {\n        debug_print(\"%s\", \"HUFF/CDIC records metadata not found in MOBI header\\n\");\n        return MOBI_DATA_CORRUPT;\n    }\n    const size_t huff_rec_index = *m->mh->huff_rec_index + offset;\n    const size_t huff_rec_count = *m->mh->huff_rec_count;\n    if (huff_rec_count > HUFF_RECORD_MAXCNT) {\n        debug_print(\"Too many HUFF record (%zu)\\n\", huff_rec_count);\n        return MOBI_DATA_CORRUPT;\n    }\n    const MOBIPdbRecord *curr = mobi_get_record_by_seqnumber(m, huff_rec_index);\n    if (curr == NULL || huff_rec_count < 2) {\n        debug_print(\"%s\", \"HUFF/CDIC record not found\\n\");\n        return MOBI_DATA_CORRUPT;\n    }\n    if (curr->size < HUFF_RECORD_MINSIZE) {\n        debug_print(\"HUFF record too short (%zu b)\\n\", curr->size);\n        return MOBI_DATA_CORRUPT;\n    }\n    ret = mobi_parse_huff(huffcdic, curr);\n    if (ret != MOBI_SUCCESS) {\n        debug_print(\"%s\", \"HUFF parsing failed\\n\");\n        return ret;\n    }\n    curr = curr->next;\n    /* allocate memory for symbols data in each CDIC record */\n    huffcdic->symbols = malloc((huff_rec_count - 1) * sizeof(*huffcdic->symbols));\n    if (huffcdic->symbols == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    /* get following CDIC records */\n    size_t i = 0;\n    while (i < huff_rec_count - 1) {\n        if (curr == NULL) {\n            debug_print(\"%s\\n\", \"CDIC record not found\");\n            return MOBI_DATA_CORRUPT;\n        }\n        ret = mobi_parse_cdic(huffcdic, curr, i++);\n        if (ret != MOBI_SUCCESS) {\n            debug_print(\"%s\", \"CDIC parsing failed\\n\");\n            return ret;\n        }\n        curr = curr->next;\n    }\n    if (huffcdic->index_count != huffcdic->index_read) {\n        debug_print(\"CDIC: wrong read index count: %zu, total: %zu\\n\", huffcdic->index_read, huffcdic->index_count);\n        return MOBI_DATA_CORRUPT;\n    }\n    return MOBI_SUCCESS;\n}", "func_hash": 211530049158768490793426546245477731217, "file_name": "read.c", "file_hash": 228295168827515416887178420817040616622, "cwe": ["CWE-119"], "cve": "CVE-2021-3888", "cve_desc": "libmobi is vulnerable to Use of Out-of-range Pointer Offset", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-3888", "file_path": "src/read.c"}
