{"idx": 211845, "project": "ImageMagick6", "commit_id": "1aea203eb36409ce6903b9e41fe7cb70030e8750", "project_url": "https://github.com/ImageMagick/ImageMagick6", "commit_url": "https://github.com/ImageMagick/ImageMagick6/commit/1aea203eb36409ce6903b9e41fe7cb70030e8750", "commit_message": "squash heap-buffer-overflow, PoC TIFF from Hardik", "target": 1, "func": "static Image *ReadTIFFImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n#define MaxPixelChannels  32\n#define ThrowTIFFException(severity,message) \\\n{ \\\n  if (pixel_info != (MemoryInfo *) NULL) \\\n    pixel_info=RelinquishVirtualMemory(pixel_info); \\\n  if (quantum_info != (QuantumInfo *) NULL) \\\n    quantum_info=DestroyQuantumInfo(quantum_info); \\\n  TIFFClose(tiff); \\\n  ThrowReaderException(severity,message); \\\n}\n\n  const char\n    *option;\n\n  float\n    *chromaticity = (float *) NULL,\n    x_position,\n    y_position,\n    x_resolution,\n    y_resolution;\n\n  Image\n    *image;\n\n  int\n    tiff_status = 0;\n\n  MagickBooleanType\n    more_frames;\n\n  MagickStatusType\n    status;\n\n  MemoryInfo\n    *pixel_info = (MemoryInfo *) NULL;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  size_t\n    number_pixels;\n\n  ssize_t\n    i,\n    scanline_size,\n    y;\n\n  TIFF\n    *tiff;\n\n  TIFFMethodType\n    method;\n\n  uint16\n    compress_tag = 0,\n    bits_per_sample = 0,\n    endian = 0,\n    extra_samples = 0,\n    interlace = 0,\n    max_sample_value = 0,\n    min_sample_value = 0,\n    orientation = 0,\n    pages = 0,\n    photometric = 0,\n    *sample_info = NULL,\n    sample_format = 0,\n    samples_per_pixel = 0,\n    units = 0,\n    value = 0;\n\n  uint32\n    height,\n    rows_per_strip,\n    width;\n\n  unsigned char\n    *pixels;\n\n  void\n    *sans[8] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };\n\n  /*\n    Open image.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) SetMagickThreadValue(tiff_exception,exception);\n  tiff=TIFFClientOpen(image->filename,\"rb\",(thandle_t) image,TIFFReadBlob,\n    TIFFWriteBlob,TIFFSeekBlob,TIFFCloseBlob,TIFFGetBlobSize,TIFFMapBlob,\n    TIFFUnmapBlob);\n  if (tiff == (TIFF *) NULL)\n    {\n      if (exception->severity == UndefinedException)\n        ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (exception->severity > ErrorException)\n    {\n      TIFFClose(tiff);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (image_info->number_scenes != 0)\n    {\n      /*\n        Generate blank images for subimage specification (e.g. image.tif[4].\n        We need to check the number of directores because it is possible that\n        the subimage(s) are stored in the photoshop profile.\n      */\n      if (image_info->scene < (size_t)TIFFNumberOfDirectories(tiff))\n        {\n          for (i=0; i < (ssize_t) image_info->scene; i++)\n          {\n            status=TIFFReadDirectory(tiff) != 0 ? MagickTrue : MagickFalse;\n            if (status == MagickFalse)\n              {\n                TIFFClose(tiff);\n                image=DestroyImageList(image);\n                return((Image *) NULL);\n              }\n            AcquireNextImage(image_info,image);\n            if (GetNextImageInList(image) == (Image *) NULL)\n              {\n                TIFFClose(tiff);\n                image=DestroyImageList(image);\n                return((Image *) NULL);\n              }\n            image=SyncNextImageInList(image);\n          }\n        }\n    }\n  more_frames=MagickTrue;\n  do\n  {\n    /* TIFFPrintDirectory(tiff,stdout,MagickFalse); */\n    photometric=PHOTOMETRIC_RGB;\n    if ((TIFFGetField(tiff,TIFFTAG_IMAGEWIDTH,&width) != 1) ||\n        (TIFFGetField(tiff,TIFFTAG_IMAGELENGTH,&height) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_PHOTOMETRIC,&photometric,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_COMPRESSION,&compress_tag,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_FILLORDER,&endian,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_PLANARCONFIG,&interlace,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLESPERPIXEL,&samples_per_pixel,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,&bits_per_sample,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLEFORMAT,&sample_format,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_MINSAMPLEVALUE,&min_sample_value,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_MAXSAMPLEVALUE,&max_sample_value,sans) != 1))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n    if (((sample_format != SAMPLEFORMAT_IEEEFP) || (bits_per_sample != 64)) &&\n        ((bits_per_sample <= 0) || (bits_per_sample > 32)))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CorruptImageError,\"UnsupportedBitsPerPixel\");\n      }\n    if (samples_per_pixel > MaxPixelChannels)\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CorruptImageError,\"MaximumChannelsExceeded\");\n      }\n    if (sample_format == SAMPLEFORMAT_IEEEFP)\n      (void) SetImageProperty(image,\"quantum:format\",\"floating-point\");\n    switch (photometric)\n    {\n      case PHOTOMETRIC_MINISBLACK:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"min-is-black\");\n        break;\n      }\n      case PHOTOMETRIC_MINISWHITE:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"min-is-white\");\n        break;\n      }\n      case PHOTOMETRIC_PALETTE:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"palette\");\n        break;\n      }\n      case PHOTOMETRIC_RGB:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"RGB\");\n        break;\n      }\n      case PHOTOMETRIC_CIELAB:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"CIELAB\");\n        break;\n      }\n      case PHOTOMETRIC_LOGL:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"CIE Log2(L)\");\n        break;\n      }\n      case PHOTOMETRIC_LOGLUV:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"LOGLUV\");\n        break;\n      }\n#if defined(PHOTOMETRIC_MASK)\n      case PHOTOMETRIC_MASK:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"MASK\");\n        break;\n      }\n#endif\n      case PHOTOMETRIC_SEPARATED:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"separated\");\n        break;\n      }\n      case PHOTOMETRIC_YCBCR:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"YCBCR\");\n        break;\n      }\n      default:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"unknown\");\n        break;\n      }\n    }\n    if (image->debug != MagickFalse)\n      {\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Geometry: %ux%u\",\n          (unsigned int) width,(unsigned int) height);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Interlace: %u\",\n          interlace);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Bits per sample: %u\",bits_per_sample);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Min sample value: %u\",min_sample_value);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Max sample value: %u\",max_sample_value);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Photometric \"\n          \"interpretation: %s\",GetImageProperty(image,\"tiff:photometric\"));\n      }\n    image->columns=(size_t) width;\n    image->rows=(size_t) height;\n    image->depth=(size_t) bits_per_sample;\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Image depth: %.20g\",\n        (double) image->depth);\n    image->endian=MSBEndian;\n    if (endian == FILLORDER_LSB2MSB)\n      image->endian=LSBEndian;\n#if defined(MAGICKCORE_HAVE_TIFFISBIGENDIAN)\n    if (TIFFIsBigEndian(tiff) == 0)\n      {\n        (void) SetImageProperty(image,\"tiff:endian\",\"lsb\");\n        image->endian=LSBEndian;\n      }\n    else\n      {\n        (void) SetImageProperty(image,\"tiff:endian\",\"msb\");\n        image->endian=MSBEndian;\n      }\n#endif\n    if ((photometric == PHOTOMETRIC_MINISBLACK) ||\n        (photometric == PHOTOMETRIC_MINISWHITE))\n      image->colorspace=GRAYColorspace;\n    if (photometric == PHOTOMETRIC_SEPARATED)\n      image->colorspace=CMYKColorspace;\n    if (photometric == PHOTOMETRIC_CIELAB)\n      image->colorspace=LabColorspace;\n    if ((photometric == PHOTOMETRIC_YCBCR) &&\n        (compress_tag != COMPRESSION_OJPEG) &&\n        (compress_tag != COMPRESSION_JPEG))\n      image->colorspace=YCbCrColorspace;\n    status=TIFFGetProfiles(tiff,image);\n    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    status=TIFFGetProperties(tiff,image);\n    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    option=GetImageOption(image_info,\"tiff:exif-properties\");\n    if ((option == (const char *) NULL) ||\n        (IsMagickTrue(option) != MagickFalse))\n      (void) TIFFGetEXIFProperties(tiff,image);\n    option=GetImageOption(image_info,\"tiff:gps-properties\");\n    if ((option == (const char *) NULL) ||\n        (IsMagickTrue(option) != MagickFalse))\n      (void) TIFFGetGPSProperties(tiff,image);\n    if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XRESOLUTION,&x_resolution,sans) == 1) &&\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_YRESOLUTION,&y_resolution,sans) == 1))\n      {\n        image->x_resolution=x_resolution;\n        image->y_resolution=y_resolution;\n      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_RESOLUTIONUNIT,&units,sans,sans) == 1)\n      {\n        if (units == RESUNIT_INCH)\n          image->units=PixelsPerInchResolution;\n        if (units == RESUNIT_CENTIMETER)\n          image->units=PixelsPerCentimeterResolution;\n      }\n    if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XPOSITION,&x_position,sans) == 1) &&\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_YPOSITION,&y_position,sans) == 1))\n      {\n        image->page.x=CastDoubleToLong(ceil(x_position*\n          image->x_resolution-0.5));\n        image->page.y=CastDoubleToLong(ceil(y_position*\n          image->y_resolution-0.5));\n      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_ORIENTATION,&orientation,sans) == 1)\n      image->orientation=(OrientationType) orientation;\n    if (TIFFGetField(tiff,TIFFTAG_WHITEPOINT,&chromaticity) == 1)\n      {\n        if ((chromaticity != (float *) NULL) && (*chromaticity != 0.0))\n          {\n            image->chromaticity.white_point.x=chromaticity[0];\n            image->chromaticity.white_point.y=chromaticity[1];\n          }\n      }\n    if (TIFFGetField(tiff,TIFFTAG_PRIMARYCHROMATICITIES,&chromaticity) == 1)\n      {\n        if ((chromaticity != (float *) NULL) && (*chromaticity != 0.0))\n          {\n            image->chromaticity.red_primary.x=chromaticity[0];\n            image->chromaticity.red_primary.y=chromaticity[1];\n            image->chromaticity.green_primary.x=chromaticity[2];\n            image->chromaticity.green_primary.y=chromaticity[3];\n            image->chromaticity.blue_primary.x=chromaticity[4];\n            image->chromaticity.blue_primary.y=chromaticity[5];\n          }\n      }\n#if defined(MAGICKCORE_HAVE_TIFFISCODECCONFIGURED) || (TIFFLIB_VERSION > 20040919)\n    if ((compress_tag != COMPRESSION_NONE) &&\n        (TIFFIsCODECConfigured(compress_tag) == 0))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CoderError,\"CompressNotSupported\");\n      }\n#endif\n    switch (compress_tag)\n    {\n      case COMPRESSION_NONE: image->compression=NoCompression; break;\n      case COMPRESSION_CCITTFAX3: image->compression=FaxCompression; break;\n      case COMPRESSION_CCITTFAX4: image->compression=Group4Compression; break;\n      case COMPRESSION_JPEG:\n      {\n         image->compression=JPEGCompression;\n#if defined(JPEG_SUPPORT)\n         {\n           char\n             sampling_factor[MaxTextExtent];\n\n           int\n             tiff_status;\n\n           uint16\n             horizontal,\n             vertical;\n\n           tiff_status=TIFFGetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,&horizontal,\n             &vertical);\n           if (tiff_status == 1)\n             {\n               (void) FormatLocaleString(sampling_factor,MaxTextExtent,\"%dx%d\",\n                 horizontal,vertical);\n               (void) SetImageProperty(image,\"jpeg:sampling-factor\",\n                 sampling_factor);\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"Sampling Factors: %s\",sampling_factor);\n             }\n         }\n#endif\n        break;\n      }\n      case COMPRESSION_OJPEG: image->compression=JPEGCompression; break;\n#if defined(COMPRESSION_LZMA)\n      case COMPRESSION_LZMA: image->compression=LZMACompression; break;\n#endif\n      case COMPRESSION_LZW: image->compression=LZWCompression; break;\n      case COMPRESSION_DEFLATE: image->compression=ZipCompression; break;\n      case COMPRESSION_ADOBE_DEFLATE: image->compression=ZipCompression; break;\n#if defined(COMPRESSION_WEBP)\n      case COMPRESSION_WEBP: image->compression=WebPCompression; break;\n#endif\n#if defined(COMPRESSION_ZSTD)\n      case COMPRESSION_ZSTD: image->compression=ZstdCompression; break;\n#endif\n      default: image->compression=RLECompression; break;\n    }\n    quantum_info=(QuantumInfo *) NULL;\n    if ((photometric == PHOTOMETRIC_PALETTE) &&\n        (pow(2.0,1.0*bits_per_sample) <= MaxColormapSize))\n      {\n        size_t\n          colors;\n\n        colors=(size_t) GetQuantumRange(bits_per_sample)+1;\n        if (AcquireImageColormap(image,colors) == MagickFalse)\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_PAGENUMBER,&value,&pages,sans) == 1)\n      image->scene=value;\n    if (image->storage_class == PseudoClass)\n      {\n        int\n          tiff_status;\n\n        size_t\n          range;\n\n        uint16\n          *blue_colormap = (uint16 *) NULL,\n          *green_colormap = (uint16 *) NULL,\n          *red_colormap = (uint16 *) NULL;\n\n        /*\n          Initialize colormap.\n        */\n        tiff_status=TIFFGetField(tiff,TIFFTAG_COLORMAP,&red_colormap,\n          &green_colormap,&blue_colormap);\n        if (tiff_status == 1)\n          {\n            if ((red_colormap != (uint16 *) NULL) &&\n                (green_colormap != (uint16 *) NULL) &&\n                (blue_colormap != (uint16 *) NULL))\n              {\n                range=255;  /* might be old style 8-bit colormap */\n                for (i=0; i < (ssize_t) image->colors; i++)\n                  if ((red_colormap[i] >= 256) || (green_colormap[i] >= 256) ||\n                      (blue_colormap[i] >= 256))\n                    {\n                      range=65535;\n                      break;\n                    }\n                for (i=0; i < (ssize_t) image->colors; i++)\n                {\n                  image->colormap[i].red=ClampToQuantum(((double)\n                    QuantumRange*red_colormap[i])/range);\n                  image->colormap[i].green=ClampToQuantum(((double)\n                    QuantumRange*green_colormap[i])/range);\n                  image->colormap[i].blue=ClampToQuantum(((double)\n                    QuantumRange*blue_colormap[i])/range);\n                }\n              }\n          }\n      }\n    if (image_info->ping != MagickFalse)\n      {\n        if (image_info->number_scenes != 0)\n          if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n            break;\n        goto next_tiff_frame;\n      }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    status=SetImageColorspace(image,image->colorspace);\n    status&=ResetImagePixels(image,exception);\n    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    /*\n      Allocate memory for the image and pixel buffer.\n    */\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if (sample_format == SAMPLEFORMAT_UINT)\n      status=SetQuantumFormat(image,quantum_info,UnsignedQuantumFormat);\n    if (sample_format == SAMPLEFORMAT_INT)\n      status=SetQuantumFormat(image,quantum_info,SignedQuantumFormat);\n    if (sample_format == SAMPLEFORMAT_IEEEFP)\n      status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);\n    if (status == MagickFalse)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n    status=MagickTrue;\n    switch (photometric)\n    {\n      case PHOTOMETRIC_MINISBLACK:\n      {\n        quantum_info->min_is_white=MagickFalse;\n        break;\n      }\n      case PHOTOMETRIC_MINISWHITE:\n      {\n        quantum_info->min_is_white=MagickTrue;\n        break;\n      }\n      default:\n        break;\n    }\n    extra_samples=0;\n    tiff_status=TIFFGetFieldDefaulted(tiff,TIFFTAG_EXTRASAMPLES,&extra_samples,\n      &sample_info,sans);\n    if (tiff_status == 1)\n      {\n        (void) SetImageProperty(image,\"tiff:alpha\",\"unspecified\");\n        if (extra_samples == 0)\n          {\n            if ((samples_per_pixel == 4) && (photometric == PHOTOMETRIC_RGB))\n              image->matte=MagickTrue;\n          }\n        else\n          for (i=0; i < extra_samples; i++)\n          {\n            image->matte=MagickTrue;\n            if (sample_info[i] == EXTRASAMPLE_ASSOCALPHA)\n              {\n                SetQuantumAlphaType(quantum_info,AssociatedQuantumAlpha);\n                (void) SetImageProperty(image,\"tiff:alpha\",\"associated\");\n              }\n            else\n              if (sample_info[i] == EXTRASAMPLE_UNASSALPHA)\n                {\n                  SetQuantumAlphaType(quantum_info,DisassociatedQuantumAlpha);\n                  (void) SetImageProperty(image,\"tiff:alpha\",\"unassociated\");\n                }\n          }\n      }\n    if (image->matte != MagickFalse)\n      (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);\n    method=ReadGenericMethod;\n    rows_per_strip=(uint32) image->rows;\n    if (TIFFGetField(tiff,TIFFTAG_ROWSPERSTRIP,&rows_per_strip) == 1)\n      {\n        char\n          value[MaxTextExtent];\n\n        (void) FormatLocaleString(value,MaxTextExtent,\"%u\",(unsigned int)\n          rows_per_strip);\n        (void) SetImageProperty(image,\"tiff:rows-per-strip\",value);\n        method=ReadStripMethod;\n        if (rows_per_strip > (uint32) image->rows)\n          rows_per_strip=(uint32) image->rows;\n      }\n    if (TIFFIsTiled(tiff) != MagickFalse)\n      {\n        uint32\n          columns,\n          rows;\n\n        if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns) != 1) ||\n            (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))\n          ThrowTIFFException(CoderError,\"ImageIsNotTiled\");\n        if ((AcquireMagickResource(WidthResource,columns) == MagickFalse) ||\n            (AcquireMagickResource(HeightResource,rows) == MagickFalse))\n          ThrowTIFFException(ImageError,\"WidthOrHeightExceedsLimit\");\n        method=ReadTileMethod;\n      }\n    if ((photometric == PHOTOMETRIC_LOGLUV) ||\n        (compress_tag == COMPRESSION_CCITTFAX3))\n      method=ReadGenericMethod;\n    if (image->compression == JPEGCompression)\n      method=GetJPEGMethod(image,tiff,photometric,bits_per_sample,\n        samples_per_pixel);\n    quantum_info->endian=LSBEndian;\n    scanline_size=TIFFScanlineSize(tiff);\n    if (scanline_size <= 0)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n    number_pixels=MagickMax((MagickSizeType) image->columns*samples_per_pixel*\n      pow(2.0,ceil(log(bits_per_sample)/log(2.0))),image->columns*\n      rows_per_strip);\n    if ((double) scanline_size > 1.5*number_pixels)\n      ThrowTIFFException(CorruptImageError,\"CorruptImage\");\n    number_pixels=MagickMax((MagickSizeType) scanline_size,number_pixels);\n    pixel_info=AcquireVirtualMemory(number_pixels,sizeof(uint32));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    (void) ResetMagickMemory(pixels,0,number_pixels*sizeof(uint32));\n    quantum_type=GrayQuantum;\n    if (image->storage_class == PseudoClass)\n      quantum_type=IndexQuantum;\n    if (interlace != PLANARCONFIG_SEPARATE)\n      {\n        size_t\n          pad;\n\n        pad=(size_t) MagickMax((ssize_t) samples_per_pixel-1,0);\n        if (image->matte != MagickFalse)\n          {\n            if (image->storage_class == PseudoClass)\n              quantum_type=IndexAlphaQuantum;\n            else\n              quantum_type=samples_per_pixel == 1 ? AlphaQuantum :\n                GrayAlphaQuantum;\n          }\n        if ((samples_per_pixel > 2) && (interlace != PLANARCONFIG_SEPARATE))\n          {\n            quantum_type=RGBQuantum;\n            pad=(size_t) MagickMax((ssize_t) samples_per_pixel+\n              extra_samples-3,0);\n            if (image->matte != MagickFalse)\n              {\n                quantum_type=RGBAQuantum;\n                pad=(size_t) MagickMax((ssize_t) samples_per_pixel+\n                  extra_samples-4,0);\n              }\n            if (image->colorspace == CMYKColorspace)\n              {\n                quantum_type=CMYKQuantum;\n                pad=(size_t) MagickMax((ssize_t) samples_per_pixel+\n                  extra_samples-4,0);\n                if (image->matte != MagickFalse)\n                  {\n                    quantum_type=CMYKAQuantum;\n                    pad=(size_t) MagickMax((ssize_t) samples_per_pixel+\n                      extra_samples-5,0);\n                  }\n              }\n            status=SetQuantumPad(image,quantum_info,pad*((bits_per_sample+7) >>\n              3));\n            if (status == MagickFalse)\n              ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n      }\n    switch (method)\n    {\n      case ReadYCCKMethod:\n      {\n        /*\n          Convert YCC TIFF image.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          int\n            status;\n\n          IndexPacket\n            *indexes;\n\n          PixelPacket\n            *magick_restrict q;\n\n          ssize_t\n            x;\n\n          unsigned char\n            *p;\n\n          status=TIFFReadPixels(tiff,0,y,(char *) pixels);\n          if (status == -1)\n            break;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          indexes=GetAuthenticIndexQueue(image);\n          p=pixels;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelCyan(q,ScaleCharToQuantum(ClampYCC((double) *p+\n              (1.402*(double) *(p+2))-179.456)));\n            SetPixelMagenta(q,ScaleCharToQuantum(ClampYCC((double) *p-\n              (0.34414*(double) *(p+1))-(0.71414*(double ) *(p+2))+\n              135.45984)));\n            SetPixelYellow(q,ScaleCharToQuantum(ClampYCC((double) *p+\n              (1.772*(double) *(p+1))-226.816)));\n            SetPixelBlack(indexes+x,ScaleCharToQuantum((unsigned char)*(p+3)));\n            q++;\n            p+=4;\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case ReadStripMethod:\n      {\n        unsigned char\n          *p;\n\n        size_t\n          extent;\n\n        ssize_t\n          stride,\n          strip_id;\n\n        tsize_t\n          strip_size;\n\n        unsigned char\n          *strip_pixels;\n\n        /*\n          Convert stripped TIFF image.\n        */\n        extent=4*(samples_per_pixel+1)*TIFFStripSize(tiff);\n        strip_pixels=(unsigned char *) AcquireQuantumMemory(extent,\n          sizeof(*strip_pixels));\n        if (strip_pixels == (unsigned char *) NULL)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) memset(strip_pixels,0,extent*sizeof(*strip_pixels));\n        stride=TIFFVStripSize(tiff,1);\n        strip_id=0;\n        p=strip_pixels;\n        for (i=0; i < (ssize_t) samples_per_pixel; i++)\n        {\n          size_t\n            rows_remaining;\n\n          switch (i)\n          {\n            case 0: break;\n            case 1: quantum_type=GreenQuantum; break;\n            case 2: quantum_type=BlueQuantum; break;\n            case 3:\n            {\n              quantum_type=AlphaQuantum;\n              if (image->colorspace == CMYKColorspace)\n                quantum_type=BlackQuantum;\n              break;\n            }\n            case 4: quantum_type=AlphaQuantum; break;\n            default: break;\n          }\n          rows_remaining=0;\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            PixelPacket\n              *magick_restrict q;\n\n            q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (PixelPacket *) NULL)\n              break;\n            if (rows_remaining == 0)\n              {\n                strip_size=TIFFReadEncodedStrip(tiff,strip_id,strip_pixels,\n                  TIFFStripSize(tiff));\n                if (strip_size == -1)\n                  break;\n                rows_remaining=rows_per_strip;\n                if ((y+rows_per_strip) > (ssize_t) image->rows)\n                  rows_remaining=(rows_per_strip-(y+rows_per_strip-\n                    image->rows));\n                p=strip_pixels;\n                strip_id++;\n              }\n            (void) ImportQuantumPixels(image,(CacheView *) NULL,\n              quantum_info,quantum_type,p,exception);\n            p+=stride;\n            rows_remaining--;\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                  image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n         if ((samples_per_pixel > 1) && (interlace != PLANARCONFIG_SEPARATE))\n            break;\n        }\n        strip_pixels=(unsigned char *) RelinquishMagickMemory(strip_pixels);\n        break;\n      }\n      case ReadTileMethod:\n      {\n        unsigned char\n          *p;\n\n        size_t\n          extent;\n\n        uint32\n          columns,\n          rows;\n\n        unsigned char\n          *tile_pixels;\n\n        /*\n          Convert tiled TIFF image.\n        */\n        if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns) != 1) ||\n            (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))\n          ThrowTIFFException(CoderError,\"ImageIsNotTiled\");\n        number_pixels=(MagickSizeType) columns*rows;\n        if (HeapOverflowSanityCheck(rows,sizeof(*tile_pixels)) != MagickFalse)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        extent=4*(samples_per_pixel+1)*MagickMax(rows*TIFFTileRowSize(tiff),\n          TIFFTileSize(tiff));\n        tile_pixels=(unsigned char *) AcquireQuantumMemory(extent,\n          sizeof(*tile_pixels));\n        if (tile_pixels == (unsigned char *) NULL)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) memset(tile_pixels,0,extent*sizeof(*tile_pixels));\n        for (i=0; i < (ssize_t) samples_per_pixel; i++)\n        {\n          switch (i)\n          {\n            case 0: break;\n            case 1: quantum_type=GreenQuantum; break;\n            case 2: quantum_type=BlueQuantum; break;\n            case 3:\n            {\n              quantum_type=AlphaQuantum;\n              if (image->colorspace == CMYKColorspace)\n                quantum_type=BlackQuantum;\n              break;\n            }\n            case 4: quantum_type=AlphaQuantum; break;\n            default: break;\n          }\n          for (y=0; y < (ssize_t) image->rows; y+=rows)\n          {\n            ssize_t\n              x;\n\n            size_t\n              rows_remaining;\n\n            rows_remaining=image->rows-y;\n            if ((ssize_t) (y+rows) < (ssize_t) image->rows)\n              rows_remaining=rows;\n            for (x=0; x < (ssize_t) image->columns; x+=columns)\n            {\n              size_t\n                columns_remaining,\n                row;\n\n              columns_remaining=image->columns-x;\n              if ((ssize_t) (x+columns) < (ssize_t) image->columns)\n                columns_remaining=columns;\n              tiff_status=TIFFReadTile(tiff,tile_pixels,(uint32) x,(uint32) y,\n                0,i);\n              if (tiff_status == -1)\n                break;\n              p=tile_pixels;\n              for (row=0; row < rows_remaining; row++)\n              {\n                PixelPacket\n                  *magick_restrict q;\n\n                q=GetAuthenticPixels(image,x,y+row,columns_remaining,1,\n                  exception);\n                if (q == (PixelPacket *) NULL)\n                  break;\n                (void) ImportQuantumPixels(image,(CacheView *) NULL,\n                  quantum_info,quantum_type,p,exception);\n                p+=TIFFTileRowSize(tiff);\n                if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                  break;\n              }\n            }\n          }\n          if ((samples_per_pixel > 1) && (interlace != PLANARCONFIG_SEPARATE))\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) i,\n                samples_per_pixel);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        tile_pixels=(unsigned char *) RelinquishMagickMemory(tile_pixels);\n        break;\n      }\n      case ReadGenericMethod:\n      default:\n      {\n        MemoryInfo\n          *generic_info = (MemoryInfo *) NULL;\n\n        uint32\n          *p;\n\n        uint32\n          *pixels;\n\n        /*\n          Convert generic TIFF image.\n        */\n        if (HeapOverflowSanityCheck(image->rows,sizeof(*pixels)) != MagickFalse)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        number_pixels=(MagickSizeType) image->columns*image->rows;\n        generic_info=AcquireVirtualMemory(number_pixels,sizeof(*pixels));\n        if (generic_info == (MemoryInfo *) NULL)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        pixels=(uint32 *) GetVirtualMemoryBlob(generic_info);\n        tiff_status=TIFFReadRGBAImage(tiff,(uint32) image->columns,(uint32)\n          image->rows,(uint32 *) pixels,0);\n        if (tiff_status == -1)\n          {\n            generic_info=RelinquishVirtualMemory(generic_info);\n            break;\n          }\n        p=pixels+(image->columns*image->rows)-1;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          ssize_t\n            x;\n\n          PixelPacket\n            *magick_restrict q;\n\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          q+=image->columns-1;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(q,ScaleCharToQuantum((unsigned char) TIFFGetR(*p)));\n            SetPixelGreen(q,ScaleCharToQuantum((unsigned char) TIFFGetG(*p)));\n            SetPixelBlue(q,ScaleCharToQuantum((unsigned char) TIFFGetB(*p)));\n            if (image->matte == MagickFalse)\n              SetPixelOpacity(q,OpaqueOpacity);\n            else\n              SetPixelAlpha(q,ScaleCharToQuantum((unsigned char) TIFFGetA(*p)));\n            p--;\n            q--;\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        generic_info=RelinquishVirtualMemory(generic_info);\n        break;\n      }\n    }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    SetQuantumImageType(image,quantum_type);\n  next_tiff_frame:\n    if (quantum_info != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n    if (tiff_status == -1)\n      {\n        status=MagickFalse;\n        break;\n      }\n    if (photometric == PHOTOMETRIC_CIELAB)\n      DecodeLabImage(image,exception);\n    if ((photometric == PHOTOMETRIC_LOGL) ||\n        (photometric == PHOTOMETRIC_MINISBLACK) ||\n        (photometric == PHOTOMETRIC_MINISWHITE))\n      {\n        image->type=GrayscaleType;\n        if (bits_per_sample == 1)\n          image->type=BilevelType;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    more_frames=TIFFReadDirectory(tiff) != 0 ? MagickTrue : MagickFalse;\n    if (more_frames != MagickFalse)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            status=MagickFalse;\n            break;\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,image->scene-1,\n          image->scene);\n        if (status == MagickFalse)\n          break;\n      }\n  } while ((status != MagickFalse) && (more_frames != MagickFalse));\n  TIFFClose(tiff);\n  if ((image_info->number_scenes != 0) &&\n      (image_info->scene >= GetImageListLength(image)))\n    status=MagickFalse;\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  TIFFReadPhotoshopLayers(image_info,image,exception);\n  return(GetFirstImageInList(image));\n}", "func_hash": 282124666378195634578988553119839535376, "file_name": "tiff.c", "file_hash": 94999311171482042296542443921541591860, "cwe": ["CWE-787"], "cve": "CVE-2022-3213", "cve_desc": "A heap buffer overflow issue was found in ImageMagick. When an application processes a malformed TIFF file, it could lead to undefined behavior or a crash causing a denial of service.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-3213", "file_path": "coders/tiff.c"}
{"idx": 452391, "project": "ImageMagick6", "commit_id": "1aea203eb36409ce6903b9e41fe7cb70030e8750", "project_url": "https://github.com/ImageMagick/ImageMagick6", "commit_url": "https://github.com/ImageMagick/ImageMagick6/commit/1aea203eb36409ce6903b9e41fe7cb70030e8750", "commit_message": "squash heap-buffer-overflow, PoC TIFF from Hardik", "target": 0, "func": "static Image *ReadTIFFImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n#define MaxPixelChannels  32\n#define ThrowTIFFException(severity,message) \\\n{ \\\n  if (pixel_info != (MemoryInfo *) NULL) \\\n    pixel_info=RelinquishVirtualMemory(pixel_info); \\\n  if (quantum_info != (QuantumInfo *) NULL) \\\n    quantum_info=DestroyQuantumInfo(quantum_info); \\\n  TIFFClose(tiff); \\\n  ThrowReaderException(severity,message); \\\n}\n\n  const char\n    *option;\n\n  float\n    *chromaticity = (float *) NULL,\n    x_position,\n    y_position,\n    x_resolution,\n    y_resolution;\n\n  Image\n    *image;\n\n  int\n    tiff_status = 0;\n\n  MagickBooleanType\n    more_frames;\n\n  MagickStatusType\n    status;\n\n  MemoryInfo\n    *pixel_info = (MemoryInfo *) NULL;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  size_t\n    number_pixels;\n\n  ssize_t\n    i,\n    scanline_size,\n    y;\n\n  TIFF\n    *tiff;\n\n  TIFFMethodType\n    method;\n\n  uint16\n    compress_tag = 0,\n    bits_per_sample = 0,\n    endian = 0,\n    extra_samples = 0,\n    interlace = 0,\n    max_sample_value = 0,\n    min_sample_value = 0,\n    orientation = 0,\n    pages = 0,\n    photometric = 0,\n    *sample_info = NULL,\n    sample_format = 0,\n    samples_per_pixel = 0,\n    units = 0,\n    value = 0;\n\n  uint32\n    height,\n    rows_per_strip,\n    width;\n\n  unsigned char\n    *pixels;\n\n  void\n    *sans[8] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };\n\n  /*\n    Open image.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) SetMagickThreadValue(tiff_exception,exception);\n  tiff=TIFFClientOpen(image->filename,\"rb\",(thandle_t) image,TIFFReadBlob,\n    TIFFWriteBlob,TIFFSeekBlob,TIFFCloseBlob,TIFFGetBlobSize,TIFFMapBlob,\n    TIFFUnmapBlob);\n  if (tiff == (TIFF *) NULL)\n    {\n      if (exception->severity == UndefinedException)\n        ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (exception->severity > ErrorException)\n    {\n      TIFFClose(tiff);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (image_info->number_scenes != 0)\n    {\n      /*\n        Generate blank images for subimage specification (e.g. image.tif[4].\n        We need to check the number of directores because it is possible that\n        the subimage(s) are stored in the photoshop profile.\n      */\n      if (image_info->scene < (size_t)TIFFNumberOfDirectories(tiff))\n        {\n          for (i=0; i < (ssize_t) image_info->scene; i++)\n          {\n            status=TIFFReadDirectory(tiff) != 0 ? MagickTrue : MagickFalse;\n            if (status == MagickFalse)\n              {\n                TIFFClose(tiff);\n                image=DestroyImageList(image);\n                return((Image *) NULL);\n              }\n            AcquireNextImage(image_info,image);\n            if (GetNextImageInList(image) == (Image *) NULL)\n              {\n                TIFFClose(tiff);\n                image=DestroyImageList(image);\n                return((Image *) NULL);\n              }\n            image=SyncNextImageInList(image);\n          }\n        }\n    }\n  more_frames=MagickTrue;\n  do\n  {\n    /* TIFFPrintDirectory(tiff,stdout,MagickFalse); */\n    photometric=PHOTOMETRIC_RGB;\n    if ((TIFFGetField(tiff,TIFFTAG_IMAGEWIDTH,&width) != 1) ||\n        (TIFFGetField(tiff,TIFFTAG_IMAGELENGTH,&height) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_PHOTOMETRIC,&photometric,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_COMPRESSION,&compress_tag,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_FILLORDER,&endian,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_PLANARCONFIG,&interlace,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLESPERPIXEL,&samples_per_pixel,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,&bits_per_sample,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLEFORMAT,&sample_format,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_MINSAMPLEVALUE,&min_sample_value,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_MAXSAMPLEVALUE,&max_sample_value,sans) != 1))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n    if (((sample_format != SAMPLEFORMAT_IEEEFP) || (bits_per_sample != 64)) &&\n        ((bits_per_sample <= 0) || (bits_per_sample > 32)))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CorruptImageError,\"UnsupportedBitsPerPixel\");\n      }\n    if (samples_per_pixel > MaxPixelChannels)\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CorruptImageError,\"MaximumChannelsExceeded\");\n      }\n    if (sample_format == SAMPLEFORMAT_IEEEFP)\n      (void) SetImageProperty(image,\"quantum:format\",\"floating-point\");\n    switch (photometric)\n    {\n      case PHOTOMETRIC_MINISBLACK:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"min-is-black\");\n        break;\n      }\n      case PHOTOMETRIC_MINISWHITE:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"min-is-white\");\n        break;\n      }\n      case PHOTOMETRIC_PALETTE:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"palette\");\n        break;\n      }\n      case PHOTOMETRIC_RGB:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"RGB\");\n        break;\n      }\n      case PHOTOMETRIC_CIELAB:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"CIELAB\");\n        break;\n      }\n      case PHOTOMETRIC_LOGL:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"CIE Log2(L)\");\n        break;\n      }\n      case PHOTOMETRIC_LOGLUV:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"LOGLUV\");\n        break;\n      }\n#if defined(PHOTOMETRIC_MASK)\n      case PHOTOMETRIC_MASK:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"MASK\");\n        break;\n      }\n#endif\n      case PHOTOMETRIC_SEPARATED:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"separated\");\n        break;\n      }\n      case PHOTOMETRIC_YCBCR:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"YCBCR\");\n        break;\n      }\n      default:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"unknown\");\n        break;\n      }\n    }\n    if (image->debug != MagickFalse)\n      {\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Geometry: %ux%u\",\n          (unsigned int) width,(unsigned int) height);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Interlace: %u\",\n          interlace);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Bits per sample: %u\",bits_per_sample);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Min sample value: %u\",min_sample_value);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Max sample value: %u\",max_sample_value);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Photometric \"\n          \"interpretation: %s\",GetImageProperty(image,\"tiff:photometric\"));\n      }\n    image->columns=(size_t) width;\n    image->rows=(size_t) height;\n    image->depth=(size_t) bits_per_sample;\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Image depth: %.20g\",\n        (double) image->depth);\n    image->endian=MSBEndian;\n    if (endian == FILLORDER_LSB2MSB)\n      image->endian=LSBEndian;\n#if defined(MAGICKCORE_HAVE_TIFFISBIGENDIAN)\n    if (TIFFIsBigEndian(tiff) == 0)\n      {\n        (void) SetImageProperty(image,\"tiff:endian\",\"lsb\");\n        image->endian=LSBEndian;\n      }\n    else\n      {\n        (void) SetImageProperty(image,\"tiff:endian\",\"msb\");\n        image->endian=MSBEndian;\n      }\n#endif\n    if ((photometric == PHOTOMETRIC_MINISBLACK) ||\n        (photometric == PHOTOMETRIC_MINISWHITE))\n      image->colorspace=GRAYColorspace;\n    if (photometric == PHOTOMETRIC_SEPARATED)\n      image->colorspace=CMYKColorspace;\n    if (photometric == PHOTOMETRIC_CIELAB)\n      image->colorspace=LabColorspace;\n    if ((photometric == PHOTOMETRIC_YCBCR) &&\n        (compress_tag != COMPRESSION_OJPEG) &&\n        (compress_tag != COMPRESSION_JPEG))\n      image->colorspace=YCbCrColorspace;\n    status=TIFFGetProfiles(tiff,image);\n    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    status=TIFFGetProperties(tiff,image);\n    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    option=GetImageOption(image_info,\"tiff:exif-properties\");\n    if ((option == (const char *) NULL) ||\n        (IsMagickTrue(option) != MagickFalse))\n      (void) TIFFGetEXIFProperties(tiff,image);\n    option=GetImageOption(image_info,\"tiff:gps-properties\");\n    if ((option == (const char *) NULL) ||\n        (IsMagickTrue(option) != MagickFalse))\n      (void) TIFFGetGPSProperties(tiff,image);\n    if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XRESOLUTION,&x_resolution,sans) == 1) &&\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_YRESOLUTION,&y_resolution,sans) == 1))\n      {\n        image->x_resolution=x_resolution;\n        image->y_resolution=y_resolution;\n      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_RESOLUTIONUNIT,&units,sans,sans) == 1)\n      {\n        if (units == RESUNIT_INCH)\n          image->units=PixelsPerInchResolution;\n        if (units == RESUNIT_CENTIMETER)\n          image->units=PixelsPerCentimeterResolution;\n      }\n    if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XPOSITION,&x_position,sans) == 1) &&\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_YPOSITION,&y_position,sans) == 1))\n      {\n        image->page.x=CastDoubleToLong(ceil(x_position*\n          image->x_resolution-0.5));\n        image->page.y=CastDoubleToLong(ceil(y_position*\n          image->y_resolution-0.5));\n      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_ORIENTATION,&orientation,sans) == 1)\n      image->orientation=(OrientationType) orientation;\n    if (TIFFGetField(tiff,TIFFTAG_WHITEPOINT,&chromaticity) == 1)\n      {\n        if ((chromaticity != (float *) NULL) && (*chromaticity != 0.0))\n          {\n            image->chromaticity.white_point.x=chromaticity[0];\n            image->chromaticity.white_point.y=chromaticity[1];\n          }\n      }\n    if (TIFFGetField(tiff,TIFFTAG_PRIMARYCHROMATICITIES,&chromaticity) == 1)\n      {\n        if ((chromaticity != (float *) NULL) && (*chromaticity != 0.0))\n          {\n            image->chromaticity.red_primary.x=chromaticity[0];\n            image->chromaticity.red_primary.y=chromaticity[1];\n            image->chromaticity.green_primary.x=chromaticity[2];\n            image->chromaticity.green_primary.y=chromaticity[3];\n            image->chromaticity.blue_primary.x=chromaticity[4];\n            image->chromaticity.blue_primary.y=chromaticity[5];\n          }\n      }\n#if defined(MAGICKCORE_HAVE_TIFFISCODECCONFIGURED) || (TIFFLIB_VERSION > 20040919)\n    if ((compress_tag != COMPRESSION_NONE) &&\n        (TIFFIsCODECConfigured(compress_tag) == 0))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CoderError,\"CompressNotSupported\");\n      }\n#endif\n    switch (compress_tag)\n    {\n      case COMPRESSION_NONE: image->compression=NoCompression; break;\n      case COMPRESSION_CCITTFAX3: image->compression=FaxCompression; break;\n      case COMPRESSION_CCITTFAX4: image->compression=Group4Compression; break;\n      case COMPRESSION_JPEG:\n      {\n         image->compression=JPEGCompression;\n#if defined(JPEG_SUPPORT)\n         {\n           char\n             sampling_factor[MaxTextExtent];\n\n           int\n             tiff_status;\n\n           uint16\n             horizontal,\n             vertical;\n\n           tiff_status=TIFFGetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,&horizontal,\n             &vertical);\n           if (tiff_status == 1)\n             {\n               (void) FormatLocaleString(sampling_factor,MaxTextExtent,\"%dx%d\",\n                 horizontal,vertical);\n               (void) SetImageProperty(image,\"jpeg:sampling-factor\",\n                 sampling_factor);\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"Sampling Factors: %s\",sampling_factor);\n             }\n         }\n#endif\n        break;\n      }\n      case COMPRESSION_OJPEG: image->compression=JPEGCompression; break;\n#if defined(COMPRESSION_LZMA)\n      case COMPRESSION_LZMA: image->compression=LZMACompression; break;\n#endif\n      case COMPRESSION_LZW: image->compression=LZWCompression; break;\n      case COMPRESSION_DEFLATE: image->compression=ZipCompression; break;\n      case COMPRESSION_ADOBE_DEFLATE: image->compression=ZipCompression; break;\n#if defined(COMPRESSION_WEBP)\n      case COMPRESSION_WEBP: image->compression=WebPCompression; break;\n#endif\n#if defined(COMPRESSION_ZSTD)\n      case COMPRESSION_ZSTD: image->compression=ZstdCompression; break;\n#endif\n      default: image->compression=RLECompression; break;\n    }\n    quantum_info=(QuantumInfo *) NULL;\n    if ((photometric == PHOTOMETRIC_PALETTE) &&\n        (pow(2.0,1.0*bits_per_sample) <= MaxColormapSize))\n      {\n        size_t\n          colors;\n\n        colors=(size_t) GetQuantumRange(bits_per_sample)+1;\n        if (AcquireImageColormap(image,colors) == MagickFalse)\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_PAGENUMBER,&value,&pages,sans) == 1)\n      image->scene=value;\n    if (image->storage_class == PseudoClass)\n      {\n        int\n          tiff_status;\n\n        size_t\n          range;\n\n        uint16\n          *blue_colormap = (uint16 *) NULL,\n          *green_colormap = (uint16 *) NULL,\n          *red_colormap = (uint16 *) NULL;\n\n        /*\n          Initialize colormap.\n        */\n        tiff_status=TIFFGetField(tiff,TIFFTAG_COLORMAP,&red_colormap,\n          &green_colormap,&blue_colormap);\n        if (tiff_status == 1)\n          {\n            if ((red_colormap != (uint16 *) NULL) &&\n                (green_colormap != (uint16 *) NULL) &&\n                (blue_colormap != (uint16 *) NULL))\n              {\n                range=255;  /* might be old style 8-bit colormap */\n                for (i=0; i < (ssize_t) image->colors; i++)\n                  if ((red_colormap[i] >= 256) || (green_colormap[i] >= 256) ||\n                      (blue_colormap[i] >= 256))\n                    {\n                      range=65535;\n                      break;\n                    }\n                for (i=0; i < (ssize_t) image->colors; i++)\n                {\n                  image->colormap[i].red=ClampToQuantum(((double)\n                    QuantumRange*red_colormap[i])/range);\n                  image->colormap[i].green=ClampToQuantum(((double)\n                    QuantumRange*green_colormap[i])/range);\n                  image->colormap[i].blue=ClampToQuantum(((double)\n                    QuantumRange*blue_colormap[i])/range);\n                }\n              }\n          }\n      }\n    if (image_info->ping != MagickFalse)\n      {\n        if (image_info->number_scenes != 0)\n          if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n            break;\n        goto next_tiff_frame;\n      }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    status=SetImageColorspace(image,image->colorspace);\n    status&=ResetImagePixels(image,exception);\n    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    /*\n      Allocate memory for the image and pixel buffer.\n    */\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if (sample_format == SAMPLEFORMAT_UINT)\n      status=SetQuantumFormat(image,quantum_info,UnsignedQuantumFormat);\n    if (sample_format == SAMPLEFORMAT_INT)\n      status=SetQuantumFormat(image,quantum_info,SignedQuantumFormat);\n    if (sample_format == SAMPLEFORMAT_IEEEFP)\n      status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);\n    if (status == MagickFalse)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n    status=MagickTrue;\n    switch (photometric)\n    {\n      case PHOTOMETRIC_MINISBLACK:\n      {\n        quantum_info->min_is_white=MagickFalse;\n        break;\n      }\n      case PHOTOMETRIC_MINISWHITE:\n      {\n        quantum_info->min_is_white=MagickTrue;\n        break;\n      }\n      default:\n        break;\n    }\n    extra_samples=0;\n    tiff_status=TIFFGetFieldDefaulted(tiff,TIFFTAG_EXTRASAMPLES,&extra_samples,\n      &sample_info,sans);\n    if (tiff_status == 1)\n      {\n        (void) SetImageProperty(image,\"tiff:alpha\",\"unspecified\");\n        if (extra_samples == 0)\n          {\n            if ((samples_per_pixel == 4) && (photometric == PHOTOMETRIC_RGB))\n              image->matte=MagickTrue;\n          }\n        else\n          for (i=0; i < extra_samples; i++)\n          {\n            image->matte=MagickTrue;\n            if (sample_info[i] == EXTRASAMPLE_ASSOCALPHA)\n              {\n                SetQuantumAlphaType(quantum_info,AssociatedQuantumAlpha);\n                (void) SetImageProperty(image,\"tiff:alpha\",\"associated\");\n              }\n            else\n              if (sample_info[i] == EXTRASAMPLE_UNASSALPHA)\n                {\n                  SetQuantumAlphaType(quantum_info,DisassociatedQuantumAlpha);\n                  (void) SetImageProperty(image,\"tiff:alpha\",\"unassociated\");\n                }\n          }\n      }\n    if (image->matte != MagickFalse)\n      (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);\n    method=ReadGenericMethod;\n    rows_per_strip=(uint32) image->rows;\n    if (TIFFGetField(tiff,TIFFTAG_ROWSPERSTRIP,&rows_per_strip) == 1)\n      {\n        char\n          value[MaxTextExtent];\n\n        (void) FormatLocaleString(value,MaxTextExtent,\"%u\",(unsigned int)\n          rows_per_strip);\n        (void) SetImageProperty(image,\"tiff:rows-per-strip\",value);\n        method=ReadStripMethod;\n        if (rows_per_strip > (uint32) image->rows)\n          rows_per_strip=(uint32) image->rows;\n      }\n    if (TIFFIsTiled(tiff) != MagickFalse)\n      {\n        uint32\n          columns,\n          rows;\n\n        if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns) != 1) ||\n            (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))\n          ThrowTIFFException(CoderError,\"ImageIsNotTiled\");\n        if ((AcquireMagickResource(WidthResource,columns) == MagickFalse) ||\n            (AcquireMagickResource(HeightResource,rows) == MagickFalse))\n          ThrowTIFFException(ImageError,\"WidthOrHeightExceedsLimit\");\n        method=ReadTileMethod;\n      }\n    if ((photometric == PHOTOMETRIC_LOGLUV) ||\n        (compress_tag == COMPRESSION_CCITTFAX3))\n      method=ReadGenericMethod;\n    if (image->compression == JPEGCompression)\n      method=GetJPEGMethod(image,tiff,photometric,bits_per_sample,\n        samples_per_pixel);\n    quantum_info->endian=LSBEndian;\n    scanline_size=TIFFScanlineSize(tiff);\n    if (scanline_size <= 0)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n    number_pixels=MagickMax((MagickSizeType) image->columns*samples_per_pixel*\n      pow(2.0,ceil(log(bits_per_sample)/log(2.0))),image->columns*\n      rows_per_strip);\n    if ((double) scanline_size > 1.5*number_pixels)\n      ThrowTIFFException(CorruptImageError,\"CorruptImage\");\n    number_pixels=MagickMax((MagickSizeType) scanline_size,number_pixels);\n    pixel_info=AcquireVirtualMemory(number_pixels,sizeof(uint32));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    (void) ResetMagickMemory(pixels,0,number_pixels*sizeof(uint32));\n    quantum_type=GrayQuantum;\n    if (image->storage_class == PseudoClass)\n      quantum_type=IndexQuantum;\n    if (interlace != PLANARCONFIG_SEPARATE)\n      {\n        size_t\n          pad;\n\n        pad=(size_t) MagickMax((ssize_t) samples_per_pixel-1,0);\n        if (image->matte != MagickFalse)\n          {\n            if (image->storage_class == PseudoClass)\n              quantum_type=IndexAlphaQuantum;\n            else\n              quantum_type=samples_per_pixel == 1 ? AlphaQuantum :\n                GrayAlphaQuantum;\n          }\n        if ((samples_per_pixel > 2) && (interlace != PLANARCONFIG_SEPARATE))\n          {\n            quantum_type=RGBQuantum;\n            pad=(size_t) MagickMax((ssize_t) samples_per_pixel+\n              extra_samples-3,0);\n            if (image->matte != MagickFalse)\n              {\n                quantum_type=RGBAQuantum;\n                pad=(size_t) MagickMax((ssize_t) samples_per_pixel+\n                  extra_samples-4,0);\n              }\n            if (image->colorspace == CMYKColorspace)\n              {\n                quantum_type=CMYKQuantum;\n                pad=(size_t) MagickMax((ssize_t) samples_per_pixel+\n                  extra_samples-4,0);\n                if (image->matte != MagickFalse)\n                  {\n                    quantum_type=CMYKAQuantum;\n                    pad=(size_t) MagickMax((ssize_t) samples_per_pixel+\n                      extra_samples-5,0);\n                  }\n              }\n            status=SetQuantumPad(image,quantum_info,pad*((bits_per_sample+7) >>\n              3));\n            if (status == MagickFalse)\n              ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n      }\n    switch (method)\n    {\n      case ReadYCCKMethod:\n      {\n        /*\n          Convert YCC TIFF image.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          int\n            status;\n\n          IndexPacket\n            *indexes;\n\n          PixelPacket\n            *magick_restrict q;\n\n          ssize_t\n            x;\n\n          unsigned char\n            *p;\n\n          status=TIFFReadPixels(tiff,0,y,(char *) pixels);\n          if (status == -1)\n            break;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          indexes=GetAuthenticIndexQueue(image);\n          p=pixels;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelCyan(q,ScaleCharToQuantum(ClampYCC((double) *p+\n              (1.402*(double) *(p+2))-179.456)));\n            SetPixelMagenta(q,ScaleCharToQuantum(ClampYCC((double) *p-\n              (0.34414*(double) *(p+1))-(0.71414*(double ) *(p+2))+\n              135.45984)));\n            SetPixelYellow(q,ScaleCharToQuantum(ClampYCC((double) *p+\n              (1.772*(double) *(p+1))-226.816)));\n            SetPixelBlack(indexes+x,ScaleCharToQuantum((unsigned char)*(p+3)));\n            q++;\n            p+=4;\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case ReadStripMethod:\n      {\n        unsigned char\n          *p;\n\n        size_t\n          extent;\n\n        ssize_t\n          stride,\n          strip_id;\n\n        tsize_t\n          strip_size;\n\n        unsigned char\n          *strip_pixels;\n\n        /*\n          Convert stripped TIFF image.\n        */\n        extent=4*((image->depth+7)/8)*(samples_per_pixel+1)*TIFFStripSize(tiff);\n        strip_pixels=(unsigned char *) AcquireQuantumMemory(extent,\n          sizeof(*strip_pixels));\n        if (strip_pixels == (unsigned char *) NULL)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) memset(strip_pixels,0,extent*sizeof(*strip_pixels));\n        stride=TIFFVStripSize(tiff,1);\n        strip_id=0;\n        p=strip_pixels;\n        for (i=0; i < (ssize_t) samples_per_pixel; i++)\n        {\n          size_t\n            rows_remaining;\n\n          switch (i)\n          {\n            case 0: break;\n            case 1: quantum_type=GreenQuantum; break;\n            case 2: quantum_type=BlueQuantum; break;\n            case 3:\n            {\n              quantum_type=AlphaQuantum;\n              if (image->colorspace == CMYKColorspace)\n                quantum_type=BlackQuantum;\n              break;\n            }\n            case 4: quantum_type=AlphaQuantum; break;\n            default: break;\n          }\n          rows_remaining=0;\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            PixelPacket\n              *magick_restrict q;\n\n            q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (PixelPacket *) NULL)\n              break;\n            if (rows_remaining == 0)\n              {\n                strip_size=TIFFReadEncodedStrip(tiff,strip_id,strip_pixels,\n                  TIFFStripSize(tiff));\n                if (strip_size == -1)\n                  break;\n                rows_remaining=rows_per_strip;\n                if ((y+rows_per_strip) > (ssize_t) image->rows)\n                  rows_remaining=(rows_per_strip-(y+rows_per_strip-\n                    image->rows));\n                p=strip_pixels;\n                strip_id++;\n              }\n            (void) ImportQuantumPixels(image,(CacheView *) NULL,\n              quantum_info,quantum_type,p,exception);\n            p+=stride;\n            rows_remaining--;\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                  image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n         if ((samples_per_pixel > 1) && (interlace != PLANARCONFIG_SEPARATE))\n            break;\n        }\n        strip_pixels=(unsigned char *) RelinquishMagickMemory(strip_pixels);\n        break;\n      }\n      case ReadTileMethod:\n      {\n        unsigned char\n          *p;\n\n        size_t\n          extent;\n\n        uint32\n          columns,\n          rows;\n\n        unsigned char\n          *tile_pixels;\n\n        /*\n          Convert tiled TIFF image.\n        */\n        if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns) != 1) ||\n            (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))\n          ThrowTIFFException(CoderError,\"ImageIsNotTiled\");\n        number_pixels=(MagickSizeType) columns*rows;\n        if (HeapOverflowSanityCheck(rows,sizeof(*tile_pixels)) != MagickFalse)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        extent=4*(samples_per_pixel+1)*MagickMax(rows*TIFFTileRowSize(tiff),\n          TIFFTileSize(tiff));\n        tile_pixels=(unsigned char *) AcquireQuantumMemory(extent,\n          sizeof(*tile_pixels));\n        if (tile_pixels == (unsigned char *) NULL)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) memset(tile_pixels,0,extent*sizeof(*tile_pixels));\n        for (i=0; i < (ssize_t) samples_per_pixel; i++)\n        {\n          switch (i)\n          {\n            case 0: break;\n            case 1: quantum_type=GreenQuantum; break;\n            case 2: quantum_type=BlueQuantum; break;\n            case 3:\n            {\n              quantum_type=AlphaQuantum;\n              if (image->colorspace == CMYKColorspace)\n                quantum_type=BlackQuantum;\n              break;\n            }\n            case 4: quantum_type=AlphaQuantum; break;\n            default: break;\n          }\n          for (y=0; y < (ssize_t) image->rows; y+=rows)\n          {\n            ssize_t\n              x;\n\n            size_t\n              rows_remaining;\n\n            rows_remaining=image->rows-y;\n            if ((ssize_t) (y+rows) < (ssize_t) image->rows)\n              rows_remaining=rows;\n            for (x=0; x < (ssize_t) image->columns; x+=columns)\n            {\n              size_t\n                columns_remaining,\n                row;\n\n              columns_remaining=image->columns-x;\n              if ((ssize_t) (x+columns) < (ssize_t) image->columns)\n                columns_remaining=columns;\n              tiff_status=TIFFReadTile(tiff,tile_pixels,(uint32) x,(uint32) y,\n                0,i);\n              if (tiff_status == -1)\n                break;\n              p=tile_pixels;\n              for (row=0; row < rows_remaining; row++)\n              {\n                PixelPacket\n                  *magick_restrict q;\n\n                q=GetAuthenticPixels(image,x,y+row,columns_remaining,1,\n                  exception);\n                if (q == (PixelPacket *) NULL)\n                  break;\n                (void) ImportQuantumPixels(image,(CacheView *) NULL,\n                  quantum_info,quantum_type,p,exception);\n                p+=TIFFTileRowSize(tiff);\n                if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                  break;\n              }\n            }\n          }\n          if ((samples_per_pixel > 1) && (interlace != PLANARCONFIG_SEPARATE))\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) i,\n                samples_per_pixel);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        tile_pixels=(unsigned char *) RelinquishMagickMemory(tile_pixels);\n        break;\n      }\n      case ReadGenericMethod:\n      default:\n      {\n        MemoryInfo\n          *generic_info = (MemoryInfo *) NULL;\n\n        uint32\n          *p;\n\n        uint32\n          *pixels;\n\n        /*\n          Convert generic TIFF image.\n        */\n        if (HeapOverflowSanityCheck(image->rows,sizeof(*pixels)) != MagickFalse)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        number_pixels=(MagickSizeType) image->columns*image->rows;\n        generic_info=AcquireVirtualMemory(number_pixels,sizeof(*pixels));\n        if (generic_info == (MemoryInfo *) NULL)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        pixels=(uint32 *) GetVirtualMemoryBlob(generic_info);\n        tiff_status=TIFFReadRGBAImage(tiff,(uint32) image->columns,(uint32)\n          image->rows,(uint32 *) pixels,0);\n        if (tiff_status == -1)\n          {\n            generic_info=RelinquishVirtualMemory(generic_info);\n            break;\n          }\n        p=pixels+(image->columns*image->rows)-1;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          ssize_t\n            x;\n\n          PixelPacket\n            *magick_restrict q;\n\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          q+=image->columns-1;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(q,ScaleCharToQuantum((unsigned char) TIFFGetR(*p)));\n            SetPixelGreen(q,ScaleCharToQuantum((unsigned char) TIFFGetG(*p)));\n            SetPixelBlue(q,ScaleCharToQuantum((unsigned char) TIFFGetB(*p)));\n            if (image->matte == MagickFalse)\n              SetPixelOpacity(q,OpaqueOpacity);\n            else\n              SetPixelAlpha(q,ScaleCharToQuantum((unsigned char) TIFFGetA(*p)));\n            p--;\n            q--;\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        generic_info=RelinquishVirtualMemory(generic_info);\n        break;\n      }\n    }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    SetQuantumImageType(image,quantum_type);\n  next_tiff_frame:\n    if (quantum_info != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n    if (tiff_status == -1)\n      {\n        status=MagickFalse;\n        break;\n      }\n    if (photometric == PHOTOMETRIC_CIELAB)\n      DecodeLabImage(image,exception);\n    if ((photometric == PHOTOMETRIC_LOGL) ||\n        (photometric == PHOTOMETRIC_MINISBLACK) ||\n        (photometric == PHOTOMETRIC_MINISWHITE))\n      {\n        image->type=GrayscaleType;\n        if (bits_per_sample == 1)\n          image->type=BilevelType;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    more_frames=TIFFReadDirectory(tiff) != 0 ? MagickTrue : MagickFalse;\n    if (more_frames != MagickFalse)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            status=MagickFalse;\n            break;\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,image->scene-1,\n          image->scene);\n        if (status == MagickFalse)\n          break;\n      }\n  } while ((status != MagickFalse) && (more_frames != MagickFalse));\n  TIFFClose(tiff);\n  if ((image_info->number_scenes != 0) &&\n      (image_info->scene >= GetImageListLength(image)))\n    status=MagickFalse;\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  TIFFReadPhotoshopLayers(image_info,image,exception);\n  return(GetFirstImageInList(image));\n}", "func_hash": 299907120858996373991818547886083873911, "file_name": "tiff.c", "file_hash": 106627250122948436089504190965714390547, "cwe": ["CWE-787"], "cve": "CVE-2022-3213", "cve_desc": "A heap buffer overflow issue was found in ImageMagick. When an application processes a malformed TIFF file, it could lead to undefined behavior or a crash causing a denial of service.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-3213", "file_path": "coders/tiff.c"}
{"idx": 211877, "project": "libexpat", "commit_id": "a2fe525e660badd64b6c557c2b1ec26ddc07f6e4", "project_url": "https://github.com/libexpat/libexpat", "commit_url": "https://github.com/libexpat/libexpat/commit/a2fe525e660badd64b6c557c2b1ec26ddc07f6e4", "commit_message": "lib: Protect against malicious namespace declarations (CVE-2022-25236)", "target": 1, "func": "addBinding(XML_Parser parser, PREFIX *prefix, const ATTRIBUTE_ID *attId,\n           const XML_Char *uri, BINDING **bindingsPtr) {\n  static const XML_Char xmlNamespace[]\n      = {ASCII_h,      ASCII_t,     ASCII_t,     ASCII_p,      ASCII_COLON,\n         ASCII_SLASH,  ASCII_SLASH, ASCII_w,     ASCII_w,      ASCII_w,\n         ASCII_PERIOD, ASCII_w,     ASCII_3,     ASCII_PERIOD, ASCII_o,\n         ASCII_r,      ASCII_g,     ASCII_SLASH, ASCII_X,      ASCII_M,\n         ASCII_L,      ASCII_SLASH, ASCII_1,     ASCII_9,      ASCII_9,\n         ASCII_8,      ASCII_SLASH, ASCII_n,     ASCII_a,      ASCII_m,\n         ASCII_e,      ASCII_s,     ASCII_p,     ASCII_a,      ASCII_c,\n         ASCII_e,      '\\0'};\n  static const int xmlLen = (int)sizeof(xmlNamespace) / sizeof(XML_Char) - 1;\n  static const XML_Char xmlnsNamespace[]\n      = {ASCII_h,     ASCII_t,      ASCII_t, ASCII_p, ASCII_COLON,  ASCII_SLASH,\n         ASCII_SLASH, ASCII_w,      ASCII_w, ASCII_w, ASCII_PERIOD, ASCII_w,\n         ASCII_3,     ASCII_PERIOD, ASCII_o, ASCII_r, ASCII_g,      ASCII_SLASH,\n         ASCII_2,     ASCII_0,      ASCII_0, ASCII_0, ASCII_SLASH,  ASCII_x,\n         ASCII_m,     ASCII_l,      ASCII_n, ASCII_s, ASCII_SLASH,  '\\0'};\n  static const int xmlnsLen\n      = (int)sizeof(xmlnsNamespace) / sizeof(XML_Char) - 1;\n\n  XML_Bool mustBeXML = XML_FALSE;\n  XML_Bool isXML = XML_TRUE;\n  XML_Bool isXMLNS = XML_TRUE;\n\n  BINDING *b;\n  int len;\n\n  /* empty URI is only valid for default namespace per XML NS 1.0 (not 1.1) */\n  if (*uri == XML_T('\\0') && prefix->name)\n    return XML_ERROR_UNDECLARING_PREFIX;\n\n  if (prefix->name && prefix->name[0] == XML_T(ASCII_x)\n      && prefix->name[1] == XML_T(ASCII_m)\n      && prefix->name[2] == XML_T(ASCII_l)) {\n    /* Not allowed to bind xmlns */\n    if (prefix->name[3] == XML_T(ASCII_n) && prefix->name[4] == XML_T(ASCII_s)\n        && prefix->name[5] == XML_T('\\0'))\n      return XML_ERROR_RESERVED_PREFIX_XMLNS;\n\n    if (prefix->name[3] == XML_T('\\0'))\n      mustBeXML = XML_TRUE;\n  }\n\n  for (len = 0; uri[len]; len++) {\n    if (isXML && (len > xmlLen || uri[len] != xmlNamespace[len]))\n      isXML = XML_FALSE;\n\n    if (! mustBeXML && isXMLNS\n        && (len > xmlnsLen || uri[len] != xmlnsNamespace[len]))\n      isXMLNS = XML_FALSE;\n  }\n  isXML = isXML && len == xmlLen;\n  isXMLNS = isXMLNS && len == xmlnsLen;\n\n  if (mustBeXML != isXML)\n    return mustBeXML ? XML_ERROR_RESERVED_PREFIX_XML\n                     : XML_ERROR_RESERVED_NAMESPACE_URI;\n\n  if (isXMLNS)\n    return XML_ERROR_RESERVED_NAMESPACE_URI;\n\n  if (parser->m_namespaceSeparator)\n    len++;\n  if (parser->m_freeBindingList) {\n    b = parser->m_freeBindingList;\n    if (len > b->uriAlloc) {\n      /* Detect and prevent integer overflow */\n      if (len > INT_MAX - EXPAND_SPARE) {\n        return XML_ERROR_NO_MEMORY;\n      }\n\n      /* Detect and prevent integer overflow.\n       * The preprocessor guard addresses the \"always false\" warning\n       * from -Wtype-limits on platforms where\n       * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */\n#if UINT_MAX >= SIZE_MAX\n      if ((unsigned)(len + EXPAND_SPARE) > (size_t)(-1) / sizeof(XML_Char)) {\n        return XML_ERROR_NO_MEMORY;\n      }\n#endif\n\n      XML_Char *temp = (XML_Char *)REALLOC(\n          parser, b->uri, sizeof(XML_Char) * (len + EXPAND_SPARE));\n      if (temp == NULL)\n        return XML_ERROR_NO_MEMORY;\n      b->uri = temp;\n      b->uriAlloc = len + EXPAND_SPARE;\n    }\n    parser->m_freeBindingList = b->nextTagBinding;\n  } else {\n    b = (BINDING *)MALLOC(parser, sizeof(BINDING));\n    if (! b)\n      return XML_ERROR_NO_MEMORY;\n\n    /* Detect and prevent integer overflow */\n    if (len > INT_MAX - EXPAND_SPARE) {\n      return XML_ERROR_NO_MEMORY;\n    }\n    /* Detect and prevent integer overflow.\n     * The preprocessor guard addresses the \"always false\" warning\n     * from -Wtype-limits on platforms where\n     * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */\n#if UINT_MAX >= SIZE_MAX\n    if ((unsigned)(len + EXPAND_SPARE) > (size_t)(-1) / sizeof(XML_Char)) {\n      return XML_ERROR_NO_MEMORY;\n    }\n#endif\n\n    b->uri\n        = (XML_Char *)MALLOC(parser, sizeof(XML_Char) * (len + EXPAND_SPARE));\n    if (! b->uri) {\n      FREE(parser, b);\n      return XML_ERROR_NO_MEMORY;\n    }\n    b->uriAlloc = len + EXPAND_SPARE;\n  }\n  b->uriLen = len;\n  memcpy(b->uri, uri, len * sizeof(XML_Char));\n  if (parser->m_namespaceSeparator)\n    b->uri[len - 1] = parser->m_namespaceSeparator;\n  b->prefix = prefix;\n  b->attId = attId;\n  b->prevPrefixBinding = prefix->binding;\n  /* NULL binding when default namespace undeclared */\n  if (*uri == XML_T('\\0') && prefix == &parser->m_dtd->defaultPrefix)\n    prefix->binding = NULL;\n  else\n    prefix->binding = b;\n  b->nextTagBinding = *bindingsPtr;\n  *bindingsPtr = b;\n  /* if attId == NULL then we are not starting a namespace scope */\n  if (attId && parser->m_startNamespaceDeclHandler)\n    parser->m_startNamespaceDeclHandler(parser->m_handlerArg, prefix->name,\n                                        prefix->binding ? uri : 0);\n  return XML_ERROR_NONE;\n}", "func_hash": 22295362737021887331084829836677682659, "file_name": "xmlparse.c", "file_hash": 64970761866861782031621044957132437337, "cwe": ["CWE-668"], "cve": "CVE-2022-25236", "cve_desc": "xmlparse.c in Expat (aka libexpat) before 2.4.5 allows attackers to insert namespace-separator characters into namespace URIs.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-25236", "file_path": "expat/lib/xmlparse.c"}
{"idx": 453109, "project": "libexpat", "commit_id": "a2fe525e660badd64b6c557c2b1ec26ddc07f6e4", "project_url": "https://github.com/libexpat/libexpat", "commit_url": "https://github.com/libexpat/libexpat/commit/a2fe525e660badd64b6c557c2b1ec26ddc07f6e4", "commit_message": "lib: Protect against malicious namespace declarations (CVE-2022-25236)", "target": 0, "func": "addBinding(XML_Parser parser, PREFIX *prefix, const ATTRIBUTE_ID *attId,\n           const XML_Char *uri, BINDING **bindingsPtr) {\n  static const XML_Char xmlNamespace[]\n      = {ASCII_h,      ASCII_t,     ASCII_t,     ASCII_p,      ASCII_COLON,\n         ASCII_SLASH,  ASCII_SLASH, ASCII_w,     ASCII_w,      ASCII_w,\n         ASCII_PERIOD, ASCII_w,     ASCII_3,     ASCII_PERIOD, ASCII_o,\n         ASCII_r,      ASCII_g,     ASCII_SLASH, ASCII_X,      ASCII_M,\n         ASCII_L,      ASCII_SLASH, ASCII_1,     ASCII_9,      ASCII_9,\n         ASCII_8,      ASCII_SLASH, ASCII_n,     ASCII_a,      ASCII_m,\n         ASCII_e,      ASCII_s,     ASCII_p,     ASCII_a,      ASCII_c,\n         ASCII_e,      '\\0'};\n  static const int xmlLen = (int)sizeof(xmlNamespace) / sizeof(XML_Char) - 1;\n  static const XML_Char xmlnsNamespace[]\n      = {ASCII_h,     ASCII_t,      ASCII_t, ASCII_p, ASCII_COLON,  ASCII_SLASH,\n         ASCII_SLASH, ASCII_w,      ASCII_w, ASCII_w, ASCII_PERIOD, ASCII_w,\n         ASCII_3,     ASCII_PERIOD, ASCII_o, ASCII_r, ASCII_g,      ASCII_SLASH,\n         ASCII_2,     ASCII_0,      ASCII_0, ASCII_0, ASCII_SLASH,  ASCII_x,\n         ASCII_m,     ASCII_l,      ASCII_n, ASCII_s, ASCII_SLASH,  '\\0'};\n  static const int xmlnsLen\n      = (int)sizeof(xmlnsNamespace) / sizeof(XML_Char) - 1;\n\n  XML_Bool mustBeXML = XML_FALSE;\n  XML_Bool isXML = XML_TRUE;\n  XML_Bool isXMLNS = XML_TRUE;\n\n  BINDING *b;\n  int len;\n\n  /* empty URI is only valid for default namespace per XML NS 1.0 (not 1.1) */\n  if (*uri == XML_T('\\0') && prefix->name)\n    return XML_ERROR_UNDECLARING_PREFIX;\n\n  if (prefix->name && prefix->name[0] == XML_T(ASCII_x)\n      && prefix->name[1] == XML_T(ASCII_m)\n      && prefix->name[2] == XML_T(ASCII_l)) {\n    /* Not allowed to bind xmlns */\n    if (prefix->name[3] == XML_T(ASCII_n) && prefix->name[4] == XML_T(ASCII_s)\n        && prefix->name[5] == XML_T('\\0'))\n      return XML_ERROR_RESERVED_PREFIX_XMLNS;\n\n    if (prefix->name[3] == XML_T('\\0'))\n      mustBeXML = XML_TRUE;\n  }\n\n  for (len = 0; uri[len]; len++) {\n    if (isXML && (len > xmlLen || uri[len] != xmlNamespace[len]))\n      isXML = XML_FALSE;\n\n    if (! mustBeXML && isXMLNS\n        && (len > xmlnsLen || uri[len] != xmlnsNamespace[len]))\n      isXMLNS = XML_FALSE;\n\n    // NOTE: While Expat does not validate namespace URIs against RFC 3986,\n    //       we have to at least make sure that the XML processor on top of\n    //       Expat (that is splitting tag names by namespace separator into\n    //       2- or 3-tuples (uri-local or uri-local-prefix)) cannot be confused\n    //       by an attacker putting additional namespace separator characters\n    //       into namespace declarations.  That would be ambiguous and not to\n    //       be expected.\n    if (parser->m_ns && (uri[len] == parser->m_namespaceSeparator)) {\n      return XML_ERROR_SYNTAX;\n    }\n  }\n  isXML = isXML && len == xmlLen;\n  isXMLNS = isXMLNS && len == xmlnsLen;\n\n  if (mustBeXML != isXML)\n    return mustBeXML ? XML_ERROR_RESERVED_PREFIX_XML\n                     : XML_ERROR_RESERVED_NAMESPACE_URI;\n\n  if (isXMLNS)\n    return XML_ERROR_RESERVED_NAMESPACE_URI;\n\n  if (parser->m_namespaceSeparator)\n    len++;\n  if (parser->m_freeBindingList) {\n    b = parser->m_freeBindingList;\n    if (len > b->uriAlloc) {\n      /* Detect and prevent integer overflow */\n      if (len > INT_MAX - EXPAND_SPARE) {\n        return XML_ERROR_NO_MEMORY;\n      }\n\n      /* Detect and prevent integer overflow.\n       * The preprocessor guard addresses the \"always false\" warning\n       * from -Wtype-limits on platforms where\n       * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */\n#if UINT_MAX >= SIZE_MAX\n      if ((unsigned)(len + EXPAND_SPARE) > (size_t)(-1) / sizeof(XML_Char)) {\n        return XML_ERROR_NO_MEMORY;\n      }\n#endif\n\n      XML_Char *temp = (XML_Char *)REALLOC(\n          parser, b->uri, sizeof(XML_Char) * (len + EXPAND_SPARE));\n      if (temp == NULL)\n        return XML_ERROR_NO_MEMORY;\n      b->uri = temp;\n      b->uriAlloc = len + EXPAND_SPARE;\n    }\n    parser->m_freeBindingList = b->nextTagBinding;\n  } else {\n    b = (BINDING *)MALLOC(parser, sizeof(BINDING));\n    if (! b)\n      return XML_ERROR_NO_MEMORY;\n\n    /* Detect and prevent integer overflow */\n    if (len > INT_MAX - EXPAND_SPARE) {\n      return XML_ERROR_NO_MEMORY;\n    }\n    /* Detect and prevent integer overflow.\n     * The preprocessor guard addresses the \"always false\" warning\n     * from -Wtype-limits on platforms where\n     * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */\n#if UINT_MAX >= SIZE_MAX\n    if ((unsigned)(len + EXPAND_SPARE) > (size_t)(-1) / sizeof(XML_Char)) {\n      return XML_ERROR_NO_MEMORY;\n    }\n#endif\n\n    b->uri\n        = (XML_Char *)MALLOC(parser, sizeof(XML_Char) * (len + EXPAND_SPARE));\n    if (! b->uri) {\n      FREE(parser, b);\n      return XML_ERROR_NO_MEMORY;\n    }\n    b->uriAlloc = len + EXPAND_SPARE;\n  }\n  b->uriLen = len;\n  memcpy(b->uri, uri, len * sizeof(XML_Char));\n  if (parser->m_namespaceSeparator)\n    b->uri[len - 1] = parser->m_namespaceSeparator;\n  b->prefix = prefix;\n  b->attId = attId;\n  b->prevPrefixBinding = prefix->binding;\n  /* NULL binding when default namespace undeclared */\n  if (*uri == XML_T('\\0') && prefix == &parser->m_dtd->defaultPrefix)\n    prefix->binding = NULL;\n  else\n    prefix->binding = b;\n  b->nextTagBinding = *bindingsPtr;\n  *bindingsPtr = b;\n  /* if attId == NULL then we are not starting a namespace scope */\n  if (attId && parser->m_startNamespaceDeclHandler)\n    parser->m_startNamespaceDeclHandler(parser->m_handlerArg, prefix->name,\n                                        prefix->binding ? uri : 0);\n  return XML_ERROR_NONE;\n}", "func_hash": 180909609780994811991308792390157424153, "file_name": "xmlparse.c", "file_hash": 39872007825496999526918942248087494728, "cwe": ["CWE-668"], "cve": "CVE-2022-25236", "cve_desc": "xmlparse.c in Expat (aka libexpat) before 2.4.5 allows attackers to insert namespace-separator characters into namespace URIs.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-25236", "file_path": "expat/lib/xmlparse.c"}
{"idx": 211915, "project": "jasper", "commit_id": "839b1bcf0450ff036c28e8db40a7abf886e02891", "project_url": "https://github.com/mdadams/jasper", "commit_url": "https://github.com/jasper-software/jasper/commit/839b1bcf0450ff036c28e8db40a7abf886e02891", "commit_message": "jp2_dec: fix `numchans` mixup\n\nWhen iterating over `dec->cdef->data.cdef.ents`, we need to use its\n`numchans` variable, not the one in `jp2_dec_t`.\n\nFixes CVE-2018-19543\nFixes CVE-2017-9782\n\nCloses https://github.com/jasper-maint/jasper/issues/13\nCloses https://github.com/jasper-maint/jasper/issues/18\nCloses https://github.com/mdadams/jasper/issues/140\nCloses https://github.com/mdadams/jasper/issues/182", "target": 1, "func": "jas_image_t *jp2_decode(jas_stream_t *in, const char *optstr)\n{\n\tjp2_box_t *box;\n\tint found;\n\tjas_image_t *image;\n\tjp2_dec_t *dec;\n\tbool samedtype;\n\tint dtype;\n\tunsigned int i;\n\tjp2_cmap_t *cmapd;\n\tjp2_pclr_t *pclrd;\n\tjp2_cdef_t *cdefd;\n\tunsigned int channo;\n\tint newcmptno;\n\tint_fast32_t *lutents;\n#if 0\n\tjp2_cdefchan_t *cdefent;\n\tint cmptno;\n#endif\n\tjp2_cmapent_t *cmapent;\n\tjas_icchdr_t icchdr;\n\tjas_iccprof_t *iccprof;\n\n\tdec = 0;\n\tbox = 0;\n\timage = 0;\n\n\tJAS_DBGLOG(100, (\"jp2_decode(%p, \\\"%s\\\")\\n\", in, optstr));\n\n\tif (!(dec = jp2_dec_create())) {\n\t\tgoto error;\n\t}\n\n\t/* Get the first box.  This should be a JP box. */\n\tif (!(box = jp2_box_get(in))) {\n\t\tjas_eprintf(\"error: cannot get box\\n\");\n\t\tgoto error;\n\t}\n\tif (box->type != JP2_BOX_JP) {\n\t\tjas_eprintf(\"error: expecting signature box\\n\");\n\t\tgoto error;\n\t}\n\tif (box->data.jp.magic != JP2_JP_MAGIC) {\n\t\tjas_eprintf(\"incorrect magic number\\n\");\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/* Get the second box.  This should be a FTYP box. */\n\tif (!(box = jp2_box_get(in))) {\n\t\tgoto error;\n\t}\n\tif (box->type != JP2_BOX_FTYP) {\n\t\tjas_eprintf(\"expecting file type box\\n\");\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/* Get more boxes... */\n\tfound = 0;\n\twhile ((box = jp2_box_get(in))) {\n\t\tif (jas_getdbglevel() >= 1) {\n\t\t\tjas_eprintf(\"got box type %s\\n\", box->info->name);\n\t\t}\n\t\tswitch (box->type) {\n\t\tcase JP2_BOX_JP2C:\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\tcase JP2_BOX_IHDR:\n\t\t\tif (!dec->ihdr) {\n\t\t\t\tdec->ihdr = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_BPCC:\n\t\t\tif (!dec->bpcc) {\n\t\t\t\tdec->bpcc = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_CDEF:\n\t\t\tif (!dec->cdef) {\n\t\t\t\tdec->cdef = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_PCLR:\n\t\t\tif (!dec->pclr) {\n\t\t\t\tdec->pclr = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_CMAP:\n\t\t\tif (!dec->cmap) {\n\t\t\t\tdec->cmap = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_COLR:\n\t\t\tif (!dec->colr) {\n\t\t\t\tdec->colr = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (box) {\n\t\t\tjp2_box_destroy(box);\n\t\t\tbox = 0;\n\t\t}\n\t\tif (found) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tjas_eprintf(\"error: no code stream found\\n\");\n\t\tgoto error;\n\t}\n\n\tif (!(dec->image = jpc_decode(in, optstr))) {\n\t\tjas_eprintf(\"error: cannot decode code stream\\n\");\n\t\tgoto error;\n\t}\n\n\t/* An IHDR box must be present. */\n\tif (!dec->ihdr) {\n\t\tjas_eprintf(\"error: missing IHDR box\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Does the number of components indicated in the IHDR box match\n\t  the value specified in the code stream? */\n\tif (dec->ihdr->data.ihdr.numcmpts != JAS_CAST(jas_uint,\n\t  jas_image_numcmpts(dec->image))) {\n\t\tjas_eprintf(\"warning: number of components mismatch\\n\");\n\t}\n\n\t/* At least one component must be present. */\n\tif (!jas_image_numcmpts(dec->image)) {\n\t\tjas_eprintf(\"error: no components\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Determine if all components have the same data type. */\n\tsamedtype = true;\n\tdtype = jas_image_cmptdtype(dec->image, 0);\n\tfor (i = 1; i < JAS_CAST(jas_uint, jas_image_numcmpts(dec->image)); ++i) {\n\t\tif (jas_image_cmptdtype(dec->image, i) != dtype) {\n\t\t\tsamedtype = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Is the component data type indicated in the IHDR box consistent\n\t  with the data in the code stream? */\n\tif ((samedtype && dec->ihdr->data.ihdr.bpc != JP2_DTYPETOBPC(dtype)) ||\n\t  (!samedtype && dec->ihdr->data.ihdr.bpc != JP2_IHDR_BPCNULL)) {\n\t\tjas_eprintf(\"warning: component data type mismatch\\n\");\n\t}\n\n\t/* Is the compression type supported? */\n\tif (dec->ihdr->data.ihdr.comptype != JP2_IHDR_COMPTYPE) {\n\t\tjas_eprintf(\"error: unsupported compression type\\n\");\n\t\tgoto error;\n\t}\n\n\tif (dec->bpcc) {\n\t\t/* Is the number of components indicated in the BPCC box\n\t\t  consistent with the code stream data? */\n\t\tif (dec->bpcc->data.bpcc.numcmpts != JAS_CAST(jas_uint, jas_image_numcmpts(\n\t\t  dec->image))) {\n\t\t\tjas_eprintf(\"warning: number of components mismatch\\n\");\n\t\t}\n\t\t/* Is the component data type information indicated in the BPCC\n\t\t  box consistent with the code stream data? */\n\t\tif (!samedtype) {\n\t\t\tfor (i = 0; i < JAS_CAST(jas_uint, jas_image_numcmpts(dec->image));\n\t\t\t  ++i) {\n\t\t\t\tif (jas_image_cmptdtype(dec->image, i) !=\n\t\t\t\t  JP2_BPCTODTYPE(dec->bpcc->data.bpcc.bpcs[i])) {\n\t\t\t\t\tjas_eprintf(\"warning: component data type mismatch\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tjas_eprintf(\"warning: superfluous BPCC box\\n\");\n\t\t}\n\t}\n\n\t/* A COLR box must be present. */\n\tif (!dec->colr) {\n\t\tjas_eprintf(\"error: no COLR box\\n\");\n\t\tgoto error;\n\t}\n\n\tswitch (dec->colr->data.colr.method) {\n\tcase JP2_COLR_ENUM:\n\t\tjas_image_setclrspc(dec->image, jp2_getcs(&dec->colr->data.colr));\n\t\tbreak;\n\tcase JP2_COLR_ICC:\n\t\ticcprof = jas_iccprof_createfrombuf(dec->colr->data.colr.iccp,\n\t\t  dec->colr->data.colr.iccplen);\n\t\tif (!iccprof) {\n\t\t\tjas_eprintf(\"error: failed to parse ICC profile\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tjas_iccprof_gethdr(iccprof, &icchdr);\n\t\tjas_eprintf(\"ICC Profile CS %08x\\n\", icchdr.colorspc);\n\t\tjas_image_setclrspc(dec->image, fromiccpcs(icchdr.colorspc));\n\t\tdec->image->cmprof_ = jas_cmprof_createfromiccprof(iccprof);\n\t\tassert(dec->image->cmprof_);\n\t\tjas_iccprof_destroy(iccprof);\n\t\tbreak;\n\t}\n\n\t/* If a CMAP box is present, a PCLR box must also be present. */\n\tif (dec->cmap && !dec->pclr) {\n\t\tjas_eprintf(\"warning: missing PCLR box or superfluous CMAP box\\n\");\n\t\tjp2_box_destroy(dec->cmap);\n\t\tdec->cmap = 0;\n\t}\n\n\t/* If a CMAP box is not present, a PCLR box must not be present. */\n\tif (!dec->cmap && dec->pclr) {\n\t\tjas_eprintf(\"warning: missing CMAP box or superfluous PCLR box\\n\");\n\t\tjp2_box_destroy(dec->pclr);\n\t\tdec->pclr = 0;\n\t}\n\n\t/* Determine the number of channels (which is essentially the number\n\t  of components after any palette mappings have been applied). */\n\tdec->numchans = dec->cmap ? dec->cmap->data.cmap.numchans :\n\t  JAS_CAST(jas_uint, jas_image_numcmpts(dec->image));\n\n\t/* Perform a basic sanity check on the CMAP box if present. */\n\tif (dec->cmap) {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\t/* Is the component number reasonable? */\n\t\t\tif (dec->cmap->data.cmap.ents[i].cmptno >= JAS_CAST(jas_uint,\n\t\t\t  jas_image_numcmpts(dec->image))) {\n\t\t\t\tjas_eprintf(\"error: invalid component number in CMAP box\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\t/* Is the LUT index reasonable? */\n\t\t\tif (dec->cmap->data.cmap.ents[i].pcol >=\n\t\t\t  dec->pclr->data.pclr.numchans) {\n\t\t\t\tjas_eprintf(\"error: invalid CMAP LUT index\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Allocate space for the channel-number to component-number LUT. */\n\tif (!(dec->chantocmptlut = jas_alloc2(dec->numchans,\n\t  sizeof(uint_fast16_t)))) {\n\t\tjas_eprintf(\"error: no memory\\n\");\n\t\tgoto error;\n\t}\n\n\tif (!dec->cmap) {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\tdec->chantocmptlut[i] = i;\n\t\t}\n\t} else {\n\t\tcmapd = &dec->cmap->data.cmap;\n\t\tpclrd = &dec->pclr->data.pclr;\n\t\tcdefd = &dec->cdef->data.cdef;\n\t\tfor (channo = 0; channo < cmapd->numchans; ++channo) {\n\t\t\tcmapent = &cmapd->ents[channo];\n\t\t\tif (cmapent->map == JP2_CMAP_DIRECT) {\n\t\t\t\tdec->chantocmptlut[channo] = channo;\n\t\t\t} else if (cmapent->map == JP2_CMAP_PALETTE) {\n\t\t\t\tlutents = jas_alloc2(pclrd->numlutents, sizeof(int_fast32_t));\n\t\t\t\tfor (i = 0; i < pclrd->numlutents; ++i) {\n\t\t\t\t\tlutents[i] = pclrd->lutdata[cmapent->pcol + i * pclrd->numchans];\n\t\t\t\t}\n\t\t\t\tnewcmptno = jas_image_numcmpts(dec->image);\n\t\t\t\tjas_image_depalettize(dec->image, cmapent->cmptno,\n\t\t\t\t  pclrd->numlutents, lutents,\n\t\t\t\t  JP2_BPCTODTYPE(pclrd->bpc[cmapent->pcol]), newcmptno);\n\t\t\t\tdec->chantocmptlut[channo] = newcmptno;\n\t\t\t\tjas_free(lutents);\n#if 0\n\t\t\t\tif (dec->cdef) {\n\t\t\t\t\tcdefent = jp2_cdef_lookup(cdefd, channo);\n\t\t\t\t\tif (!cdefent) {\n\t\t\t\t\t\tabort();\n\t\t\t\t\t}\n\t\t\t\tjas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), cdefent->type, cdefent->assoc));\n\t\t\t\t} else {\n\t\t\t\tjas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), 0, channo + 1));\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Mark all components as being of unknown type. */\n\n\tfor (i = 0; i < JAS_CAST(jas_uint, jas_image_numcmpts(dec->image)); ++i) {\n\t\tjas_image_setcmpttype(dec->image, i, JAS_IMAGE_CT_UNKNOWN);\n\t}\n\n\t/* Determine the type of each component. */\n\tif (dec->cdef) {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\t/* Is the channel number reasonable? */\n\t\t\tif (dec->cdef->data.cdef.ents[i].channo >= dec->numchans) {\n\t\t\t\tjas_eprintf(\"error: invalid channel number in CDEF box\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tjas_image_setcmpttype(dec->image,\n\t\t\t  dec->chantocmptlut[dec->cdef->data.cdef.ents[i].channo],\n\t\t\t  jp2_getct(jas_image_clrspc(dec->image),\n\t\t\t  dec->cdef->data.cdef.ents[i].type,\n\t\t\t  dec->cdef->data.cdef.ents[i].assoc));\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\tjas_image_setcmpttype(dec->image, dec->chantocmptlut[i],\n\t\t\t  jp2_getct(jas_image_clrspc(dec->image), 0, i + 1));\n\t\t}\n\t}\n\n\t/* Delete any components that are not of interest. */\n\tfor (i = jas_image_numcmpts(dec->image); i > 0; --i) {\n\t\tif (jas_image_cmpttype(dec->image, i - 1) == JAS_IMAGE_CT_UNKNOWN) {\n\t\t\tjas_image_delcmpt(dec->image, i - 1);\n\t\t}\n\t}\n\n\t/* Ensure that some components survived. */\n\tif (!jas_image_numcmpts(dec->image)) {\n\t\tjas_eprintf(\"error: no components\\n\");\n\t\tgoto error;\n\t}\n#if 0\njas_eprintf(\"no of components is %d\\n\", jas_image_numcmpts(dec->image));\n#endif\n\n\t/* Prevent the image from being destroyed later. */\n\timage = dec->image;\n\tdec->image = 0;\n\n\tjp2_dec_destroy(dec);\n\n\treturn image;\n\nerror:\n\tif (box) {\n\t\tjp2_box_destroy(box);\n\t}\n\tif (dec) {\n\t\tjp2_dec_destroy(dec);\n\t}\n\treturn 0;\n}", "func_hash": 59868521314205020877993173661951509362, "file_name": "jp2_dec.c", "file_hash": 93955147082917127962057718477708272955, "cwe": ["CWE-125"], "cve": "CVE-2017-9782", "cve_desc": "JasPer 2.0.12 allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted image, related to the jp2_decode function in libjasper/jp2/jp2_dec.c.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-9782", "file_path": "src/libjasper/jp2/jp2_dec.c"}
