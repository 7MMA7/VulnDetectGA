{"idx": 355649, "project": "vim", "commit_id": "fe6fb267e6ee5c5da2f41889e4e0e0ac5bf4b89d", "project_url": "https://github.com/vim/vim", "commit_url": "https://github.com/vim/vim/commit/fe6fb267e6ee5c5da2f41889e4e0e0ac5bf4b89d", "commit_message": "patch 8.2.4206: condition with many \"(\" causes a crash\n\nProblem:    Condition with many \"(\" causes a crash.\nSolution:   Limit recursion to 1000.", "target": 0, "func": "eval7(\n    char_u\t**arg,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\twant_string)\t// after \".\" operator\n{\n    int\t\tevaluate = evalarg != NULL\n\t\t\t\t      && (evalarg->eval_flags & EVAL_EVALUATE);\n    int\t\tlen;\n    char_u\t*s;\n    char_u\t*name_start = NULL;\n    char_u\t*start_leader, *end_leader;\n    int\t\tret = OK;\n    char_u\t*alias;\n    static\tint recurse = 0;\n\n    /*\n     * Initialise variable so that clear_tv() can't mistake this for a\n     * string and free a string that isn't there.\n     */\n    rettv->v_type = VAR_UNKNOWN;\n\n    /*\n     * Skip '!', '-' and '+' characters.  They are handled later.\n     */\n    start_leader = *arg;\n    if (eval_leader(arg, in_vim9script()) == FAIL)\n\treturn FAIL;\n    end_leader = *arg;\n\n    if (**arg == '.' && (!isdigit(*(*arg + 1))\n#ifdef FEAT_FLOAT\n\t    || in_old_script(2)\n#endif\n\t    ))\n    {\n\tsemsg(_(e_invalid_expression_str), *arg);\n\t++*arg;\n\treturn FAIL;\n    }\n\n    // Limit recursion to 1000 levels.  At least at 10000 we run out of stack\n    // and crash.\n    if (recurse == 1000)\n    {\n\tsemsg(_(e_expression_too_recursive_str), *arg);\n\treturn FAIL;\n    }\n    ++recurse;\n\n    switch (**arg)\n    {\n    /*\n     * Number constant.\n     */\n    case '0':\n    case '1':\n    case '2':\n    case '3':\n    case '4':\n    case '5':\n    case '6':\n    case '7':\n    case '8':\n    case '9':\n    case '.':\tret = eval_number(arg, rettv, evaluate, want_string);\n\n\t\t// Apply prefixed \"-\" and \"+\" now.  Matters especially when\n\t\t// \"->\" follows.\n\t\tif (ret == OK && evaluate && end_leader > start_leader\n\t\t\t\t\t\t  && rettv->v_type != VAR_BLOB)\n\t\t    ret = eval7_leader(rettv, TRUE, start_leader, &end_leader);\n\t\tbreak;\n\n    /*\n     * String constant: \"string\".\n     */\n    case '\"':\tret = eval_string(arg, rettv, evaluate);\n\t\tbreak;\n\n    /*\n     * Literal string constant: 'str''ing'.\n     */\n    case '\\'':\tret = eval_lit_string(arg, rettv, evaluate);\n\t\tbreak;\n\n    /*\n     * List: [expr, expr]\n     */\n    case '[':\tret = eval_list(arg, rettv, evalarg, TRUE);\n\t\tbreak;\n\n    /*\n     * Dictionary: #{key: val, key: val}\n     */\n    case '#':\tif (in_vim9script())\n\t\t{\n\t\t    ret = vim9_bad_comment(*arg) ? FAIL : NOTDONE;\n\t\t}\n\t\telse if ((*arg)[1] == '{')\n\t\t{\n\t\t    ++*arg;\n\t\t    ret = eval_dict(arg, rettv, evalarg, TRUE);\n\t\t}\n\t\telse\n\t\t    ret = NOTDONE;\n\t\tbreak;\n\n    /*\n     * Lambda: {arg, arg -> expr}\n     * Dictionary: {'key': val, 'key': val}\n     */\n    case '{':\tif (in_vim9script())\n\t\t    ret = NOTDONE;\n\t\telse\n\t\t    ret = get_lambda_tv(arg, rettv, in_vim9script(), evalarg);\n\t\tif (ret == NOTDONE)\n\t\t    ret = eval_dict(arg, rettv, evalarg, FALSE);\n\t\tbreak;\n\n    /*\n     * Option value: &name\n     */\n    case '&':\tret = eval_option(arg, rettv, evaluate);\n\t\tbreak;\n\n    /*\n     * Environment variable: $VAR.\n     */\n    case '$':\tret = eval_env_var(arg, rettv, evaluate);\n\t\tbreak;\n\n    /*\n     * Register contents: @r.\n     */\n    case '@':\t++*arg;\n\t\tif (evaluate)\n\t\t{\n\t\t    if (in_vim9script() && IS_WHITE_OR_NUL(**arg))\n\t\t\tsemsg(_(e_syntax_error_at_str), *arg);\n\t\t    else if (in_vim9script() && !valid_yank_reg(**arg, FALSE))\n\t\t\temsg_invreg(**arg);\n\t\t    else\n\t\t    {\n\t\t\trettv->v_type = VAR_STRING;\n\t\t\trettv->vval.v_string = get_reg_contents(**arg,\n\t\t\t\t\t\t\t\tGREG_EXPR_SRC);\n\t\t    }\n\t\t}\n\t\tif (**arg != NUL)\n\t\t    ++*arg;\n\t\tbreak;\n\n    /*\n     * nested expression: (expression).\n     * or lambda: (arg) => expr\n     */\n    case '(':\tret = NOTDONE;\n\t\tif (in_vim9script())\n\t\t{\n\t\t    ret = get_lambda_tv(arg, rettv, TRUE, evalarg);\n\t\t    if (ret == OK && evaluate)\n\t\t    {\n\t\t\tufunc_T *ufunc = rettv->vval.v_partial->pt_func;\n\n\t\t\t// Compile it here to get the return type.  The return\n\t\t\t// type is optional, when it's missing use t_unknown.\n\t\t\t// This is recognized in compile_return().\n\t\t\tif (ufunc->uf_ret_type->tt_type == VAR_VOID)\n\t\t\t    ufunc->uf_ret_type = &t_unknown;\n\t\t\tif (compile_def_function(ufunc,\n\t\t\t\t     FALSE, COMPILE_TYPE(ufunc), NULL) == FAIL)\n\t\t\t{\n\t\t\t    clear_tv(rettv);\n\t\t\t    ret = FAIL;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif (ret == NOTDONE)\n\t\t{\n\t\t    *arg = skipwhite_and_linebreak(*arg + 1, evalarg);\n\t\t    ret = eval1(arg, rettv, evalarg);\t// recursive!\n\n\t\t    *arg = skipwhite_and_linebreak(*arg, evalarg);\n\t\t    if (**arg == ')')\n\t\t\t++*arg;\n\t\t    else if (ret == OK)\n\t\t    {\n\t\t\temsg(_(e_missing_closing_paren));\n\t\t\tclear_tv(rettv);\n\t\t\tret = FAIL;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n    default:\tret = NOTDONE;\n\t\tbreak;\n    }\n\n    if (ret == NOTDONE)\n    {\n\t/*\n\t * Must be a variable or function name.\n\t * Can also be a curly-braces kind of name: {expr}.\n\t */\n\ts = *arg;\n\tlen = get_name_len(arg, &alias, evaluate, TRUE);\n\tif (alias != NULL)\n\t    s = alias;\n\n\tif (len <= 0)\n\t    ret = FAIL;\n\telse\n\t{\n\t    int\t    flags = evalarg == NULL ? 0 : evalarg->eval_flags;\n\n\t    if (evaluate && in_vim9script() && len == 1 && *s == '_')\n\t    {\n\t\temsg(_(e_cannot_use_underscore_here));\n\t\tret = FAIL;\n\t    }\n\t    else if ((in_vim9script() ? **arg : *skipwhite(*arg)) == '(')\n\t    {\n\t\t// \"name(...\"  recursive!\n\t\t*arg = skipwhite(*arg);\n\t\tret = eval_func(arg, evalarg, s, len, rettv, flags, NULL);\n\t    }\n\t    else if (flags & EVAL_CONSTANT)\n\t\tret = FAIL;\n\t    else if (evaluate)\n\t    {\n\t\t// get the value of \"true\", \"false\" or a variable\n\t\tif (len == 4 && in_vim9script() && STRNCMP(s, \"true\", 4) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_BOOL;\n\t\t    rettv->vval.v_number = VVAL_TRUE;\n\t\t    ret = OK;\n\t\t}\n\t\telse if (len == 5 && in_vim9script()\n\t\t\t\t\t\t&& STRNCMP(s, \"false\", 5) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_BOOL;\n\t\t    rettv->vval.v_number = VVAL_FALSE;\n\t\t    ret = OK;\n\t\t}\n\t\telse if (len == 4 && in_vim9script()\n\t\t\t\t\t\t&& STRNCMP(s, \"null\", 4) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_SPECIAL;\n\t\t    rettv->vval.v_number = VVAL_NULL;\n\t\t    ret = OK;\n\t\t}\n\t\telse\n\t\t{\n\t\t    name_start = s;\n\t\t    ret = eval_variable(s, len, 0, rettv, NULL,\n\t\t\t\t\t   EVAL_VAR_VERBOSE + EVAL_VAR_IMPORT);\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// skip the name\n\t\tcheck_vars(s, len);\n\t\tret = OK;\n\t    }\n\t}\n\tvim_free(alias);\n    }\n\n    // Handle following '[', '(' and '.' for expr[expr], expr.name,\n    // expr(expr), expr->name(expr)\n    if (ret == OK)\n\tret = handle_subscript(arg, name_start, rettv, evalarg, TRUE);\n\n    /*\n     * Apply logical NOT and unary '-', from right to left, ignore '+'.\n     */\n    if (ret == OK && evaluate && end_leader > start_leader)\n\tret = eval7_leader(rettv, FALSE, start_leader, &end_leader);\n\n    --recurse;\n    return ret;\n}", "func_hash": 324139368658301016034800923930937563014, "file_name": "eval.c", "file_hash": 208824404078014502397565483410500490043, "cwe": ["CWE-787"], "cve": "CVE-2022-0351", "cve_desc": "Access of Memory Location Before Start of Buffer in GitHub repository vim/vim prior to 8.2.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-0351", "file_path": "src/eval.c"}
{"idx": 204351, "project": "squirrel", "commit_id": "23a0620658714b996d20da3d4dd1a0dcf9b0bd98", "project_url": "https://github.com/albertodemichelis/squirrel", "commit_url": "https://github.com/albertodemichelis/squirrel/commit/23a0620658714b996d20da3d4dd1a0dcf9b0bd98", "commit_message": "check max member count in class", "target": 1, "func": "bool SQClass::NewSlot(SQSharedState *ss,const SQObjectPtr &key,const SQObjectPtr &val,bool bstatic)\n{\n    SQObjectPtr temp;\n    bool belongs_to_static_table = sq_type(val) == OT_CLOSURE || sq_type(val) == OT_NATIVECLOSURE || bstatic;\n    if(_locked && !belongs_to_static_table)\n        return false; //the class already has an instance so cannot be modified\n    if(_members->Get(key,temp) && _isfield(temp)) //overrides the default value\n    {\n        _defaultvalues[_member_idx(temp)].val = val;\n        return true;\n    }\n    if(belongs_to_static_table) {\n        SQInteger mmidx;\n        if((sq_type(val) == OT_CLOSURE || sq_type(val) == OT_NATIVECLOSURE) &&\n            (mmidx = ss->GetMetaMethodIdxByName(key)) != -1) {\n            _metamethods[mmidx] = val;\n        }\n        else {\n            SQObjectPtr theval = val;\n            if(_base && sq_type(val) == OT_CLOSURE) {\n                theval = _closure(val)->Clone();\n                _closure(theval)->_base = _base;\n                __ObjAddRef(_base); //ref for the closure\n            }\n            if(sq_type(temp) == OT_NULL) {\n                bool isconstructor;\n                SQVM::IsEqual(ss->_constructoridx, key, isconstructor);\n                if(isconstructor) {\n                    _constructoridx = (SQInteger)_methods.size();\n                }\n                SQClassMember m;\n                m.val = theval;\n                _members->NewSlot(key,SQObjectPtr(_make_method_idx(_methods.size())));\n                _methods.push_back(m);\n            }\n            else {\n                _methods[_member_idx(temp)].val = theval;\n            }\n        }\n        return true;\n    }\n    SQClassMember m;\n    m.val = val;\n    _members->NewSlot(key,SQObjectPtr(_make_field_idx(_defaultvalues.size())));\n    _defaultvalues.push_back(m);\n    return true;\n}", "func_hash": 269872855469648419079058130898644045027, "file_name": "sqclass.cpp", "file_hash": 75131817582394814638781750834830258905, "cwe": ["CWE-125"], "cve": "CVE-2021-41556", "cve_desc": "sqclass.cpp in Squirrel through 2.2.5 and 3.x through 3.1 allows an out-of-bounds read (in the core interpreter) that can lead to Code Execution. If a victim executes an attacker-controlled squirrel script, it is possible for the attacker to break out of the squirrel script sandbox even if all dangerous functionality such as File System functions has been disabled. An attacker might abuse this bug to target (for example) Cloud services that allow customization via SquirrelScripts, or distribute malware through video games that embed a Squirrel Engine.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-41556", "file_path": "squirrel/sqclass.cpp"}
{"idx": 357668, "project": "squirrel", "commit_id": "23a0620658714b996d20da3d4dd1a0dcf9b0bd98", "project_url": "https://github.com/albertodemichelis/squirrel", "commit_url": "https://github.com/albertodemichelis/squirrel/commit/23a0620658714b996d20da3d4dd1a0dcf9b0bd98", "commit_message": "check max member count in class", "target": 0, "func": "bool SQClass::NewSlot(SQSharedState *ss,const SQObjectPtr &key,const SQObjectPtr &val,bool bstatic)\n{\n    SQObjectPtr temp;\n    bool belongs_to_static_table = sq_type(val) == OT_CLOSURE || sq_type(val) == OT_NATIVECLOSURE || bstatic;\n    if(_locked && !belongs_to_static_table)\n        return false; //the class already has an instance so cannot be modified\n    if(_members->Get(key,temp) && _isfield(temp)) //overrides the default value\n    {\n        _defaultvalues[_member_idx(temp)].val = val;\n        return true;\n    }\n\tif (_members->CountUsed() >= MEMBER_MAX_COUNT) {\n\t\treturn false;\n\t}\n    if(belongs_to_static_table) {\n        SQInteger mmidx;\n        if((sq_type(val) == OT_CLOSURE || sq_type(val) == OT_NATIVECLOSURE) &&\n            (mmidx = ss->GetMetaMethodIdxByName(key)) != -1) {\n            _metamethods[mmidx] = val;\n        }\n        else {\n            SQObjectPtr theval = val;\n            if(_base && sq_type(val) == OT_CLOSURE) {\n                theval = _closure(val)->Clone();\n                _closure(theval)->_base = _base;\n                __ObjAddRef(_base); //ref for the closure\n            }\n            if(sq_type(temp) == OT_NULL) {\n                bool isconstructor;\n                SQVM::IsEqual(ss->_constructoridx, key, isconstructor);\n                if(isconstructor) {\n                    _constructoridx = (SQInteger)_methods.size();\n                }\n                SQClassMember m;\n                m.val = theval;\n                _members->NewSlot(key,SQObjectPtr(_make_method_idx(_methods.size())));\n                _methods.push_back(m);\n            }\n            else {\n                _methods[_member_idx(temp)].val = theval;\n            }\n        }\n        return true;\n    }\n    SQClassMember m;\n    m.val = val;\n    _members->NewSlot(key,SQObjectPtr(_make_field_idx(_defaultvalues.size())));\n    _defaultvalues.push_back(m);\n    return true;\n}", "func_hash": 114176109037888032181151333197990654093, "file_name": "sqclass.cpp", "file_hash": 129356662613675265537572681929065618991, "cwe": ["CWE-125"], "cve": "CVE-2021-41556", "cve_desc": "sqclass.cpp in Squirrel through 2.2.5 and 3.x through 3.1 allows an out-of-bounds read (in the core interpreter) that can lead to Code Execution. If a victim executes an attacker-controlled squirrel script, it is possible for the attacker to break out of the squirrel script sandbox even if all dangerous functionality such as File System functions has been disabled. An attacker might abuse this bug to target (for example) Cloud services that allow customization via SquirrelScripts, or distribute malware through video games that embed a Squirrel Engine.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-41556", "file_path": "squirrel/sqclass.cpp"}
{"idx": 204412, "project": "bpf", "commit_id": "4b81ccebaeee885ab1aa1438133f2991e3a2b6ea", "project_url": "https://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf", "commit_url": "https://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf.git/commit/?id=4b81ccebaeee885ab1aa1438133f2991e3a2b6ea", "commit_message": "bpf, ringbuf: Deny reserve of buffers larger than ringbuf\n\nA BPF program might try to reserve a buffer larger than the ringbuf size.\nIf the consumer pointer is way ahead of the producer, that would be\nsuccessfully reserved, allowing the BPF program to read or write out of\nthe ringbuf allocated area.\n\nReported-by: Ryota Shiga (Flatt Security)\nFixes: 457f44363a88 (\"bpf: Implement BPF ring buffer and verifier support for it\")\nSigned-off-by: Thadeu Lima de Souza Cascardo <cascardo@canonical.com>\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>\nAcked-by: Andrii Nakryiko <andrii@kernel.org>\nAcked-by: Alexei Starovoitov <ast@kernel.org>", "target": 1, "func": "static void *__bpf_ringbuf_reserve(struct bpf_ringbuf *rb, u64 size)\n{\n\tunsigned long cons_pos, prod_pos, new_prod_pos, flags;\n\tu32 len, pg_off;\n\tstruct bpf_ringbuf_hdr *hdr;\n\n\tif (unlikely(size > RINGBUF_MAX_RECORD_SZ))\n\t\treturn NULL;\n\n\tlen = round_up(size + BPF_RINGBUF_HDR_SZ, 8);\n\tcons_pos = smp_load_acquire(&rb->consumer_pos);\n\n\tif (in_nmi()) {\n\t\tif (!spin_trylock_irqsave(&rb->spinlock, flags))\n\t\t\treturn NULL;\n\t} else {\n\t\tspin_lock_irqsave(&rb->spinlock, flags);\n\t}\n\n\tprod_pos = rb->producer_pos;\n\tnew_prod_pos = prod_pos + len;\n\n\t/* check for out of ringbuf space by ensuring producer position\n\t * doesn't advance more than (ringbuf_size - 1) ahead\n\t */\n\tif (new_prod_pos - cons_pos > rb->mask) {\n\t\tspin_unlock_irqrestore(&rb->spinlock, flags);\n\t\treturn NULL;\n\t}\n\n\thdr = (void *)rb->data + (prod_pos & rb->mask);\n\tpg_off = bpf_ringbuf_rec_pg_off(rb, hdr);\n\thdr->len = size | BPF_RINGBUF_BUSY_BIT;\n\thdr->pg_off = pg_off;\n\n\t/* pairs with consumer's smp_load_acquire() */\n\tsmp_store_release(&rb->producer_pos, new_prod_pos);\n\n\tspin_unlock_irqrestore(&rb->spinlock, flags);\n\n\treturn (void *)hdr + BPF_RINGBUF_HDR_SZ;\n}", "func_hash": 305878074800514937766892583405358065403, "file_name": "ringbuf.c", "file_hash": 6876939472683174674440151046802738508, "cwe": ["CWE-787"], "cve": "CVE-2021-3489", "cve_desc": "The eBPF RINGBUF bpf_ringbuf_reserve() function in the Linux kernel did not check that the allocated size was smaller than the ringbuf size, allowing an attacker to perform out-of-bounds writes within the kernel and therefore, arbitrary code execution. This issue was fixed via commit 4b81ccebaeee (\"bpf, ringbuf: Deny reserve of buffers larger than ringbuf\") (v5.13-rc4) and backported to the stable kernels in v5.12.4, v5.11.21, and v5.10.37. It was introduced via 457f44363a88 (\"bpf: Implement BPF ring buffer and verifier support for it\") (v5.8-rc1).", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-3489", "file_path": "kernel/bpf/ringbuf.c"}
{"idx": 359206, "project": "bpf", "commit_id": "4b81ccebaeee885ab1aa1438133f2991e3a2b6ea", "project_url": "https://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf", "commit_url": "https://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf.git/commit/?id=4b81ccebaeee885ab1aa1438133f2991e3a2b6ea", "commit_message": "bpf, ringbuf: Deny reserve of buffers larger than ringbuf\n\nA BPF program might try to reserve a buffer larger than the ringbuf size.\nIf the consumer pointer is way ahead of the producer, that would be\nsuccessfully reserved, allowing the BPF program to read or write out of\nthe ringbuf allocated area.\n\nReported-by: Ryota Shiga (Flatt Security)\nFixes: 457f44363a88 (\"bpf: Implement BPF ring buffer and verifier support for it\")\nSigned-off-by: Thadeu Lima de Souza Cascardo <cascardo@canonical.com>\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>\nAcked-by: Andrii Nakryiko <andrii@kernel.org>\nAcked-by: Alexei Starovoitov <ast@kernel.org>", "target": 0, "func": "static void *__bpf_ringbuf_reserve(struct bpf_ringbuf *rb, u64 size)\n{\n\tunsigned long cons_pos, prod_pos, new_prod_pos, flags;\n\tu32 len, pg_off;\n\tstruct bpf_ringbuf_hdr *hdr;\n\n\tif (unlikely(size > RINGBUF_MAX_RECORD_SZ))\n\t\treturn NULL;\n\n\tlen = round_up(size + BPF_RINGBUF_HDR_SZ, 8);\n\tif (len > rb->mask + 1)\n\t\treturn NULL;\n\n\tcons_pos = smp_load_acquire(&rb->consumer_pos);\n\n\tif (in_nmi()) {\n\t\tif (!spin_trylock_irqsave(&rb->spinlock, flags))\n\t\t\treturn NULL;\n\t} else {\n\t\tspin_lock_irqsave(&rb->spinlock, flags);\n\t}\n\n\tprod_pos = rb->producer_pos;\n\tnew_prod_pos = prod_pos + len;\n\n\t/* check for out of ringbuf space by ensuring producer position\n\t * doesn't advance more than (ringbuf_size - 1) ahead\n\t */\n\tif (new_prod_pos - cons_pos > rb->mask) {\n\t\tspin_unlock_irqrestore(&rb->spinlock, flags);\n\t\treturn NULL;\n\t}\n\n\thdr = (void *)rb->data + (prod_pos & rb->mask);\n\tpg_off = bpf_ringbuf_rec_pg_off(rb, hdr);\n\thdr->len = size | BPF_RINGBUF_BUSY_BIT;\n\thdr->pg_off = pg_off;\n\n\t/* pairs with consumer's smp_load_acquire() */\n\tsmp_store_release(&rb->producer_pos, new_prod_pos);\n\n\tspin_unlock_irqrestore(&rb->spinlock, flags);\n\n\treturn (void *)hdr + BPF_RINGBUF_HDR_SZ;\n}", "func_hash": 233821322614692863219886146117009832812, "file_name": "ringbuf.c", "file_hash": 3063228527898556498340075998394929987, "cwe": ["CWE-787"], "cve": "CVE-2021-3489", "cve_desc": "The eBPF RINGBUF bpf_ringbuf_reserve() function in the Linux kernel did not check that the allocated size was smaller than the ringbuf size, allowing an attacker to perform out-of-bounds writes within the kernel and therefore, arbitrary code execution. This issue was fixed via commit 4b81ccebaeee (\"bpf, ringbuf: Deny reserve of buffers larger than ringbuf\") (v5.13-rc4) and backported to the stable kernels in v5.12.4, v5.11.21, and v5.10.37. It was introduced via 457f44363a88 (\"bpf: Implement BPF ring buffer and verifier support for it\") (v5.8-rc1).", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-3489", "file_path": "kernel/bpf/ringbuf.c"}
