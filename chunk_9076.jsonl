{"idx": 215142, "project": "open62541", "commit_id": "b79db1ac78146fc06b0b8435773d3967de2d659c", "project_url": "https://github.com/open62541/open62541", "commit_url": "https://github.com/open62541/open62541/commit/b79db1ac78146fc06b0b8435773d3967de2d659c", "commit_message": "fix(plugin): Add default limits for chunks and message size\n\nBased on a reported DoS vulnerability reported by Team82 (Claroty\nResearch).", "target": 1, "func": "setup_secureChannel(void) {\n    TestingPolicy(&dummyPolicy, dummyCertificate, &fCalled, &keySizes);\n    UA_SecureChannel_init(&testChannel, &UA_ConnectionConfig_default);\n    UA_SecureChannel_setSecurityPolicy(&testChannel, &dummyPolicy, &dummyCertificate);\n\n    testingConnection = createDummyConnection(65535, &sentData);\n    UA_Connection_attachSecureChannel(&testingConnection, &testChannel);\n    testChannel.connection = &testingConnection;\n\n    testChannel.state = UA_SECURECHANNELSTATE_OPEN;\n}", "func_hash": 129373646789395132978577350520275897854, "file_name": "check_securechannel.c", "file_hash": 237191463744761061393465477757063019069, "cwe": ["CWE-703"], "cve": "CVE-2022-25761", "cve_desc": "The package open62541/open62541 before 1.2.5, from 1.3-rc1 and before 1.3.1 are vulnerable to Denial of Service (DoS) due to a missing limitation on the number of received chunks - per single session or in total for all concurrent sessions. An attacker can exploit this vulnerability by sending an unlimited number of huge chunks (e.g. 2GB each) without sending the Final closing chunk.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-25761", "file_path": "tests/check_securechannel.c"}
{"idx": 484063, "project": "open62541", "commit_id": "b79db1ac78146fc06b0b8435773d3967de2d659c", "project_url": "https://github.com/open62541/open62541", "commit_url": "https://github.com/open62541/open62541/commit/b79db1ac78146fc06b0b8435773d3967de2d659c", "commit_message": "fix(plugin): Add default limits for chunks and message size\n\nBased on a reported DoS vulnerability reported by Team82 (Claroty\nResearch).", "target": 0, "func": "setup_secureChannel(void) {\n    TestingPolicy(&dummyPolicy, dummyCertificate, &fCalled, &keySizes);\n    UA_SecureChannel_init(&testChannel, &UA_ConnectionConfig_default);\n    UA_SecureChannel_setSecurityPolicy(&testChannel, &dummyPolicy, &dummyCertificate);\n\n    testingConnection =\n        createDummyConnection(UA_ConnectionConfig_default.sendBufferSize, &sentData);\n    UA_Connection_attachSecureChannel(&testingConnection, &testChannel);\n    testChannel.connection = &testingConnection;\n\n    testChannel.state = UA_SECURECHANNELSTATE_OPEN;\n}", "func_hash": 210099699353094700409954983864057205013, "file_name": "check_securechannel.c", "file_hash": 317936293844889222163489724834611177083, "cwe": ["CWE-703"], "cve": "CVE-2022-25761", "cve_desc": "The package open62541/open62541 before 1.2.5, from 1.3-rc1 and before 1.3.1 are vulnerable to Denial of Service (DoS) due to a missing limitation on the number of received chunks - per single session or in total for all concurrent sessions. An attacker can exploit this vulnerability by sending an unlimited number of huge chunks (e.g. 2GB each) without sending the Final closing chunk.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-25761", "file_path": "tests/check_securechannel.c"}
{"idx": 215262, "project": "qemu", "commit_id": "e73adfbeec9d4e008630c814759052ed945c3fed", "project_url": "https://github.com/bonzini/qemu", "commit_url": "https://git.qemu.org/?p=qemu.git;a=commit;h=e73adfbeec9d4e008630c814759052ed945c3fed", "commit_message": "cadence_gem: switch to use qemu_receive_packet() for loopback\n\nThis patch switches to use qemu_receive_packet() which can detect\nreentrancy and return early.\n\nThis is intended to address CVE-2021-3416.\n\nCc: Prasad J Pandit <ppandit@redhat.com>\nCc: qemu-stable@nongnu.org\nReviewed-by: Philippe Mathieu-Daud\u00e9 <philmd@redhat.com>\nSigned-off-by: Alexander Bulekov <alxndr@bu.edu>\nSigned-off-by: Jason Wang <jasowang@redhat.com>", "target": 1, "func": "static void gem_transmit(CadenceGEMState *s)\n{\n    uint32_t desc[DESC_MAX_NUM_WORDS];\n    hwaddr packet_desc_addr;\n    uint8_t     *p;\n    unsigned    total_bytes;\n    int q = 0;\n\n    /* Do nothing if transmit is not enabled. */\n    if (!(s->regs[GEM_NWCTRL] & GEM_NWCTRL_TXENA)) {\n        return;\n    }\n\n    DB_PRINT(\"\\n\");\n\n    /* The packet we will hand off to QEMU.\n     * Packets scattered across multiple descriptors are gathered to this\n     * one contiguous buffer first.\n     */\n    p = s->tx_packet;\n    total_bytes = 0;\n\n    for (q = s->num_priority_queues - 1; q >= 0; q--) {\n        /* read current descriptor */\n        packet_desc_addr = gem_get_tx_desc_addr(s, q);\n\n        DB_PRINT(\"read descriptor 0x%\" HWADDR_PRIx \"\\n\", packet_desc_addr);\n        address_space_read(&s->dma_as, packet_desc_addr,\n                           MEMTXATTRS_UNSPECIFIED, desc,\n                           sizeof(uint32_t) * gem_get_desc_len(s, false));\n        /* Handle all descriptors owned by hardware */\n        while (tx_desc_get_used(desc) == 0) {\n\n            /* Do nothing if transmit is not enabled. */\n            if (!(s->regs[GEM_NWCTRL] & GEM_NWCTRL_TXENA)) {\n                return;\n            }\n            print_gem_tx_desc(desc, q);\n\n            /* The real hardware would eat this (and possibly crash).\n             * For QEMU let's lend a helping hand.\n             */\n            if ((tx_desc_get_buffer(s, desc) == 0) ||\n                (tx_desc_get_length(desc) == 0)) {\n                DB_PRINT(\"Invalid TX descriptor @ 0x%\" HWADDR_PRIx \"\\n\",\n                         packet_desc_addr);\n                break;\n            }\n\n            if (tx_desc_get_length(desc) > gem_get_max_buf_len(s, true) -\n                                               (p - s->tx_packet)) {\n                qemu_log_mask(LOG_GUEST_ERROR, \"TX descriptor @ 0x%\" \\\n                         HWADDR_PRIx \" too large: size 0x%x space 0x%zx\\n\",\n                         packet_desc_addr, tx_desc_get_length(desc),\n                         gem_get_max_buf_len(s, true) - (p - s->tx_packet));\n                gem_set_isr(s, q, GEM_INT_AMBA_ERR);\n                break;\n            }\n\n            /* Gather this fragment of the packet from \"dma memory\" to our\n             * contig buffer.\n             */\n            address_space_read(&s->dma_as, tx_desc_get_buffer(s, desc),\n                               MEMTXATTRS_UNSPECIFIED,\n                               p, tx_desc_get_length(desc));\n            p += tx_desc_get_length(desc);\n            total_bytes += tx_desc_get_length(desc);\n\n            /* Last descriptor for this packet; hand the whole thing off */\n            if (tx_desc_get_last(desc)) {\n                uint32_t desc_first[DESC_MAX_NUM_WORDS];\n                hwaddr desc_addr = gem_get_tx_desc_addr(s, q);\n\n                /* Modify the 1st descriptor of this packet to be owned by\n                 * the processor.\n                 */\n                address_space_read(&s->dma_as, desc_addr,\n                                   MEMTXATTRS_UNSPECIFIED, desc_first,\n                                   sizeof(desc_first));\n                tx_desc_set_used(desc_first);\n                address_space_write(&s->dma_as, desc_addr,\n                                    MEMTXATTRS_UNSPECIFIED, desc_first,\n                                    sizeof(desc_first));\n                /* Advance the hardware current descriptor past this packet */\n                if (tx_desc_get_wrap(desc)) {\n                    s->tx_desc_addr[q] = gem_get_tx_queue_base_addr(s, q);\n                } else {\n                    s->tx_desc_addr[q] = packet_desc_addr +\n                                         4 * gem_get_desc_len(s, false);\n                }\n                DB_PRINT(\"TX descriptor next: 0x%08x\\n\", s->tx_desc_addr[q]);\n\n                s->regs[GEM_TXSTATUS] |= GEM_TXSTATUS_TXCMPL;\n                gem_set_isr(s, q, GEM_INT_TXCMPL);\n\n                /* Handle interrupt consequences */\n                gem_update_int_status(s);\n\n                /* Is checksum offload enabled? */\n                if (s->regs[GEM_DMACFG] & GEM_DMACFG_TXCSUM_OFFL) {\n                    net_checksum_calculate(s->tx_packet, total_bytes, CSUM_ALL);\n                }\n\n                /* Update MAC statistics */\n                gem_transmit_updatestats(s, s->tx_packet, total_bytes);\n\n                /* Send the packet somewhere */\n                if (s->phy_loop || (s->regs[GEM_NWCTRL] &\n                                    GEM_NWCTRL_LOCALLOOP)) {\n                    gem_receive(qemu_get_queue(s->nic), s->tx_packet,\n                                total_bytes);\n                } else {\n                    qemu_send_packet(qemu_get_queue(s->nic), s->tx_packet,\n                                     total_bytes);\n                }\n\n                /* Prepare for next packet */\n                p = s->tx_packet;\n                total_bytes = 0;\n            }\n\n            /* read next descriptor */\n            if (tx_desc_get_wrap(desc)) {\n\n                if (s->regs[GEM_DMACFG] & GEM_DMACFG_ADDR_64B) {\n                    packet_desc_addr = s->regs[GEM_TBQPH];\n                    packet_desc_addr <<= 32;\n                } else {\n                    packet_desc_addr = 0;\n                }\n                packet_desc_addr |= gem_get_tx_queue_base_addr(s, q);\n            } else {\n                packet_desc_addr += 4 * gem_get_desc_len(s, false);\n            }\n            DB_PRINT(\"read descriptor 0x%\" HWADDR_PRIx \"\\n\", packet_desc_addr);\n            address_space_read(&s->dma_as, packet_desc_addr,\n                               MEMTXATTRS_UNSPECIFIED, desc,\n                               sizeof(uint32_t) * gem_get_desc_len(s, false));\n        }\n\n        if (tx_desc_get_used(desc)) {\n            s->regs[GEM_TXSTATUS] |= GEM_TXSTATUS_USED;\n            /* IRQ TXUSED is defined only for queue 0 */\n            if (q == 0) {\n                gem_set_isr(s, 0, GEM_INT_TXUSED);\n            }\n            gem_update_int_status(s);\n        }\n    }\n}", "func_hash": 96949803014582607595727068395060090256, "file_name": "cadence_gem.c", "file_hash": 142576312399333534516163795241152257631, "cwe": ["CWE-835"], "cve": "CVE-2021-3416", "cve_desc": "A potential stack overflow via infinite loop issue was found in various NIC emulators of QEMU in versions up to and including 5.2.0. The issue occurs in loopback mode of a NIC wherein reentrant DMA checks get bypassed. A guest user/process may use this flaw to consume CPU cycles or crash the QEMU process on the host resulting in DoS scenario.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-3416", "file_path": "hw/net/cadence_gem.c"}
{"idx": 486796, "project": "qemu", "commit_id": "e73adfbeec9d4e008630c814759052ed945c3fed", "project_url": "https://github.com/bonzini/qemu", "commit_url": "https://git.qemu.org/?p=qemu.git;a=commit;h=e73adfbeec9d4e008630c814759052ed945c3fed", "commit_message": "cadence_gem: switch to use qemu_receive_packet() for loopback\n\nThis patch switches to use qemu_receive_packet() which can detect\nreentrancy and return early.\n\nThis is intended to address CVE-2021-3416.\n\nCc: Prasad J Pandit <ppandit@redhat.com>\nCc: qemu-stable@nongnu.org\nReviewed-by: Philippe Mathieu-Daud\u00e9 <philmd@redhat.com>\nSigned-off-by: Alexander Bulekov <alxndr@bu.edu>\nSigned-off-by: Jason Wang <jasowang@redhat.com>", "target": 0, "func": "static void gem_transmit(CadenceGEMState *s)\n{\n    uint32_t desc[DESC_MAX_NUM_WORDS];\n    hwaddr packet_desc_addr;\n    uint8_t     *p;\n    unsigned    total_bytes;\n    int q = 0;\n\n    /* Do nothing if transmit is not enabled. */\n    if (!(s->regs[GEM_NWCTRL] & GEM_NWCTRL_TXENA)) {\n        return;\n    }\n\n    DB_PRINT(\"\\n\");\n\n    /* The packet we will hand off to QEMU.\n     * Packets scattered across multiple descriptors are gathered to this\n     * one contiguous buffer first.\n     */\n    p = s->tx_packet;\n    total_bytes = 0;\n\n    for (q = s->num_priority_queues - 1; q >= 0; q--) {\n        /* read current descriptor */\n        packet_desc_addr = gem_get_tx_desc_addr(s, q);\n\n        DB_PRINT(\"read descriptor 0x%\" HWADDR_PRIx \"\\n\", packet_desc_addr);\n        address_space_read(&s->dma_as, packet_desc_addr,\n                           MEMTXATTRS_UNSPECIFIED, desc,\n                           sizeof(uint32_t) * gem_get_desc_len(s, false));\n        /* Handle all descriptors owned by hardware */\n        while (tx_desc_get_used(desc) == 0) {\n\n            /* Do nothing if transmit is not enabled. */\n            if (!(s->regs[GEM_NWCTRL] & GEM_NWCTRL_TXENA)) {\n                return;\n            }\n            print_gem_tx_desc(desc, q);\n\n            /* The real hardware would eat this (and possibly crash).\n             * For QEMU let's lend a helping hand.\n             */\n            if ((tx_desc_get_buffer(s, desc) == 0) ||\n                (tx_desc_get_length(desc) == 0)) {\n                DB_PRINT(\"Invalid TX descriptor @ 0x%\" HWADDR_PRIx \"\\n\",\n                         packet_desc_addr);\n                break;\n            }\n\n            if (tx_desc_get_length(desc) > gem_get_max_buf_len(s, true) -\n                                               (p - s->tx_packet)) {\n                qemu_log_mask(LOG_GUEST_ERROR, \"TX descriptor @ 0x%\" \\\n                         HWADDR_PRIx \" too large: size 0x%x space 0x%zx\\n\",\n                         packet_desc_addr, tx_desc_get_length(desc),\n                         gem_get_max_buf_len(s, true) - (p - s->tx_packet));\n                gem_set_isr(s, q, GEM_INT_AMBA_ERR);\n                break;\n            }\n\n            /* Gather this fragment of the packet from \"dma memory\" to our\n             * contig buffer.\n             */\n            address_space_read(&s->dma_as, tx_desc_get_buffer(s, desc),\n                               MEMTXATTRS_UNSPECIFIED,\n                               p, tx_desc_get_length(desc));\n            p += tx_desc_get_length(desc);\n            total_bytes += tx_desc_get_length(desc);\n\n            /* Last descriptor for this packet; hand the whole thing off */\n            if (tx_desc_get_last(desc)) {\n                uint32_t desc_first[DESC_MAX_NUM_WORDS];\n                hwaddr desc_addr = gem_get_tx_desc_addr(s, q);\n\n                /* Modify the 1st descriptor of this packet to be owned by\n                 * the processor.\n                 */\n                address_space_read(&s->dma_as, desc_addr,\n                                   MEMTXATTRS_UNSPECIFIED, desc_first,\n                                   sizeof(desc_first));\n                tx_desc_set_used(desc_first);\n                address_space_write(&s->dma_as, desc_addr,\n                                    MEMTXATTRS_UNSPECIFIED, desc_first,\n                                    sizeof(desc_first));\n                /* Advance the hardware current descriptor past this packet */\n                if (tx_desc_get_wrap(desc)) {\n                    s->tx_desc_addr[q] = gem_get_tx_queue_base_addr(s, q);\n                } else {\n                    s->tx_desc_addr[q] = packet_desc_addr +\n                                         4 * gem_get_desc_len(s, false);\n                }\n                DB_PRINT(\"TX descriptor next: 0x%08x\\n\", s->tx_desc_addr[q]);\n\n                s->regs[GEM_TXSTATUS] |= GEM_TXSTATUS_TXCMPL;\n                gem_set_isr(s, q, GEM_INT_TXCMPL);\n\n                /* Handle interrupt consequences */\n                gem_update_int_status(s);\n\n                /* Is checksum offload enabled? */\n                if (s->regs[GEM_DMACFG] & GEM_DMACFG_TXCSUM_OFFL) {\n                    net_checksum_calculate(s->tx_packet, total_bytes, CSUM_ALL);\n                }\n\n                /* Update MAC statistics */\n                gem_transmit_updatestats(s, s->tx_packet, total_bytes);\n\n                /* Send the packet somewhere */\n                if (s->phy_loop || (s->regs[GEM_NWCTRL] &\n                                    GEM_NWCTRL_LOCALLOOP)) {\n                    qemu_receive_packet(qemu_get_queue(s->nic), s->tx_packet,\n                                        total_bytes);\n                } else {\n                    qemu_send_packet(qemu_get_queue(s->nic), s->tx_packet,\n                                     total_bytes);\n                }\n\n                /* Prepare for next packet */\n                p = s->tx_packet;\n                total_bytes = 0;\n            }\n\n            /* read next descriptor */\n            if (tx_desc_get_wrap(desc)) {\n\n                if (s->regs[GEM_DMACFG] & GEM_DMACFG_ADDR_64B) {\n                    packet_desc_addr = s->regs[GEM_TBQPH];\n                    packet_desc_addr <<= 32;\n                } else {\n                    packet_desc_addr = 0;\n                }\n                packet_desc_addr |= gem_get_tx_queue_base_addr(s, q);\n            } else {\n                packet_desc_addr += 4 * gem_get_desc_len(s, false);\n            }\n            DB_PRINT(\"read descriptor 0x%\" HWADDR_PRIx \"\\n\", packet_desc_addr);\n            address_space_read(&s->dma_as, packet_desc_addr,\n                               MEMTXATTRS_UNSPECIFIED, desc,\n                               sizeof(uint32_t) * gem_get_desc_len(s, false));\n        }\n\n        if (tx_desc_get_used(desc)) {\n            s->regs[GEM_TXSTATUS] |= GEM_TXSTATUS_USED;\n            /* IRQ TXUSED is defined only for queue 0 */\n            if (q == 0) {\n                gem_set_isr(s, 0, GEM_INT_TXUSED);\n            }\n            gem_update_int_status(s);\n        }\n    }\n}", "func_hash": 333706942896596885696237067919896756767, "file_name": "cadence_gem.c", "file_hash": 35811516595388673046749961470018191104, "cwe": ["CWE-835"], "cve": "CVE-2021-3416", "cve_desc": "A potential stack overflow via infinite loop issue was found in various NIC emulators of QEMU in versions up to and including 5.2.0. The issue occurs in loopback mode of a NIC wherein reentrant DMA checks get bypassed. A guest user/process may use this flaw to consume CPU cycles or crash the QEMU process on the host resulting in DoS scenario.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-3416", "file_path": "hw/net/cadence_gem.c"}
