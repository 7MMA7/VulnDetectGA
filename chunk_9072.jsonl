{"idx": 214339, "project": "linux", "commit_id": "f62f3c20647ebd5fb6ecb8f0b477b9281c44c10a", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=f62f3c20647ebd5fb6ecb8f0b477b9281c44c10a", "commit_message": "KVM: PPC: Book3S: Fix H_RTAS rets buffer overflow\n\nThe kvmppc_rtas_hcall() sets the host rtas_args.rets pointer based on\nthe rtas_args.nargs that was provided by the guest. That guest nargs\nvalue is not range checked, so the guest can cause the host rets pointer\nto be pointed outside the args array. The individual rtas function\nhandlers check the nargs and nrets values to ensure they are correct,\nbut if they are not, the handlers store a -3 (0xfffffffd) failure\nindication in rets[0] which corrupts host memory.\n\nFix this by testing up front whether the guest supplied nargs and nret\nwould exceed the array size, and fail the hcall directly without storing\na failure indication to rets[0].\n\nAlso expand on a comment about why we kill the guest and try not to\nreturn errors directly if we have a valid rets[0] pointer.\n\nFixes: 8e591cb72047 (\"KVM: PPC: Book3S: Add infrastructure to implement kernel-side RTAS calls\")\nCc: stable@vger.kernel.org # v3.10+\nReported-by: Alexey Kardashevskiy <aik@ozlabs.ru>\nSigned-off-by: Nicholas Piggin <npiggin@gmail.com>\nSigned-off-by: Michael Ellerman <mpe@ellerman.id.au>", "target": 1, "func": "int kvmppc_rtas_hcall(struct kvm_vcpu *vcpu)\n{\n\tstruct rtas_token_definition *d;\n\tstruct rtas_args args;\n\trtas_arg_t *orig_rets;\n\tgpa_t args_phys;\n\tint rc;\n\n\t/*\n\t * r4 contains the guest physical address of the RTAS args\n\t * Mask off the top 4 bits since this is a guest real address\n\t */\n\targs_phys = kvmppc_get_gpr(vcpu, 4) & KVM_PAM;\n\n\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n\trc = kvm_read_guest(vcpu->kvm, args_phys, &args, sizeof(args));\n\tsrcu_read_unlock(&vcpu->kvm->srcu, vcpu->srcu_idx);\n\tif (rc)\n\t\tgoto fail;\n\n\t/*\n\t * args->rets is a pointer into args->args. Now that we've\n\t * copied args we need to fix it up to point into our copy,\n\t * not the guest args. We also need to save the original\n\t * value so we can restore it on the way out.\n\t */\n\torig_rets = args.rets;\n\targs.rets = &args.args[be32_to_cpu(args.nargs)];\n\n\tmutex_lock(&vcpu->kvm->arch.rtas_token_lock);\n\n\trc = -ENOENT;\n\tlist_for_each_entry(d, &vcpu->kvm->arch.rtas_tokens, list) {\n\t\tif (d->token == be32_to_cpu(args.token)) {\n\t\t\td->handler->handler(vcpu, &args);\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&vcpu->kvm->arch.rtas_token_lock);\n\n\tif (rc == 0) {\n\t\targs.rets = orig_rets;\n\t\trc = kvm_write_guest(vcpu->kvm, args_phys, &args, sizeof(args));\n\t\tif (rc)\n\t\t\tgoto fail;\n\t}\n\n\treturn rc;\n\nfail:\n\t/*\n\t * We only get here if the guest has called RTAS with a bogus\n\t * args pointer. That means we can't get to the args, and so we\n\t * can't fail the RTAS call. So fail right out to userspace,\n\t * which should kill the guest.\n\t */\n\treturn rc;\n}", "func_hash": 66579788869283176691450230454774242085, "file_name": "book3s_rtas.c", "file_hash": 244969410022637408362665450874858593503, "cwe": ["CWE-787"], "cve": "CVE-2021-37576", "cve_desc": "arch/powerpc/kvm/book3s_rtas.c in the Linux kernel through 5.13.5 on the powerpc platform allows KVM guest OS users to cause host OS memory corruption via rtas_args.nargs, aka CID-f62f3c20647e.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-37576", "file_path": "arch/powerpc/kvm/book3s_rtas.c"}
{"idx": 477811, "project": "linux", "commit_id": "f62f3c20647ebd5fb6ecb8f0b477b9281c44c10a", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=f62f3c20647ebd5fb6ecb8f0b477b9281c44c10a", "commit_message": "KVM: PPC: Book3S: Fix H_RTAS rets buffer overflow\n\nThe kvmppc_rtas_hcall() sets the host rtas_args.rets pointer based on\nthe rtas_args.nargs that was provided by the guest. That guest nargs\nvalue is not range checked, so the guest can cause the host rets pointer\nto be pointed outside the args array. The individual rtas function\nhandlers check the nargs and nrets values to ensure they are correct,\nbut if they are not, the handlers store a -3 (0xfffffffd) failure\nindication in rets[0] which corrupts host memory.\n\nFix this by testing up front whether the guest supplied nargs and nret\nwould exceed the array size, and fail the hcall directly without storing\na failure indication to rets[0].\n\nAlso expand on a comment about why we kill the guest and try not to\nreturn errors directly if we have a valid rets[0] pointer.\n\nFixes: 8e591cb72047 (\"KVM: PPC: Book3S: Add infrastructure to implement kernel-side RTAS calls\")\nCc: stable@vger.kernel.org # v3.10+\nReported-by: Alexey Kardashevskiy <aik@ozlabs.ru>\nSigned-off-by: Nicholas Piggin <npiggin@gmail.com>\nSigned-off-by: Michael Ellerman <mpe@ellerman.id.au>", "target": 0, "func": "int kvmppc_rtas_hcall(struct kvm_vcpu *vcpu)\n{\n\tstruct rtas_token_definition *d;\n\tstruct rtas_args args;\n\trtas_arg_t *orig_rets;\n\tgpa_t args_phys;\n\tint rc;\n\n\t/*\n\t * r4 contains the guest physical address of the RTAS args\n\t * Mask off the top 4 bits since this is a guest real address\n\t */\n\targs_phys = kvmppc_get_gpr(vcpu, 4) & KVM_PAM;\n\n\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n\trc = kvm_read_guest(vcpu->kvm, args_phys, &args, sizeof(args));\n\tsrcu_read_unlock(&vcpu->kvm->srcu, vcpu->srcu_idx);\n\tif (rc)\n\t\tgoto fail;\n\n\t/*\n\t * args->rets is a pointer into args->args. Now that we've\n\t * copied args we need to fix it up to point into our copy,\n\t * not the guest args. We also need to save the original\n\t * value so we can restore it on the way out.\n\t */\n\torig_rets = args.rets;\n\tif (be32_to_cpu(args.nargs) >= ARRAY_SIZE(args.args)) {\n\t\t/*\n\t\t * Don't overflow our args array: ensure there is room for\n\t\t * at least rets[0] (even if the call specifies 0 nret).\n\t\t *\n\t\t * Each handler must then check for the correct nargs and nret\n\t\t * values, but they may always return failure in rets[0].\n\t\t */\n\t\trc = -EINVAL;\n\t\tgoto fail;\n\t}\n\targs.rets = &args.args[be32_to_cpu(args.nargs)];\n\n\tmutex_lock(&vcpu->kvm->arch.rtas_token_lock);\n\n\trc = -ENOENT;\n\tlist_for_each_entry(d, &vcpu->kvm->arch.rtas_tokens, list) {\n\t\tif (d->token == be32_to_cpu(args.token)) {\n\t\t\td->handler->handler(vcpu, &args);\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&vcpu->kvm->arch.rtas_token_lock);\n\n\tif (rc == 0) {\n\t\targs.rets = orig_rets;\n\t\trc = kvm_write_guest(vcpu->kvm, args_phys, &args, sizeof(args));\n\t\tif (rc)\n\t\t\tgoto fail;\n\t}\n\n\treturn rc;\n\nfail:\n\t/*\n\t * We only get here if the guest has called RTAS with a bogus\n\t * args pointer or nargs/nret values that would overflow the\n\t * array. That means we can't get to the args, and so we can't\n\t * fail the RTAS call. So fail right out to userspace, which\n\t * should kill the guest.\n\t *\n\t * SLOF should actually pass the hcall return value from the\n\t * rtas handler call in r3, so enter_rtas could be modified to\n\t * return a failure indication in r3 and we could return such\n\t * errors to the guest rather than failing to host userspace.\n\t * However old guests that don't test for failure could then\n\t * continue silently after errors, so for now we won't do this.\n\t */\n\treturn rc;\n}", "func_hash": 270253933279643819807414798855847113264, "file_name": "book3s_rtas.c", "file_hash": 244634684304024017969354424959522055540, "cwe": ["CWE-787"], "cve": "CVE-2021-37576", "cve_desc": "arch/powerpc/kvm/book3s_rtas.c in the Linux kernel through 5.13.5 on the powerpc platform allows KVM guest OS users to cause host OS memory corruption via rtas_args.nargs, aka CID-f62f3c20647e.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-37576", "file_path": "arch/powerpc/kvm/book3s_rtas.c"}
{"idx": 214358, "project": "clamav-devel", "commit_id": "224fee54dd6cd8933d7007331ec2bfca0398d4b4", "project_url": "https://github.com/vrtadmin/clamav-devel", "commit_url": "http://git.clamav.net/gitweb?p=clamav-devel.git;a=commit;h=224fee54dd6cd8933d7007331ec2bfca0398d4b4", "commit_message": "libclamav/mspack.c: fix Quantum decompressor (bb#1771)", "target": 1, "func": "int qtm_decompress(struct qtm_stream *qtm, off_t out_bytes) {\n  unsigned int frame_start, frame_end, window_posn, match_offset, range;\n  unsigned char *window, *i_ptr, *i_end, *runsrc, *rundest;\n  int i, j, selector, extra, sym, match_length, ret;\n  unsigned short H, L, C, symf;\n\n  register unsigned int bit_buffer;\n  register unsigned char bits_left;\n  unsigned char bits_needed, bit_run;\n\n  /* easy answers */\n  if (!qtm || (out_bytes < 0)) return CL_ENULLARG;\n  if (qtm->error) return qtm->error;\n\n  /* flush out any stored-up bytes before we begin */\n  i = qtm->o_end - qtm->o_ptr;\n  if ((off_t) i > out_bytes) i = (int) out_bytes;\n  if (i) {\n    if (qtm->wflag && (ret = mspack_write(qtm->ofd, qtm->o_ptr, i, qtm->file)) != CL_SUCCESS) {\n      return qtm->error = ret;\n    }\n    qtm->o_ptr  += i;\n    out_bytes   -= i;\n  }\n  if (out_bytes == 0) return CL_SUCCESS;\n\n  /* restore local state */\n  QTM_RESTORE_BITS;\n  window = qtm->window;\n  window_posn = qtm->window_posn;\n  frame_start = qtm->frame_start;\n  H = qtm->H;\n  L = qtm->L;\n  C = qtm->C;\n\n  /* while we do not have enough decoded bytes in reserve: */\n  while ((qtm->o_end - qtm->o_ptr) < out_bytes) {\n\n    /* read header if necessary. Initialises H, L and C */\n    if (!qtm->header_read) {\n      H = 0xFFFF; L = 0; QTM_READ_BITS(C, 16);\n      qtm->header_read = 1;\n    }\n\n    /* decode more, at most up to to frame boundary */\n    frame_end = window_posn + (out_bytes - (qtm->o_end - qtm->o_ptr));\n    if ((frame_start + QTM_FRAME_SIZE) < frame_end) {\n      frame_end = frame_start + QTM_FRAME_SIZE;\n    }\n\n    while (window_posn < frame_end) {\n      QTM_GET_SYMBOL(qtm->model7, selector);\n      if (selector < 4) {\n\tstruct qtm_model *mdl = (selector == 0) ? &qtm->model0 :\n\t                        ((selector == 1) ? &qtm->model1 :\n\t\t\t\t((selector == 2) ? &qtm->model2 :\n                                                   &qtm->model3));\n\tQTM_GET_SYMBOL((*mdl), sym);\n\twindow[window_posn++] = sym;\n      }\n      else {\n\tswitch (selector) {\n\tcase 4: /* selector 4 = fixed length match (3 bytes) */\n\t  QTM_GET_SYMBOL(qtm->model4, sym);\n\t  QTM_READ_BITS(extra, qtm->extra_bits[sym]);\n\t  match_offset = qtm->position_base[sym] + extra + 1;\n\t  match_length = 3;\n\t  break;\n\n\tcase 5: /* selector 5 = fixed length match (4 bytes) */\n\t  QTM_GET_SYMBOL(qtm->model5, sym);\n\t  QTM_READ_BITS(extra, qtm->extra_bits[sym]);\n\t  match_offset = qtm->position_base[sym] + extra + 1;\n\t  match_length = 4;\n\t  break;\n\n\tcase 6: /* selector 6 = variable length match */\n\t  QTM_GET_SYMBOL(qtm->model6len, sym);\n\t  QTM_READ_BITS(extra, qtm->length_extra[sym]);\n\t  match_length = qtm->length_base[sym] + extra + 5;\n\n\t  QTM_GET_SYMBOL(qtm->model6, sym);\n\t  QTM_READ_BITS(extra, qtm->extra_bits[sym]);\n\t  match_offset = qtm->position_base[sym] + extra + 1;\n\t  break;\n\n\tdefault:\n\t  /* should be impossible, model7 can only return 0-6 */\n\t  return qtm->error = CL_EFORMAT;\n\t}\n\n\trundest = &window[window_posn];\n\ti = match_length;\n\t/* does match offset wrap the window? */\n\tif (match_offset > window_posn) {\n\t  /* j = length from match offset to end of window */\n\t  j = match_offset - window_posn;\n\t  if (j > (int) qtm->window_size) {\n\t    cli_dbgmsg(\"qtm_decompress: match offset beyond window boundaries\\n\");\n\t    return qtm->error = CL_EFORMAT;\n\t  }\n\t  runsrc = &window[qtm->window_size - j];\n\t  if (j < i) {\n\t    /* if match goes over the window edge, do two copy runs */\n\t    i -= j; while (j-- > 0) *rundest++ = *runsrc++;\n\t    runsrc = window;\n\t  }\n\t  while (i-- > 0) *rundest++ = *runsrc++;\n\t}\n\telse {\n\t  runsrc = rundest - match_offset;\n\t  if(i > (int) (qtm->window_size - window_posn))\n\t    i = qtm->window_size - window_posn;\n\t  while (i-- > 0) *rundest++ = *runsrc++;\n\t}\n\twindow_posn += match_length;\n      }\n    } /* while (window_posn < frame_end) */\n\n    qtm->o_end = &window[window_posn];\n\n    /* another frame completed? */\n    if ((window_posn - frame_start) >= QTM_FRAME_SIZE) {\n      if ((window_posn - frame_start) != QTM_FRAME_SIZE) {\n\tcli_dbgmsg(\"qtm_decompress: overshot frame alignment\\n\");\n\treturn qtm->error = CL_EFORMAT;\n      }\n\n      /* re-align input */\n      if (bits_left & 7) QTM_REMOVE_BITS(bits_left & 7);\n      do { QTM_READ_BITS(i, 8); } while (i != 0xFF);\n      qtm->header_read = 0;\n\n      /* window wrap? */\n      if (window_posn == qtm->window_size) {\n\t/* flush all currently stored data */\n\ti = (qtm->o_end - qtm->o_ptr);\n\tif (qtm->wflag && (ret = mspack_write(qtm->ofd, qtm->o_ptr, i, qtm->file)) != CL_SUCCESS) {\n\t  return qtm->error = ret;\n\t}\n\tout_bytes -= i;\n\tqtm->o_ptr = &window[0];\n\tqtm->o_end = &window[0];\n\twindow_posn = 0;\n      }\n\n      frame_start = window_posn;\n    }\n\n  } /* while (more bytes needed) */\n\n  if (out_bytes) {\n    i = (int) out_bytes;\n    if (qtm->wflag && (ret = mspack_write(qtm->ofd, qtm->o_ptr, i, qtm->file)) != CL_SUCCESS) {\n      return qtm->error = ret;\n    }\n    qtm->o_ptr += i;\n  }\n\n  /* store local state */\n  QTM_STORE_BITS;\n  qtm->window_posn = window_posn;\n  qtm->frame_start = frame_start;\n  qtm->H = H;\n  qtm->L = L;\n  qtm->C = C;\n\n  return CL_SUCCESS;\n}", "func_hash": 291050376752284006088755347145639053650, "file_name": "mspack.c", "file_hash": 137114659534783781079186144852150621076, "cwe": ["CWE-20"], "cve": "CVE-2010-1311", "cve_desc": "The qtm_decompress function in libclamav/mspack.c in ClamAV before 0.96 allows remote attackers to cause a denial of service (memory corruption and application crash) via a crafted CAB archive that uses the Quantum (aka .Q) compression format.  NOTE: some of these details are obtained from third party information.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2010-1311", "file_path": "libclamav/mspack.c"}
{"idx": 477946, "project": "clamav-devel", "commit_id": "224fee54dd6cd8933d7007331ec2bfca0398d4b4", "project_url": "https://github.com/vrtadmin/clamav-devel", "commit_url": "http://git.clamav.net/gitweb?p=clamav-devel.git;a=commit;h=224fee54dd6cd8933d7007331ec2bfca0398d4b4", "commit_message": "libclamav/mspack.c: fix Quantum decompressor (bb#1771)", "target": 0, "func": "int qtm_decompress(struct qtm_stream *qtm, off_t out_bytes) {\n  unsigned int frame_start, frame_end, window_posn, match_offset, range;\n  unsigned char *window, *i_ptr, *i_end, *runsrc, *rundest;\n  int i, j, selector, extra, sym, match_length, ret;\n  unsigned short H, L, C, symf;\n\n  register unsigned int bit_buffer;\n  register unsigned char bits_left;\n  unsigned char bits_needed, bit_run;\n\n  /* easy answers */\n  if (!qtm || (out_bytes < 0)) return CL_ENULLARG;\n  if (qtm->error) return qtm->error;\n\n  /* flush out any stored-up bytes before we begin */\n  i = qtm->o_end - qtm->o_ptr;\n  if ((off_t) i > out_bytes) i = (int) out_bytes;\n  if (i) {\n    if (qtm->wflag && (ret = mspack_write(qtm->ofd, qtm->o_ptr, i, qtm->file)) != CL_SUCCESS) {\n      return qtm->error = ret;\n    }\n    qtm->o_ptr  += i;\n    out_bytes   -= i;\n  }\n  if (out_bytes == 0) return CL_SUCCESS;\n\n  /* restore local state */\n  QTM_RESTORE_BITS;\n  window = qtm->window;\n  window_posn = qtm->window_posn;\n  frame_start = qtm->frame_start;\n  H = qtm->H;\n  L = qtm->L;\n  C = qtm->C;\n\n  /* while we do not have enough decoded bytes in reserve: */\n  while ((qtm->o_end - qtm->o_ptr) < out_bytes) {\n\n    /* read header if necessary. Initialises H, L and C */\n    if (!qtm->header_read) {\n      H = 0xFFFF; L = 0; QTM_READ_BITS(C, 16);\n      qtm->header_read = 1;\n    }\n\n    /* decode more, at most up to to frame boundary */\n    frame_end = window_posn + (out_bytes - (qtm->o_end - qtm->o_ptr));\n    if ((frame_start + QTM_FRAME_SIZE) < frame_end) {\n      frame_end = frame_start + QTM_FRAME_SIZE;\n    }\n\n    while (window_posn < frame_end) {\n      QTM_GET_SYMBOL(qtm->model7, selector);\n      if (selector < 4) {\n\tstruct qtm_model *mdl = (selector == 0) ? &qtm->model0 :\n\t                        ((selector == 1) ? &qtm->model1 :\n\t\t\t\t((selector == 2) ? &qtm->model2 :\n                                                   &qtm->model3));\n\tQTM_GET_SYMBOL((*mdl), sym);\n\twindow[window_posn++] = sym;\n      }\n      else {\n\tswitch (selector) {\n\tcase 4: /* selector 4 = fixed length match (3 bytes) */\n\t  QTM_GET_SYMBOL(qtm->model4, sym);\n\t  QTM_READ_BITS(extra, qtm->extra_bits[sym]);\n\t  match_offset = qtm->position_base[sym] + extra + 1;\n\t  match_length = 3;\n\t  break;\n\n\tcase 5: /* selector 5 = fixed length match (4 bytes) */\n\t  QTM_GET_SYMBOL(qtm->model5, sym);\n\t  QTM_READ_BITS(extra, qtm->extra_bits[sym]);\n\t  match_offset = qtm->position_base[sym] + extra + 1;\n\t  match_length = 4;\n\t  break;\n\n\tcase 6: /* selector 6 = variable length match */\n\t  QTM_GET_SYMBOL(qtm->model6len, sym);\n\t  QTM_READ_BITS(extra, qtm->length_extra[sym]);\n\t  match_length = qtm->length_base[sym] + extra + 5;\n\n\t  QTM_GET_SYMBOL(qtm->model6, sym);\n\t  QTM_READ_BITS(extra, qtm->extra_bits[sym]);\n\t  match_offset = qtm->position_base[sym] + extra + 1;\n\t  break;\n\n\tdefault:\n\t  /* should be impossible, model7 can only return 0-6 */\n\t  return qtm->error = CL_EFORMAT;\n\t}\n\n\tif (window_posn + match_length > qtm->window_size) {\n\t  cli_dbgmsg(\"qtm_decompress: match ran over window wrap\\n\");\n\t  return qtm->error = CL_EFORMAT;\n\t}\n\n\trundest = &window[window_posn];\n\ti = match_length;\n\t/* does match offset wrap the window? */\n\tif (match_offset > window_posn) {\n\t  /* j = length from match offset to end of window */\n\t  j = match_offset - window_posn;\n\t  if (j > (int) qtm->window_size) {\n\t    cli_dbgmsg(\"qtm_decompress: match offset beyond window boundaries\\n\");\n\t    return qtm->error = CL_EFORMAT;\n\t  }\n\t  runsrc = &window[qtm->window_size - j];\n\t  if (j < i) {\n\t    /* if match goes over the window edge, do two copy runs */\n\t    i -= j; while (j-- > 0) *rundest++ = *runsrc++;\n\t    runsrc = window;\n\t  }\n\t  while (i-- > 0) *rundest++ = *runsrc++;\n\t}\n\telse {\n\t  runsrc = rundest - match_offset;\n\t  if(i > (int) (qtm->window_size - window_posn))\n\t    i = qtm->window_size - window_posn;\n\t  while (i-- > 0) *rundest++ = *runsrc++;\n\t}\n\twindow_posn += match_length;\n      }\n    } /* while (window_posn < frame_end) */\n\n    qtm->o_end = &window[window_posn];\n\n    /* another frame completed? */\n    if ((window_posn - frame_start) >= QTM_FRAME_SIZE) {\n      if ((window_posn - frame_start) != QTM_FRAME_SIZE) {\n\tcli_dbgmsg(\"qtm_decompress: overshot frame alignment\\n\");\n\treturn qtm->error = CL_EFORMAT;\n      }\n\n      /* re-align input */\n      if (bits_left & 7) QTM_REMOVE_BITS(bits_left & 7);\n      do { QTM_READ_BITS(i, 8); } while (i != 0xFF);\n      qtm->header_read = 0;\n\n      /* window wrap? */\n      if (window_posn == qtm->window_size) {\n\t/* flush all currently stored data */\n\ti = (qtm->o_end - qtm->o_ptr);\n\tif (qtm->wflag && (ret = mspack_write(qtm->ofd, qtm->o_ptr, i, qtm->file)) != CL_SUCCESS) {\n\t  return qtm->error = ret;\n\t}\n\tout_bytes -= i;\n\tqtm->o_ptr = &window[0];\n\tqtm->o_end = &window[0];\n\twindow_posn = 0;\n      }\n\n      frame_start = window_posn;\n    }\n\n  } /* while (more bytes needed) */\n\n  if (out_bytes) {\n    i = (int) out_bytes;\n    if (qtm->wflag && (ret = mspack_write(qtm->ofd, qtm->o_ptr, i, qtm->file)) != CL_SUCCESS) {\n      return qtm->error = ret;\n    }\n    qtm->o_ptr += i;\n  }\n\n  /* store local state */\n  QTM_STORE_BITS;\n  qtm->window_posn = window_posn;\n  qtm->frame_start = frame_start;\n  qtm->H = H;\n  qtm->L = L;\n  qtm->C = C;\n\n  return CL_SUCCESS;\n}", "func_hash": 309561544522405112370599990059884786931, "file_name": "mspack.c", "file_hash": 294647704290965311324683497678599566631, "cwe": ["CWE-20"], "cve": "CVE-2010-1311", "cve_desc": "The qtm_decompress function in libclamav/mspack.c in ClamAV before 0.96 allows remote attackers to cause a denial of service (memory corruption and application crash) via a crafted CAB archive that uses the Quantum (aka .Q) compression format.  NOTE: some of these details are obtained from third party information.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2010-1311", "file_path": "libclamav/mspack.c"}
