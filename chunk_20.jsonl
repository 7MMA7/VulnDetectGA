{"idx": 205823, "project": "ovs", "commit_id": "803ed12e31b0377c37d7aa8c94b3b92f2081e349", "project_url": "https://github.com/openvswitch/ovs", "commit_url": "https://github.com/openvswitch/ovs/commit/803ed12e31b0377c37d7aa8c94b3b92f2081e349", "commit_message": "ipf: release unhandled packets from the batch\n\nSince 640d4db788ed (\"ipf: Fix a use-after-free error, ...\") the ipf\nframework unconditionally allocates a new dp_packet to track\nindividual fragments.  This prevents a use-after-free.  However, an\nadditional issue was present - even when the packet buffer is cloned,\nif the ip fragment handling code keeps it, the original buffer is\nleaked during the refill loop.  Even in the original processing code,\nthe hardcoded dnsteal branches would always leak a packet buffer from\nthe refill loop.\n\nThis can be confirmed with valgrind:\n\n==717566== 16,672 (4,480 direct, 12,192 indirect) bytes in 8 blocks are definitely lost in loss record 390 of 390\n==717566==    at 0x484086F: malloc (vg_replace_malloc.c:380)\n==717566==    by 0x537BFD: xmalloc__ (util.c:137)\n==717566==    by 0x537BFD: xmalloc (util.c:172)\n==717566==    by 0x46DDD4: dp_packet_new (dp-packet.c:153)\n==717566==    by 0x46DDD4: dp_packet_new_with_headroom (dp-packet.c:163)\n==717566==    by 0x550AA6: netdev_linux_batch_rxq_recv_sock.constprop.0 (netdev-linux.c:1262)\n==717566==    by 0x5512AF: netdev_linux_rxq_recv (netdev-linux.c:1511)\n==717566==    by 0x4AB7E0: netdev_rxq_recv (netdev.c:727)\n==717566==    by 0x47F00D: dp_netdev_process_rxq_port (dpif-netdev.c:4699)\n==717566==    by 0x47FD13: dpif_netdev_run (dpif-netdev.c:5957)\n==717566==    by 0x4331D2: type_run (ofproto-dpif.c:370)\n==717566==    by 0x41DFD8: ofproto_type_run (ofproto.c:1768)\n==717566==    by 0x40A7FB: bridge_run__ (bridge.c:3245)\n==717566==    by 0x411269: bridge_run (bridge.c:3310)\n==717566==    by 0x406E6C: main (ovs-vswitchd.c:127)\n\nThe fix is to delete the original packet when it isn't able to be\nreinserted into the packet batch.  Subsequent valgrind runs show that\nthe packets are not leaked from the batch any longer.\n\nFixes: 640d4db788ed (\"ipf: Fix a use-after-free error, and remove the 'do_not_steal' flag.\")\nFixes: 4ea96698f667 (\"Userspace datapath: Add fragmentation handling.\")\nReported-by: Wan Junjie <wanjunjie@bytedance.com>\nReported-at: https://github.com/openvswitch/ovs-issues/issues/226\nSigned-off-by: Aaron Conole <aconole@redhat.com>\nReviewed-by: David Marchand <david.marchand@redhat.com>\nTested-by: Wan Junjie <wanjunjie@bytedance.com>\nSigned-off-by: Alin-Gabriel Serdean <aserdean@ovn.org>", "target": 1, "func": "ipf_extract_frags_from_batch(struct ipf *ipf, struct dp_packet_batch *pb,\n                             ovs_be16 dl_type, uint16_t zone, long long now,\n                             uint32_t hash_basis)\n{\n    const size_t pb_cnt = dp_packet_batch_size(pb);\n    int pb_idx; /* Index in a packet batch. */\n    struct dp_packet *pkt;\n\n    DP_PACKET_BATCH_REFILL_FOR_EACH (pb_idx, pb_cnt, pkt, pb) {\n        if (OVS_UNLIKELY((dl_type == htons(ETH_TYPE_IP) &&\n                          ipf_is_valid_v4_frag(ipf, pkt))\n                          ||\n                          (dl_type == htons(ETH_TYPE_IPV6) &&\n                          ipf_is_valid_v6_frag(ipf, pkt)))) {\n\n            ovs_mutex_lock(&ipf->ipf_lock);\n            if (!ipf_handle_frag(ipf, pkt, dl_type, zone, now, hash_basis)) {\n                dp_packet_batch_refill(pb, pkt, pb_idx);\n            }\n            ovs_mutex_unlock(&ipf->ipf_lock);\n        } else {\n            dp_packet_batch_refill(pb, pkt, pb_idx);\n        }\n    }\n}", "func_hash": 268719993787134993398351954055334505161, "file_name": "ipf.c", "file_hash": 8691777507480014794600271586586377411, "cwe": ["CWE-401"], "cve": "CVE-2021-3905", "cve_desc": "A memory leak was found in Open vSwitch (OVS) during userspace IP fragmentation processing. An attacker could use this flaw to potentially exhaust available memory by keeping sending packet fragments.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-3905", "file_path": "lib/ipf.c"}
{"idx": 373535, "project": "ovs", "commit_id": "803ed12e31b0377c37d7aa8c94b3b92f2081e349", "project_url": "https://github.com/openvswitch/ovs", "commit_url": "https://github.com/openvswitch/ovs/commit/803ed12e31b0377c37d7aa8c94b3b92f2081e349", "commit_message": "ipf: release unhandled packets from the batch\n\nSince 640d4db788ed (\"ipf: Fix a use-after-free error, ...\") the ipf\nframework unconditionally allocates a new dp_packet to track\nindividual fragments.  This prevents a use-after-free.  However, an\nadditional issue was present - even when the packet buffer is cloned,\nif the ip fragment handling code keeps it, the original buffer is\nleaked during the refill loop.  Even in the original processing code,\nthe hardcoded dnsteal branches would always leak a packet buffer from\nthe refill loop.\n\nThis can be confirmed with valgrind:\n\n==717566== 16,672 (4,480 direct, 12,192 indirect) bytes in 8 blocks are definitely lost in loss record 390 of 390\n==717566==    at 0x484086F: malloc (vg_replace_malloc.c:380)\n==717566==    by 0x537BFD: xmalloc__ (util.c:137)\n==717566==    by 0x537BFD: xmalloc (util.c:172)\n==717566==    by 0x46DDD4: dp_packet_new (dp-packet.c:153)\n==717566==    by 0x46DDD4: dp_packet_new_with_headroom (dp-packet.c:163)\n==717566==    by 0x550AA6: netdev_linux_batch_rxq_recv_sock.constprop.0 (netdev-linux.c:1262)\n==717566==    by 0x5512AF: netdev_linux_rxq_recv (netdev-linux.c:1511)\n==717566==    by 0x4AB7E0: netdev_rxq_recv (netdev.c:727)\n==717566==    by 0x47F00D: dp_netdev_process_rxq_port (dpif-netdev.c:4699)\n==717566==    by 0x47FD13: dpif_netdev_run (dpif-netdev.c:5957)\n==717566==    by 0x4331D2: type_run (ofproto-dpif.c:370)\n==717566==    by 0x41DFD8: ofproto_type_run (ofproto.c:1768)\n==717566==    by 0x40A7FB: bridge_run__ (bridge.c:3245)\n==717566==    by 0x411269: bridge_run (bridge.c:3310)\n==717566==    by 0x406E6C: main (ovs-vswitchd.c:127)\n\nThe fix is to delete the original packet when it isn't able to be\nreinserted into the packet batch.  Subsequent valgrind runs show that\nthe packets are not leaked from the batch any longer.\n\nFixes: 640d4db788ed (\"ipf: Fix a use-after-free error, and remove the 'do_not_steal' flag.\")\nFixes: 4ea96698f667 (\"Userspace datapath: Add fragmentation handling.\")\nReported-by: Wan Junjie <wanjunjie@bytedance.com>\nReported-at: https://github.com/openvswitch/ovs-issues/issues/226\nSigned-off-by: Aaron Conole <aconole@redhat.com>\nReviewed-by: David Marchand <david.marchand@redhat.com>\nTested-by: Wan Junjie <wanjunjie@bytedance.com>\nSigned-off-by: Alin-Gabriel Serdean <aserdean@ovn.org>", "target": 0, "func": "ipf_extract_frags_from_batch(struct ipf *ipf, struct dp_packet_batch *pb,\n                             ovs_be16 dl_type, uint16_t zone, long long now,\n                             uint32_t hash_basis)\n{\n    const size_t pb_cnt = dp_packet_batch_size(pb);\n    int pb_idx; /* Index in a packet batch. */\n    struct dp_packet *pkt;\n\n    DP_PACKET_BATCH_REFILL_FOR_EACH (pb_idx, pb_cnt, pkt, pb) {\n        if (OVS_UNLIKELY((dl_type == htons(ETH_TYPE_IP) &&\n                          ipf_is_valid_v4_frag(ipf, pkt))\n                          ||\n                          (dl_type == htons(ETH_TYPE_IPV6) &&\n                          ipf_is_valid_v6_frag(ipf, pkt)))) {\n\n            ovs_mutex_lock(&ipf->ipf_lock);\n            if (!ipf_handle_frag(ipf, pkt, dl_type, zone, now, hash_basis)) {\n                dp_packet_batch_refill(pb, pkt, pb_idx);\n            } else {\n                dp_packet_delete(pkt);\n            }\n            ovs_mutex_unlock(&ipf->ipf_lock);\n        } else {\n            dp_packet_batch_refill(pb, pkt, pb_idx);\n        }\n    }\n}", "func_hash": 120994420466199339145680136614353279460, "file_name": "ipf.c", "file_hash": 251424754321869382912198899459965953031, "cwe": ["CWE-401"], "cve": "CVE-2021-3905", "cve_desc": "A memory leak was found in Open vSwitch (OVS) during userspace IP fragmentation processing. An attacker could use this flaw to potentially exhaust available memory by keeping sending packet fragments.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-3905", "file_path": "lib/ipf.c"}
{"idx": 206043, "project": "gimp", "commit_id": "c57f9dcf1934a9ab0cd67650f2dea18cb0902270", "project_url": "https://github.com/GNOME/gimp", "commit_url": "https://git.gnome.org/browse/gimp/commit/?id=c57f9dcf1934a9ab0cd67650f2dea18cb0902270", "commit_message": "Bug 790784 - (CVE-2017-17784) heap overread in gbr parser / load_image.\n\nWe were assuming the input name was well formed, hence was\nnul-terminated. As any data coming from external input, this has to be\nthorougly checked.\nSimilar to commit 06d24a79af94837d615d0024916bb95a01bf3c59 but adapted\nto older gimp-2-8 code.", "target": 1, "func": "load_image (const gchar  *filename,\n            GError      **error)\n{\n  gchar             *name;\n  gint               fd;\n  BrushHeader        bh;\n  guchar            *brush_buf = NULL;\n  gint32             image_ID;\n  gint32             layer_ID;\n  GimpParasite      *parasite;\n  GimpDrawable      *drawable;\n  GimpPixelRgn       pixel_rgn;\n  gint               bn_size;\n  GimpImageBaseType  base_type;\n  GimpImageType      image_type;\n  gsize              size;\n\n  fd = g_open (filename, O_RDONLY | _O_BINARY, 0);\n\n  if (fd == -1)\n    {\n      g_set_error (error, G_FILE_ERROR, g_file_error_from_errno (errno),\n                   _(\"Could not open '%s' for reading: %s\"),\n                   gimp_filename_to_utf8 (filename), g_strerror (errno));\n      return -1;\n    }\n\n  gimp_progress_init_printf (_(\"Opening '%s'\"),\n                             gimp_filename_to_utf8 (filename));\n\n  if (read (fd, &bh, sizeof (BrushHeader)) != sizeof (BrushHeader))\n    {\n      close (fd);\n      return -1;\n    }\n\n  /*  rearrange the bytes in each unsigned int  */\n  bh.header_size  = g_ntohl (bh.header_size);\n  bh.version      = g_ntohl (bh.version);\n  bh.width        = g_ntohl (bh.width);\n  bh.height       = g_ntohl (bh.height);\n  bh.bytes        = g_ntohl (bh.bytes);\n  bh.magic_number = g_ntohl (bh.magic_number);\n  bh.spacing      = g_ntohl (bh.spacing);\n\n  /* Sanitize values */\n  if ((bh.width == 0) || (bh.width > GIMP_MAX_IMAGE_SIZE) ||\n      (bh.height == 0) || (bh.height > GIMP_MAX_IMAGE_SIZE) ||\n      ((bh.bytes != 1) && (bh.bytes != 2) && (bh.bytes != 4) &&\n       (bh.bytes != 18)) ||\n      (G_MAXSIZE / bh.width / bh.height / bh.bytes < 1))\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"Invalid header data in '%s': width=%lu, height=%lu, \"\n                     \"bytes=%lu\"), gimp_filename_to_utf8 (filename),\n                   (unsigned long int)bh.width, (unsigned long int)bh.height,\n                   (unsigned long int)bh.bytes);\n      return -1;\n    }\n\n  switch (bh.version)\n    {\n    case 1:\n      /* Version 1 didn't have a magic number and had no spacing  */\n      bh.spacing = 25;\n      /* And we need to rewind the handle, 4 due spacing and 4 due magic */\n      lseek (fd, -8, SEEK_CUR);\n      bh.header_size += 8;\n      break;\n\n    case 3: /*  cinepaint brush  */\n      if (bh.bytes == 18 /* FLOAT16_GRAY_GIMAGE */)\n        {\n          bh.bytes = 2;\n        }\n      else\n        {\n          g_message (_(\"Unsupported brush format\"));\n          close (fd);\n          return -1;\n        }\n      /*  fallthrough  */\n\n    case 2:\n      if (bh.magic_number == GBRUSH_MAGIC &&\n          bh.header_size  >  sizeof (BrushHeader))\n        break;\n\n    default:\n      g_message (_(\"Unsupported brush format\"));\n      close (fd);\n      return -1;\n    }\n\n  if ((bn_size = (bh.header_size - sizeof (BrushHeader))) > 0)\n    {\n      gchar *temp = g_new (gchar, bn_size);\n\n      if ((read (fd, temp, bn_size)) < bn_size)\n        {\n          g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                       _(\"Error in GIMP brush file '%s'\"),\n                       gimp_filename_to_utf8 (filename));\n          close (fd);\n          g_free (temp);\n          return -1;\n        }\n\n      name = gimp_any_to_utf8 (temp, -1,\n                               _(\"Invalid UTF-8 string in brush file '%s'.\"),\n                               gimp_filename_to_utf8 (filename));\n      g_free (temp);\n    }\n  else\n    {\n      name = g_strdup (_(\"Unnamed\"));\n    }\n\n  /* Now there's just raw data left. */\n\n  size = bh.width * bh.height * bh.bytes;\n  brush_buf = g_malloc (size);\n\n  if (read (fd, brush_buf, size) != size)\n    {\n      close (fd);\n      g_free (brush_buf);\n      g_free (name);\n      return -1;\n    }\n\n  switch (bh.bytes)\n    {\n    case 1:\n      {\n        PatternHeader ph;\n\n        /*  For backwards-compatibility, check if a pattern follows.\n            The obsolete .gpb format did it this way.  */\n\n        if (read (fd, &ph, sizeof (PatternHeader)) == sizeof(PatternHeader))\n          {\n            /*  rearrange the bytes in each unsigned int  */\n            ph.header_size  = g_ntohl (ph.header_size);\n            ph.version      = g_ntohl (ph.version);\n            ph.width        = g_ntohl (ph.width);\n            ph.height       = g_ntohl (ph.height);\n            ph.bytes        = g_ntohl (ph.bytes);\n            ph.magic_number = g_ntohl (ph.magic_number);\n\n            if (ph.magic_number == GPATTERN_MAGIC        &&\n                ph.version      == 1                     &&\n                ph.header_size  > sizeof (PatternHeader) &&\n                ph.bytes        == 3                     &&\n                ph.width        == bh.width              &&\n                ph.height       == bh.height             &&\n                lseek (fd, ph.header_size - sizeof (PatternHeader),\n                       SEEK_CUR) > 0)\n              {\n                guchar *plain_brush = brush_buf;\n                gint    i;\n\n                bh.bytes = 4;\n                brush_buf = g_malloc (4 * bh.width * bh.height);\n\n                for (i = 0; i < ph.width * ph.height; i++)\n                  {\n                    if (read (fd, brush_buf + i * 4, 3) != 3)\n                      {\n                        close (fd);\n                        g_free (name);\n                        g_free (plain_brush);\n                        g_free (brush_buf);\n                        return -1;\n                      }\n                    brush_buf[i * 4 + 3] = plain_brush[i];\n                  }\n                g_free (plain_brush);\n              }\n          }\n      }\n      break;\n\n    case 2:\n      {\n        guint16 *buf = (guint16 *) brush_buf;\n        gint     i;\n\n        for (i = 0; i < bh.width * bh.height; i++, buf++)\n          {\n            union\n            {\n              guint16 u[2];\n              gfloat  f;\n            } short_float;\n\n#if G_BYTE_ORDER == G_LITTLE_ENDIAN\n            short_float.u[0] = 0;\n            short_float.u[1] = GUINT16_FROM_BE (*buf);\n#else\n            short_float.u[0] = GUINT16_FROM_BE (*buf);\n            short_float.u[1] = 0;\n#endif\n\n            brush_buf[i] = (guchar) (short_float.f * 255.0 + 0.5);\n          }\n\n        bh.bytes = 1;\n      }\n      break;\n\n    default:\n      break;\n    }\n\n  /*\n   * Create a new image of the proper size and\n   * associate the filename with it.\n   */\n\n  switch (bh.bytes)\n    {\n    case 1:\n      base_type = GIMP_GRAY;\n      image_type = GIMP_GRAY_IMAGE;\n      break;\n\n    case 4:\n      base_type = GIMP_RGB;\n      image_type = GIMP_RGBA_IMAGE;\n      break;\n\n    default:\n      g_message (\"Unsupported brush depth: %d\\n\"\n                 \"GIMP Brushes must be GRAY or RGBA\\n\",\n                 bh.bytes);\n      g_free (name);\n      return -1;\n    }\n\n  image_ID = gimp_image_new (bh.width, bh.height, base_type);\n  gimp_image_set_filename (image_ID, filename);\n\n  parasite = gimp_parasite_new (\"gimp-brush-name\",\n                                GIMP_PARASITE_PERSISTENT,\n                                strlen (name) + 1, name);\n  gimp_image_attach_parasite (image_ID, parasite);\n  gimp_parasite_free (parasite);\n\n  layer_ID = gimp_layer_new (image_ID, name, bh.width, bh.height,\n                             image_type, 100, GIMP_NORMAL_MODE);\n  gimp_image_insert_layer (image_ID, layer_ID, -1, 0);\n\n  g_free (name);\n\n  drawable = gimp_drawable_get (layer_ID);\n  gimp_pixel_rgn_init (&pixel_rgn, drawable,\n                       0, 0, drawable->width, drawable->height,\n                       TRUE, FALSE);\n\n  gimp_pixel_rgn_set_rect (&pixel_rgn, brush_buf,\n                           0, 0, bh.width, bh.height);\n  g_free (brush_buf);\n\n  if (image_type == GIMP_GRAY_IMAGE)\n    gimp_invert (layer_ID);\n\n  close (fd);\n\n  gimp_drawable_flush (drawable);\n  gimp_progress_update (1.0);\n\n  return image_ID;\n}", "func_hash": 219487381392289910094593757172224969152, "file_name": "file-gbr.c", "file_hash": 210537502330856952427982223109888523462, "cwe": ["CWE-125"], "cve": "CVE-2017-17784", "cve_desc": "In GIMP 2.8.22, there is a heap-based buffer over-read in load_image in plug-ins/common/file-gbr.c in the gbr import parser, related to mishandling of UTF-8 data.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-17784", "file_path": "plug-ins/common/file-gbr.c"}
{"idx": 376678, "project": "gimp", "commit_id": "c57f9dcf1934a9ab0cd67650f2dea18cb0902270", "project_url": "https://github.com/GNOME/gimp", "commit_url": "https://git.gnome.org/browse/gimp/commit/?id=c57f9dcf1934a9ab0cd67650f2dea18cb0902270", "commit_message": "Bug 790784 - (CVE-2017-17784) heap overread in gbr parser / load_image.\n\nWe were assuming the input name was well formed, hence was\nnul-terminated. As any data coming from external input, this has to be\nthorougly checked.\nSimilar to commit 06d24a79af94837d615d0024916bb95a01bf3c59 but adapted\nto older gimp-2-8 code.", "target": 0, "func": "load_image (const gchar  *filename,\n            GError      **error)\n{\n  gchar             *name;\n  gint               fd;\n  BrushHeader        bh;\n  guchar            *brush_buf = NULL;\n  gint32             image_ID;\n  gint32             layer_ID;\n  GimpParasite      *parasite;\n  GimpDrawable      *drawable;\n  GimpPixelRgn       pixel_rgn;\n  gint               bn_size;\n  GimpImageBaseType  base_type;\n  GimpImageType      image_type;\n  gsize              size;\n\n  fd = g_open (filename, O_RDONLY | _O_BINARY, 0);\n\n  if (fd == -1)\n    {\n      g_set_error (error, G_FILE_ERROR, g_file_error_from_errno (errno),\n                   _(\"Could not open '%s' for reading: %s\"),\n                   gimp_filename_to_utf8 (filename), g_strerror (errno));\n      return -1;\n    }\n\n  gimp_progress_init_printf (_(\"Opening '%s'\"),\n                             gimp_filename_to_utf8 (filename));\n\n  if (read (fd, &bh, sizeof (BrushHeader)) != sizeof (BrushHeader))\n    {\n      close (fd);\n      return -1;\n    }\n\n  /*  rearrange the bytes in each unsigned int  */\n  bh.header_size  = g_ntohl (bh.header_size);\n  bh.version      = g_ntohl (bh.version);\n  bh.width        = g_ntohl (bh.width);\n  bh.height       = g_ntohl (bh.height);\n  bh.bytes        = g_ntohl (bh.bytes);\n  bh.magic_number = g_ntohl (bh.magic_number);\n  bh.spacing      = g_ntohl (bh.spacing);\n\n  /* Sanitize values */\n  if ((bh.width == 0) || (bh.width > GIMP_MAX_IMAGE_SIZE) ||\n      (bh.height == 0) || (bh.height > GIMP_MAX_IMAGE_SIZE) ||\n      ((bh.bytes != 1) && (bh.bytes != 2) && (bh.bytes != 4) &&\n       (bh.bytes != 18)) ||\n      (G_MAXSIZE / bh.width / bh.height / bh.bytes < 1))\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"Invalid header data in '%s': width=%lu, height=%lu, \"\n                     \"bytes=%lu\"), gimp_filename_to_utf8 (filename),\n                   (unsigned long int)bh.width, (unsigned long int)bh.height,\n                   (unsigned long int)bh.bytes);\n      return -1;\n    }\n\n  switch (bh.version)\n    {\n    case 1:\n      /* Version 1 didn't have a magic number and had no spacing  */\n      bh.spacing = 25;\n      /* And we need to rewind the handle, 4 due spacing and 4 due magic */\n      lseek (fd, -8, SEEK_CUR);\n      bh.header_size += 8;\n      break;\n\n    case 3: /*  cinepaint brush  */\n      if (bh.bytes == 18 /* FLOAT16_GRAY_GIMAGE */)\n        {\n          bh.bytes = 2;\n        }\n      else\n        {\n          g_message (_(\"Unsupported brush format\"));\n          close (fd);\n          return -1;\n        }\n      /*  fallthrough  */\n\n    case 2:\n      if (bh.magic_number == GBRUSH_MAGIC &&\n          bh.header_size  >  sizeof (BrushHeader))\n        break;\n\n    default:\n      g_message (_(\"Unsupported brush format\"));\n      close (fd);\n      return -1;\n    }\n\n  if ((bn_size = (bh.header_size - sizeof (BrushHeader))) > 0)\n    {\n      gchar *temp = g_new (gchar, bn_size);\n\n      if ((read (fd, temp, bn_size)) < bn_size ||\n          temp[bn_size - 1] != '\\0')\n        {\n          g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                       _(\"Error in GIMP brush file '%s'\"),\n                       gimp_filename_to_utf8 (filename));\n          close (fd);\n          g_free (temp);\n          return -1;\n        }\n\n      name = gimp_any_to_utf8 (temp, -1,\n                               _(\"Invalid UTF-8 string in brush file '%s'.\"),\n                               gimp_filename_to_utf8 (filename));\n      g_free (temp);\n    }\n  else\n    {\n      name = g_strdup (_(\"Unnamed\"));\n    }\n\n  /* Now there's just raw data left. */\n\n  size = bh.width * bh.height * bh.bytes;\n  brush_buf = g_malloc (size);\n\n  if (read (fd, brush_buf, size) != size)\n    {\n      close (fd);\n      g_free (brush_buf);\n      g_free (name);\n      return -1;\n    }\n\n  switch (bh.bytes)\n    {\n    case 1:\n      {\n        PatternHeader ph;\n\n        /*  For backwards-compatibility, check if a pattern follows.\n            The obsolete .gpb format did it this way.  */\n\n        if (read (fd, &ph, sizeof (PatternHeader)) == sizeof(PatternHeader))\n          {\n            /*  rearrange the bytes in each unsigned int  */\n            ph.header_size  = g_ntohl (ph.header_size);\n            ph.version      = g_ntohl (ph.version);\n            ph.width        = g_ntohl (ph.width);\n            ph.height       = g_ntohl (ph.height);\n            ph.bytes        = g_ntohl (ph.bytes);\n            ph.magic_number = g_ntohl (ph.magic_number);\n\n            if (ph.magic_number == GPATTERN_MAGIC        &&\n                ph.version      == 1                     &&\n                ph.header_size  > sizeof (PatternHeader) &&\n                ph.bytes        == 3                     &&\n                ph.width        == bh.width              &&\n                ph.height       == bh.height             &&\n                lseek (fd, ph.header_size - sizeof (PatternHeader),\n                       SEEK_CUR) > 0)\n              {\n                guchar *plain_brush = brush_buf;\n                gint    i;\n\n                bh.bytes = 4;\n                brush_buf = g_malloc (4 * bh.width * bh.height);\n\n                for (i = 0; i < ph.width * ph.height; i++)\n                  {\n                    if (read (fd, brush_buf + i * 4, 3) != 3)\n                      {\n                        close (fd);\n                        g_free (name);\n                        g_free (plain_brush);\n                        g_free (brush_buf);\n                        return -1;\n                      }\n                    brush_buf[i * 4 + 3] = plain_brush[i];\n                  }\n                g_free (plain_brush);\n              }\n          }\n      }\n      break;\n\n    case 2:\n      {\n        guint16 *buf = (guint16 *) brush_buf;\n        gint     i;\n\n        for (i = 0; i < bh.width * bh.height; i++, buf++)\n          {\n            union\n            {\n              guint16 u[2];\n              gfloat  f;\n            } short_float;\n\n#if G_BYTE_ORDER == G_LITTLE_ENDIAN\n            short_float.u[0] = 0;\n            short_float.u[1] = GUINT16_FROM_BE (*buf);\n#else\n            short_float.u[0] = GUINT16_FROM_BE (*buf);\n            short_float.u[1] = 0;\n#endif\n\n            brush_buf[i] = (guchar) (short_float.f * 255.0 + 0.5);\n          }\n\n        bh.bytes = 1;\n      }\n      break;\n\n    default:\n      break;\n    }\n\n  /*\n   * Create a new image of the proper size and\n   * associate the filename with it.\n   */\n\n  switch (bh.bytes)\n    {\n    case 1:\n      base_type = GIMP_GRAY;\n      image_type = GIMP_GRAY_IMAGE;\n      break;\n\n    case 4:\n      base_type = GIMP_RGB;\n      image_type = GIMP_RGBA_IMAGE;\n      break;\n\n    default:\n      g_message (\"Unsupported brush depth: %d\\n\"\n                 \"GIMP Brushes must be GRAY or RGBA\\n\",\n                 bh.bytes);\n      g_free (name);\n      return -1;\n    }\n\n  image_ID = gimp_image_new (bh.width, bh.height, base_type);\n  gimp_image_set_filename (image_ID, filename);\n\n  parasite = gimp_parasite_new (\"gimp-brush-name\",\n                                GIMP_PARASITE_PERSISTENT,\n                                strlen (name) + 1, name);\n  gimp_image_attach_parasite (image_ID, parasite);\n  gimp_parasite_free (parasite);\n\n  layer_ID = gimp_layer_new (image_ID, name, bh.width, bh.height,\n                             image_type, 100, GIMP_NORMAL_MODE);\n  gimp_image_insert_layer (image_ID, layer_ID, -1, 0);\n\n  g_free (name);\n\n  drawable = gimp_drawable_get (layer_ID);\n  gimp_pixel_rgn_init (&pixel_rgn, drawable,\n                       0, 0, drawable->width, drawable->height,\n                       TRUE, FALSE);\n\n  gimp_pixel_rgn_set_rect (&pixel_rgn, brush_buf,\n                           0, 0, bh.width, bh.height);\n  g_free (brush_buf);\n\n  if (image_type == GIMP_GRAY_IMAGE)\n    gimp_invert (layer_ID);\n\n  close (fd);\n\n  gimp_drawable_flush (drawable);\n  gimp_progress_update (1.0);\n\n  return image_ID;\n}", "func_hash": 269327823766609487068724383051357537961, "file_name": "file-gbr.c", "file_hash": 146644042188037261041231342134151379601, "cwe": ["CWE-125"], "cve": "CVE-2017-17784", "cve_desc": "In GIMP 2.8.22, there is a heap-based buffer over-read in load_image in plug-ins/common/file-gbr.c in the gbr import parser, related to mishandling of UTF-8 data.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-17784", "file_path": "plug-ins/common/file-gbr.c"}
{"idx": 206262, "project": "vim", "commit_id": "c6fdb15d423df22e1776844811d082322475e48a", "project_url": "https://github.com/vim/vim", "commit_url": "https://github.com/vim/vim/commit/c6fdb15d423df22e1776844811d082322475e48a", "commit_message": "patch 9.0.0025: accessing beyond allocated memory with the cmdline window\n\nProblem:    Accessing beyond allocated memory when using the cmdline window in\n            Ex mode.\nSolution:   Use \"*\" instead of \"'<,'>\" for Visual mode.", "target": 1, "func": "parse_command_modifiers(\n\texarg_T\t    *eap,\n\tchar\t    **errormsg,\n\tcmdmod_T    *cmod,\n\tint\t    skip_only)\n{\n    char_u  *orig_cmd = eap->cmd;\n    char_u  *cmd_start = NULL;\n    int\t    use_plus_cmd = FALSE;\n    int\t    starts_with_colon = FALSE;\n    int\t    vim9script = in_vim9script();\n    int\t    has_visual_range = FALSE;\n\n    CLEAR_POINTER(cmod);\n    cmod->cmod_flags = sticky_cmdmod_flags;\n\n    if (STRNCMP(eap->cmd, \"'<,'>\", 5) == 0)\n    {\n\t// The automatically inserted Visual area range is skipped, so that\n\t// typing \":cmdmod cmd\" in Visual mode works without having to move the\n\t// range to after the modififiers. The command will be\n\t// \"'<,'>cmdmod cmd\", parse \"cmdmod cmd\" and then put back \"'<,'>\"\n\t// before \"cmd\" below.\n\teap->cmd += 5;\n\tcmd_start = eap->cmd;\n\thas_visual_range = TRUE;\n    }\n\n    // Repeat until no more command modifiers are found.\n    for (;;)\n    {\n\tchar_u  *p;\n\n\twhile (*eap->cmd == ' ' || *eap->cmd == '\\t' || *eap->cmd == ':')\n\t{\n\t    if (*eap->cmd == ':')\n\t\tstarts_with_colon = TRUE;\n\t    ++eap->cmd;\n\t}\n\n\t// in ex mode, an empty command (after modifiers) works like :+\n\tif (*eap->cmd == NUL && exmode_active\n\t\t   && (getline_equal(eap->getline, eap->cookie, getexmodeline)\n\t\t       || getline_equal(eap->getline, eap->cookie, getexline))\n\t\t\t&& curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t{\n\t    use_plus_cmd = TRUE;\n\t    if (!skip_only)\n\t\tex_pressedreturn = TRUE;\n\t    break;  // no modifiers following\n\t}\n\n\t// ignore comment and empty lines\n\tif (comment_start(eap->cmd, starts_with_colon))\n\t{\n\t    // a comment ends at a NL\n\t    if (eap->nextcmd == NULL)\n\t    {\n\t\teap->nextcmd = vim_strchr(eap->cmd, '\\n');\n\t\tif (eap->nextcmd != NULL)\n\t\t    ++eap->nextcmd;\n\t    }\n\t    if (vim9script && has_cmdmod(cmod, FALSE))\n\t\t*errormsg = _(e_command_modifier_without_command);\n\t    return FAIL;\n\t}\n\tif (*eap->cmd == NUL)\n\t{\n\t    if (!skip_only)\n\t    {\n\t\tex_pressedreturn = TRUE;\n\t\tif (vim9script && has_cmdmod(cmod, FALSE))\n\t\t    *errormsg = _(e_command_modifier_without_command);\n\t    }\n\t    return FAIL;\n\t}\n\n\tp = skip_range(eap->cmd, TRUE, NULL);\n\n\t// In Vim9 script a variable can shadow a command modifier:\n\t//   verbose = 123\n\t//   verbose += 123\n\t//   silent! verbose = func()\n\t//   verbose.member = 2\n\t//   verbose[expr] = 2\n\t// But not:\n\t//   verbose [a, b] = list\n\tif (vim9script)\n\t{\n\t    char_u *s, *n;\n\n\t    for (s = eap->cmd; ASCII_ISALPHA(*s); ++s)\n\t\t;\n\t    n = skipwhite(s);\n\t    if (*n == '.' || *n == '=' || (*n != NUL && n[1] == '=')\n\t\t    || *s == '[')\n\t\tbreak;\n\t}\n\n\tswitch (*p)\n\t{\n\t    // When adding an entry, also modify cmd_exists().\n\t    case 'a':\tif (!checkforcmd_noparen(&eap->cmd, \"aboveleft\", 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_ABOVE;\n\t\t\tcontinue;\n\n\t    case 'b':\tif (checkforcmd_noparen(&eap->cmd, \"belowright\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_split |= WSP_BELOW;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_opt(&eap->cmd, \"browse\", 3, TRUE))\n\t\t\t{\n#ifdef FEAT_BROWSE_CMD\n\t\t\t    cmod->cmod_flags |= CMOD_BROWSE;\n#endif\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"botright\", 2))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_BOT;\n\t\t\tcontinue;\n\n\t    case 'c':\tif (!checkforcmd_opt(&eap->cmd, \"confirm\", 4, TRUE))\n\t\t\t    break;\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t\t\tcmod->cmod_flags |= CMOD_CONFIRM;\n#endif\n\t\t\tcontinue;\n\n\t    case 'k':\tif (checkforcmd_noparen(&eap->cmd, \"keepmarks\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_KEEPMARKS;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd, \"keepalt\", 5))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_KEEPALT;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd, \"keeppatterns\", 5))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_KEEPPATTERNS;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"keepjumps\", 5))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_KEEPJUMPS;\n\t\t\tcontinue;\n\n\t    case 'f':\t// only accept \":filter {pat} cmd\"\n\t\t\t{\n\t\t\t    char_u  *reg_pat;\n\t\t\t    char_u  *nulp = NULL;\n\t\t\t    int\t    c = 0;\n\n\t\t\t    if (!checkforcmd_noparen(&p, \"filter\", 4)\n\t\t\t\t    || *p == NUL\n\t\t\t\t    || (ends_excmd(*p)\n#ifdef FEAT_EVAL\n\t\t\t\t\t// in \":filter #pat# cmd\" # does not\n\t\t\t\t\t// start a comment\n\t\t\t\t     && (!vim9script || VIM_ISWHITE(p[1]))\n#endif\n\t\t\t\t     ))\n\t\t\t\tbreak;\n\t\t\t    if (*p == '!')\n\t\t\t    {\n\t\t\t\tcmod->cmod_filter_force = TRUE;\n\t\t\t\tp = skipwhite(p + 1);\n\t\t\t\tif (*p == NUL || ends_excmd(*p))\n\t\t\t\t    break;\n\t\t\t    }\n#ifdef FEAT_EVAL\n\t\t\t    // Avoid that \"filter(arg)\" is recognized.\n\t\t\t    if (vim9script && !VIM_ISWHITE(p[-1]))\n\t\t\t\tbreak;\n#endif\n\t\t\t    if (skip_only)\n\t\t\t\tp = skip_vimgrep_pat(p, NULL, NULL);\n\t\t\t    else\n\t\t\t\t// NOTE: This puts a NUL after the pattern.\n\t\t\t\tp = skip_vimgrep_pat_ext(p, &reg_pat, NULL,\n\t\t\t\t\t\t\t\t    &nulp, &c);\n\t\t\t    if (p == NULL || *p == NUL)\n\t\t\t\tbreak;\n\t\t\t    if (!skip_only)\n\t\t\t    {\n\t\t\t\tcmod->cmod_filter_regmatch.regprog =\n\t\t\t\t\t\tvim_regcomp(reg_pat, RE_MAGIC);\n\t\t\t\tif (cmod->cmod_filter_regmatch.regprog == NULL)\n\t\t\t\t    break;\n\t\t\t\t// restore the character overwritten by NUL\n\t\t\t\tif (nulp != NULL)\n\t\t\t\t    *nulp = c;\n\t\t\t    }\n\t\t\t    eap->cmd = p;\n\t\t\t    continue;\n\t\t\t}\n\n\t\t\t// \":hide\" and \":hide | cmd\" are not modifiers\n\t    case 'h':\tif (p != eap->cmd || !checkforcmd_noparen(&p, \"hide\", 3)\n\t\t\t\t\t       || *p == NUL || ends_excmd(*p))\n\t\t\t    break;\n\t\t\teap->cmd = p;\n\t\t\tcmod->cmod_flags |= CMOD_HIDE;\n\t\t\tcontinue;\n\n\t    case 'l':\tif (checkforcmd_noparen(&eap->cmd, \"lockmarks\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_LOCKMARKS;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd, \"legacy\", 3))\n\t\t\t{\n\t\t\t    if (ends_excmd2(p, eap->cmd))\n\t\t\t    {\n\t\t\t\t*errormsg =\n\t\t\t\t      _(e_legacy_must_be_followed_by_command);\n\t\t\t\treturn FAIL;\n\t\t\t    }\n\t\t\t    cmod->cmod_flags |= CMOD_LEGACY;\n\t\t\t    continue;\n\t\t\t}\n\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"leftabove\", 5))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_ABOVE;\n\t\t\tcontinue;\n\n\t    case 'n':\tif (checkforcmd_noparen(&eap->cmd, \"noautocmd\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_NOAUTOCMD;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"noswapfile\", 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_NOSWAPFILE;\n\t\t\tcontinue;\n\n\t    case 'r':\tif (!checkforcmd_noparen(&eap->cmd, \"rightbelow\", 6))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_BELOW;\n\t\t\tcontinue;\n\n\t    case 's':\tif (checkforcmd_noparen(&eap->cmd, \"sandbox\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_SANDBOX;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"silent\", 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_SILENT;\n\t\t\tif (*eap->cmd == '!' && !VIM_ISWHITE(eap->cmd[-1]))\n\t\t\t{\n\t\t\t    // \":silent!\", but not \"silent !cmd\"\n\t\t\t    eap->cmd = skipwhite(eap->cmd + 1);\n\t\t\t    cmod->cmod_flags |= CMOD_ERRSILENT;\n\t\t\t}\n\t\t\tcontinue;\n\n\t    case 't':\tif (checkforcmd_noparen(&p, \"tab\", 3))\n\t\t\t{\n\t\t\t    if (!skip_only)\n\t\t\t    {\n\t\t\t\tlong tabnr = get_address(eap, &eap->cmd,\n\t\t\t\t\t\t    ADDR_TABS, eap->skip,\n\t\t\t\t\t\t    skip_only, FALSE, 1);\n\t\t\t\tif (tabnr == MAXLNUM)\n\t\t\t\t    cmod->cmod_tab = tabpage_index(curtab) + 1;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    if (tabnr < 0 || tabnr > LAST_TAB_NR)\n\t\t\t\t    {\n\t\t\t\t\t*errormsg = _(e_invalid_range);\n\t\t\t\t\treturn FAIL;\n\t\t\t\t    }\n\t\t\t\t    cmod->cmod_tab = tabnr + 1;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    eap->cmd = p;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"topleft\", 2))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_TOP;\n\t\t\tcontinue;\n\n\t    case 'u':\tif (!checkforcmd_noparen(&eap->cmd, \"unsilent\", 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_UNSILENT;\n\t\t\tcontinue;\n\n\t    case 'v':\tif (checkforcmd_noparen(&eap->cmd, \"vertical\", 4))\n\t\t\t{\n\t\t\t    cmod->cmod_split |= WSP_VERT;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd, \"vim9cmd\", 4))\n\t\t\t{\n\t\t\t    if (ends_excmd2(p, eap->cmd))\n\t\t\t    {\n\t\t\t\t*errormsg =\n\t\t\t\t      _(e_vim9cmd_must_be_followed_by_command);\n\t\t\t\treturn FAIL;\n\t\t\t    }\n\t\t\t    cmod->cmod_flags |= CMOD_VIM9CMD;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&p, \"verbose\", 4))\n\t\t\t    break;\n\t\t\tif (vim_isdigit(*eap->cmd))\n\t\t\t{\n\t\t\t    // zero means not set, one is verbose == 0, etc.\n\t\t\t    cmod->cmod_verbose = atoi((char *)eap->cmd) + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t    cmod->cmod_verbose = 2;  // default: verbose == 1\n\t\t\teap->cmd = p;\n\t\t\tcontinue;\n\t}\n\tbreak;\n    }\n\n    if (has_visual_range)\n    {\n\tif (eap->cmd > cmd_start)\n\t{\n\t    // Move the '<,'> range to after the modifiers and insert a colon.\n\t    // Since the modifiers have been parsed put the colon on top of the\n\t    // space: \"'<,'>mod cmd\" -> \"mod:'<,'>cmd\n\t    // Put eap->cmd after the colon.\n\t    if (use_plus_cmd)\n\t    {\n\t\tsize_t len = STRLEN(cmd_start);\n\n\t\t// Special case: empty command uses \"+\":\n\t\t//  \"'<,'>mods\" -> \"mods'<,'>+\n\t\tmch_memmove(orig_cmd, cmd_start, len);\n\t\tSTRCPY(orig_cmd + len, \"'<,'>+\");\n\t    }\n\t    else\n\t    {\n\t\tmch_memmove(cmd_start - 5, cmd_start, eap->cmd - cmd_start);\n\t\teap->cmd -= 5;\n\t\tmch_memmove(eap->cmd - 1, \":'<,'>\", 6);\n\t    }\n\t}\n\telse\n\t    // No modifiers, move the pointer back.\n\t    // Special case: change empty command to \"+\".\n\t    if (use_plus_cmd)\n\t\teap->cmd = (char_u *)\"'<,'>+\";\n\t    else\n\t\teap->cmd = orig_cmd;\n    }\n    else if (use_plus_cmd)\n\teap->cmd = (char_u *)\"+\";\n\n    return OK;\n}", "func_hash": 61928994098668347793112269457604758897, "file_name": "ex_docmd.c", "file_hash": 287878878694425028301990758845576774946, "cwe": ["CWE-787"], "cve": "CVE-2022-2288", "cve_desc": "Out-of-bounds Write in GitHub repository vim/vim prior to 9.0.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-2288", "file_path": "src/ex_docmd.c"}
{"idx": 379334, "project": "vim", "commit_id": "c6fdb15d423df22e1776844811d082322475e48a", "project_url": "https://github.com/vim/vim", "commit_url": "https://github.com/vim/vim/commit/c6fdb15d423df22e1776844811d082322475e48a", "commit_message": "patch 9.0.0025: accessing beyond allocated memory with the cmdline window\n\nProblem:    Accessing beyond allocated memory when using the cmdline window in\n            Ex mode.\nSolution:   Use \"*\" instead of \"'<,'>\" for Visual mode.", "target": 0, "func": "parse_command_modifiers(\n\texarg_T\t    *eap,\n\tchar\t    **errormsg,\n\tcmdmod_T    *cmod,\n\tint\t    skip_only)\n{\n    char_u  *orig_cmd = eap->cmd;\n    char_u  *cmd_start = NULL;\n    int\t    use_plus_cmd = FALSE;\n    int\t    starts_with_colon = FALSE;\n    int\t    vim9script = in_vim9script();\n    int\t    has_visual_range = FALSE;\n\n    CLEAR_POINTER(cmod);\n    cmod->cmod_flags = sticky_cmdmod_flags;\n\n    if (STRNCMP(eap->cmd, \"'<,'>\", 5) == 0)\n    {\n\t// The automatically inserted Visual area range is skipped, so that\n\t// typing \":cmdmod cmd\" in Visual mode works without having to move the\n\t// range to after the modififiers. The command will be\n\t// \"'<,'>cmdmod cmd\", parse \"cmdmod cmd\" and then put back \"'<,'>\"\n\t// before \"cmd\" below.\n\teap->cmd += 5;\n\tcmd_start = eap->cmd;\n\thas_visual_range = TRUE;\n    }\n\n    // Repeat until no more command modifiers are found.\n    for (;;)\n    {\n\tchar_u  *p;\n\n\twhile (*eap->cmd == ' ' || *eap->cmd == '\\t' || *eap->cmd == ':')\n\t{\n\t    if (*eap->cmd == ':')\n\t\tstarts_with_colon = TRUE;\n\t    ++eap->cmd;\n\t}\n\n\t// in ex mode, an empty command (after modifiers) works like :+\n\tif (*eap->cmd == NUL && exmode_active\n\t\t   && (getline_equal(eap->getline, eap->cookie, getexmodeline)\n\t\t       || getline_equal(eap->getline, eap->cookie, getexline))\n\t\t\t&& curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t{\n\t    use_plus_cmd = TRUE;\n\t    if (!skip_only)\n\t\tex_pressedreturn = TRUE;\n\t    break;  // no modifiers following\n\t}\n\n\t// ignore comment and empty lines\n\tif (comment_start(eap->cmd, starts_with_colon))\n\t{\n\t    // a comment ends at a NL\n\t    if (eap->nextcmd == NULL)\n\t    {\n\t\teap->nextcmd = vim_strchr(eap->cmd, '\\n');\n\t\tif (eap->nextcmd != NULL)\n\t\t    ++eap->nextcmd;\n\t    }\n\t    if (vim9script && has_cmdmod(cmod, FALSE))\n\t\t*errormsg = _(e_command_modifier_without_command);\n\t    return FAIL;\n\t}\n\tif (*eap->cmd == NUL)\n\t{\n\t    if (!skip_only)\n\t    {\n\t\tex_pressedreturn = TRUE;\n\t\tif (vim9script && has_cmdmod(cmod, FALSE))\n\t\t    *errormsg = _(e_command_modifier_without_command);\n\t    }\n\t    return FAIL;\n\t}\n\n\tp = skip_range(eap->cmd, TRUE, NULL);\n\n\t// In Vim9 script a variable can shadow a command modifier:\n\t//   verbose = 123\n\t//   verbose += 123\n\t//   silent! verbose = func()\n\t//   verbose.member = 2\n\t//   verbose[expr] = 2\n\t// But not:\n\t//   verbose [a, b] = list\n\tif (vim9script)\n\t{\n\t    char_u *s, *n;\n\n\t    for (s = eap->cmd; ASCII_ISALPHA(*s); ++s)\n\t\t;\n\t    n = skipwhite(s);\n\t    if (*n == '.' || *n == '=' || (*n != NUL && n[1] == '=')\n\t\t    || *s == '[')\n\t\tbreak;\n\t}\n\n\tswitch (*p)\n\t{\n\t    // When adding an entry, also modify cmd_exists().\n\t    case 'a':\tif (!checkforcmd_noparen(&eap->cmd, \"aboveleft\", 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_ABOVE;\n\t\t\tcontinue;\n\n\t    case 'b':\tif (checkforcmd_noparen(&eap->cmd, \"belowright\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_split |= WSP_BELOW;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_opt(&eap->cmd, \"browse\", 3, TRUE))\n\t\t\t{\n#ifdef FEAT_BROWSE_CMD\n\t\t\t    cmod->cmod_flags |= CMOD_BROWSE;\n#endif\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"botright\", 2))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_BOT;\n\t\t\tcontinue;\n\n\t    case 'c':\tif (!checkforcmd_opt(&eap->cmd, \"confirm\", 4, TRUE))\n\t\t\t    break;\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t\t\tcmod->cmod_flags |= CMOD_CONFIRM;\n#endif\n\t\t\tcontinue;\n\n\t    case 'k':\tif (checkforcmd_noparen(&eap->cmd, \"keepmarks\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_KEEPMARKS;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd, \"keepalt\", 5))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_KEEPALT;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd, \"keeppatterns\", 5))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_KEEPPATTERNS;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"keepjumps\", 5))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_KEEPJUMPS;\n\t\t\tcontinue;\n\n\t    case 'f':\t// only accept \":filter {pat} cmd\"\n\t\t\t{\n\t\t\t    char_u  *reg_pat;\n\t\t\t    char_u  *nulp = NULL;\n\t\t\t    int\t    c = 0;\n\n\t\t\t    if (!checkforcmd_noparen(&p, \"filter\", 4)\n\t\t\t\t    || *p == NUL\n\t\t\t\t    || (ends_excmd(*p)\n#ifdef FEAT_EVAL\n\t\t\t\t\t// in \":filter #pat# cmd\" # does not\n\t\t\t\t\t// start a comment\n\t\t\t\t     && (!vim9script || VIM_ISWHITE(p[1]))\n#endif\n\t\t\t\t     ))\n\t\t\t\tbreak;\n\t\t\t    if (*p == '!')\n\t\t\t    {\n\t\t\t\tcmod->cmod_filter_force = TRUE;\n\t\t\t\tp = skipwhite(p + 1);\n\t\t\t\tif (*p == NUL || ends_excmd(*p))\n\t\t\t\t    break;\n\t\t\t    }\n#ifdef FEAT_EVAL\n\t\t\t    // Avoid that \"filter(arg)\" is recognized.\n\t\t\t    if (vim9script && !VIM_ISWHITE(p[-1]))\n\t\t\t\tbreak;\n#endif\n\t\t\t    if (skip_only)\n\t\t\t\tp = skip_vimgrep_pat(p, NULL, NULL);\n\t\t\t    else\n\t\t\t\t// NOTE: This puts a NUL after the pattern.\n\t\t\t\tp = skip_vimgrep_pat_ext(p, &reg_pat, NULL,\n\t\t\t\t\t\t\t\t    &nulp, &c);\n\t\t\t    if (p == NULL || *p == NUL)\n\t\t\t\tbreak;\n\t\t\t    if (!skip_only)\n\t\t\t    {\n\t\t\t\tcmod->cmod_filter_regmatch.regprog =\n\t\t\t\t\t\tvim_regcomp(reg_pat, RE_MAGIC);\n\t\t\t\tif (cmod->cmod_filter_regmatch.regprog == NULL)\n\t\t\t\t    break;\n\t\t\t\t// restore the character overwritten by NUL\n\t\t\t\tif (nulp != NULL)\n\t\t\t\t    *nulp = c;\n\t\t\t    }\n\t\t\t    eap->cmd = p;\n\t\t\t    continue;\n\t\t\t}\n\n\t\t\t// \":hide\" and \":hide | cmd\" are not modifiers\n\t    case 'h':\tif (p != eap->cmd || !checkforcmd_noparen(&p, \"hide\", 3)\n\t\t\t\t\t       || *p == NUL || ends_excmd(*p))\n\t\t\t    break;\n\t\t\teap->cmd = p;\n\t\t\tcmod->cmod_flags |= CMOD_HIDE;\n\t\t\tcontinue;\n\n\t    case 'l':\tif (checkforcmd_noparen(&eap->cmd, \"lockmarks\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_LOCKMARKS;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd, \"legacy\", 3))\n\t\t\t{\n\t\t\t    if (ends_excmd2(p, eap->cmd))\n\t\t\t    {\n\t\t\t\t*errormsg =\n\t\t\t\t      _(e_legacy_must_be_followed_by_command);\n\t\t\t\treturn FAIL;\n\t\t\t    }\n\t\t\t    cmod->cmod_flags |= CMOD_LEGACY;\n\t\t\t    continue;\n\t\t\t}\n\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"leftabove\", 5))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_ABOVE;\n\t\t\tcontinue;\n\n\t    case 'n':\tif (checkforcmd_noparen(&eap->cmd, \"noautocmd\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_NOAUTOCMD;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"noswapfile\", 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_NOSWAPFILE;\n\t\t\tcontinue;\n\n\t    case 'r':\tif (!checkforcmd_noparen(&eap->cmd, \"rightbelow\", 6))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_BELOW;\n\t\t\tcontinue;\n\n\t    case 's':\tif (checkforcmd_noparen(&eap->cmd, \"sandbox\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_SANDBOX;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"silent\", 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_SILENT;\n\t\t\tif (*eap->cmd == '!' && !VIM_ISWHITE(eap->cmd[-1]))\n\t\t\t{\n\t\t\t    // \":silent!\", but not \"silent !cmd\"\n\t\t\t    eap->cmd = skipwhite(eap->cmd + 1);\n\t\t\t    cmod->cmod_flags |= CMOD_ERRSILENT;\n\t\t\t}\n\t\t\tcontinue;\n\n\t    case 't':\tif (checkforcmd_noparen(&p, \"tab\", 3))\n\t\t\t{\n\t\t\t    if (!skip_only)\n\t\t\t    {\n\t\t\t\tlong tabnr = get_address(eap, &eap->cmd,\n\t\t\t\t\t\t    ADDR_TABS, eap->skip,\n\t\t\t\t\t\t    skip_only, FALSE, 1);\n\t\t\t\tif (tabnr == MAXLNUM)\n\t\t\t\t    cmod->cmod_tab = tabpage_index(curtab) + 1;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    if (tabnr < 0 || tabnr > LAST_TAB_NR)\n\t\t\t\t    {\n\t\t\t\t\t*errormsg = _(e_invalid_range);\n\t\t\t\t\treturn FAIL;\n\t\t\t\t    }\n\t\t\t\t    cmod->cmod_tab = tabnr + 1;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    eap->cmd = p;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"topleft\", 2))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_TOP;\n\t\t\tcontinue;\n\n\t    case 'u':\tif (!checkforcmd_noparen(&eap->cmd, \"unsilent\", 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_UNSILENT;\n\t\t\tcontinue;\n\n\t    case 'v':\tif (checkforcmd_noparen(&eap->cmd, \"vertical\", 4))\n\t\t\t{\n\t\t\t    cmod->cmod_split |= WSP_VERT;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd, \"vim9cmd\", 4))\n\t\t\t{\n\t\t\t    if (ends_excmd2(p, eap->cmd))\n\t\t\t    {\n\t\t\t\t*errormsg =\n\t\t\t\t      _(e_vim9cmd_must_be_followed_by_command);\n\t\t\t\treturn FAIL;\n\t\t\t    }\n\t\t\t    cmod->cmod_flags |= CMOD_VIM9CMD;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&p, \"verbose\", 4))\n\t\t\t    break;\n\t\t\tif (vim_isdigit(*eap->cmd))\n\t\t\t{\n\t\t\t    // zero means not set, one is verbose == 0, etc.\n\t\t\t    cmod->cmod_verbose = atoi((char *)eap->cmd) + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t    cmod->cmod_verbose = 2;  // default: verbose == 1\n\t\t\teap->cmd = p;\n\t\t\tcontinue;\n\t}\n\tbreak;\n    }\n\n    if (has_visual_range)\n    {\n\tif (eap->cmd > cmd_start)\n\t{\n\t    // Move the '<,'> range to after the modifiers and insert a colon.\n\t    // Since the modifiers have been parsed put the colon on top of the\n\t    // space: \"'<,'>mod cmd\" -> \"mod:'<,'>cmd\n\t    // Put eap->cmd after the colon.\n\t    if (use_plus_cmd)\n\t    {\n\t\tsize_t len = STRLEN(cmd_start);\n\n\t\t// Special case: empty command uses \"+\":\n\t\t//  \"'<,'>mods\" -> \"mods *+\n\t\t//  Use \"*\" instead of \"'<,'>\" to avoid the command getting\n\t\t//  longer, in case is was allocated.\n\t\tmch_memmove(orig_cmd, cmd_start, len);\n\t\tSTRCPY(orig_cmd + len, \" *+\");\n\t    }\n\t    else\n\t    {\n\t\tmch_memmove(cmd_start - 5, cmd_start, eap->cmd - cmd_start);\n\t\teap->cmd -= 5;\n\t\tmch_memmove(eap->cmd - 1, \":'<,'>\", 6);\n\t    }\n\t}\n\telse\n\t    // No modifiers, move the pointer back.\n\t    // Special case: change empty command to \"+\".\n\t    if (use_plus_cmd)\n\t\teap->cmd = (char_u *)\"'<,'>+\";\n\t    else\n\t\teap->cmd = orig_cmd;\n    }\n    else if (use_plus_cmd)\n\teap->cmd = (char_u *)\"+\";\n\n    return OK;\n}", "func_hash": 128847198820720658441664267481456465295, "file_name": "ex_docmd.c", "file_hash": 80050062526332961104670632599823980115, "cwe": ["CWE-787"], "cve": "CVE-2022-2288", "cve_desc": "Out-of-bounds Write in GitHub repository vim/vim prior to 9.0.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-2288", "file_path": "src/ex_docmd.c"}
{"idx": 206417, "project": "vim", "commit_id": "0971c7a4e537ea120a6bb2195960be8d0815e97b", "project_url": "https://github.com/vim/vim", "commit_url": "https://github.com/vim/vim/commit/0971c7a4e537ea120a6bb2195960be8d0815e97b", "commit_message": "patch 8.2.5162: reading before the start of the line with BS in Replace mode\n\nProblem:    Reading before the start of the line with BS in Replace mode.\nSolution:   Check the cursor column is more than zero.", "target": 1, "func": "ins_bs(\n    int\t\tc,\n    int\t\tmode,\n    int\t\t*inserted_space_p)\n{\n    linenr_T\tlnum;\n    int\t\tcc;\n    int\t\ttemp = 0;\t    // init for GCC\n    colnr_T\tsave_col;\n    colnr_T\tmincol;\n    int\t\tdid_backspace = FALSE;\n    int\t\tin_indent;\n    int\t\toldState;\n    int\t\tcpc[MAX_MCO];\t    // composing characters\n    int\t\tcall_fix_indent = FALSE;\n\n    /*\n     * can't delete anything in an empty file\n     * can't backup past first character in buffer\n     * can't backup past starting point unless 'backspace' > 1\n     * can backup to a previous line if 'backspace' == 0\n     */\n    if (       BUFEMPTY()\n\t    || (\n#ifdef FEAT_RIGHTLEFT\n\t\t!revins_on &&\n#endif\n\t\t((curwin->w_cursor.lnum == 1 && curwin->w_cursor.col == 0)\n\t\t    || (!can_bs(BS_START)\n\t\t\t&& ((arrow_used\n#ifdef FEAT_JOB_CHANNEL\n\t\t\t\t&& !bt_prompt(curbuf)\n#endif\n\t\t\t) || (curwin->w_cursor.lnum == Insstart_orig.lnum\n\t\t\t\t&& curwin->w_cursor.col <= Insstart_orig.col)))\n\t\t    || (!can_bs(BS_INDENT) && !arrow_used && ai_col > 0\n\t\t\t\t\t && curwin->w_cursor.col <= ai_col)\n\t\t    || (!can_bs(BS_EOL) && curwin->w_cursor.col == 0))))\n    {\n\tvim_beep(BO_BS);\n\treturn FALSE;\n    }\n\n    if (stop_arrow() == FAIL)\n\treturn FALSE;\n    in_indent = inindent(0);\n    if (in_indent)\n\tcan_cindent = FALSE;\n    end_comment_pending = NUL;\t// After BS, don't auto-end comment\n#ifdef FEAT_RIGHTLEFT\n    if (revins_on)\t    // put cursor after last inserted char\n\tinc_cursor();\n#endif\n\n    // Virtualedit:\n    //\tBACKSPACE_CHAR eats a virtual space\n    //\tBACKSPACE_WORD eats all coladd\n    //\tBACKSPACE_LINE eats all coladd and keeps going\n    if (curwin->w_cursor.coladd > 0)\n    {\n\tif (mode == BACKSPACE_CHAR)\n\t{\n\t    --curwin->w_cursor.coladd;\n\t    return TRUE;\n\t}\n\tif (mode == BACKSPACE_WORD)\n\t{\n\t    curwin->w_cursor.coladd = 0;\n\t    return TRUE;\n\t}\n\tcurwin->w_cursor.coladd = 0;\n    }\n\n    /*\n     * Delete newline!\n     */\n    if (curwin->w_cursor.col == 0)\n    {\n\tlnum = Insstart.lnum;\n\tif (curwin->w_cursor.lnum == lnum\n#ifdef FEAT_RIGHTLEFT\n\t\t\t|| revins_on\n#endif\n\t\t\t\t    )\n\t{\n\t    if (u_save((linenr_T)(curwin->w_cursor.lnum - 2),\n\t\t\t       (linenr_T)(curwin->w_cursor.lnum + 1)) == FAIL)\n\t\treturn FALSE;\n\t    --Insstart.lnum;\n\t    Insstart.col = (colnr_T)STRLEN(ml_get(Insstart.lnum));\n\t}\n\t/*\n\t * In replace mode:\n\t * cc < 0: NL was inserted, delete it\n\t * cc >= 0: NL was replaced, put original characters back\n\t */\n\tcc = -1;\n\tif (State & REPLACE_FLAG)\n\t    cc = replace_pop();\t    // returns -1 if NL was inserted\n\t/*\n\t * In replace mode, in the line we started replacing, we only move the\n\t * cursor.\n\t */\n\tif ((State & REPLACE_FLAG) && curwin->w_cursor.lnum <= lnum)\n\t{\n\t    dec_cursor();\n\t}\n\telse\n\t{\n\t    if (!(State & VREPLACE_FLAG)\n\t\t\t\t   || curwin->w_cursor.lnum > orig_line_count)\n\t    {\n\t\ttemp = gchar_cursor();\t// remember current char\n\t\t--curwin->w_cursor.lnum;\n\n\t\t// When \"aw\" is in 'formatoptions' we must delete the space at\n\t\t// the end of the line, otherwise the line will be broken\n\t\t// again when auto-formatting.\n\t\tif (has_format_option(FO_AUTO)\n\t\t\t\t\t   && has_format_option(FO_WHITE_PAR))\n\t\t{\n\t\t    char_u  *ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum,\n\t\t\t\t\t\t\t\t\tTRUE);\n\t\t    int\t    len;\n\n\t\t    len = (int)STRLEN(ptr);\n\t\t    if (len > 0 && ptr[len - 1] == ' ')\n\t\t\tptr[len - 1] = NUL;\n\t\t}\n\n\t\t(void)do_join(2, FALSE, FALSE, FALSE, FALSE);\n\t\tif (temp == NUL && gchar_cursor() != NUL)\n\t\t    inc_cursor();\n\t    }\n\t    else\n\t\tdec_cursor();\n\n\t    /*\n\t     * In MODE_REPLACE mode we have to put back the text that was\n\t     * replaced by the NL. On the replace stack is first a\n\t     * NUL-terminated sequence of characters that were deleted and then\n\t     * the characters that NL replaced.\n\t     */\n\t    if (State & REPLACE_FLAG)\n\t    {\n\t\t/*\n\t\t * Do the next ins_char() in MODE_NORMAL state, to\n\t\t * prevent ins_char() from replacing characters and\n\t\t * avoiding showmatch().\n\t\t */\n\t\toldState = State;\n\t\tState = MODE_NORMAL;\n\t\t/*\n\t\t * restore characters (blanks) deleted after cursor\n\t\t */\n\t\twhile (cc > 0)\n\t\t{\n\t\t    save_col = curwin->w_cursor.col;\n\t\t    mb_replace_pop_ins(cc);\n\t\t    curwin->w_cursor.col = save_col;\n\t\t    cc = replace_pop();\n\t\t}\n\t\t// restore the characters that NL replaced\n\t\treplace_pop_ins();\n\t\tState = oldState;\n\t    }\n\t}\n\tdid_ai = FALSE;\n    }\n    else\n    {\n\t/*\n\t * Delete character(s) before the cursor.\n\t */\n#ifdef FEAT_RIGHTLEFT\n\tif (revins_on)\t\t// put cursor on last inserted char\n\t    dec_cursor();\n#endif\n\tmincol = 0;\n\t\t\t\t\t\t// keep indent\n\tif (mode == BACKSPACE_LINE\n\t\t&& (curbuf->b_p_ai || cindent_on())\n#ifdef FEAT_RIGHTLEFT\n\t\t&& !revins_on\n#endif\n\t\t\t    )\n\t{\n\t    save_col = curwin->w_cursor.col;\n\t    beginline(BL_WHITE);\n\t    if (curwin->w_cursor.col < save_col)\n\t    {\n\t\tmincol = curwin->w_cursor.col;\n\t\t// should now fix the indent to match with the previous line\n\t\tcall_fix_indent = TRUE;\n\t    }\n\t    curwin->w_cursor.col = save_col;\n\t}\n\n\t/*\n\t * Handle deleting one 'shiftwidth' or 'softtabstop'.\n\t */\n\tif (\t   mode == BACKSPACE_CHAR\n\t\t&& ((p_sta && in_indent)\n\t\t    || ((get_sts_value() != 0\n#ifdef FEAT_VARTABS\n\t\t\t|| tabstop_count(curbuf->b_p_vsts_array)\n#endif\n\t\t\t)\n\t\t\t&& curwin->w_cursor.col > 0\n\t\t\t&& (*(ml_get_cursor() - 1) == TAB\n\t\t\t    || (*(ml_get_cursor() - 1) == ' '\n\t\t\t\t&& (!*inserted_space_p\n\t\t\t\t    || arrow_used))))))\n\t{\n\t    int\t\tts;\n\t    colnr_T\tvcol;\n\t    colnr_T\twant_vcol;\n\t    colnr_T\tstart_vcol;\n\n\t    *inserted_space_p = FALSE;\n\t    // Compute the virtual column where we want to be.  Since\n\t    // 'showbreak' may get in the way, need to get the last column of\n\t    // the previous character.\n\t    getvcol(curwin, &curwin->w_cursor, &vcol, NULL, NULL);\n\t    start_vcol = vcol;\n\t    dec_cursor();\n\t    getvcol(curwin, &curwin->w_cursor, NULL, NULL, &want_vcol);\n\t    inc_cursor();\n#ifdef FEAT_VARTABS\n\t    if (p_sta && in_indent)\n\t    {\n\t\tts = (int)get_sw_value(curbuf);\n\t\twant_vcol = (want_vcol / ts) * ts;\n\t    }\n\t    else\n\t\twant_vcol = tabstop_start(want_vcol, get_sts_value(),\n\t\t\t\t\t\t       curbuf->b_p_vsts_array);\n#else\n\t    if (p_sta && in_indent)\n\t\tts = (int)get_sw_value(curbuf);\n\t    else\n\t\tts = (int)get_sts_value();\n\t    want_vcol = (want_vcol / ts) * ts;\n#endif\n\n\t    // delete characters until we are at or before want_vcol\n\t    while (vcol > want_vcol\n\t\t    && (cc = *(ml_get_cursor() - 1), VIM_ISWHITE(cc)))\n\t\tins_bs_one(&vcol);\n\n\t    // insert extra spaces until we are at want_vcol\n\t    while (vcol < want_vcol)\n\t    {\n\t\t// Remember the first char we inserted\n\t\tif (curwin->w_cursor.lnum == Insstart_orig.lnum\n\t\t\t\t   && curwin->w_cursor.col < Insstart_orig.col)\n\t\t    Insstart_orig.col = curwin->w_cursor.col;\n\n\t\tif (State & VREPLACE_FLAG)\n\t\t    ins_char(' ');\n\t\telse\n\t\t{\n\t\t    ins_str((char_u *)\" \");\n\t\t    if ((State & REPLACE_FLAG))\n\t\t\treplace_push(NUL);\n\t\t}\n\t\tgetvcol(curwin, &curwin->w_cursor, &vcol, NULL, NULL);\n\t    }\n\n\t    // If we are now back where we started delete one character.  Can\n\t    // happen when using 'sts' and 'linebreak'.\n\t    if (vcol >= start_vcol)\n\t\tins_bs_one(&vcol);\n\t}\n\n\t/*\n\t * Delete up to starting point, start of line or previous word.\n\t */\n\telse\n\t{\n\t    int cclass = 0, prev_cclass = 0;\n\n\t    if (has_mbyte)\n\t\tcclass = mb_get_class(ml_get_cursor());\n\t    do\n\t    {\n#ifdef FEAT_RIGHTLEFT\n\t\tif (!revins_on) // put cursor on char to be deleted\n#endif\n\t\t    dec_cursor();\n\n\t\tcc = gchar_cursor();\n\t\t// look multi-byte character class\n\t\tif (has_mbyte)\n\t\t{\n\t\t    prev_cclass = cclass;\n\t\t    cclass = mb_get_class(ml_get_cursor());\n\t\t}\n\n\t\t// start of word?\n\t\tif (mode == BACKSPACE_WORD && !vim_isspace(cc))\n\t\t{\n\t\t    mode = BACKSPACE_WORD_NOT_SPACE;\n\t\t    temp = vim_iswordc(cc);\n\t\t}\n\t\t// end of word?\n\t\telse if (mode == BACKSPACE_WORD_NOT_SPACE\n\t\t\t&& ((vim_isspace(cc) || vim_iswordc(cc) != temp)\n\t\t\t|| prev_cclass != cclass))\n\t\t{\n#ifdef FEAT_RIGHTLEFT\n\t\t    if (!revins_on)\n#endif\n\t\t\tinc_cursor();\n#ifdef FEAT_RIGHTLEFT\n\t\t    else if (State & REPLACE_FLAG)\n\t\t\tdec_cursor();\n#endif\n\t\t    break;\n\t\t}\n\t\tif (State & REPLACE_FLAG)\n\t\t    replace_do_bs(-1);\n\t\telse\n\t\t{\n\t\t    if (enc_utf8 && p_deco)\n\t\t\t(void)utfc_ptr2char(ml_get_cursor(), cpc);\n\t\t    (void)del_char(FALSE);\n\t\t    /*\n\t\t     * If there are combining characters and 'delcombine' is set\n\t\t     * move the cursor back.  Don't back up before the base\n\t\t     * character.\n\t\t     */\n\t\t    if (enc_utf8 && p_deco && cpc[0] != NUL)\n\t\t\tinc_cursor();\n#ifdef FEAT_RIGHTLEFT\n\t\t    if (revins_chars)\n\t\t    {\n\t\t\trevins_chars--;\n\t\t\trevins_legal++;\n\t\t    }\n\t\t    if (revins_on && gchar_cursor() == NUL)\n\t\t\tbreak;\n#endif\n\t\t}\n\t\t// Just a single backspace?:\n\t\tif (mode == BACKSPACE_CHAR)\n\t\t    break;\n\t    } while (\n#ifdef FEAT_RIGHTLEFT\n\t\t    revins_on ||\n#endif\n\t\t    (curwin->w_cursor.col > mincol\n\t\t    &&  (can_bs(BS_NOSTOP)\n\t\t\t|| (curwin->w_cursor.lnum != Insstart_orig.lnum\n\t\t\t|| curwin->w_cursor.col != Insstart_orig.col)\n\t\t    )));\n\t}\n\tdid_backspace = TRUE;\n    }\n    did_si = FALSE;\n    can_si = FALSE;\n    can_si_back = FALSE;\n    if (curwin->w_cursor.col <= 1)\n\tdid_ai = FALSE;\n\n    if (call_fix_indent)\n\tfix_indent();\n\n    /*\n     * It's a little strange to put backspaces into the redo\n     * buffer, but it makes auto-indent a lot easier to deal\n     * with.\n     */\n    AppendCharToRedobuff(c);\n\n    // If deleted before the insertion point, adjust it\n    if (curwin->w_cursor.lnum == Insstart_orig.lnum\n\t\t\t\t  && curwin->w_cursor.col < Insstart_orig.col)\n\tInsstart_orig.col = curwin->w_cursor.col;\n\n    // vi behaviour: the cursor moves backward but the character that\n    //\t\t     was there remains visible\n    // Vim behaviour: the cursor moves backward and the character that\n    //\t\t      was there is erased from the screen.\n    // We can emulate the vi behaviour by pretending there is a dollar\n    // displayed even when there isn't.\n    //  --pkv Sun Jan 19 01:56:40 EST 2003\n    if (vim_strchr(p_cpo, CPO_BACKSPACE) != NULL && dollar_vcol == -1)\n\tdollar_vcol = curwin->w_virtcol;\n\n#ifdef FEAT_FOLDING\n    // When deleting a char the cursor line must never be in a closed fold.\n    // E.g., when 'foldmethod' is indent and deleting the first non-white\n    // char before a Tab.\n    if (did_backspace)\n\tfoldOpenCursor();\n#endif\n\n    return did_backspace;\n}", "func_hash": 172194519756788339453675041357999010208, "file_name": "edit.c", "file_hash": 334216402611901751671385717284214475763, "cwe": ["CWE-787"], "cve": "CVE-2022-2207", "cve_desc": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-2207", "file_path": "src/edit.c"}
{"idx": 380955, "project": "vim", "commit_id": "0971c7a4e537ea120a6bb2195960be8d0815e97b", "project_url": "https://github.com/vim/vim", "commit_url": "https://github.com/vim/vim/commit/0971c7a4e537ea120a6bb2195960be8d0815e97b", "commit_message": "patch 8.2.5162: reading before the start of the line with BS in Replace mode\n\nProblem:    Reading before the start of the line with BS in Replace mode.\nSolution:   Check the cursor column is more than zero.", "target": 0, "func": "ins_bs(\n    int\t\tc,\n    int\t\tmode,\n    int\t\t*inserted_space_p)\n{\n    linenr_T\tlnum;\n    int\t\tcc;\n    int\t\ttemp = 0;\t    // init for GCC\n    colnr_T\tsave_col;\n    colnr_T\tmincol;\n    int\t\tdid_backspace = FALSE;\n    int\t\tin_indent;\n    int\t\toldState;\n    int\t\tcpc[MAX_MCO];\t    // composing characters\n    int\t\tcall_fix_indent = FALSE;\n\n    /*\n     * can't delete anything in an empty file\n     * can't backup past first character in buffer\n     * can't backup past starting point unless 'backspace' > 1\n     * can backup to a previous line if 'backspace' == 0\n     */\n    if (       BUFEMPTY()\n\t    || (\n#ifdef FEAT_RIGHTLEFT\n\t\t!revins_on &&\n#endif\n\t\t((curwin->w_cursor.lnum == 1 && curwin->w_cursor.col == 0)\n\t\t    || (!can_bs(BS_START)\n\t\t\t&& ((arrow_used\n#ifdef FEAT_JOB_CHANNEL\n\t\t\t\t&& !bt_prompt(curbuf)\n#endif\n\t\t\t) || (curwin->w_cursor.lnum == Insstart_orig.lnum\n\t\t\t\t&& curwin->w_cursor.col <= Insstart_orig.col)))\n\t\t    || (!can_bs(BS_INDENT) && !arrow_used && ai_col > 0\n\t\t\t\t\t && curwin->w_cursor.col <= ai_col)\n\t\t    || (!can_bs(BS_EOL) && curwin->w_cursor.col == 0))))\n    {\n\tvim_beep(BO_BS);\n\treturn FALSE;\n    }\n\n    if (stop_arrow() == FAIL)\n\treturn FALSE;\n    in_indent = inindent(0);\n    if (in_indent)\n\tcan_cindent = FALSE;\n    end_comment_pending = NUL;\t// After BS, don't auto-end comment\n#ifdef FEAT_RIGHTLEFT\n    if (revins_on)\t    // put cursor after last inserted char\n\tinc_cursor();\n#endif\n\n    // Virtualedit:\n    //\tBACKSPACE_CHAR eats a virtual space\n    //\tBACKSPACE_WORD eats all coladd\n    //\tBACKSPACE_LINE eats all coladd and keeps going\n    if (curwin->w_cursor.coladd > 0)\n    {\n\tif (mode == BACKSPACE_CHAR)\n\t{\n\t    --curwin->w_cursor.coladd;\n\t    return TRUE;\n\t}\n\tif (mode == BACKSPACE_WORD)\n\t{\n\t    curwin->w_cursor.coladd = 0;\n\t    return TRUE;\n\t}\n\tcurwin->w_cursor.coladd = 0;\n    }\n\n    /*\n     * Delete newline!\n     */\n    if (curwin->w_cursor.col == 0)\n    {\n\tlnum = Insstart.lnum;\n\tif (curwin->w_cursor.lnum == lnum\n#ifdef FEAT_RIGHTLEFT\n\t\t\t|| revins_on\n#endif\n\t\t\t\t    )\n\t{\n\t    if (u_save((linenr_T)(curwin->w_cursor.lnum - 2),\n\t\t\t       (linenr_T)(curwin->w_cursor.lnum + 1)) == FAIL)\n\t\treturn FALSE;\n\t    --Insstart.lnum;\n\t    Insstart.col = (colnr_T)STRLEN(ml_get(Insstart.lnum));\n\t}\n\t/*\n\t * In replace mode:\n\t * cc < 0: NL was inserted, delete it\n\t * cc >= 0: NL was replaced, put original characters back\n\t */\n\tcc = -1;\n\tif (State & REPLACE_FLAG)\n\t    cc = replace_pop();\t    // returns -1 if NL was inserted\n\t/*\n\t * In replace mode, in the line we started replacing, we only move the\n\t * cursor.\n\t */\n\tif ((State & REPLACE_FLAG) && curwin->w_cursor.lnum <= lnum)\n\t{\n\t    dec_cursor();\n\t}\n\telse\n\t{\n\t    if (!(State & VREPLACE_FLAG)\n\t\t\t\t   || curwin->w_cursor.lnum > orig_line_count)\n\t    {\n\t\ttemp = gchar_cursor();\t// remember current char\n\t\t--curwin->w_cursor.lnum;\n\n\t\t// When \"aw\" is in 'formatoptions' we must delete the space at\n\t\t// the end of the line, otherwise the line will be broken\n\t\t// again when auto-formatting.\n\t\tif (has_format_option(FO_AUTO)\n\t\t\t\t\t   && has_format_option(FO_WHITE_PAR))\n\t\t{\n\t\t    char_u  *ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum,\n\t\t\t\t\t\t\t\t\tTRUE);\n\t\t    int\t    len;\n\n\t\t    len = (int)STRLEN(ptr);\n\t\t    if (len > 0 && ptr[len - 1] == ' ')\n\t\t\tptr[len - 1] = NUL;\n\t\t}\n\n\t\t(void)do_join(2, FALSE, FALSE, FALSE, FALSE);\n\t\tif (temp == NUL && gchar_cursor() != NUL)\n\t\t    inc_cursor();\n\t    }\n\t    else\n\t\tdec_cursor();\n\n\t    /*\n\t     * In MODE_REPLACE mode we have to put back the text that was\n\t     * replaced by the NL. On the replace stack is first a\n\t     * NUL-terminated sequence of characters that were deleted and then\n\t     * the characters that NL replaced.\n\t     */\n\t    if (State & REPLACE_FLAG)\n\t    {\n\t\t/*\n\t\t * Do the next ins_char() in MODE_NORMAL state, to\n\t\t * prevent ins_char() from replacing characters and\n\t\t * avoiding showmatch().\n\t\t */\n\t\toldState = State;\n\t\tState = MODE_NORMAL;\n\t\t/*\n\t\t * restore characters (blanks) deleted after cursor\n\t\t */\n\t\twhile (cc > 0)\n\t\t{\n\t\t    save_col = curwin->w_cursor.col;\n\t\t    mb_replace_pop_ins(cc);\n\t\t    curwin->w_cursor.col = save_col;\n\t\t    cc = replace_pop();\n\t\t}\n\t\t// restore the characters that NL replaced\n\t\treplace_pop_ins();\n\t\tState = oldState;\n\t    }\n\t}\n\tdid_ai = FALSE;\n    }\n    else\n    {\n\t/*\n\t * Delete character(s) before the cursor.\n\t */\n#ifdef FEAT_RIGHTLEFT\n\tif (revins_on)\t\t// put cursor on last inserted char\n\t    dec_cursor();\n#endif\n\tmincol = 0;\n\t\t\t\t\t\t// keep indent\n\tif (mode == BACKSPACE_LINE\n\t\t&& (curbuf->b_p_ai || cindent_on())\n#ifdef FEAT_RIGHTLEFT\n\t\t&& !revins_on\n#endif\n\t\t\t    )\n\t{\n\t    save_col = curwin->w_cursor.col;\n\t    beginline(BL_WHITE);\n\t    if (curwin->w_cursor.col < save_col)\n\t    {\n\t\tmincol = curwin->w_cursor.col;\n\t\t// should now fix the indent to match with the previous line\n\t\tcall_fix_indent = TRUE;\n\t    }\n\t    curwin->w_cursor.col = save_col;\n\t}\n\n\t/*\n\t * Handle deleting one 'shiftwidth' or 'softtabstop'.\n\t */\n\tif (\t   mode == BACKSPACE_CHAR\n\t\t&& ((p_sta && in_indent)\n\t\t    || ((get_sts_value() != 0\n#ifdef FEAT_VARTABS\n\t\t\t|| tabstop_count(curbuf->b_p_vsts_array)\n#endif\n\t\t\t)\n\t\t\t&& curwin->w_cursor.col > 0\n\t\t\t&& (*(ml_get_cursor() - 1) == TAB\n\t\t\t    || (*(ml_get_cursor() - 1) == ' '\n\t\t\t\t&& (!*inserted_space_p\n\t\t\t\t    || arrow_used))))))\n\t{\n\t    int\t\tts;\n\t    colnr_T\tvcol;\n\t    colnr_T\twant_vcol;\n\t    colnr_T\tstart_vcol;\n\n\t    *inserted_space_p = FALSE;\n\t    // Compute the virtual column where we want to be.  Since\n\t    // 'showbreak' may get in the way, need to get the last column of\n\t    // the previous character.\n\t    getvcol(curwin, &curwin->w_cursor, &vcol, NULL, NULL);\n\t    start_vcol = vcol;\n\t    dec_cursor();\n\t    getvcol(curwin, &curwin->w_cursor, NULL, NULL, &want_vcol);\n\t    inc_cursor();\n#ifdef FEAT_VARTABS\n\t    if (p_sta && in_indent)\n\t    {\n\t\tts = (int)get_sw_value(curbuf);\n\t\twant_vcol = (want_vcol / ts) * ts;\n\t    }\n\t    else\n\t\twant_vcol = tabstop_start(want_vcol, get_sts_value(),\n\t\t\t\t\t\t       curbuf->b_p_vsts_array);\n#else\n\t    if (p_sta && in_indent)\n\t\tts = (int)get_sw_value(curbuf);\n\t    else\n\t\tts = (int)get_sts_value();\n\t    want_vcol = (want_vcol / ts) * ts;\n#endif\n\n\t    // delete characters until we are at or before want_vcol\n\t    while (vcol > want_vcol && curwin->w_cursor.col > 0\n\t\t    && (cc = *(ml_get_cursor() - 1), VIM_ISWHITE(cc)))\n\t\tins_bs_one(&vcol);\n\n\t    // insert extra spaces until we are at want_vcol\n\t    while (vcol < want_vcol)\n\t    {\n\t\t// Remember the first char we inserted\n\t\tif (curwin->w_cursor.lnum == Insstart_orig.lnum\n\t\t\t\t   && curwin->w_cursor.col < Insstart_orig.col)\n\t\t    Insstart_orig.col = curwin->w_cursor.col;\n\n\t\tif (State & VREPLACE_FLAG)\n\t\t    ins_char(' ');\n\t\telse\n\t\t{\n\t\t    ins_str((char_u *)\" \");\n\t\t    if ((State & REPLACE_FLAG))\n\t\t\treplace_push(NUL);\n\t\t}\n\t\tgetvcol(curwin, &curwin->w_cursor, &vcol, NULL, NULL);\n\t    }\n\n\t    // If we are now back where we started delete one character.  Can\n\t    // happen when using 'sts' and 'linebreak'.\n\t    if (vcol >= start_vcol)\n\t\tins_bs_one(&vcol);\n\t}\n\n\t/*\n\t * Delete up to starting point, start of line or previous word.\n\t */\n\telse\n\t{\n\t    int cclass = 0, prev_cclass = 0;\n\n\t    if (has_mbyte)\n\t\tcclass = mb_get_class(ml_get_cursor());\n\t    do\n\t    {\n#ifdef FEAT_RIGHTLEFT\n\t\tif (!revins_on) // put cursor on char to be deleted\n#endif\n\t\t    dec_cursor();\n\n\t\tcc = gchar_cursor();\n\t\t// look multi-byte character class\n\t\tif (has_mbyte)\n\t\t{\n\t\t    prev_cclass = cclass;\n\t\t    cclass = mb_get_class(ml_get_cursor());\n\t\t}\n\n\t\t// start of word?\n\t\tif (mode == BACKSPACE_WORD && !vim_isspace(cc))\n\t\t{\n\t\t    mode = BACKSPACE_WORD_NOT_SPACE;\n\t\t    temp = vim_iswordc(cc);\n\t\t}\n\t\t// end of word?\n\t\telse if (mode == BACKSPACE_WORD_NOT_SPACE\n\t\t\t&& ((vim_isspace(cc) || vim_iswordc(cc) != temp)\n\t\t\t|| prev_cclass != cclass))\n\t\t{\n#ifdef FEAT_RIGHTLEFT\n\t\t    if (!revins_on)\n#endif\n\t\t\tinc_cursor();\n#ifdef FEAT_RIGHTLEFT\n\t\t    else if (State & REPLACE_FLAG)\n\t\t\tdec_cursor();\n#endif\n\t\t    break;\n\t\t}\n\t\tif (State & REPLACE_FLAG)\n\t\t    replace_do_bs(-1);\n\t\telse\n\t\t{\n\t\t    if (enc_utf8 && p_deco)\n\t\t\t(void)utfc_ptr2char(ml_get_cursor(), cpc);\n\t\t    (void)del_char(FALSE);\n\t\t    /*\n\t\t     * If there are combining characters and 'delcombine' is set\n\t\t     * move the cursor back.  Don't back up before the base\n\t\t     * character.\n\t\t     */\n\t\t    if (enc_utf8 && p_deco && cpc[0] != NUL)\n\t\t\tinc_cursor();\n#ifdef FEAT_RIGHTLEFT\n\t\t    if (revins_chars)\n\t\t    {\n\t\t\trevins_chars--;\n\t\t\trevins_legal++;\n\t\t    }\n\t\t    if (revins_on && gchar_cursor() == NUL)\n\t\t\tbreak;\n#endif\n\t\t}\n\t\t// Just a single backspace?:\n\t\tif (mode == BACKSPACE_CHAR)\n\t\t    break;\n\t    } while (\n#ifdef FEAT_RIGHTLEFT\n\t\t    revins_on ||\n#endif\n\t\t    (curwin->w_cursor.col > mincol\n\t\t    &&  (can_bs(BS_NOSTOP)\n\t\t\t|| (curwin->w_cursor.lnum != Insstart_orig.lnum\n\t\t\t|| curwin->w_cursor.col != Insstart_orig.col)\n\t\t    )));\n\t}\n\tdid_backspace = TRUE;\n    }\n    did_si = FALSE;\n    can_si = FALSE;\n    can_si_back = FALSE;\n    if (curwin->w_cursor.col <= 1)\n\tdid_ai = FALSE;\n\n    if (call_fix_indent)\n\tfix_indent();\n\n    /*\n     * It's a little strange to put backspaces into the redo\n     * buffer, but it makes auto-indent a lot easier to deal\n     * with.\n     */\n    AppendCharToRedobuff(c);\n\n    // If deleted before the insertion point, adjust it\n    if (curwin->w_cursor.lnum == Insstart_orig.lnum\n\t\t\t\t  && curwin->w_cursor.col < Insstart_orig.col)\n\tInsstart_orig.col = curwin->w_cursor.col;\n\n    // vi behaviour: the cursor moves backward but the character that\n    //\t\t     was there remains visible\n    // Vim behaviour: the cursor moves backward and the character that\n    //\t\t      was there is erased from the screen.\n    // We can emulate the vi behaviour by pretending there is a dollar\n    // displayed even when there isn't.\n    //  --pkv Sun Jan 19 01:56:40 EST 2003\n    if (vim_strchr(p_cpo, CPO_BACKSPACE) != NULL && dollar_vcol == -1)\n\tdollar_vcol = curwin->w_virtcol;\n\n#ifdef FEAT_FOLDING\n    // When deleting a char the cursor line must never be in a closed fold.\n    // E.g., when 'foldmethod' is indent and deleting the first non-white\n    // char before a Tab.\n    if (did_backspace)\n\tfoldOpenCursor();\n#endif\n\n    return did_backspace;\n}", "func_hash": 64259932111379563055532506605085485351, "file_name": "edit.c", "file_hash": 91657375912486719968624749742093008286, "cwe": ["CWE-787"], "cve": "CVE-2022-2207", "cve_desc": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-2207", "file_path": "src/edit.c"}
{"idx": 206555, "project": "php-src", "commit_id": "cc08cbc84d46933c1e9e0149633f1ed5d19e45e9", "project_url": "https://github.com/php/php-src", "commit_url": "https://git.php.net/?p=php-src.git;a=commit;h=cc08cbc84d46933c1e9e0149633f1ed5d19e45e9", "commit_message": "Fix #73280: Stack Buffer Overflow in GD dynamicGetbuf\n\nWe make sure to never pass a negative `rlen` as size to memcpy().\n\nCf. <https://github.com/libgd/libgd/commit/53110871>.", "target": 1, "func": "static int dynamicGetbuf (gdIOCtxPtr ctx, void *buf, int len)\n{\n\tint rlen, remain;\n\tdpIOCtxPtr dctx;\n\tdynamicPtr *dp;\n\n\tdctx = (dpIOCtxPtr) ctx;\n\tdp = dctx->dp;\n\n\tremain = dp->logicalSize - dp->pos;\n\tif (remain >= len) {\n\t\trlen = len;\n\t} else {\n\t\tif (remain == 0) {\n\t\t\treturn EOF;\n\t\t}\n\t\trlen = remain;\n\t}\n\n\tmemcpy(buf, (void *) ((char *) dp->data + dp->pos), rlen);\n\tdp->pos += rlen;\n\n\treturn rlen;\n}", "func_hash": 44554623121680820346289655905713695377, "file_name": "gd_io_dp.c", "file_hash": 66950500877592745162628589676156559345, "cwe": ["CWE-119"], "cve": "CVE-2016-8670", "cve_desc": "Integer signedness error in the dynamicGetbuf function in gd_io_dp.c in the GD Graphics Library (aka libgd) through 2.2.3, as used in PHP before 5.6.28 and 7.x before 7.0.13, allows remote attackers to cause a denial of service (stack-based buffer overflow) or possibly have unspecified other impact via a crafted imagecreatefromstring call.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-8670", "file_path": "ext/gd/libgd/gd_io_dp.c"}
{"idx": 382797, "project": "php-src", "commit_id": "cc08cbc84d46933c1e9e0149633f1ed5d19e45e9", "project_url": "https://github.com/php/php-src", "commit_url": "https://git.php.net/?p=php-src.git;a=commit;h=cc08cbc84d46933c1e9e0149633f1ed5d19e45e9", "commit_message": "Fix #73280: Stack Buffer Overflow in GD dynamicGetbuf\n\nWe make sure to never pass a negative `rlen` as size to memcpy().\n\nCf. <https://github.com/libgd/libgd/commit/53110871>.", "target": 0, "func": "static int dynamicGetbuf (gdIOCtxPtr ctx, void *buf, int len)\n{\n\tint rlen, remain;\n\tdpIOCtxPtr dctx;\n\tdynamicPtr *dp;\n\n\tdctx = (dpIOCtxPtr) ctx;\n\tdp = dctx->dp;\n\n\tremain = dp->logicalSize - dp->pos;\n\tif (remain >= len) {\n\t\trlen = len;\n\t} else {\n\t\tif (remain <= 0) {\n\t\t\treturn EOF;\n\t\t}\n\t\trlen = remain;\n\t}\n\n\tmemcpy(buf, (void *) ((char *) dp->data + dp->pos), rlen);\n\tdp->pos += rlen;\n\n\treturn rlen;\n}", "func_hash": 227798178939410399739015256330671261805, "file_name": "gd_io_dp.c", "file_hash": 171487762597506665250744911889099357441, "cwe": ["CWE-119"], "cve": "CVE-2016-8670", "cve_desc": "Integer signedness error in the dynamicGetbuf function in gd_io_dp.c in the GD Graphics Library (aka libgd) through 2.2.3, as used in PHP before 5.6.28 and 7.x before 7.0.13, allows remote attackers to cause a denial of service (stack-based buffer overflow) or possibly have unspecified other impact via a crafted imagecreatefromstring call.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-8670", "file_path": "ext/gd/libgd/gd_io_dp.c"}
{"idx": 206625, "project": "raptor", "commit_id": "590681e546cd9aa18d57dc2ea1858cb734a3863f", "project_url": "https://github.com/dajobe/raptor", "commit_url": "https://github.com/dajobe/raptor/commit/590681e546cd9aa18d57dc2ea1858cb734a3863f", "commit_message": "Calcualte max nspace declarations correctly for XML writer\n\n(raptor_xml_writer_start_element_common): Calculate max including for\neach attribute a potential name and value.\n\nFixes Issues #0000617 http://bugs.librdf.org/mantis/view.php?id=617\nand #0000618 http://bugs.librdf.org/mantis/view.php?id=618", "target": 1, "func": "raptor_xml_writer_start_element_common(raptor_xml_writer* xml_writer,\n                                       raptor_xml_element* element,\n                                       int auto_empty)\n{\n  raptor_iostream* iostr = xml_writer->iostr;\n  raptor_namespace_stack *nstack = xml_writer->nstack;\n  int depth = xml_writer->depth;\n  int auto_indent = XML_WRITER_AUTO_INDENT(xml_writer);\n  struct nsd *nspace_declarations = NULL;\n  size_t nspace_declarations_count = 0;  \n  unsigned int i;\n\n  /* max is 1 per element and 1 for each attribute + size of declared */\n  if(nstack) {\n    int nspace_max_count = element->attribute_count+1;\n    if(element->declared_nspaces)\n      nspace_max_count += raptor_sequence_size(element->declared_nspaces);\n    if(element->xml_language)\n      nspace_max_count++;\n\n    nspace_declarations = RAPTOR_CALLOC(struct nsd*, nspace_max_count,\n                                        sizeof(struct nsd));\n    if(!nspace_declarations)\n      return 1;\n  }\n\n  if(element->name->nspace) {\n    if(nstack && !raptor_namespaces_namespace_in_scope(nstack, element->name->nspace)) {\n      nspace_declarations[0].declaration=\n        raptor_namespace_format_as_xml(element->name->nspace,\n                                       &nspace_declarations[0].length);\n      if(!nspace_declarations[0].declaration)\n        goto error;\n      nspace_declarations[0].nspace = element->name->nspace;\n      nspace_declarations_count++;\n    }\n  }\n\n  if(nstack && element->attributes) {\n    for(i = 0; i < element->attribute_count; i++) {\n      /* qname */\n      if(element->attributes[i]->nspace) {\n        /* Check if we need a namespace declaration attribute */\n        if(nstack && \n           !raptor_namespaces_namespace_in_scope(nstack, element->attributes[i]->nspace) && element->attributes[i]->nspace != element->name->nspace) {\n          /* not in scope and not same as element (so already going to be declared)*/\n          unsigned int j;\n          int declare_me = 1;\n          \n          /* check it wasn't an earlier declaration too */\n          for(j = 0; j < nspace_declarations_count; j++)\n            if(nspace_declarations[j].nspace == element->attributes[j]->nspace) {\n              declare_me = 0;\n              break;\n            }\n            \n          if(declare_me) {\n            nspace_declarations[nspace_declarations_count].declaration=\n              raptor_namespace_format_as_xml(element->attributes[i]->nspace,\n                                             &nspace_declarations[nspace_declarations_count].length);\n            if(!nspace_declarations[nspace_declarations_count].declaration)\n              goto error;\n            nspace_declarations[nspace_declarations_count].nspace = element->attributes[i]->nspace;\n            nspace_declarations_count++;\n          }\n        }\n      }\n\n      /* Add the attribute + value */\n      nspace_declarations[nspace_declarations_count].declaration=\n        raptor_qname_format_as_xml(element->attributes[i],\n                                   &nspace_declarations[nspace_declarations_count].length);\n      if(!nspace_declarations[nspace_declarations_count].declaration)\n        goto error;\n      nspace_declarations[nspace_declarations_count].nspace = NULL;\n      nspace_declarations_count++;\n\n    }\n  }\n\n  if(nstack && element->declared_nspaces &&\n     raptor_sequence_size(element->declared_nspaces) > 0) {\n    for(i = 0; i< (unsigned int)raptor_sequence_size(element->declared_nspaces); i++) {\n      raptor_namespace* nspace = (raptor_namespace*)raptor_sequence_get_at(element->declared_nspaces, i);\n      unsigned int j;\n      int declare_me = 1;\n      \n      /* check it wasn't an earlier declaration too */\n      for(j = 0; j < nspace_declarations_count; j++)\n        if(nspace_declarations[j].nspace == nspace) {\n          declare_me = 0;\n          break;\n        }\n      \n      if(declare_me) {\n        nspace_declarations[nspace_declarations_count].declaration=\n          raptor_namespace_format_as_xml(nspace,\n                                         &nspace_declarations[nspace_declarations_count].length);\n        if(!nspace_declarations[nspace_declarations_count].declaration)\n          goto error;\n        nspace_declarations[nspace_declarations_count].nspace = nspace;\n        nspace_declarations_count++;\n      }\n\n    }\n  }\n\n  if(nstack && element->xml_language) {\n    size_t lang_len = strlen(RAPTOR_GOOD_CAST(char*, element->xml_language));\n#define XML_LANG_PREFIX_LEN 10\n    size_t buf_length = XML_LANG_PREFIX_LEN + lang_len + 1;\n    unsigned char* buffer = RAPTOR_MALLOC(unsigned char*, buf_length + 1);\n    const char quote = '\\\"';\n    unsigned char* p;\n\n    memcpy(buffer, \"xml:lang=\\\"\", XML_LANG_PREFIX_LEN);\n    p = buffer + XML_LANG_PREFIX_LEN;\n    p += raptor_xml_escape_string(xml_writer->world,\n                                  element->xml_language, lang_len,\n                                  p, buf_length, quote);\n    *p++ = quote;\n    *p = '\\0';\n\n    nspace_declarations[nspace_declarations_count].declaration = buffer;\n    nspace_declarations[nspace_declarations_count].length = buf_length;\n    nspace_declarations[nspace_declarations_count].nspace = NULL;\n    nspace_declarations_count++;\n  }\n  \n\n  raptor_iostream_write_byte('<', iostr);\n\n  if(element->name->nspace && element->name->nspace->prefix_length > 0) {\n    raptor_iostream_counted_string_write((const char*)element->name->nspace->prefix, \n                                         element->name->nspace->prefix_length,\n                                         iostr);\n    raptor_iostream_write_byte(':', iostr);\n  }\n  raptor_iostream_counted_string_write((const char*)element->name->local_name,\n                                       element->name->local_name_length,\n                                       iostr);\n\n  /* declare namespaces and attributes */\n  if(nspace_declarations_count) {\n    int need_indent = 0;\n    \n    /* sort them into the canonical order */\n    qsort((void*)nspace_declarations, \n          nspace_declarations_count, sizeof(struct nsd),\n          raptor_xml_writer_nsd_compare);\n\n    /* declare namespaces first */\n    for(i = 0; i < nspace_declarations_count; i++) {\n      if(!nspace_declarations[i].nspace)\n        continue;\n\n      if(auto_indent && need_indent) {\n        /* indent attributes */\n        raptor_xml_writer_newline(xml_writer);\n        xml_writer->depth++;\n        raptor_xml_writer_indent(xml_writer);\n        xml_writer->depth--;\n      }\n      raptor_iostream_write_byte(' ', iostr);\n      raptor_iostream_counted_string_write((const char*)nspace_declarations[i].declaration,\n                                           nspace_declarations[i].length,\n                                           iostr);\n      RAPTOR_FREE(char*, nspace_declarations[i].declaration);\n      nspace_declarations[i].declaration = NULL;\n      need_indent = 1;\n      \n      if(raptor_namespace_stack_start_namespace(nstack,\n                                                (raptor_namespace*)nspace_declarations[i].nspace,\n                                                depth))\n        goto error;\n    }\n\n    /* declare attributes */\n    for(i = 0; i < nspace_declarations_count; i++) {\n      if(nspace_declarations[i].nspace)\n        continue;\n\n      if(auto_indent && need_indent) {\n        /* indent attributes */\n        raptor_xml_writer_newline(xml_writer);\n        xml_writer->depth++;\n        raptor_xml_writer_indent(xml_writer);\n        xml_writer->depth--;\n      }\n      raptor_iostream_write_byte(' ', iostr);\n      raptor_iostream_counted_string_write((const char*)nspace_declarations[i].declaration,\n                                           nspace_declarations[i].length,\n                                           iostr);\n      need_indent = 1;\n\n      RAPTOR_FREE(char*, nspace_declarations[i].declaration);\n      nspace_declarations[i].declaration = NULL;\n    }\n  }\n\n  if(!auto_empty)\n    raptor_iostream_write_byte('>', iostr);\n\n  if(nstack)\n    RAPTOR_FREE(stringarray, nspace_declarations);\n\n  return 0;\n\n  /* Clean up nspace_declarations on error */\n  error:\n\n  for(i = 0; i < nspace_declarations_count; i++) {\n    if(nspace_declarations[i].declaration)\n      RAPTOR_FREE(char*, nspace_declarations[i].declaration);\n  }\n\n  RAPTOR_FREE(stringarray, nspace_declarations);\n\n  return 1;\n}", "func_hash": 183974089624650942434351568312452779610, "file_name": "raptor_xml_writer.c", "file_hash": 303005196227120175198140448209688194758, "cwe": ["CWE-787"], "cve": "CVE-2017-18926", "cve_desc": "raptor_xml_writer_start_element_common in raptor_xml_writer.c in Raptor RDF Syntax Library 2.0.15 miscalculates the maximum nspace declarations for the XML writer, leading to heap-based buffer overflows (sometimes seen in raptor_qname_format_as_xml).", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-18926", "file_path": "src/raptor_xml_writer.c"}
{"idx": 384124, "project": "raptor", "commit_id": "590681e546cd9aa18d57dc2ea1858cb734a3863f", "project_url": "https://github.com/dajobe/raptor", "commit_url": "https://github.com/dajobe/raptor/commit/590681e546cd9aa18d57dc2ea1858cb734a3863f", "commit_message": "Calcualte max nspace declarations correctly for XML writer\n\n(raptor_xml_writer_start_element_common): Calculate max including for\neach attribute a potential name and value.\n\nFixes Issues #0000617 http://bugs.librdf.org/mantis/view.php?id=617\nand #0000618 http://bugs.librdf.org/mantis/view.php?id=618", "target": 0, "func": "raptor_xml_writer_start_element_common(raptor_xml_writer* xml_writer,\n                                       raptor_xml_element* element,\n                                       int auto_empty)\n{\n  raptor_iostream* iostr = xml_writer->iostr;\n  raptor_namespace_stack *nstack = xml_writer->nstack;\n  int depth = xml_writer->depth;\n  int auto_indent = XML_WRITER_AUTO_INDENT(xml_writer);\n  struct nsd *nspace_declarations = NULL;\n  size_t nspace_declarations_count = 0;  \n  unsigned int i;\n\n  if(nstack) {\n    int nspace_max_count = element->attribute_count * 2; /* attr and value */\n    if(element->name->nspace)\n      nspace_max_count++;\n    if(element->declared_nspaces)\n      nspace_max_count += raptor_sequence_size(element->declared_nspaces);\n    if(element->xml_language)\n      nspace_max_count++;\n\n    nspace_declarations = RAPTOR_CALLOC(struct nsd*, nspace_max_count,\n                                        sizeof(struct nsd));\n    if(!nspace_declarations)\n      return 1;\n  }\n\n  if(element->name->nspace) {\n    if(nstack && !raptor_namespaces_namespace_in_scope(nstack, element->name->nspace)) {\n      nspace_declarations[0].declaration=\n        raptor_namespace_format_as_xml(element->name->nspace,\n                                       &nspace_declarations[0].length);\n      if(!nspace_declarations[0].declaration)\n        goto error;\n      nspace_declarations[0].nspace = element->name->nspace;\n      nspace_declarations_count++;\n    }\n  }\n\n  if(nstack && element->attributes) {\n    for(i = 0; i < element->attribute_count; i++) {\n      /* qname */\n      if(element->attributes[i]->nspace) {\n        /* Check if we need a namespace declaration attribute */\n        if(nstack && \n           !raptor_namespaces_namespace_in_scope(nstack, element->attributes[i]->nspace) && element->attributes[i]->nspace != element->name->nspace) {\n          /* not in scope and not same as element (so already going to be declared)*/\n          unsigned int j;\n          int declare_me = 1;\n          \n          /* check it wasn't an earlier declaration too */\n          for(j = 0; j < nspace_declarations_count; j++)\n            if(nspace_declarations[j].nspace == element->attributes[j]->nspace) {\n              declare_me = 0;\n              break;\n            }\n            \n          if(declare_me) {\n            nspace_declarations[nspace_declarations_count].declaration=\n              raptor_namespace_format_as_xml(element->attributes[i]->nspace,\n                                             &nspace_declarations[nspace_declarations_count].length);\n            if(!nspace_declarations[nspace_declarations_count].declaration)\n              goto error;\n            nspace_declarations[nspace_declarations_count].nspace = element->attributes[i]->nspace;\n            nspace_declarations_count++;\n          }\n        }\n      }\n\n      /* Add the attribute's value */\n      nspace_declarations[nspace_declarations_count].declaration=\n        raptor_qname_format_as_xml(element->attributes[i],\n                                   &nspace_declarations[nspace_declarations_count].length);\n      if(!nspace_declarations[nspace_declarations_count].declaration)\n        goto error;\n      nspace_declarations[nspace_declarations_count].nspace = NULL;\n      nspace_declarations_count++;\n\n    }\n  }\n\n  if(nstack && element->declared_nspaces &&\n     raptor_sequence_size(element->declared_nspaces) > 0) {\n    for(i = 0; i< (unsigned int)raptor_sequence_size(element->declared_nspaces); i++) {\n      raptor_namespace* nspace = (raptor_namespace*)raptor_sequence_get_at(element->declared_nspaces, i);\n      unsigned int j;\n      int declare_me = 1;\n      \n      /* check it wasn't an earlier declaration too */\n      for(j = 0; j < nspace_declarations_count; j++)\n        if(nspace_declarations[j].nspace == nspace) {\n          declare_me = 0;\n          break;\n        }\n      \n      if(declare_me) {\n        nspace_declarations[nspace_declarations_count].declaration=\n          raptor_namespace_format_as_xml(nspace,\n                                         &nspace_declarations[nspace_declarations_count].length);\n        if(!nspace_declarations[nspace_declarations_count].declaration)\n          goto error;\n        nspace_declarations[nspace_declarations_count].nspace = nspace;\n        nspace_declarations_count++;\n      }\n\n    }\n  }\n\n  if(nstack && element->xml_language) {\n    size_t lang_len = strlen(RAPTOR_GOOD_CAST(char*, element->xml_language));\n#define XML_LANG_PREFIX_LEN 10\n    size_t buf_length = XML_LANG_PREFIX_LEN + lang_len + 1;\n    unsigned char* buffer = RAPTOR_MALLOC(unsigned char*, buf_length + 1);\n    const char quote = '\\\"';\n    unsigned char* p;\n\n    memcpy(buffer, \"xml:lang=\\\"\", XML_LANG_PREFIX_LEN);\n    p = buffer + XML_LANG_PREFIX_LEN;\n    p += raptor_xml_escape_string(xml_writer->world,\n                                  element->xml_language, lang_len,\n                                  p, buf_length, quote);\n    *p++ = quote;\n    *p = '\\0';\n\n    nspace_declarations[nspace_declarations_count].declaration = buffer;\n    nspace_declarations[nspace_declarations_count].length = buf_length;\n    nspace_declarations[nspace_declarations_count].nspace = NULL;\n    nspace_declarations_count++;\n  }\n  \n\n  raptor_iostream_write_byte('<', iostr);\n\n  if(element->name->nspace && element->name->nspace->prefix_length > 0) {\n    raptor_iostream_counted_string_write((const char*)element->name->nspace->prefix, \n                                         element->name->nspace->prefix_length,\n                                         iostr);\n    raptor_iostream_write_byte(':', iostr);\n  }\n  raptor_iostream_counted_string_write((const char*)element->name->local_name,\n                                       element->name->local_name_length,\n                                       iostr);\n\n  /* declare namespaces and attributes */\n  if(nspace_declarations_count) {\n    int need_indent = 0;\n    \n    /* sort them into the canonical order */\n    qsort((void*)nspace_declarations, \n          nspace_declarations_count, sizeof(struct nsd),\n          raptor_xml_writer_nsd_compare);\n\n    /* declare namespaces first */\n    for(i = 0; i < nspace_declarations_count; i++) {\n      if(!nspace_declarations[i].nspace)\n        continue;\n\n      if(auto_indent && need_indent) {\n        /* indent attributes */\n        raptor_xml_writer_newline(xml_writer);\n        xml_writer->depth++;\n        raptor_xml_writer_indent(xml_writer);\n        xml_writer->depth--;\n      }\n      raptor_iostream_write_byte(' ', iostr);\n      raptor_iostream_counted_string_write((const char*)nspace_declarations[i].declaration,\n                                           nspace_declarations[i].length,\n                                           iostr);\n      RAPTOR_FREE(char*, nspace_declarations[i].declaration);\n      nspace_declarations[i].declaration = NULL;\n      need_indent = 1;\n      \n      if(raptor_namespace_stack_start_namespace(nstack,\n                                                (raptor_namespace*)nspace_declarations[i].nspace,\n                                                depth))\n        goto error;\n    }\n\n    /* declare attributes */\n    for(i = 0; i < nspace_declarations_count; i++) {\n      if(nspace_declarations[i].nspace)\n        continue;\n\n      if(auto_indent && need_indent) {\n        /* indent attributes */\n        raptor_xml_writer_newline(xml_writer);\n        xml_writer->depth++;\n        raptor_xml_writer_indent(xml_writer);\n        xml_writer->depth--;\n      }\n      raptor_iostream_write_byte(' ', iostr);\n      raptor_iostream_counted_string_write((const char*)nspace_declarations[i].declaration,\n                                           nspace_declarations[i].length,\n                                           iostr);\n      need_indent = 1;\n\n      RAPTOR_FREE(char*, nspace_declarations[i].declaration);\n      nspace_declarations[i].declaration = NULL;\n    }\n  }\n\n  if(!auto_empty)\n    raptor_iostream_write_byte('>', iostr);\n\n  if(nstack)\n    RAPTOR_FREE(stringarray, nspace_declarations);\n\n  return 0;\n\n  /* Clean up nspace_declarations on error */\n  error:\n\n  for(i = 0; i < nspace_declarations_count; i++) {\n    if(nspace_declarations[i].declaration)\n      RAPTOR_FREE(char*, nspace_declarations[i].declaration);\n  }\n\n  RAPTOR_FREE(stringarray, nspace_declarations);\n\n  return 1;\n}", "func_hash": 82963305933956175677502497774267767451, "file_name": "raptor_xml_writer.c", "file_hash": 139112831165877018854969912519011883099, "cwe": ["CWE-787"], "cve": "CVE-2017-18926", "cve_desc": "raptor_xml_writer_start_element_common in raptor_xml_writer.c in Raptor RDF Syntax Library 2.0.15 miscalculates the maximum nspace declarations for the XML writer, leading to heap-based buffer overflows (sometimes seen in raptor_qname_format_as_xml).", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-18926", "file_path": "src/raptor_xml_writer.c"}
{"idx": 206639, "project": "linux", "commit_id": "e02f0d3970404bfea385b6edb86f2d936db0ea2b", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/e02f0d3970404bfea385b6edb86f2d936db0ea2b", "commit_message": "netfilter: nf_tables: disallow binding to already bound chain\n\nUpdate nft_data_init() to report EINVAL if chain is already bound.\n\nFixes: d0e2c7de92c7 (\"netfilter: nf_tables: add NFT_CHAIN_BINDING\")\nReported-by: Gwangun Jung <exsociety@gmail.com>\nSigned-off-by: Pablo Neira Ayuso <pablo@netfilter.org>", "target": 1, "func": "static int nft_verdict_init(const struct nft_ctx *ctx, struct nft_data *data,\n\t\t\t    struct nft_data_desc *desc, const struct nlattr *nla)\n{\n\tu8 genmask = nft_genmask_next(ctx->net);\n\tstruct nlattr *tb[NFTA_VERDICT_MAX + 1];\n\tstruct nft_chain *chain;\n\tint err;\n\n\terr = nla_parse_nested_deprecated(tb, NFTA_VERDICT_MAX, nla,\n\t\t\t\t\t  nft_verdict_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!tb[NFTA_VERDICT_CODE])\n\t\treturn -EINVAL;\n\tdata->verdict.code = ntohl(nla_get_be32(tb[NFTA_VERDICT_CODE]));\n\n\tswitch (data->verdict.code) {\n\tdefault:\n\t\tswitch (data->verdict.code & NF_VERDICT_MASK) {\n\t\tcase NF_ACCEPT:\n\t\tcase NF_DROP:\n\t\tcase NF_QUEUE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tfallthrough;\n\tcase NFT_CONTINUE:\n\tcase NFT_BREAK:\n\tcase NFT_RETURN:\n\t\tbreak;\n\tcase NFT_JUMP:\n\tcase NFT_GOTO:\n\t\tif (tb[NFTA_VERDICT_CHAIN]) {\n\t\t\tchain = nft_chain_lookup(ctx->net, ctx->table,\n\t\t\t\t\t\t tb[NFTA_VERDICT_CHAIN],\n\t\t\t\t\t\t genmask);\n\t\t} else if (tb[NFTA_VERDICT_CHAIN_ID]) {\n\t\t\tchain = nft_chain_lookup_byid(ctx->net, ctx->table,\n\t\t\t\t\t\t      tb[NFTA_VERDICT_CHAIN_ID]);\n\t\t\tif (IS_ERR(chain))\n\t\t\t\treturn PTR_ERR(chain);\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (IS_ERR(chain))\n\t\t\treturn PTR_ERR(chain);\n\t\tif (nft_is_base_chain(chain))\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (desc->flags & NFT_DATA_DESC_SETELEM &&\n\t\t    chain->flags & NFT_CHAIN_BINDING)\n\t\t\treturn -EINVAL;\n\n\t\tchain->use++;\n\t\tdata->verdict.chain = chain;\n\t\tbreak;\n\t}\n\n\tdesc->len = sizeof(data->verdict);\n\n\treturn 0;\n}", "func_hash": 76294390154807140346030498178733770308, "file_name": "nf_tables_api.c", "file_hash": 280373467088228575441623327249382307245, "cwe": ["CWE-703"], "cve": "CVE-2022-39190", "cve_desc": "An issue was discovered in net/netfilter/nf_tables_api.c in the Linux kernel before 5.19.6. A denial of service can occur upon binding to an already bound chain.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-39190", "file_path": "net/netfilter/nf_tables_api.c"}
{"idx": 384201, "project": "linux", "commit_id": "e02f0d3970404bfea385b6edb86f2d936db0ea2b", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/e02f0d3970404bfea385b6edb86f2d936db0ea2b", "commit_message": "netfilter: nf_tables: disallow binding to already bound chain\n\nUpdate nft_data_init() to report EINVAL if chain is already bound.\n\nFixes: d0e2c7de92c7 (\"netfilter: nf_tables: add NFT_CHAIN_BINDING\")\nReported-by: Gwangun Jung <exsociety@gmail.com>\nSigned-off-by: Pablo Neira Ayuso <pablo@netfilter.org>", "target": 0, "func": "static int nft_verdict_init(const struct nft_ctx *ctx, struct nft_data *data,\n\t\t\t    struct nft_data_desc *desc, const struct nlattr *nla)\n{\n\tu8 genmask = nft_genmask_next(ctx->net);\n\tstruct nlattr *tb[NFTA_VERDICT_MAX + 1];\n\tstruct nft_chain *chain;\n\tint err;\n\n\terr = nla_parse_nested_deprecated(tb, NFTA_VERDICT_MAX, nla,\n\t\t\t\t\t  nft_verdict_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!tb[NFTA_VERDICT_CODE])\n\t\treturn -EINVAL;\n\tdata->verdict.code = ntohl(nla_get_be32(tb[NFTA_VERDICT_CODE]));\n\n\tswitch (data->verdict.code) {\n\tdefault:\n\t\tswitch (data->verdict.code & NF_VERDICT_MASK) {\n\t\tcase NF_ACCEPT:\n\t\tcase NF_DROP:\n\t\tcase NF_QUEUE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tfallthrough;\n\tcase NFT_CONTINUE:\n\tcase NFT_BREAK:\n\tcase NFT_RETURN:\n\t\tbreak;\n\tcase NFT_JUMP:\n\tcase NFT_GOTO:\n\t\tif (tb[NFTA_VERDICT_CHAIN]) {\n\t\t\tchain = nft_chain_lookup(ctx->net, ctx->table,\n\t\t\t\t\t\t tb[NFTA_VERDICT_CHAIN],\n\t\t\t\t\t\t genmask);\n\t\t} else if (tb[NFTA_VERDICT_CHAIN_ID]) {\n\t\t\tchain = nft_chain_lookup_byid(ctx->net, ctx->table,\n\t\t\t\t\t\t      tb[NFTA_VERDICT_CHAIN_ID]);\n\t\t\tif (IS_ERR(chain))\n\t\t\t\treturn PTR_ERR(chain);\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (IS_ERR(chain))\n\t\t\treturn PTR_ERR(chain);\n\t\tif (nft_is_base_chain(chain))\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (nft_chain_is_bound(chain))\n\t\t\treturn -EINVAL;\n\t\tif (desc->flags & NFT_DATA_DESC_SETELEM &&\n\t\t    chain->flags & NFT_CHAIN_BINDING)\n\t\t\treturn -EINVAL;\n\n\t\tchain->use++;\n\t\tdata->verdict.chain = chain;\n\t\tbreak;\n\t}\n\n\tdesc->len = sizeof(data->verdict);\n\n\treturn 0;\n}", "func_hash": 189225679685979204194302814541477257663, "file_name": "nf_tables_api.c", "file_hash": 161585463478410786724773068235961577198, "cwe": ["CWE-703"], "cve": "CVE-2022-39190", "cve_desc": "An issue was discovered in net/netfilter/nf_tables_api.c in the Linux kernel before 5.19.6. A denial of service can occur upon binding to an already bound chain.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-39190", "file_path": "net/netfilter/nf_tables_api.c"}
{"idx": 206670, "project": "nbdkit", "commit_id": "6c5faac6a37077cf2366388a80862bb00616d0d8", "project_url": "https://github.com/libguestfs/nbdkit", "commit_url": "https://gitlab.com/nbdkit/nbdkit/-/commit/6c5faac6a37077cf2366388a80862bb00616d0d8", "commit_message": "server: reset meta context replies on starttls\n\nRelated to CVE-2021-3716, but not as severe.  No compliant client will\nsend NBD_CMD_BLOCK_STATUS unless it first negotiates\nNBD_OPT_SET_META_CONTEXT.  If an attacker injects a premature\nSET_META_CONTEXT, either the client will never notice (because it\nnever uses BLOCK_STATUS), or the client will overwrite the attacker's\nattempt with the client's own SET_META_CONTEXT request after\nencryption is enabled.  So I don't class this as having the potential\nto trigger denial-of-service due to any protocol mismatch between\ncompliant client and server (I don't care what happens with\nnon-compliant clients).\n\nFixes: 26455d45 (server: protocol: Implement Block Status \"base:allocation\".)", "target": 1, "func": "negotiate_handshake_newstyle_options (void)\n{\n  GET_CONN;\n  struct nbd_new_option new_option;\n  size_t nr_options;\n  bool list_seen = false;\n  uint64_t version;\n  uint32_t option;\n  uint32_t optlen;\n  struct nbd_export_name_option_reply handshake_finish;\n  const char *optname;\n  uint64_t exportsize;\n  struct backend *b;\n\n  for (nr_options = MAX_NR_OPTIONS; nr_options > 0; --nr_options) {\n    CLEANUP_FREE char *data = NULL;\n\n    if (conn_recv_full (&new_option, sizeof new_option,\n                        \"reading option: conn->recv: %m\") == -1)\n      return -1;\n\n    version = be64toh (new_option.version);\n    if (version != NBD_NEW_VERSION) {\n      nbdkit_error (\"unknown option version %\" PRIx64\n                    \", expecting %\" PRIx64,\n                    version, NBD_NEW_VERSION);\n      return -1;\n    }\n\n    /* There is a maximum option length we will accept, regardless\n     * of the option type.\n     */\n    optlen = be32toh (new_option.optlen);\n    if (optlen > MAX_REQUEST_SIZE) {\n      nbdkit_error (\"client option data too long (%\" PRIu32 \")\", optlen);\n      return -1;\n    }\n    data = malloc (optlen + 1); /* Allowing a trailing NUL helps some uses */\n    if (data == NULL) {\n      nbdkit_error (\"malloc: %m\");\n      return -1;\n    }\n\n    option = be32toh (new_option.option);\n    optname = name_of_nbd_opt (option);\n\n    /* If the client lacks fixed newstyle support, it should only send\n     * NBD_OPT_EXPORT_NAME.\n     */\n    if (!(conn->cflags & NBD_FLAG_FIXED_NEWSTYLE) &&\n        option != NBD_OPT_EXPORT_NAME) {\n      if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID))\n        return -1;\n      continue;\n    }\n\n    /* In --tls=require / FORCEDTLS mode the only options allowed\n     * before TLS negotiation are NBD_OPT_ABORT and NBD_OPT_STARTTLS.\n     */\n    if (tls == 2 && !conn->using_tls &&\n        !(option == NBD_OPT_ABORT || option == NBD_OPT_STARTTLS)) {\n      if (send_newstyle_option_reply (option, NBD_REP_ERR_TLS_REQD))\n        return -1;\n      continue;\n    }\n\n    switch (option) {\n    case NBD_OPT_EXPORT_NAME:\n      if (conn_recv_full (data, optlen,\n                          \"read: %s: %m\", name_of_nbd_opt (option)) == -1)\n        return -1;\n      if (check_export_name (option, data, optlen, optlen) == -1)\n        return -1;\n\n      /* We have to finish the handshake by sending handshake_finish.\n       * On failure, we have to disconnect.\n       */\n      if (finish_newstyle_options (&exportsize, data, optlen) == -1)\n        return -1;\n\n      memset (&handshake_finish, 0, sizeof handshake_finish);\n      handshake_finish.exportsize = htobe64 (exportsize);\n      handshake_finish.eflags = htobe16 (conn->eflags);\n\n      if (conn->send (&handshake_finish,\n                      (conn->cflags & NBD_FLAG_NO_ZEROES)\n                      ? offsetof (struct nbd_export_name_option_reply, zeroes)\n                      : sizeof handshake_finish, 0) == -1) {\n        nbdkit_error (\"write: %s: %m\", optname);\n        return -1;\n      }\n      break;\n\n    case NBD_OPT_ABORT:\n      if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)\n        return -1;\n      debug (\"client sent %s to abort the connection\",\n             name_of_nbd_opt (option));\n      return -1;\n\n    case NBD_OPT_LIST:\n      if (optlen != 0) {\n        if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)\n            == -1)\n          return -1;\n        if (conn_recv_full (data, optlen,\n                            \"read: %s: %m\", name_of_nbd_opt (option)) == -1)\n          return -1;\n        continue;\n      }\n\n      if (list_seen) {\n        debug (\"newstyle negotiation: %s: export list already advertised\",\n               name_of_nbd_opt (option));\n        if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID) == -1)\n          return -1;\n        continue;\n      }\n      else {\n        /* Send back the exportname list. */\n        debug (\"newstyle negotiation: %s: advertising exports\",\n               name_of_nbd_opt (option));\n        if (send_newstyle_option_reply_exportnames (option, &nr_options) == -1)\n          return -1;\n        list_seen = true;\n      }\n      break;\n\n    case NBD_OPT_STARTTLS:\n      if (optlen != 0) {\n        if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)\n            == -1)\n          return -1;\n        if (conn_recv_full (data, optlen,\n                            \"read: %s: %m\", name_of_nbd_opt (option)) == -1)\n          return -1;\n        continue;\n      }\n\n      if (tls == 0) {           /* --tls=off (NOTLS mode). */\n#ifdef HAVE_GNUTLS\n#define NO_TLS_REPLY NBD_REP_ERR_POLICY\n#else\n#define NO_TLS_REPLY NBD_REP_ERR_UNSUP\n#endif\n        if (send_newstyle_option_reply (option, NO_TLS_REPLY) == -1)\n          return -1;\n      }\n      else /* --tls=on or --tls=require */ {\n        /* We can't upgrade to TLS twice on the same connection. */\n        if (conn->using_tls) {\n          if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID) == -1)\n            return -1;\n          continue;\n        }\n\n        /* We have to send the (unencrypted) reply before starting\n         * the handshake.\n         */\n        if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)\n          return -1;\n\n        /* Upgrade the connection to TLS.  Also performs access control. */\n        if (crypto_negotiate_tls (conn->sockin, conn->sockout) == -1)\n          return -1;\n        conn->using_tls = true;\n        debug (\"using TLS on this connection\");\n        /* Wipe out any cached state. */\n        conn->structured_replies = false;\n        for_each_backend (b) {\n          free (conn->default_exportname[b->i]);\n          conn->default_exportname[b->i] = NULL;\n        }\n      }\n      break;\n\n    case NBD_OPT_INFO:\n    case NBD_OPT_GO:\n      if (conn_recv_full (data, optlen, \"read: %s: %m\", optname) == -1)\n        return -1;\n\n      if (optlen < 6) { /* 32 bit export length + 16 bit nr info */\n        debug (\"newstyle negotiation: %s option length < 6\", optname);\n\n        if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)\n            == -1)\n          return -1;\n        continue;\n      }\n\n      {\n        uint32_t exportnamelen;\n        uint16_t nrinfos;\n        uint16_t info;\n        size_t i;\n\n        /* Validate the name length and number of INFO requests. */\n        memcpy (&exportnamelen, &data[0], 4);\n        exportnamelen = be32toh (exportnamelen);\n        if (exportnamelen > optlen-6 /* NB optlen >= 6, see above */) {\n          debug (\"newstyle negotiation: %s: export name too long\", optname);\n          if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)\n              == -1)\n            return -1;\n          continue;\n        }\n        memcpy (&nrinfos, &data[exportnamelen+4], 2);\n        nrinfos = be16toh (nrinfos);\n        if (optlen != 4 + exportnamelen + 2 + 2*nrinfos) {\n          debug (\"newstyle negotiation: %s: \"\n                 \"number of information requests incorrect\", optname);\n          if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)\n              == -1)\n            return -1;\n          continue;\n        }\n\n        /* As with NBD_OPT_EXPORT_NAME we print the export name and\n         * save it in the connection.  If an earlier\n         * NBD_OPT_SET_META_CONTEXT used an export name, it must match\n         * or else we drop the support for that context.\n         */\n        if (check_export_name (option, &data[4], exportnamelen,\n                               optlen - 6) == -1) {\n          if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)\n              == -1)\n            return -1;\n          continue;\n        }\n\n        /* The spec is confusing, but it is required that we send back\n         * NBD_INFO_EXPORT, even if the client did not request it!\n         * qemu client in particular does not request this, but will\n         * fail if we don't send it.  Note that if .open fails, but we\n         * succeed at .close, then we merely return an error to the\n         * client and let them try another NBD_OPT, rather than\n         * disconnecting.\n         */\n        if (finish_newstyle_options (&exportsize,\n                                     &data[4], exportnamelen) == -1) {\n          if (conn->top_context) {\n            if (backend_finalize (conn->top_context) == -1)\n              return -1;\n            backend_close (conn->top_context);\n            conn->top_context = NULL;\n          }\n          if (send_newstyle_option_reply (option, NBD_REP_ERR_UNKNOWN) == -1)\n            return -1;\n          continue;\n        }\n\n        if (send_newstyle_option_reply_info_export (option,\n                                                    NBD_REP_INFO,\n                                                    NBD_INFO_EXPORT,\n                                                    exportsize) == -1)\n          return -1;\n\n        /* For now we send NBD_INFO_NAME and NBD_INFO_DESCRIPTION if\n         * requested, and ignore all other info requests (including\n         * NBD_INFO_EXPORT if it was requested, because we replied\n         * already above).\n         */\n        for (i = 0; i < nrinfos; ++i) {\n          memcpy (&info, &data[4 + exportnamelen + 2 + i*2], 2);\n          info = be16toh (info);\n          switch (info) {\n          case NBD_INFO_EXPORT: /* ignore - reply sent above */ break;\n          case NBD_INFO_NAME:\n            {\n              const char *name = &data[4];\n              size_t namelen = exportnamelen;\n\n              if (exportnamelen == 0) {\n                name = backend_default_export (top, read_only);\n                if (!name) {\n                  debug (\"newstyle negotiation: %s: \"\n                         \"NBD_INFO_NAME: no name to send\", optname);\n                  break;\n                }\n                namelen = -1;\n              }\n              if (send_newstyle_option_reply_info_str (option,\n                                                       NBD_REP_INFO,\n                                                       NBD_INFO_NAME,\n                                                       name, namelen) == -1)\n                return -1;\n            }\n            break;\n          case NBD_INFO_DESCRIPTION:\n            {\n              const char *desc = backend_export_description (conn->top_context);\n\n              if (!desc) {\n                debug (\"newstyle negotiation: %s: \"\n                       \"NBD_INFO_DESCRIPTION: no description to send\",\n                       optname);\n                break;\n              }\n              if (send_newstyle_option_reply_info_str (option,\n                                                       NBD_REP_INFO,\n                                                       NBD_INFO_DESCRIPTION,\n                                                       desc, -1) == -1)\n                return -1;\n            }\n            break;\n          default:\n            debug (\"newstyle negotiation: %s: \"\n                   \"ignoring NBD_INFO_* request %u (%s)\",\n                   optname, (unsigned) info, name_of_nbd_info (info));\n            break;\n          }\n        }\n      }\n\n      /* Unlike NBD_OPT_EXPORT_NAME, NBD_OPT_GO sends back an ACK\n       * or ERROR packet.  If this was NBD_OPT_LIST, call .close.\n       */\n      if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)\n        return -1;\n\n      if (option == NBD_OPT_INFO) {\n        if (backend_finalize (conn->top_context) == -1)\n          return -1;\n        backend_close (conn->top_context);\n        conn->top_context = NULL;\n      }\n\n      break;\n\n    case NBD_OPT_STRUCTURED_REPLY:\n      if (optlen != 0) {\n        if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)\n            == -1)\n          return -1;\n        if (conn_recv_full (data, optlen,\n                            \"read: %s: %m\", name_of_nbd_opt (option)) == -1)\n          return -1;\n        continue;\n      }\n\n      debug (\"newstyle negotiation: %s: client requested structured replies\",\n             name_of_nbd_opt (option));\n\n      if (no_sr) {\n        /* Must fail with ERR_UNSUP for qemu 4.2 to remain happy;\n         * but failing with ERR_POLICY would have been nicer.\n         */\n        if (send_newstyle_option_reply (option, NBD_REP_ERR_UNSUP) == -1)\n          return -1;\n        debug (\"newstyle negotiation: %s: structured replies are disabled\",\n               name_of_nbd_opt (option));\n        break;\n      }\n\n      if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)\n        return -1;\n\n      conn->structured_replies = true;\n      break;\n\n    case NBD_OPT_LIST_META_CONTEXT:\n    case NBD_OPT_SET_META_CONTEXT:\n      {\n        uint32_t opt_index;\n        uint32_t exportnamelen;\n        uint32_t nr_queries;\n        uint32_t querylen;\n        const char *what;\n\n        if (conn_recv_full (data, optlen, \"read: %s: %m\", optname) == -1)\n          return -1;\n\n        /* Note that we support base:allocation whether or not the plugin\n         * supports can_extents.\n         */\n        if (!conn->structured_replies) {\n          if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)\n              == -1)\n            return -1;\n          continue;\n        }\n\n        /* Minimum length of the option payload is:\n         *   32 bit export name length followed by empty export name\n         * + 32 bit number of queries followed by no queries\n         * = 8 bytes.\n         */\n        what = \"optlen < 8\";\n        if (optlen < 8) {\n        opt_meta_invalid_option_len:\n          debug (\"newstyle negotiation: %s: invalid option length: %s\",\n                 optname, what);\n\n          if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)\n              == -1)\n            return -1;\n          continue;\n        }\n\n        memcpy (&exportnamelen, &data[0], 4);\n        exportnamelen = be32toh (exportnamelen);\n        what = \"validating export name\";\n        if (check_export_name (option, &data[4], exportnamelen,\n                               optlen - 8) == -1)\n          goto opt_meta_invalid_option_len;\n\n        /* Remember the export name: the NBD spec says that if the client\n         * later uses NBD_OPT_GO on a different export, then the context\n         * returned here is not usable.\n         */\n        if (option == NBD_OPT_SET_META_CONTEXT) {\n          conn->exportname_from_set_meta_context =\n            strndup (&data[4], exportnamelen);\n          if (conn->exportname_from_set_meta_context == NULL) {\n            nbdkit_error (\"malloc: %m\");\n            return -1;\n          }\n        }\n\n        opt_index = 4 + exportnamelen;\n\n        /* Read the number of queries. */\n        what = \"reading number of queries\";\n        if (opt_index+4 > optlen)\n          goto opt_meta_invalid_option_len;\n        memcpy (&nr_queries, &data[opt_index], 4);\n        nr_queries = be32toh (nr_queries);\n        opt_index += 4;\n\n        /* for LIST: nr_queries == 0 means return all meta contexts\n         * for SET: nr_queries == 0 means reset all contexts\n         */\n        debug (\"newstyle negotiation: %s: %s count: %d\", optname,\n               option == NBD_OPT_LIST_META_CONTEXT ? \"query\" : \"set\",\n               nr_queries);\n        if (option == NBD_OPT_SET_META_CONTEXT)\n          conn->meta_context_base_allocation = false;\n        if (nr_queries == 0) {\n          if (option == NBD_OPT_LIST_META_CONTEXT) {\n            if (send_newstyle_option_reply_meta_context (option,\n                                                         NBD_REP_META_CONTEXT,\n                                                         0, \"base:allocation\")\n                == -1)\n              return -1;\n          }\n\n          if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)\n            return -1;\n        }\n        else {\n          /* Read and answer each query. */\n          while (nr_queries > 0) {\n            what = \"reading query string length\";\n            if (opt_index+4 > optlen)\n              goto opt_meta_invalid_option_len;\n            memcpy (&querylen, &data[opt_index], 4);\n            querylen = be32toh (querylen);\n            opt_index += 4;\n            what = \"reading query string\";\n            if (check_string (option, &data[opt_index], querylen,\n                              optlen - opt_index, \"meta context query\") == -1)\n              goto opt_meta_invalid_option_len;\n\n            debug (\"newstyle negotiation: %s: %s %.*s\",\n                   optname,\n                   option == NBD_OPT_LIST_META_CONTEXT ? \"query\" : \"set\",\n                   (int) querylen, &data[opt_index]);\n\n            /* For LIST, \"base:\" returns all supported contexts in the\n             * base namespace.  We only support \"base:allocation\".\n             */\n            if (option == NBD_OPT_LIST_META_CONTEXT &&\n                querylen == 5 &&\n                strncmp (&data[opt_index], \"base:\", 5) == 0) {\n              if (send_newstyle_option_reply_meta_context\n                  (option, NBD_REP_META_CONTEXT,\n                   0, \"base:allocation\") == -1)\n                return -1;\n            }\n            /* \"base:allocation\" requested by name. */\n            else if (querylen == 15 &&\n                     strncmp (&data[opt_index], \"base:allocation\", 15) == 0) {\n              if (send_newstyle_option_reply_meta_context\n                  (option, NBD_REP_META_CONTEXT,\n                   option == NBD_OPT_SET_META_CONTEXT\n                   ? base_allocation_id : 0,\n                   \"base:allocation\") == -1)\n                return -1;\n              if (option == NBD_OPT_SET_META_CONTEXT)\n                conn->meta_context_base_allocation = true;\n            }\n            /* Every other query must be ignored. */\n\n            opt_index += querylen;\n            nr_queries--;\n          }\n          if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)\n            return -1;\n        }\n        debug (\"newstyle negotiation: %s: reply complete\", optname);\n      }\n      break;\n\n    default:\n      /* Unknown option. */\n      if (send_newstyle_option_reply (option, NBD_REP_ERR_UNSUP) == -1)\n        return -1;\n      if (conn_recv_full (data, optlen,\n                          \"reading unknown option data: conn->recv: %m\") == -1)\n        return -1;\n    }\n\n    /* Note, since it's not very clear from the protocol doc, that the\n     * client must send NBD_OPT_EXPORT_NAME or NBD_OPT_GO last, and\n     * that ends option negotiation.\n     */\n    if (option == NBD_OPT_EXPORT_NAME || option == NBD_OPT_GO)\n      break;\n  }\n\n  if (nr_options == 0) {\n    nbdkit_error (\"client spent too much time negotiating without selecting \"\n                  \"an export\");\n    return -1;\n  }\n\n  /* In --tls=require / FORCEDTLS mode, we must have upgraded to TLS\n   * by the time we finish option negotiation.  If not, give up.\n   */\n  if (tls == 2 && !conn->using_tls) {\n    nbdkit_error (\"non-TLS client tried to connect in --tls=require mode\");\n    return -1;\n  }\n\n  return 0;\n}", "func_hash": 230092713719482299459555478858076762309, "file_name": "protocol-handshake-newstyle.c", "file_hash": 263209595426945567952192628081217546469, "cwe": ["CWE-924"], "cve": "CVE-2021-3716", "cve_desc": "A flaw was found in nbdkit due to to improperly caching plaintext state across the STARTTLS encryption boundary. A MitM attacker could use this flaw to inject a plaintext NBD_OPT_STRUCTURED_REPLY before proxying everything else a client sends to the server, potentially leading the client to terminate the NBD session. The highest threat from this vulnerability is to system availability.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-3716", "file_path": "server/protocol-handshake-newstyle.c"}
{"idx": 384677, "project": "nbdkit", "commit_id": "6c5faac6a37077cf2366388a80862bb00616d0d8", "project_url": "https://github.com/libguestfs/nbdkit", "commit_url": "https://gitlab.com/nbdkit/nbdkit/-/commit/6c5faac6a37077cf2366388a80862bb00616d0d8", "commit_message": "server: reset meta context replies on starttls\n\nRelated to CVE-2021-3716, but not as severe.  No compliant client will\nsend NBD_CMD_BLOCK_STATUS unless it first negotiates\nNBD_OPT_SET_META_CONTEXT.  If an attacker injects a premature\nSET_META_CONTEXT, either the client will never notice (because it\nnever uses BLOCK_STATUS), or the client will overwrite the attacker's\nattempt with the client's own SET_META_CONTEXT request after\nencryption is enabled.  So I don't class this as having the potential\nto trigger denial-of-service due to any protocol mismatch between\ncompliant client and server (I don't care what happens with\nnon-compliant clients).\n\nFixes: 26455d45 (server: protocol: Implement Block Status \"base:allocation\".)", "target": 0, "func": "negotiate_handshake_newstyle_options (void)\n{\n  GET_CONN;\n  struct nbd_new_option new_option;\n  size_t nr_options;\n  bool list_seen = false;\n  uint64_t version;\n  uint32_t option;\n  uint32_t optlen;\n  struct nbd_export_name_option_reply handshake_finish;\n  const char *optname;\n  uint64_t exportsize;\n  struct backend *b;\n\n  for (nr_options = MAX_NR_OPTIONS; nr_options > 0; --nr_options) {\n    CLEANUP_FREE char *data = NULL;\n\n    if (conn_recv_full (&new_option, sizeof new_option,\n                        \"reading option: conn->recv: %m\") == -1)\n      return -1;\n\n    version = be64toh (new_option.version);\n    if (version != NBD_NEW_VERSION) {\n      nbdkit_error (\"unknown option version %\" PRIx64\n                    \", expecting %\" PRIx64,\n                    version, NBD_NEW_VERSION);\n      return -1;\n    }\n\n    /* There is a maximum option length we will accept, regardless\n     * of the option type.\n     */\n    optlen = be32toh (new_option.optlen);\n    if (optlen > MAX_REQUEST_SIZE) {\n      nbdkit_error (\"client option data too long (%\" PRIu32 \")\", optlen);\n      return -1;\n    }\n    data = malloc (optlen + 1); /* Allowing a trailing NUL helps some uses */\n    if (data == NULL) {\n      nbdkit_error (\"malloc: %m\");\n      return -1;\n    }\n\n    option = be32toh (new_option.option);\n    optname = name_of_nbd_opt (option);\n\n    /* If the client lacks fixed newstyle support, it should only send\n     * NBD_OPT_EXPORT_NAME.\n     */\n    if (!(conn->cflags & NBD_FLAG_FIXED_NEWSTYLE) &&\n        option != NBD_OPT_EXPORT_NAME) {\n      if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID))\n        return -1;\n      continue;\n    }\n\n    /* In --tls=require / FORCEDTLS mode the only options allowed\n     * before TLS negotiation are NBD_OPT_ABORT and NBD_OPT_STARTTLS.\n     */\n    if (tls == 2 && !conn->using_tls &&\n        !(option == NBD_OPT_ABORT || option == NBD_OPT_STARTTLS)) {\n      if (send_newstyle_option_reply (option, NBD_REP_ERR_TLS_REQD))\n        return -1;\n      continue;\n    }\n\n    switch (option) {\n    case NBD_OPT_EXPORT_NAME:\n      if (conn_recv_full (data, optlen,\n                          \"read: %s: %m\", name_of_nbd_opt (option)) == -1)\n        return -1;\n      if (check_export_name (option, data, optlen, optlen) == -1)\n        return -1;\n\n      /* We have to finish the handshake by sending handshake_finish.\n       * On failure, we have to disconnect.\n       */\n      if (finish_newstyle_options (&exportsize, data, optlen) == -1)\n        return -1;\n\n      memset (&handshake_finish, 0, sizeof handshake_finish);\n      handshake_finish.exportsize = htobe64 (exportsize);\n      handshake_finish.eflags = htobe16 (conn->eflags);\n\n      if (conn->send (&handshake_finish,\n                      (conn->cflags & NBD_FLAG_NO_ZEROES)\n                      ? offsetof (struct nbd_export_name_option_reply, zeroes)\n                      : sizeof handshake_finish, 0) == -1) {\n        nbdkit_error (\"write: %s: %m\", optname);\n        return -1;\n      }\n      break;\n\n    case NBD_OPT_ABORT:\n      if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)\n        return -1;\n      debug (\"client sent %s to abort the connection\",\n             name_of_nbd_opt (option));\n      return -1;\n\n    case NBD_OPT_LIST:\n      if (optlen != 0) {\n        if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)\n            == -1)\n          return -1;\n        if (conn_recv_full (data, optlen,\n                            \"read: %s: %m\", name_of_nbd_opt (option)) == -1)\n          return -1;\n        continue;\n      }\n\n      if (list_seen) {\n        debug (\"newstyle negotiation: %s: export list already advertised\",\n               name_of_nbd_opt (option));\n        if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID) == -1)\n          return -1;\n        continue;\n      }\n      else {\n        /* Send back the exportname list. */\n        debug (\"newstyle negotiation: %s: advertising exports\",\n               name_of_nbd_opt (option));\n        if (send_newstyle_option_reply_exportnames (option, &nr_options) == -1)\n          return -1;\n        list_seen = true;\n      }\n      break;\n\n    case NBD_OPT_STARTTLS:\n      if (optlen != 0) {\n        if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)\n            == -1)\n          return -1;\n        if (conn_recv_full (data, optlen,\n                            \"read: %s: %m\", name_of_nbd_opt (option)) == -1)\n          return -1;\n        continue;\n      }\n\n      if (tls == 0) {           /* --tls=off (NOTLS mode). */\n#ifdef HAVE_GNUTLS\n#define NO_TLS_REPLY NBD_REP_ERR_POLICY\n#else\n#define NO_TLS_REPLY NBD_REP_ERR_UNSUP\n#endif\n        if (send_newstyle_option_reply (option, NO_TLS_REPLY) == -1)\n          return -1;\n      }\n      else /* --tls=on or --tls=require */ {\n        /* We can't upgrade to TLS twice on the same connection. */\n        if (conn->using_tls) {\n          if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID) == -1)\n            return -1;\n          continue;\n        }\n\n        /* We have to send the (unencrypted) reply before starting\n         * the handshake.\n         */\n        if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)\n          return -1;\n\n        /* Upgrade the connection to TLS.  Also performs access control. */\n        if (crypto_negotiate_tls (conn->sockin, conn->sockout) == -1)\n          return -1;\n        conn->using_tls = true;\n        debug (\"using TLS on this connection\");\n        /* Wipe out any cached state. */\n        conn->structured_replies = false;\n        free (conn->exportname_from_set_meta_context);\n        conn->exportname_from_set_meta_context = NULL;\n        conn->meta_context_base_allocation = false;\n        for_each_backend (b) {\n          free (conn->default_exportname[b->i]);\n          conn->default_exportname[b->i] = NULL;\n        }\n      }\n      break;\n\n    case NBD_OPT_INFO:\n    case NBD_OPT_GO:\n      if (conn_recv_full (data, optlen, \"read: %s: %m\", optname) == -1)\n        return -1;\n\n      if (optlen < 6) { /* 32 bit export length + 16 bit nr info */\n        debug (\"newstyle negotiation: %s option length < 6\", optname);\n\n        if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)\n            == -1)\n          return -1;\n        continue;\n      }\n\n      {\n        uint32_t exportnamelen;\n        uint16_t nrinfos;\n        uint16_t info;\n        size_t i;\n\n        /* Validate the name length and number of INFO requests. */\n        memcpy (&exportnamelen, &data[0], 4);\n        exportnamelen = be32toh (exportnamelen);\n        if (exportnamelen > optlen-6 /* NB optlen >= 6, see above */) {\n          debug (\"newstyle negotiation: %s: export name too long\", optname);\n          if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)\n              == -1)\n            return -1;\n          continue;\n        }\n        memcpy (&nrinfos, &data[exportnamelen+4], 2);\n        nrinfos = be16toh (nrinfos);\n        if (optlen != 4 + exportnamelen + 2 + 2*nrinfos) {\n          debug (\"newstyle negotiation: %s: \"\n                 \"number of information requests incorrect\", optname);\n          if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)\n              == -1)\n            return -1;\n          continue;\n        }\n\n        /* As with NBD_OPT_EXPORT_NAME we print the export name and\n         * save it in the connection.  If an earlier\n         * NBD_OPT_SET_META_CONTEXT used an export name, it must match\n         * or else we drop the support for that context.\n         */\n        if (check_export_name (option, &data[4], exportnamelen,\n                               optlen - 6) == -1) {\n          if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)\n              == -1)\n            return -1;\n          continue;\n        }\n\n        /* The spec is confusing, but it is required that we send back\n         * NBD_INFO_EXPORT, even if the client did not request it!\n         * qemu client in particular does not request this, but will\n         * fail if we don't send it.  Note that if .open fails, but we\n         * succeed at .close, then we merely return an error to the\n         * client and let them try another NBD_OPT, rather than\n         * disconnecting.\n         */\n        if (finish_newstyle_options (&exportsize,\n                                     &data[4], exportnamelen) == -1) {\n          if (conn->top_context) {\n            if (backend_finalize (conn->top_context) == -1)\n              return -1;\n            backend_close (conn->top_context);\n            conn->top_context = NULL;\n          }\n          if (send_newstyle_option_reply (option, NBD_REP_ERR_UNKNOWN) == -1)\n            return -1;\n          continue;\n        }\n\n        if (send_newstyle_option_reply_info_export (option,\n                                                    NBD_REP_INFO,\n                                                    NBD_INFO_EXPORT,\n                                                    exportsize) == -1)\n          return -1;\n\n        /* For now we send NBD_INFO_NAME and NBD_INFO_DESCRIPTION if\n         * requested, and ignore all other info requests (including\n         * NBD_INFO_EXPORT if it was requested, because we replied\n         * already above).\n         */\n        for (i = 0; i < nrinfos; ++i) {\n          memcpy (&info, &data[4 + exportnamelen + 2 + i*2], 2);\n          info = be16toh (info);\n          switch (info) {\n          case NBD_INFO_EXPORT: /* ignore - reply sent above */ break;\n          case NBD_INFO_NAME:\n            {\n              const char *name = &data[4];\n              size_t namelen = exportnamelen;\n\n              if (exportnamelen == 0) {\n                name = backend_default_export (top, read_only);\n                if (!name) {\n                  debug (\"newstyle negotiation: %s: \"\n                         \"NBD_INFO_NAME: no name to send\", optname);\n                  break;\n                }\n                namelen = -1;\n              }\n              if (send_newstyle_option_reply_info_str (option,\n                                                       NBD_REP_INFO,\n                                                       NBD_INFO_NAME,\n                                                       name, namelen) == -1)\n                return -1;\n            }\n            break;\n          case NBD_INFO_DESCRIPTION:\n            {\n              const char *desc = backend_export_description (conn->top_context);\n\n              if (!desc) {\n                debug (\"newstyle negotiation: %s: \"\n                       \"NBD_INFO_DESCRIPTION: no description to send\",\n                       optname);\n                break;\n              }\n              if (send_newstyle_option_reply_info_str (option,\n                                                       NBD_REP_INFO,\n                                                       NBD_INFO_DESCRIPTION,\n                                                       desc, -1) == -1)\n                return -1;\n            }\n            break;\n          default:\n            debug (\"newstyle negotiation: %s: \"\n                   \"ignoring NBD_INFO_* request %u (%s)\",\n                   optname, (unsigned) info, name_of_nbd_info (info));\n            break;\n          }\n        }\n      }\n\n      /* Unlike NBD_OPT_EXPORT_NAME, NBD_OPT_GO sends back an ACK\n       * or ERROR packet.  If this was NBD_OPT_LIST, call .close.\n       */\n      if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)\n        return -1;\n\n      if (option == NBD_OPT_INFO) {\n        if (backend_finalize (conn->top_context) == -1)\n          return -1;\n        backend_close (conn->top_context);\n        conn->top_context = NULL;\n      }\n\n      break;\n\n    case NBD_OPT_STRUCTURED_REPLY:\n      if (optlen != 0) {\n        if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)\n            == -1)\n          return -1;\n        if (conn_recv_full (data, optlen,\n                            \"read: %s: %m\", name_of_nbd_opt (option)) == -1)\n          return -1;\n        continue;\n      }\n\n      debug (\"newstyle negotiation: %s: client requested structured replies\",\n             name_of_nbd_opt (option));\n\n      if (no_sr) {\n        /* Must fail with ERR_UNSUP for qemu 4.2 to remain happy;\n         * but failing with ERR_POLICY would have been nicer.\n         */\n        if (send_newstyle_option_reply (option, NBD_REP_ERR_UNSUP) == -1)\n          return -1;\n        debug (\"newstyle negotiation: %s: structured replies are disabled\",\n               name_of_nbd_opt (option));\n        break;\n      }\n\n      if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)\n        return -1;\n\n      conn->structured_replies = true;\n      break;\n\n    case NBD_OPT_LIST_META_CONTEXT:\n    case NBD_OPT_SET_META_CONTEXT:\n      {\n        uint32_t opt_index;\n        uint32_t exportnamelen;\n        uint32_t nr_queries;\n        uint32_t querylen;\n        const char *what;\n\n        if (conn_recv_full (data, optlen, \"read: %s: %m\", optname) == -1)\n          return -1;\n\n        /* Note that we support base:allocation whether or not the plugin\n         * supports can_extents.\n         */\n        if (!conn->structured_replies) {\n          if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)\n              == -1)\n            return -1;\n          continue;\n        }\n\n        /* Minimum length of the option payload is:\n         *   32 bit export name length followed by empty export name\n         * + 32 bit number of queries followed by no queries\n         * = 8 bytes.\n         */\n        what = \"optlen < 8\";\n        if (optlen < 8) {\n        opt_meta_invalid_option_len:\n          debug (\"newstyle negotiation: %s: invalid option length: %s\",\n                 optname, what);\n\n          if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)\n              == -1)\n            return -1;\n          continue;\n        }\n\n        memcpy (&exportnamelen, &data[0], 4);\n        exportnamelen = be32toh (exportnamelen);\n        what = \"validating export name\";\n        if (check_export_name (option, &data[4], exportnamelen,\n                               optlen - 8) == -1)\n          goto opt_meta_invalid_option_len;\n\n        /* Remember the export name: the NBD spec says that if the client\n         * later uses NBD_OPT_GO on a different export, then the context\n         * returned here is not usable.\n         */\n        if (option == NBD_OPT_SET_META_CONTEXT) {\n          conn->exportname_from_set_meta_context =\n            strndup (&data[4], exportnamelen);\n          if (conn->exportname_from_set_meta_context == NULL) {\n            nbdkit_error (\"malloc: %m\");\n            return -1;\n          }\n        }\n\n        opt_index = 4 + exportnamelen;\n\n        /* Read the number of queries. */\n        what = \"reading number of queries\";\n        if (opt_index+4 > optlen)\n          goto opt_meta_invalid_option_len;\n        memcpy (&nr_queries, &data[opt_index], 4);\n        nr_queries = be32toh (nr_queries);\n        opt_index += 4;\n\n        /* for LIST: nr_queries == 0 means return all meta contexts\n         * for SET: nr_queries == 0 means reset all contexts\n         */\n        debug (\"newstyle negotiation: %s: %s count: %d\", optname,\n               option == NBD_OPT_LIST_META_CONTEXT ? \"query\" : \"set\",\n               nr_queries);\n        if (option == NBD_OPT_SET_META_CONTEXT)\n          conn->meta_context_base_allocation = false;\n        if (nr_queries == 0) {\n          if (option == NBD_OPT_LIST_META_CONTEXT) {\n            if (send_newstyle_option_reply_meta_context (option,\n                                                         NBD_REP_META_CONTEXT,\n                                                         0, \"base:allocation\")\n                == -1)\n              return -1;\n          }\n\n          if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)\n            return -1;\n        }\n        else {\n          /* Read and answer each query. */\n          while (nr_queries > 0) {\n            what = \"reading query string length\";\n            if (opt_index+4 > optlen)\n              goto opt_meta_invalid_option_len;\n            memcpy (&querylen, &data[opt_index], 4);\n            querylen = be32toh (querylen);\n            opt_index += 4;\n            what = \"reading query string\";\n            if (check_string (option, &data[opt_index], querylen,\n                              optlen - opt_index, \"meta context query\") == -1)\n              goto opt_meta_invalid_option_len;\n\n            debug (\"newstyle negotiation: %s: %s %.*s\",\n                   optname,\n                   option == NBD_OPT_LIST_META_CONTEXT ? \"query\" : \"set\",\n                   (int) querylen, &data[opt_index]);\n\n            /* For LIST, \"base:\" returns all supported contexts in the\n             * base namespace.  We only support \"base:allocation\".\n             */\n            if (option == NBD_OPT_LIST_META_CONTEXT &&\n                querylen == 5 &&\n                strncmp (&data[opt_index], \"base:\", 5) == 0) {\n              if (send_newstyle_option_reply_meta_context\n                  (option, NBD_REP_META_CONTEXT,\n                   0, \"base:allocation\") == -1)\n                return -1;\n            }\n            /* \"base:allocation\" requested by name. */\n            else if (querylen == 15 &&\n                     strncmp (&data[opt_index], \"base:allocation\", 15) == 0) {\n              if (send_newstyle_option_reply_meta_context\n                  (option, NBD_REP_META_CONTEXT,\n                   option == NBD_OPT_SET_META_CONTEXT\n                   ? base_allocation_id : 0,\n                   \"base:allocation\") == -1)\n                return -1;\n              if (option == NBD_OPT_SET_META_CONTEXT)\n                conn->meta_context_base_allocation = true;\n            }\n            /* Every other query must be ignored. */\n\n            opt_index += querylen;\n            nr_queries--;\n          }\n          if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)\n            return -1;\n        }\n        debug (\"newstyle negotiation: %s: reply complete\", optname);\n      }\n      break;\n\n    default:\n      /* Unknown option. */\n      if (send_newstyle_option_reply (option, NBD_REP_ERR_UNSUP) == -1)\n        return -1;\n      if (conn_recv_full (data, optlen,\n                          \"reading unknown option data: conn->recv: %m\") == -1)\n        return -1;\n    }\n\n    /* Note, since it's not very clear from the protocol doc, that the\n     * client must send NBD_OPT_EXPORT_NAME or NBD_OPT_GO last, and\n     * that ends option negotiation.\n     */\n    if (option == NBD_OPT_EXPORT_NAME || option == NBD_OPT_GO)\n      break;\n  }\n\n  if (nr_options == 0) {\n    nbdkit_error (\"client spent too much time negotiating without selecting \"\n                  \"an export\");\n    return -1;\n  }\n\n  /* In --tls=require / FORCEDTLS mode, we must have upgraded to TLS\n   * by the time we finish option negotiation.  If not, give up.\n   */\n  if (tls == 2 && !conn->using_tls) {\n    nbdkit_error (\"non-TLS client tried to connect in --tls=require mode\");\n    return -1;\n  }\n\n  return 0;\n}", "func_hash": 13793654971535202622888110493636437287, "file_name": "protocol-handshake-newstyle.c", "file_hash": 210643238405506282504328455056206224474, "cwe": ["CWE-924"], "cve": "CVE-2021-3716", "cve_desc": "A flaw was found in nbdkit due to to improperly caching plaintext state across the STARTTLS encryption boundary. A MitM attacker could use this flaw to inject a plaintext NBD_OPT_STRUCTURED_REPLY before proxying everything else a client sends to the server, potentially leading the client to terminate the NBD session. The highest threat from this vulnerability is to system availability.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-3716", "file_path": "server/protocol-handshake-newstyle.c"}
{"idx": 206676, "project": "vim", "commit_id": "777e7c21b7627be80961848ac560cb0a9978ff43", "project_url": "https://github.com/vim/vim", "commit_url": "https://github.com/vim/vim/commit/777e7c21b7627be80961848ac560cb0a9978ff43", "commit_message": "patch 8.2.3564: invalid memory access when scrolling without valid screen\n\nProblem:    Invalid memory access when scrolling without a valid screen.\nSolution:   Do not set VALID_BOTLINE in w_valid.", "target": 1, "func": "update_topline(void)\n{\n    long\tline_count;\n    int\t\thalfheight;\n    int\t\tn;\n    linenr_T\told_topline;\n#ifdef FEAT_DIFF\n    int\t\told_topfill;\n#endif\n#ifdef FEAT_FOLDING\n    linenr_T\tlnum;\n#endif\n    int\t\tcheck_topline = FALSE;\n    int\t\tcheck_botline = FALSE;\n    long        *so_ptr = curwin->w_p_so >= 0 ? &curwin->w_p_so : &p_so;\n    int\t\tsave_so = *so_ptr;\n\n    // If there is no valid screen and when the window height is zero just use\n    // the cursor line.\n    if (!screen_valid(TRUE) || curwin->w_height == 0)\n    {\n\tcheck_cursor_lnum();\n\tcurwin->w_topline = curwin->w_cursor.lnum;\n\tcurwin->w_botline = curwin->w_topline;\n\tcurwin->w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP;\n\tcurwin->w_scbind_pos = 1;\n\treturn;\n    }\n\n    check_cursor_moved(curwin);\n    if (curwin->w_valid & VALID_TOPLINE)\n\treturn;\n\n    // When dragging with the mouse, don't scroll that quickly\n    if (mouse_dragging > 0)\n\t*so_ptr = mouse_dragging - 1;\n\n    old_topline = curwin->w_topline;\n#ifdef FEAT_DIFF\n    old_topfill = curwin->w_topfill;\n#endif\n\n    /*\n     * If the buffer is empty, always set topline to 1.\n     */\n    if (BUFEMPTY())\t\t// special case - file is empty\n    {\n\tif (curwin->w_topline != 1)\n\t    redraw_later(NOT_VALID);\n\tcurwin->w_topline = 1;\n\tcurwin->w_botline = 2;\n\tcurwin->w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP;\n\tcurwin->w_scbind_pos = 1;\n    }\n\n    /*\n     * If the cursor is above or near the top of the window, scroll the window\n     * to show the line the cursor is in, with 'scrolloff' context.\n     */\n    else\n    {\n\tif (curwin->w_topline > 1)\n\t{\n\t    // If the cursor is above topline, scrolling is always needed.\n\t    // If the cursor is far below topline and there is no folding,\n\t    // scrolling down is never needed.\n\t    if (curwin->w_cursor.lnum < curwin->w_topline)\n\t\tcheck_topline = TRUE;\n\t    else if (check_top_offset())\n\t\tcheck_topline = TRUE;\n\t}\n#ifdef FEAT_DIFF\n\t    // Check if there are more filler lines than allowed.\n\tif (!check_topline && curwin->w_topfill > diff_check_fill(curwin,\n\t\t\t\t\t\t\t   curwin->w_topline))\n\t    check_topline = TRUE;\n#endif\n\n\tif (check_topline)\n\t{\n\t    halfheight = curwin->w_height / 2 - 1;\n\t    if (halfheight < 2)\n\t\thalfheight = 2;\n\n#ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t    {\n\t\t// Count the number of logical lines between the cursor and\n\t\t// topline + scrolloff (approximation of how much will be\n\t\t// scrolled).\n\t\tn = 0;\n\t\tfor (lnum = curwin->w_cursor.lnum;\n\t\t\t\t    lnum < curwin->w_topline + *so_ptr; ++lnum)\n\t\t{\n\t\t    ++n;\n\t\t    // stop at end of file or when we know we are far off\n\t\t    if (lnum >= curbuf->b_ml.ml_line_count || n >= halfheight)\n\t\t\tbreak;\n\t\t    (void)hasFolding(lnum, NULL, &lnum);\n\t\t}\n\t    }\n\t    else\n#endif\n\t\tn = curwin->w_topline + *so_ptr - curwin->w_cursor.lnum;\n\n\t    // If we weren't very close to begin with, we scroll to put the\n\t    // cursor in the middle of the window.  Otherwise put the cursor\n\t    // near the top of the window.\n\t    if (n >= halfheight)\n\t\tscroll_cursor_halfway(FALSE);\n\t    else\n\t    {\n\t\tscroll_cursor_top(scrolljump_value(), FALSE);\n\t\tcheck_botline = TRUE;\n\t    }\n\t}\n\n\telse\n\t{\n#ifdef FEAT_FOLDING\n\t    // Make sure topline is the first line of a fold.\n\t    (void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n\t    check_botline = TRUE;\n\t}\n    }\n\n    /*\n     * If the cursor is below the bottom of the window, scroll the window\n     * to put the cursor on the window.\n     * When w_botline is invalid, recompute it first, to avoid a redraw later.\n     * If w_botline was approximated, we might need a redraw later in a few\n     * cases, but we don't want to spend (a lot of) time recomputing w_botline\n     * for every small change.\n     */\n    if (check_botline)\n    {\n\tif (!(curwin->w_valid & VALID_BOTLINE_AP))\n\t    validate_botline();\n\n\tif (curwin->w_botline <= curbuf->b_ml.ml_line_count)\n\t{\n\t    if (curwin->w_cursor.lnum < curwin->w_botline)\n\t    {\n\t      if (((long)curwin->w_cursor.lnum\n\t\t\t\t\t     >= (long)curwin->w_botline - *so_ptr\n#ifdef FEAT_FOLDING\n\t\t\t|| hasAnyFolding(curwin)\n#endif\n\t\t\t))\n\t      {\n\t\tlineoff_T\tloff;\n\n\t\t// Cursor is (a few lines) above botline, check if there are\n\t\t// 'scrolloff' window lines below the cursor.  If not, need to\n\t\t// scroll.\n\t\tn = curwin->w_empty_rows;\n\t\tloff.lnum = curwin->w_cursor.lnum;\n#ifdef FEAT_FOLDING\n\t\t// In a fold go to its last line.\n\t\t(void)hasFolding(loff.lnum, NULL, &loff.lnum);\n#endif\n#ifdef FEAT_DIFF\n\t\tloff.fill = 0;\n\t\tn += curwin->w_filler_rows;\n#endif\n\t\tloff.height = 0;\n\t\twhile (loff.lnum < curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t\t&& (loff.lnum + 1 < curwin->w_botline || loff.fill == 0)\n#endif\n\t\t\t)\n\t\t{\n\t\t    n += loff.height;\n\t\t    if (n >= *so_ptr)\n\t\t\tbreak;\n\t\t    botline_forw(&loff);\n\t\t}\n\t\tif (n >= *so_ptr)\n\t\t    // sufficient context, no need to scroll\n\t\t    check_botline = FALSE;\n\t      }\n\t      else\n\t\t  // sufficient context, no need to scroll\n\t\t  check_botline = FALSE;\n\t    }\n\t    if (check_botline)\n\t    {\n#ifdef FEAT_FOLDING\n\t\tif (hasAnyFolding(curwin))\n\t\t{\n\t\t    // Count the number of logical lines between the cursor and\n\t\t    // botline - scrolloff (approximation of how much will be\n\t\t    // scrolled).\n\t\t    line_count = 0;\n\t\t    for (lnum = curwin->w_cursor.lnum;\n\t\t\t\t   lnum >= curwin->w_botline - *so_ptr; --lnum)\n\t\t    {\n\t\t\t++line_count;\n\t\t\t// stop at end of file or when we know we are far off\n\t\t\tif (lnum <= 0 || line_count > curwin->w_height + 1)\n\t\t\t    break;\n\t\t\t(void)hasFolding(lnum, &lnum, NULL);\n\t\t    }\n\t\t}\n\t\telse\n#endif\n\t\t    line_count = curwin->w_cursor.lnum - curwin->w_botline\n\t\t\t\t\t\t\t\t   + 1 + *so_ptr;\n\t\tif (line_count <= curwin->w_height + 1)\n\t\t    scroll_cursor_bot(scrolljump_value(), FALSE);\n\t\telse\n\t\t    scroll_cursor_halfway(FALSE);\n\t    }\n\t}\n    }\n    curwin->w_valid |= VALID_TOPLINE;\n\n    /*\n     * Need to redraw when topline changed.\n     */\n    if (curwin->w_topline != old_topline\n#ifdef FEAT_DIFF\n\t    || curwin->w_topfill != old_topfill\n#endif\n\t    )\n    {\n\tdollar_vcol = -1;\n\tif (curwin->w_skipcol != 0)\n\t{\n\t    curwin->w_skipcol = 0;\n\t    redraw_later(NOT_VALID);\n\t}\n\telse\n\t    redraw_later(VALID);\n\t// May need to set w_skipcol when cursor in w_topline.\n\tif (curwin->w_cursor.lnum == curwin->w_topline)\n\t    validate_cursor();\n    }\n\n    *so_ptr = save_so;\n}", "func_hash": 228543629723963000813717359055705778977, "file_name": "move.c", "file_hash": 235877722919937919149866597040080656666, "cwe": ["CWE-122"], "cve": "CVE-2021-3903", "cve_desc": "vim is vulnerable to Heap-based Buffer Overflow", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-3903", "file_path": "src/move.c"}
{"idx": 384767, "project": "vim", "commit_id": "777e7c21b7627be80961848ac560cb0a9978ff43", "project_url": "https://github.com/vim/vim", "commit_url": "https://github.com/vim/vim/commit/777e7c21b7627be80961848ac560cb0a9978ff43", "commit_message": "patch 8.2.3564: invalid memory access when scrolling without valid screen\n\nProblem:    Invalid memory access when scrolling without a valid screen.\nSolution:   Do not set VALID_BOTLINE in w_valid.", "target": 0, "func": "update_topline(void)\n{\n    long\tline_count;\n    int\t\thalfheight;\n    int\t\tn;\n    linenr_T\told_topline;\n#ifdef FEAT_DIFF\n    int\t\told_topfill;\n#endif\n#ifdef FEAT_FOLDING\n    linenr_T\tlnum;\n#endif\n    int\t\tcheck_topline = FALSE;\n    int\t\tcheck_botline = FALSE;\n    long        *so_ptr = curwin->w_p_so >= 0 ? &curwin->w_p_so : &p_so;\n    int\t\tsave_so = *so_ptr;\n\n    // If there is no valid screen and when the window height is zero just use\n    // the cursor line.\n    if (!screen_valid(TRUE) || curwin->w_height == 0)\n    {\n\tcheck_cursor_lnum();\n\tcurwin->w_topline = curwin->w_cursor.lnum;\n\tcurwin->w_botline = curwin->w_topline;\n\tcurwin->w_scbind_pos = 1;\n\treturn;\n    }\n\n    check_cursor_moved(curwin);\n    if (curwin->w_valid & VALID_TOPLINE)\n\treturn;\n\n    // When dragging with the mouse, don't scroll that quickly\n    if (mouse_dragging > 0)\n\t*so_ptr = mouse_dragging - 1;\n\n    old_topline = curwin->w_topline;\n#ifdef FEAT_DIFF\n    old_topfill = curwin->w_topfill;\n#endif\n\n    /*\n     * If the buffer is empty, always set topline to 1.\n     */\n    if (BUFEMPTY())\t\t// special case - file is empty\n    {\n\tif (curwin->w_topline != 1)\n\t    redraw_later(NOT_VALID);\n\tcurwin->w_topline = 1;\n\tcurwin->w_botline = 2;\n\tcurwin->w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP;\n\tcurwin->w_scbind_pos = 1;\n    }\n\n    /*\n     * If the cursor is above or near the top of the window, scroll the window\n     * to show the line the cursor is in, with 'scrolloff' context.\n     */\n    else\n    {\n\tif (curwin->w_topline > 1)\n\t{\n\t    // If the cursor is above topline, scrolling is always needed.\n\t    // If the cursor is far below topline and there is no folding,\n\t    // scrolling down is never needed.\n\t    if (curwin->w_cursor.lnum < curwin->w_topline)\n\t\tcheck_topline = TRUE;\n\t    else if (check_top_offset())\n\t\tcheck_topline = TRUE;\n\t}\n#ifdef FEAT_DIFF\n\t    // Check if there are more filler lines than allowed.\n\tif (!check_topline && curwin->w_topfill > diff_check_fill(curwin,\n\t\t\t\t\t\t\t   curwin->w_topline))\n\t    check_topline = TRUE;\n#endif\n\n\tif (check_topline)\n\t{\n\t    halfheight = curwin->w_height / 2 - 1;\n\t    if (halfheight < 2)\n\t\thalfheight = 2;\n\n#ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t    {\n\t\t// Count the number of logical lines between the cursor and\n\t\t// topline + scrolloff (approximation of how much will be\n\t\t// scrolled).\n\t\tn = 0;\n\t\tfor (lnum = curwin->w_cursor.lnum;\n\t\t\t\t    lnum < curwin->w_topline + *so_ptr; ++lnum)\n\t\t{\n\t\t    ++n;\n\t\t    // stop at end of file or when we know we are far off\n\t\t    if (lnum >= curbuf->b_ml.ml_line_count || n >= halfheight)\n\t\t\tbreak;\n\t\t    (void)hasFolding(lnum, NULL, &lnum);\n\t\t}\n\t    }\n\t    else\n#endif\n\t\tn = curwin->w_topline + *so_ptr - curwin->w_cursor.lnum;\n\n\t    // If we weren't very close to begin with, we scroll to put the\n\t    // cursor in the middle of the window.  Otherwise put the cursor\n\t    // near the top of the window.\n\t    if (n >= halfheight)\n\t\tscroll_cursor_halfway(FALSE);\n\t    else\n\t    {\n\t\tscroll_cursor_top(scrolljump_value(), FALSE);\n\t\tcheck_botline = TRUE;\n\t    }\n\t}\n\n\telse\n\t{\n#ifdef FEAT_FOLDING\n\t    // Make sure topline is the first line of a fold.\n\t    (void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n\t    check_botline = TRUE;\n\t}\n    }\n\n    /*\n     * If the cursor is below the bottom of the window, scroll the window\n     * to put the cursor on the window.\n     * When w_botline is invalid, recompute it first, to avoid a redraw later.\n     * If w_botline was approximated, we might need a redraw later in a few\n     * cases, but we don't want to spend (a lot of) time recomputing w_botline\n     * for every small change.\n     */\n    if (check_botline)\n    {\n\tif (!(curwin->w_valid & VALID_BOTLINE_AP))\n\t    validate_botline();\n\n\tif (curwin->w_botline <= curbuf->b_ml.ml_line_count)\n\t{\n\t    if (curwin->w_cursor.lnum < curwin->w_botline)\n\t    {\n\t      if (((long)curwin->w_cursor.lnum\n\t\t\t\t\t     >= (long)curwin->w_botline - *so_ptr\n#ifdef FEAT_FOLDING\n\t\t\t|| hasAnyFolding(curwin)\n#endif\n\t\t\t))\n\t      {\n\t\tlineoff_T\tloff;\n\n\t\t// Cursor is (a few lines) above botline, check if there are\n\t\t// 'scrolloff' window lines below the cursor.  If not, need to\n\t\t// scroll.\n\t\tn = curwin->w_empty_rows;\n\t\tloff.lnum = curwin->w_cursor.lnum;\n#ifdef FEAT_FOLDING\n\t\t// In a fold go to its last line.\n\t\t(void)hasFolding(loff.lnum, NULL, &loff.lnum);\n#endif\n#ifdef FEAT_DIFF\n\t\tloff.fill = 0;\n\t\tn += curwin->w_filler_rows;\n#endif\n\t\tloff.height = 0;\n\t\twhile (loff.lnum < curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t\t&& (loff.lnum + 1 < curwin->w_botline || loff.fill == 0)\n#endif\n\t\t\t)\n\t\t{\n\t\t    n += loff.height;\n\t\t    if (n >= *so_ptr)\n\t\t\tbreak;\n\t\t    botline_forw(&loff);\n\t\t}\n\t\tif (n >= *so_ptr)\n\t\t    // sufficient context, no need to scroll\n\t\t    check_botline = FALSE;\n\t      }\n\t      else\n\t\t  // sufficient context, no need to scroll\n\t\t  check_botline = FALSE;\n\t    }\n\t    if (check_botline)\n\t    {\n#ifdef FEAT_FOLDING\n\t\tif (hasAnyFolding(curwin))\n\t\t{\n\t\t    // Count the number of logical lines between the cursor and\n\t\t    // botline - scrolloff (approximation of how much will be\n\t\t    // scrolled).\n\t\t    line_count = 0;\n\t\t    for (lnum = curwin->w_cursor.lnum;\n\t\t\t\t   lnum >= curwin->w_botline - *so_ptr; --lnum)\n\t\t    {\n\t\t\t++line_count;\n\t\t\t// stop at end of file or when we know we are far off\n\t\t\tif (lnum <= 0 || line_count > curwin->w_height + 1)\n\t\t\t    break;\n\t\t\t(void)hasFolding(lnum, &lnum, NULL);\n\t\t    }\n\t\t}\n\t\telse\n#endif\n\t\t    line_count = curwin->w_cursor.lnum - curwin->w_botline\n\t\t\t\t\t\t\t\t   + 1 + *so_ptr;\n\t\tif (line_count <= curwin->w_height + 1)\n\t\t    scroll_cursor_bot(scrolljump_value(), FALSE);\n\t\telse\n\t\t    scroll_cursor_halfway(FALSE);\n\t    }\n\t}\n    }\n    curwin->w_valid |= VALID_TOPLINE;\n\n    /*\n     * Need to redraw when topline changed.\n     */\n    if (curwin->w_topline != old_topline\n#ifdef FEAT_DIFF\n\t    || curwin->w_topfill != old_topfill\n#endif\n\t    )\n    {\n\tdollar_vcol = -1;\n\tif (curwin->w_skipcol != 0)\n\t{\n\t    curwin->w_skipcol = 0;\n\t    redraw_later(NOT_VALID);\n\t}\n\telse\n\t    redraw_later(VALID);\n\t// May need to set w_skipcol when cursor in w_topline.\n\tif (curwin->w_cursor.lnum == curwin->w_topline)\n\t    validate_cursor();\n    }\n\n    *so_ptr = save_so;\n}", "func_hash": 318695242827135485367008238388311307871, "file_name": "move.c", "file_hash": 216110417083492209479100354226379064539, "cwe": ["CWE-122"], "cve": "CVE-2021-3903", "cve_desc": "vim is vulnerable to Heap-based Buffer Overflow", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-3903", "file_path": "src/move.c"}
{"idx": 206677, "project": "vim", "commit_id": "5921aeb5741fc6e84c870d68c7c35b93ad0c9f87", "project_url": "https://github.com/vim/vim", "commit_url": "https://github.com/vim/vim/commit/5921aeb5741fc6e84c870d68c7c35b93ad0c9f87", "commit_message": "patch 8.2.4418: crash when using special multi-byte character\n\nProblem:    Crash when using special multi-byte character.\nSolution:   Don't use isalpha() for an arbitrary character.", "target": 1, "func": "unix_expandpath(\n    garray_T\t*gap,\n    char_u\t*path,\n    int\t\twildoff,\n    int\t\tflags,\t\t// EW_* flags\n    int\t\tdidstar)\t// expanded \"**\" once already\n{\n    char_u\t*buf;\n    char_u\t*path_end;\n    char_u\t*p, *s, *e;\n    int\t\tstart_len = gap->ga_len;\n    char_u\t*pat;\n    regmatch_T\tregmatch;\n    int\t\tstarts_with_dot;\n    int\t\tmatches;\n    int\t\tlen;\n    int\t\tstarstar = FALSE;\n    static int\tstardepth = 0;\t    // depth for \"**\" expansion\n\n    DIR\t\t*dirp;\n    struct dirent *dp;\n\n    // Expanding \"**\" may take a long time, check for CTRL-C.\n    if (stardepth > 0)\n    {\n\tui_breakcheck();\n\tif (got_int)\n\t    return 0;\n    }\n\n    // make room for file name\n    buf = alloc(STRLEN(path) + BASENAMELEN + 5);\n    if (buf == NULL)\n\treturn 0;\n\n    /*\n     * Find the first part in the path name that contains a wildcard.\n     * When EW_ICASE is set every letter is considered to be a wildcard.\n     * Copy it into \"buf\", including the preceding characters.\n     */\n    p = buf;\n    s = buf;\n    e = NULL;\n    path_end = path;\n    while (*path_end != NUL)\n    {\n\t// May ignore a wildcard that has a backslash before it; it will\n\t// be removed by rem_backslash() or file_pat_to_reg_pat() below.\n\tif (path_end >= path + wildoff && rem_backslash(path_end))\n\t    *p++ = *path_end++;\n\telse if (*path_end == '/')\n\t{\n\t    if (e != NULL)\n\t\tbreak;\n\t    s = p + 1;\n\t}\n\telse if (path_end >= path + wildoff\n\t\t\t && (vim_strchr((char_u *)\"*?[{~$\", *path_end) != NULL\n\t\t\t     || (!p_fic && (flags & EW_ICASE)\n\t\t\t\t\t     && isalpha(PTR2CHAR(path_end)))))\n\t    e = p;\n\tif (has_mbyte)\n\t{\n\t    len = (*mb_ptr2len)(path_end);\n\t    STRNCPY(p, path_end, len);\n\t    p += len;\n\t    path_end += len;\n\t}\n\telse\n\t    *p++ = *path_end++;\n    }\n    e = p;\n    *e = NUL;\n\n    // Now we have one wildcard component between \"s\" and \"e\".\n    // Remove backslashes between \"wildoff\" and the start of the wildcard\n    // component.\n    for (p = buf + wildoff; p < s; ++p)\n\tif (rem_backslash(p))\n\t{\n\t    STRMOVE(p, p + 1);\n\t    --e;\n\t    --s;\n\t}\n\n    // Check for \"**\" between \"s\" and \"e\".\n    for (p = s; p < e; ++p)\n\tif (p[0] == '*' && p[1] == '*')\n\t    starstar = TRUE;\n\n    // convert the file pattern to a regexp pattern\n    starts_with_dot = *s == '.';\n    pat = file_pat_to_reg_pat(s, e, NULL, FALSE);\n    if (pat == NULL)\n    {\n\tvim_free(buf);\n\treturn 0;\n    }\n\n    // compile the regexp into a program\n    if (flags & EW_ICASE)\n\tregmatch.rm_ic = TRUE;\t\t// 'wildignorecase' set\n    else\n\tregmatch.rm_ic = p_fic;\t// ignore case when 'fileignorecase' is set\n    if (flags & (EW_NOERROR | EW_NOTWILD))\n\t++emsg_silent;\n    regmatch.regprog = vim_regcomp(pat, RE_MAGIC);\n    if (flags & (EW_NOERROR | EW_NOTWILD))\n\t--emsg_silent;\n    vim_free(pat);\n\n    if (regmatch.regprog == NULL && (flags & EW_NOTWILD) == 0)\n    {\n\tvim_free(buf);\n\treturn 0;\n    }\n\n    // If \"**\" is by itself, this is the first time we encounter it and more\n    // is following then find matches without any directory.\n    if (!didstar && stardepth < 100 && starstar && e - s == 2\n\t\t\t\t\t\t\t  && *path_end == '/')\n    {\n\tSTRCPY(s, path_end + 1);\n\t++stardepth;\n\t(void)unix_expandpath(gap, buf, (int)(s - buf), flags, TRUE);\n\t--stardepth;\n    }\n\n    // open the directory for scanning\n    *s = NUL;\n    dirp = opendir(*buf == NUL ? \".\" : (char *)buf);\n\n    // Find all matching entries\n    if (dirp != NULL)\n    {\n\tfor (;;)\n\t{\n\t    dp = readdir(dirp);\n\t    if (dp == NULL)\n\t\tbreak;\n\t    if ((dp->d_name[0] != '.' || starts_with_dot\n\t\t\t|| ((flags & EW_DODOT)\n\t\t\t    && dp->d_name[1] != NUL\n\t\t\t    && (dp->d_name[1] != '.' || dp->d_name[2] != NUL)))\n\t\t && ((regmatch.regprog != NULL && vim_regexec(&regmatch,\n\t\t\t\t\t     (char_u *)dp->d_name, (colnr_T)0))\n\t\t   || ((flags & EW_NOTWILD)\n\t\t     && fnamencmp(path + (s - buf), dp->d_name, e - s) == 0)))\n\t    {\n\t\tSTRCPY(s, dp->d_name);\n\t\tlen = STRLEN(buf);\n\n\t\tif (starstar && stardepth < 100)\n\t\t{\n\t\t    // For \"**\" in the pattern first go deeper in the tree to\n\t\t    // find matches.\n\t\t    STRCPY(buf + len, \"/**\");\n\t\t    STRCPY(buf + len + 3, path_end);\n\t\t    ++stardepth;\n\t\t    (void)unix_expandpath(gap, buf, len + 1, flags, TRUE);\n\t\t    --stardepth;\n\t\t}\n\n\t\tSTRCPY(buf + len, path_end);\n\t\tif (mch_has_exp_wildcard(path_end)) // handle more wildcards\n\t\t{\n\t\t    // need to expand another component of the path\n\t\t    // remove backslashes for the remaining components only\n\t\t    (void)unix_expandpath(gap, buf, len + 1, flags, FALSE);\n\t\t}\n\t\telse\n\t\t{\n\t\t    stat_T  sb;\n\n\t\t    // no more wildcards, check if there is a match\n\t\t    // remove backslashes for the remaining components only\n\t\t    if (*path_end != NUL)\n\t\t\tbackslash_halve(buf + len + 1);\n\t\t    // add existing file or symbolic link\n\t\t    if ((flags & EW_ALLLINKS) ? mch_lstat((char *)buf, &sb) >= 0\n\t\t\t\t\t\t      : mch_getperm(buf) >= 0)\n\t\t    {\n#ifdef MACOS_CONVERT\n\t\t\tsize_t precomp_len = STRLEN(buf)+1;\n\t\t\tchar_u *precomp_buf =\n\t\t\t    mac_precompose_path(buf, precomp_len, &precomp_len);\n\n\t\t\tif (precomp_buf)\n\t\t\t{\n\t\t\t    mch_memmove(buf, precomp_buf, precomp_len);\n\t\t\t    vim_free(precomp_buf);\n\t\t\t}\n#endif\n\t\t\taddfile(gap, buf, flags);\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\tclosedir(dirp);\n    }\n\n    vim_free(buf);\n    vim_regfree(regmatch.regprog);\n\n    matches = gap->ga_len - start_len;\n    if (matches > 0)\n\tqsort(((char_u **)gap->ga_data) + start_len, matches,\n\t\t\t\t\t\t   sizeof(char_u *), pstrcmp);\n    return matches;\n}", "func_hash": 312674114892145176500352390912517515307, "file_name": "filepath.c", "file_hash": 229066241137802797352238773426978474827, "cwe": ["CWE-703"], "cve": "CVE-2022-0685", "cve_desc": "Use of Out-of-range Pointer Offset in GitHub repository vim/vim prior to 8.2.4418.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-0685", "file_path": "src/filepath.c"}
{"idx": 384803, "project": "vim", "commit_id": "5921aeb5741fc6e84c870d68c7c35b93ad0c9f87", "project_url": "https://github.com/vim/vim", "commit_url": "https://github.com/vim/vim/commit/5921aeb5741fc6e84c870d68c7c35b93ad0c9f87", "commit_message": "patch 8.2.4418: crash when using special multi-byte character\n\nProblem:    Crash when using special multi-byte character.\nSolution:   Don't use isalpha() for an arbitrary character.", "target": 0, "func": "unix_expandpath(\n    garray_T\t*gap,\n    char_u\t*path,\n    int\t\twildoff,\n    int\t\tflags,\t\t// EW_* flags\n    int\t\tdidstar)\t// expanded \"**\" once already\n{\n    char_u\t*buf;\n    char_u\t*path_end;\n    char_u\t*p, *s, *e;\n    int\t\tstart_len = gap->ga_len;\n    char_u\t*pat;\n    regmatch_T\tregmatch;\n    int\t\tstarts_with_dot;\n    int\t\tmatches;\n    int\t\tlen;\n    int\t\tstarstar = FALSE;\n    static int\tstardepth = 0;\t    // depth for \"**\" expansion\n\n    DIR\t\t*dirp;\n    struct dirent *dp;\n\n    // Expanding \"**\" may take a long time, check for CTRL-C.\n    if (stardepth > 0)\n    {\n\tui_breakcheck();\n\tif (got_int)\n\t    return 0;\n    }\n\n    // make room for file name\n    buf = alloc(STRLEN(path) + BASENAMELEN + 5);\n    if (buf == NULL)\n\treturn 0;\n\n    /*\n     * Find the first part in the path name that contains a wildcard.\n     * When EW_ICASE is set every letter is considered to be a wildcard.\n     * Copy it into \"buf\", including the preceding characters.\n     */\n    p = buf;\n    s = buf;\n    e = NULL;\n    path_end = path;\n    while (*path_end != NUL)\n    {\n\t// May ignore a wildcard that has a backslash before it; it will\n\t// be removed by rem_backslash() or file_pat_to_reg_pat() below.\n\tif (path_end >= path + wildoff && rem_backslash(path_end))\n\t    *p++ = *path_end++;\n\telse if (*path_end == '/')\n\t{\n\t    if (e != NULL)\n\t\tbreak;\n\t    s = p + 1;\n\t}\n\telse if (path_end >= path + wildoff\n\t\t\t && (vim_strchr((char_u *)\"*?[{~$\", *path_end) != NULL\n\t\t\t     || (!p_fic && (flags & EW_ICASE)\n\t\t\t\t\t  && vim_isalpha(PTR2CHAR(path_end)))))\n\t    e = p;\n\tif (has_mbyte)\n\t{\n\t    len = (*mb_ptr2len)(path_end);\n\t    STRNCPY(p, path_end, len);\n\t    p += len;\n\t    path_end += len;\n\t}\n\telse\n\t    *p++ = *path_end++;\n    }\n    e = p;\n    *e = NUL;\n\n    // Now we have one wildcard component between \"s\" and \"e\".\n    // Remove backslashes between \"wildoff\" and the start of the wildcard\n    // component.\n    for (p = buf + wildoff; p < s; ++p)\n\tif (rem_backslash(p))\n\t{\n\t    STRMOVE(p, p + 1);\n\t    --e;\n\t    --s;\n\t}\n\n    // Check for \"**\" between \"s\" and \"e\".\n    for (p = s; p < e; ++p)\n\tif (p[0] == '*' && p[1] == '*')\n\t    starstar = TRUE;\n\n    // convert the file pattern to a regexp pattern\n    starts_with_dot = *s == '.';\n    pat = file_pat_to_reg_pat(s, e, NULL, FALSE);\n    if (pat == NULL)\n    {\n\tvim_free(buf);\n\treturn 0;\n    }\n\n    // compile the regexp into a program\n    if (flags & EW_ICASE)\n\tregmatch.rm_ic = TRUE;\t\t// 'wildignorecase' set\n    else\n\tregmatch.rm_ic = p_fic;\t// ignore case when 'fileignorecase' is set\n    if (flags & (EW_NOERROR | EW_NOTWILD))\n\t++emsg_silent;\n    regmatch.regprog = vim_regcomp(pat, RE_MAGIC);\n    if (flags & (EW_NOERROR | EW_NOTWILD))\n\t--emsg_silent;\n    vim_free(pat);\n\n    if (regmatch.regprog == NULL && (flags & EW_NOTWILD) == 0)\n    {\n\tvim_free(buf);\n\treturn 0;\n    }\n\n    // If \"**\" is by itself, this is the first time we encounter it and more\n    // is following then find matches without any directory.\n    if (!didstar && stardepth < 100 && starstar && e - s == 2\n\t\t\t\t\t\t\t  && *path_end == '/')\n    {\n\tSTRCPY(s, path_end + 1);\n\t++stardepth;\n\t(void)unix_expandpath(gap, buf, (int)(s - buf), flags, TRUE);\n\t--stardepth;\n    }\n\n    // open the directory for scanning\n    *s = NUL;\n    dirp = opendir(*buf == NUL ? \".\" : (char *)buf);\n\n    // Find all matching entries\n    if (dirp != NULL)\n    {\n\tfor (;;)\n\t{\n\t    dp = readdir(dirp);\n\t    if (dp == NULL)\n\t\tbreak;\n\t    if ((dp->d_name[0] != '.' || starts_with_dot\n\t\t\t|| ((flags & EW_DODOT)\n\t\t\t    && dp->d_name[1] != NUL\n\t\t\t    && (dp->d_name[1] != '.' || dp->d_name[2] != NUL)))\n\t\t && ((regmatch.regprog != NULL && vim_regexec(&regmatch,\n\t\t\t\t\t     (char_u *)dp->d_name, (colnr_T)0))\n\t\t   || ((flags & EW_NOTWILD)\n\t\t     && fnamencmp(path + (s - buf), dp->d_name, e - s) == 0)))\n\t    {\n\t\tSTRCPY(s, dp->d_name);\n\t\tlen = STRLEN(buf);\n\n\t\tif (starstar && stardepth < 100)\n\t\t{\n\t\t    // For \"**\" in the pattern first go deeper in the tree to\n\t\t    // find matches.\n\t\t    STRCPY(buf + len, \"/**\");\n\t\t    STRCPY(buf + len + 3, path_end);\n\t\t    ++stardepth;\n\t\t    (void)unix_expandpath(gap, buf, len + 1, flags, TRUE);\n\t\t    --stardepth;\n\t\t}\n\n\t\tSTRCPY(buf + len, path_end);\n\t\tif (mch_has_exp_wildcard(path_end)) // handle more wildcards\n\t\t{\n\t\t    // need to expand another component of the path\n\t\t    // remove backslashes for the remaining components only\n\t\t    (void)unix_expandpath(gap, buf, len + 1, flags, FALSE);\n\t\t}\n\t\telse\n\t\t{\n\t\t    stat_T  sb;\n\n\t\t    // no more wildcards, check if there is a match\n\t\t    // remove backslashes for the remaining components only\n\t\t    if (*path_end != NUL)\n\t\t\tbackslash_halve(buf + len + 1);\n\t\t    // add existing file or symbolic link\n\t\t    if ((flags & EW_ALLLINKS) ? mch_lstat((char *)buf, &sb) >= 0\n\t\t\t\t\t\t      : mch_getperm(buf) >= 0)\n\t\t    {\n#ifdef MACOS_CONVERT\n\t\t\tsize_t precomp_len = STRLEN(buf)+1;\n\t\t\tchar_u *precomp_buf =\n\t\t\t    mac_precompose_path(buf, precomp_len, &precomp_len);\n\n\t\t\tif (precomp_buf)\n\t\t\t{\n\t\t\t    mch_memmove(buf, precomp_buf, precomp_len);\n\t\t\t    vim_free(precomp_buf);\n\t\t\t}\n#endif\n\t\t\taddfile(gap, buf, flags);\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\tclosedir(dirp);\n    }\n\n    vim_free(buf);\n    vim_regfree(regmatch.regprog);\n\n    matches = gap->ga_len - start_len;\n    if (matches > 0)\n\tqsort(((char_u **)gap->ga_data) + start_len, matches,\n\t\t\t\t\t\t   sizeof(char_u *), pstrcmp);\n    return matches;\n}", "func_hash": 314207374277767272342244288300260252688, "file_name": "filepath.c", "file_hash": 268435853121240029622170757643385181583, "cwe": ["CWE-703"], "cve": "CVE-2022-0685", "cve_desc": "Use of Out-of-range Pointer Offset in GitHub repository vim/vim prior to 8.2.4418.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-0685", "file_path": "src/filepath.c"}
