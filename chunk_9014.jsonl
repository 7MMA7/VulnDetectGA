{"idx": 210420, "project": "ghostpdl", "commit_id": "362ec9daadb9992b0def3520cd1dc6fa52edd1c4", "project_url": "https://github.com/ArtifexSoftware/ghostpdl", "commit_url": "http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=362ec9daadb9992b0def3520cd1dc6fa52edd1c4", "commit_message": "Fix bug 697459 Buffer overflow in fill_threshold_buffer\n\nThere was an overflow check for ht_buffer size, but none for the larger\nthreshold_buffer. Note that this file didn't fail on Windows because the\ncombination of the ht_buffer and the size of the (miscalculated due to\noverflow) threshold_buffer would have exceeded the 2Gb limit.", "target": 1, "func": "fill_threshhold_buffer(byte *dest_strip, byte *src_strip, int src_width,\n                       int left_offset, int left_width, int num_tiles,\n                       int right_width)\n{\n    byte *ptr_out_temp = dest_strip;\n    int ii;\n\n    /* Left part */\n    memcpy(dest_strip, src_strip + left_offset, left_width);\n    ptr_out_temp += left_width;\n    /* Now the full parts */\n    for (ii = 0; ii < num_tiles; ii++){\n        memcpy(ptr_out_temp, src_strip, src_width);\n        ptr_out_temp += src_width;\n    }\n    /* Now the remainder */\n    memcpy(ptr_out_temp, src_strip, right_width);\n#ifdef PACIFY_VALGRIND\n    ptr_out_temp += right_width;\n    ii = (dest_strip-ptr_out_temp) % (LAND_BITS-1);\n    if (ii > 0)\n        memset(ptr_out_temp, 0, ii);\n#endif\n}", "func_hash": 275119302871668131072600871324331925714, "file_name": "gxht_thresh.c", "file_hash": 55226233922377438981259129835747302773, "cwe": ["CWE-119"], "cve": "CVE-2016-10317", "cve_desc": "The fill_threshhold_buffer function in base/gxht_thresh.c in Artifex Software, Inc. Ghostscript 9.20 allows remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted PostScript document.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-10317", "file_path": "base/gxht_thresh.c"}
{"idx": 434902, "project": "ghostpdl", "commit_id": "362ec9daadb9992b0def3520cd1dc6fa52edd1c4", "project_url": "https://github.com/ArtifexSoftware/ghostpdl", "commit_url": "http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=362ec9daadb9992b0def3520cd1dc6fa52edd1c4", "commit_message": "Fix bug 697459 Buffer overflow in fill_threshold_buffer\n\nThere was an overflow check for ht_buffer size, but none for the larger\nthreshold_buffer. Note that this file didn't fail on Windows because the\ncombination of the ht_buffer and the size of the (miscalculated due to\noverflow) threshold_buffer would have exceeded the 2Gb limit.", "target": 0, "func": "fill_threshold_buffer(byte *dest_strip, byte *src_strip, int src_width,\n                       int left_offset, int left_width, int num_tiles,\n                       int right_width)\n{\n    byte *ptr_out_temp = dest_strip;\n    int ii;\n\n    /* Left part */\n    memcpy(dest_strip, src_strip + left_offset, left_width);\n    ptr_out_temp += left_width;\n    /* Now the full parts */\n    for (ii = 0; ii < num_tiles; ii++){\n        memcpy(ptr_out_temp, src_strip, src_width);\n        ptr_out_temp += src_width;\n    }\n    /* Now the remainder */\n    memcpy(ptr_out_temp, src_strip, right_width);\n#ifdef PACIFY_VALGRIND\n    ptr_out_temp += right_width;\n    ii = (dest_strip-ptr_out_temp) % (LAND_BITS-1);\n    if (ii > 0)\n        memset(ptr_out_temp, 0, ii);\n#endif\n}", "func_hash": 193585732429345138409504649279045778338, "file_name": "gxht_thresh.c", "file_hash": 56725769697123827323251738198105594342, "cwe": ["CWE-119"], "cve": "CVE-2016-10317", "cve_desc": "The fill_threshhold_buffer function in base/gxht_thresh.c in Artifex Software, Inc. Ghostscript 9.20 allows remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted PostScript document.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-10317", "file_path": "base/gxht_thresh.c"}
{"idx": 210453, "project": "ghostpdl", "commit_id": "366ad48d076c1aa4c8f83c65011258a04e348207", "project_url": "https://github.com/ArtifexSoftware/ghostpdl", "commit_url": "https://git.ghostscript.com/?p=ghostpdl.git;a=commitdiff;h=366ad48d076c1aa4c8f83c65011258a04e348207", "commit_message": "Bug 701815: avoid uninitialised bytes being >7, which broke indexing.\n\nFixes:\n    ./sanbin/gs -dBATCH -dNOPAUSE -sOutputFile=tmp -sDEVICE=jetp3852 ../bug-701815.pdf", "target": 1, "func": "jetp3852_print_page(gx_device_printer *pdev, gp_file *prn_stream)\n{\n#define DATA_SIZE (LINE_SIZE * 8)\n\n    unsigned int cnt_2prn;\n    unsigned int count,tempcnt;\n    unsigned char vtp,cntc1,cntc2;\n    int line_size_color_plane;\n\n    byte data[DATA_SIZE];\n    byte plane_data[LINE_SIZE * 3];\n\n    /* Set initial condition for printer */\n    gp_fputs(\"\\033@\",prn_stream);\n\n    /* Send each scan line in turn */\n    {\n        int lnum;\n        int line_size = gdev_mem_bytes_per_scan_line((gx_device *)pdev);\n        int num_blank_lines = 0;\n\n        if (line_size > DATA_SIZE) {\n            emprintf2(pdev->memory, \"invalid resolution and/or width gives line_size = %d, max. is %d\\n\",\n                      line_size, DATA_SIZE);\n            return_error(gs_error_rangecheck);\n        }\n\n        for ( lnum = 0; lnum < pdev->height; lnum++ ) {\n            byte *end_data = data + line_size;\n            gdev_prn_copy_scan_lines(pdev, lnum,\n                                     (byte *)data, line_size);\n            /* Remove trailing 0s. */\n            while ( end_data > data && end_data[-1] == 0 )\n                end_data--;\n            if ( end_data == data ) {\n                /* Blank line */\n                num_blank_lines++;\n            } else {\n                int i;\n                byte *odp;\n                byte *row;\n\n                /* Pad with 0s to fill out the last */\n                /* block of 8 bytes. */\n                memset(end_data, 0, 7);\n\n                /* Transpose the data to get pixel planes. */\n                for ( i = 0, odp = plane_data; i < DATA_SIZE;\n                      i += 8, odp++\n                    ) { /* The following is for 16-bit machines */\n#define spread3(c)\\\n { 0, c, c*0x100, c*0x101, c*0x10000L, c*0x10001L, c*0x10100L, c*0x10101L }\n                    static ulong spr40[8] = spread3(0x40);\n                    static ulong spr8[8] = spread3(8);\n                    static ulong spr2[8] = spread3(2);\n                    register byte *dp = data + i;\n                    register ulong pword =\n                                     (spr40[dp[0]] << 1) +\n                                     (spr40[dp[1]]) +\n                                     (spr40[dp[2]] >> 1) +\n                                     (spr8[dp[3]] << 1) +\n                                     (spr8[dp[4]]) +\n                                     (spr8[dp[5]] >> 1) +\n                                     (spr2[dp[6]]) +\n                                     (spr2[dp[7]] >> 1);\n                    odp[0] = (byte)(pword >> 16);\n                    odp[LINE_SIZE] = (byte)(pword >> 8);\n                    odp[LINE_SIZE*2] = (byte)(pword);\n                }\n                /* Skip blank lines if any */\n                if ( num_blank_lines > 0 ) {\n                    /* Do \"dot skips\" */\n                    while(num_blank_lines > 255) {\n                        gp_fputs(\"\\033e\\377\",prn_stream);\n                        num_blank_lines -= 255;\n                    }\n                    vtp = num_blank_lines;\n                    gp_fprintf(prn_stream,\"\\033e%c\",vtp);\n                    num_blank_lines = 0;\n                }\n\n                /* Transfer raster graphics in the order R, G, B. */\n                /* Apparently it is stored in B, G, R */\n                /* Calculate the amount of data to send by what */\n                /* Ghostscript tells us the scan line_size in (bytes) */\n\n                count = line_size / 3;\n                line_size_color_plane = count / 3;\n                cnt_2prn = line_size_color_plane * 3 + 5;\n                tempcnt = cnt_2prn;\n                cntc1 = (tempcnt & 0xFF00) >> 8;\n                cntc2 = (tempcnt & 0x00FF);\n                gp_fprintf(prn_stream, \"\\033[O%c%c\\200\\037\",cntc2,cntc1);\n                gp_fputc('\\000',prn_stream);\n                gp_fputs(\"\\124\\124\",prn_stream);\n\n                for ( row = plane_data + LINE_SIZE * 2, i = 0;\n                      i < 3; row -= LINE_SIZE, i++ ) {\n                    int jj;\n                    byte ctemp;\n                    odp = row;\n                    /* Complement bytes */\n                    for (jj=0; jj< line_size_color_plane; jj++) {\n                        ctemp = *odp;\n                        *odp++ = ~ctemp;\n                    }\n                    gp_fwrite(row, sizeof(byte),\n                              line_size_color_plane, prn_stream);\n                }\n            }\n        }\n    }\n\n    /* eject page */\n    gp_fputs(\"\\014\", prn_stream);\n\n    return 0;\n}", "func_hash": 93148813029453334596229816591999204427, "file_name": "gdev3852.c", "file_hash": 229444063869235911698513683887059150132, "cwe": ["CWE-120"], "cve": "CVE-2020-16302", "cve_desc": "A buffer overflow vulnerability in jetp3852_print_page() in devices/gdev3852.c of Artifex Software GhostScript v9.50 allows a remote attacker to escalate privileges via a crafted PDF file. This is fixed in v9.51.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2020-16302", "file_path": "devices/gdev3852.c"}
{"idx": 435409, "project": "ghostpdl", "commit_id": "366ad48d076c1aa4c8f83c65011258a04e348207", "project_url": "https://github.com/ArtifexSoftware/ghostpdl", "commit_url": "https://git.ghostscript.com/?p=ghostpdl.git;a=commitdiff;h=366ad48d076c1aa4c8f83c65011258a04e348207", "commit_message": "Bug 701815: avoid uninitialised bytes being >7, which broke indexing.\n\nFixes:\n    ./sanbin/gs -dBATCH -dNOPAUSE -sOutputFile=tmp -sDEVICE=jetp3852 ../bug-701815.pdf", "target": 0, "func": "jetp3852_print_page(gx_device_printer *pdev, gp_file *prn_stream)\n{\n#define DATA_SIZE (LINE_SIZE * 8)\n\n    unsigned int cnt_2prn;\n    unsigned int count,tempcnt;\n    unsigned char vtp,cntc1,cntc2;\n    int line_size_color_plane;\n\n    byte data[DATA_SIZE];\n    byte plane_data[LINE_SIZE * 3];\n\n    /* Initialise data to zeros, otherwise later on, uninitialised bytes in\n    dp[] can be greater than 7, which breaks spr8[dp[]]. */\n    memset(data, 0x00, DATA_SIZE);\n\n    /* Set initial condition for printer */\n    gp_fputs(\"\\033@\",prn_stream);\n\n    /* Send each scan line in turn */\n    {\n        int lnum;\n        int line_size = gdev_mem_bytes_per_scan_line((gx_device *)pdev);\n        int num_blank_lines = 0;\n\n        if (line_size > DATA_SIZE) {\n            emprintf2(pdev->memory, \"invalid resolution and/or width gives line_size = %d, max. is %d\\n\",\n                      line_size, DATA_SIZE);\n            return_error(gs_error_rangecheck);\n        }\n\n        for ( lnum = 0; lnum < pdev->height; lnum++ ) {\n            byte *end_data = data + line_size;\n            gdev_prn_copy_scan_lines(pdev, lnum,\n                                     (byte *)data, line_size);\n            /* Remove trailing 0s. */\n            while ( end_data > data && end_data[-1] == 0 )\n                end_data--;\n            if ( end_data == data ) {\n                /* Blank line */\n                num_blank_lines++;\n            } else {\n                int i;\n                byte *odp;\n                byte *row;\n\n                /* Transpose the data to get pixel planes. */\n                for ( i = 0, odp = plane_data; i < DATA_SIZE;\n                      i += 8, odp++\n                    ) { /* The following is for 16-bit machines */\n#define spread3(c)\\\n { 0, c, c*0x100, c*0x101, c*0x10000L, c*0x10001L, c*0x10100L, c*0x10101L }\n                    static ulong spr40[8] = spread3(0x40);\n                    static ulong spr8[8] = spread3(8);\n                    static ulong spr2[8] = spread3(2);\n                    register byte *dp = data + i;\n                    register ulong pword =\n                                     (spr40[dp[0]] << 1) +\n                                     (spr40[dp[1]]) +\n                                     (spr40[dp[2]] >> 1) +\n                                     (spr8[dp[3]] << 1) +\n                                     (spr8[dp[4]]) +\n                                     (spr8[dp[5]] >> 1) +\n                                     (spr2[dp[6]]) +\n                                     (spr2[dp[7]] >> 1);\n                    odp[0] = (byte)(pword >> 16);\n                    odp[LINE_SIZE] = (byte)(pword >> 8);\n                    odp[LINE_SIZE*2] = (byte)(pword);\n                }\n                /* Skip blank lines if any */\n                if ( num_blank_lines > 0 ) {\n                    /* Do \"dot skips\" */\n                    while(num_blank_lines > 255) {\n                        gp_fputs(\"\\033e\\377\",prn_stream);\n                        num_blank_lines -= 255;\n                    }\n                    vtp = num_blank_lines;\n                    gp_fprintf(prn_stream,\"\\033e%c\",vtp);\n                    num_blank_lines = 0;\n                }\n\n                /* Transfer raster graphics in the order R, G, B. */\n                /* Apparently it is stored in B, G, R */\n                /* Calculate the amount of data to send by what */\n                /* Ghostscript tells us the scan line_size in (bytes) */\n\n                count = line_size / 3;\n                line_size_color_plane = count / 3;\n                cnt_2prn = line_size_color_plane * 3 + 5;\n                tempcnt = cnt_2prn;\n                cntc1 = (tempcnt & 0xFF00) >> 8;\n                cntc2 = (tempcnt & 0x00FF);\n                gp_fprintf(prn_stream, \"\\033[O%c%c\\200\\037\",cntc2,cntc1);\n                gp_fputc('\\000',prn_stream);\n                gp_fputs(\"\\124\\124\",prn_stream);\n\n                for ( row = plane_data + LINE_SIZE * 2, i = 0;\n                      i < 3; row -= LINE_SIZE, i++ ) {\n                    int jj;\n                    byte ctemp;\n                    odp = row;\n                    /* Complement bytes */\n                    for (jj=0; jj< line_size_color_plane; jj++) {\n                        ctemp = *odp;\n                        *odp++ = ~ctemp;\n                    }\n                    gp_fwrite(row, sizeof(byte),\n                              line_size_color_plane, prn_stream);\n                }\n            }\n        }\n    }\n\n    /* eject page */\n    gp_fputs(\"\\014\", prn_stream);\n\n    return 0;\n}", "func_hash": 85965008618432429994990471615914575554, "file_name": "gdev3852.c", "file_hash": 93770144039043531856386464739578824717, "cwe": ["CWE-120"], "cve": "CVE-2020-16302", "cve_desc": "A buffer overflow vulnerability in jetp3852_print_page() in devices/gdev3852.c of Artifex Software GhostScript v9.50 allows a remote attacker to escalate privileges via a crafted PDF file. This is fixed in v9.51.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2020-16302", "file_path": "devices/gdev3852.c"}
{"idx": 210484, "project": "linux", "commit_id": "89c2b3b74918200e46699338d7bcc19b1ea12110", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=89c2b3b74918200e46699338d7bcc19b1ea12110", "commit_message": "io_uring: reexpand under-reexpanded iters\n\n[   74.211232] BUG: KASAN: stack-out-of-bounds in iov_iter_revert+0x809/0x900\n[   74.212778] Read of size 8 at addr ffff888025dc78b8 by task\nsyz-executor.0/828\n[   74.214756] CPU: 0 PID: 828 Comm: syz-executor.0 Not tainted\n5.14.0-rc3-next-20210730 #1\n[   74.216525] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996),\nBIOS rel-1.14.0-0-g155821a1990b-prebuilt.qemu.org 04/01/2014\n[   74.219033] Call Trace:\n[   74.219683]  dump_stack_lvl+0x8b/0xb3\n[   74.220706]  print_address_description.constprop.0+0x1f/0x140\n[   74.224226]  kasan_report.cold+0x7f/0x11b\n[   74.226085]  iov_iter_revert+0x809/0x900\n[   74.227960]  io_write+0x57d/0xe40\n[   74.232647]  io_issue_sqe+0x4da/0x6a80\n[   74.242578]  __io_queue_sqe+0x1ac/0xe60\n[   74.245358]  io_submit_sqes+0x3f6e/0x76a0\n[   74.248207]  __do_sys_io_uring_enter+0x90c/0x1a20\n[   74.257167]  do_syscall_64+0x3b/0x90\n[   74.257984]  entry_SYSCALL_64_after_hwframe+0x44/0xae\n\nold_size = iov_iter_count();\n...\niov_iter_revert(old_size - iov_iter_count());\n\nIf iov_iter_revert() is done base on the initial size as above, and the\niter is truncated and not reexpanded in the middle, it miscalculates\nborders causing problems. This trace is due to no one reexpanding after\ngeneric_write_checks().\n\nNow iters store how many bytes has been truncated, so reexpand them to\nthe initial state right before reverting.\n\nCc: stable@vger.kernel.org\nReported-by: Palash Oswal <oswalpalash@gmail.com>\nReported-by: Sudip Mukherjee <sudipm.mukherjee@gmail.com>\nReported-and-tested-by: syzbot+9671693590ef5aad8953@syzkaller.appspotmail.com\nSigned-off-by: Pavel Begunkov <asml.silence@gmail.com>\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>", "target": 1, "func": "static int io_read(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct iovec inline_vecs[UIO_FASTIOV], *iovec = inline_vecs;\n\tstruct kiocb *kiocb = &req->rw.kiocb;\n\tstruct iov_iter __iter, *iter = &__iter;\n\tstruct io_async_rw *rw = req->async_data;\n\tssize_t io_size, ret, ret2;\n\tbool force_nonblock = issue_flags & IO_URING_F_NONBLOCK;\n\n\tif (rw) {\n\t\titer = &rw->iter;\n\t\tiovec = NULL;\n\t} else {\n\t\tret = io_import_iovec(READ, req, &iovec, iter, !force_nonblock);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\tio_size = iov_iter_count(iter);\n\treq->result = io_size;\n\n\t/* Ensure we clear previously set non-block flag */\n\tif (!force_nonblock)\n\t\tkiocb->ki_flags &= ~IOCB_NOWAIT;\n\telse\n\t\tkiocb->ki_flags |= IOCB_NOWAIT;\n\n\t/* If the file doesn't support async, just async punt */\n\tif (force_nonblock && !io_file_supports_async(req, READ)) {\n\t\tret = io_setup_async_rw(req, iovec, inline_vecs, iter, true);\n\t\treturn ret ?: -EAGAIN;\n\t}\n\n\tret = rw_verify_area(READ, req->file, io_kiocb_ppos(kiocb), io_size);\n\tif (unlikely(ret)) {\n\t\tkfree(iovec);\n\t\treturn ret;\n\t}\n\n\tret = io_iter_do_read(req, iter);\n\n\tif (ret == -EAGAIN || (req->flags & REQ_F_REISSUE)) {\n\t\treq->flags &= ~REQ_F_REISSUE;\n\t\t/* IOPOLL retry should happen for io-wq threads */\n\t\tif (!force_nonblock && !(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\t\tgoto done;\n\t\t/* no retry on NONBLOCK nor RWF_NOWAIT */\n\t\tif (req->flags & REQ_F_NOWAIT)\n\t\t\tgoto done;\n\t\t/* some cases will consume bytes even on error returns */\n\t\tiov_iter_revert(iter, io_size - iov_iter_count(iter));\n\t\tret = 0;\n\t} else if (ret == -EIOCBQUEUED) {\n\t\tgoto out_free;\n\t} else if (ret <= 0 || ret == io_size || !force_nonblock ||\n\t\t   (req->flags & REQ_F_NOWAIT) || !(req->flags & REQ_F_ISREG)) {\n\t\t/* read all, failed, already did sync or don't want to retry */\n\t\tgoto done;\n\t}\n\n\tret2 = io_setup_async_rw(req, iovec, inline_vecs, iter, true);\n\tif (ret2)\n\t\treturn ret2;\n\n\tiovec = NULL;\n\trw = req->async_data;\n\t/* now use our persistent iterator, if we aren't already */\n\titer = &rw->iter;\n\n\tdo {\n\t\tio_size -= ret;\n\t\trw->bytes_done += ret;\n\t\t/* if we can retry, do so with the callbacks armed */\n\t\tif (!io_rw_should_retry(req)) {\n\t\t\tkiocb->ki_flags &= ~IOCB_WAITQ;\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\t/*\n\t\t * Now retry read with the IOCB_WAITQ parts set in the iocb. If\n\t\t * we get -EIOCBQUEUED, then we'll get a notification when the\n\t\t * desired page gets unlocked. We can also get a partial read\n\t\t * here, and if we do, then just retry at the new offset.\n\t\t */\n\t\tret = io_iter_do_read(req, iter);\n\t\tif (ret == -EIOCBQUEUED)\n\t\t\treturn 0;\n\t\t/* we got some bytes, but not all. retry. */\n\t\tkiocb->ki_flags &= ~IOCB_WAITQ;\n\t} while (ret > 0 && ret < io_size);\ndone:\n\tkiocb_done(kiocb, ret, issue_flags);\nout_free:\n\t/* it's faster to check here then delegate to kfree */\n\tif (iovec)\n\t\tkfree(iovec);\n\treturn 0;\n}", "func_hash": 240635131512739563674871384281451113000, "file_name": "io_uring.c", "file_hash": 270228936608432888169467151756461550796, "cwe": ["CWE-125"], "cve": "CVE-2022-1508", "cve_desc": "An out-of-bounds read flaw was found in the Linux kernel\u2019s io_uring module in the way a user triggers the io_read() function with some special parameters. This flaw allows a local user to read some memory out of bounds.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-1508", "file_path": "fs/io_uring.c"}
