{"idx": 206771, "project": "qcad", "commit_id": "1eeffc5daf5a06cf6213ffc19e95923cdebb2eb8", "project_url": "https://github.com/qcad/qcad", "commit_url": "https://github.com/qcad/qcad/commit/1eeffc5daf5a06cf6213ffc19e95923cdebb2eb8", "commit_message": "check vertexIndex which might be -1 for broken DXF", "target": 1, "func": "bool DL_Dxf::handleLWPolylineData(DL_CreationInterface* /*creationInterface*/) {\n    // Allocate LWPolyline vertices (group code 90):\n    if (groupCode==90) {\n        maxVertices = toInt(groupValue);\n        if (maxVertices>0) {\n            if (vertices!=NULL) {\n                delete[] vertices;\n            }\n            vertices = new double[4*maxVertices];\n            for (int i=0; i<maxVertices; ++i) {\n                vertices[i*4] = 0.0;\n                vertices[i*4+1] = 0.0;\n                vertices[i*4+2] = 0.0;\n                vertices[i*4+3] = 0.0;\n            }\n        }\n        vertexIndex=-1;\n        return true;\n    }\n\n    // Process LWPolylines vertices (group codes 10/20/30/42):\n    else if (groupCode==10 || groupCode==20 ||\n             groupCode==30 || groupCode==42) {\n\n        if (vertexIndex<maxVertices-1 && groupCode==10) {\n            vertexIndex++;\n        }\n\n        if (groupCode<=30) {\n            if (vertexIndex>=0 && vertexIndex<maxVertices) {\n                vertices[4*vertexIndex + (groupCode/10-1)] = toReal(groupValue);\n            }\n        } else if (groupCode==42 && vertexIndex<maxVertices) {\n            vertices[4*vertexIndex + 3] = toReal(groupValue);\n        }\n        return true;\n    }\n    return false;\n}", "func_hash": 109412697930486379897697175336143106380, "file_name": "dl_dxf.cpp", "file_hash": 313944639125792713455398286070640568043, "cwe": ["CWE-191"], "cve": "CVE-2021-21897", "cve_desc": "A code execution vulnerability exists in the DL_Dxf::handleLWPolylineData functionality of Ribbonsoft dxflib 3.17.0. A specially-crafted .dxf file can lead to a heap buffer overflow. An attacker can provide a malicious file to trigger this vulnerability.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-21897", "file_path": "src/3rdparty/dxflib/src/dl_dxf.cpp"}
{"idx": 386565, "project": "qcad", "commit_id": "1eeffc5daf5a06cf6213ffc19e95923cdebb2eb8", "project_url": "https://github.com/qcad/qcad", "commit_url": "https://github.com/qcad/qcad/commit/1eeffc5daf5a06cf6213ffc19e95923cdebb2eb8", "commit_message": "check vertexIndex which might be -1 for broken DXF", "target": 0, "func": "bool DL_Dxf::handleLWPolylineData(DL_CreationInterface* /*creationInterface*/) {\n    // Allocate LWPolyline vertices (group code 90):\n    if (groupCode==90) {\n        maxVertices = toInt(groupValue);\n        if (maxVertices>0) {\n            if (vertices!=NULL) {\n                delete[] vertices;\n            }\n            vertices = new double[4*maxVertices];\n            for (int i=0; i<maxVertices; ++i) {\n                vertices[i*4] = 0.0;\n                vertices[i*4+1] = 0.0;\n                vertices[i*4+2] = 0.0;\n                vertices[i*4+3] = 0.0;\n            }\n        }\n        vertexIndex=-1;\n        return true;\n    }\n\n    // Process LWPolylines vertices (group codes 10/20/30/42):\n    else if (groupCode==10 || groupCode==20 ||\n             groupCode==30 || groupCode==42) {\n\n        if (vertexIndex<maxVertices-1 && groupCode==10) {\n            vertexIndex++;\n        }\n\n        if (groupCode<=30) {\n            if (vertexIndex>=0 && vertexIndex<maxVertices && vertexIndex>=0) {\n                vertices[4*vertexIndex + (groupCode/10-1)] = toReal(groupValue);\n            }\n        } else if (groupCode==42 && vertexIndex<maxVertices && vertexIndex>=0) {\n            vertices[4*vertexIndex + 3] = toReal(groupValue);\n        }\n        return true;\n    }\n    return false;\n}", "func_hash": 66825183138389317029314964036422106221, "file_name": "dl_dxf.cpp", "file_hash": 181081005270076491555487324786328968837, "cwe": ["CWE-191"], "cve": "CVE-2021-21897", "cve_desc": "A code execution vulnerability exists in the DL_Dxf::handleLWPolylineData functionality of Ribbonsoft dxflib 3.17.0. A specially-crafted .dxf file can lead to a heap buffer overflow. An attacker can provide a malicious file to trigger this vulnerability.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-21897", "file_path": "src/3rdparty/dxflib/src/dl_dxf.cpp"}
{"idx": 206781, "project": "linux", "commit_id": "ea8569194b43f0f01f0a84c689388542c7254a1f", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=ea8569194b43f0f01f0a84c689388542c7254a1f", "commit_message": "udf: Restore i_lenAlloc when inode expansion fails\n\nWhen we fail to expand inode from inline format to a normal format, we\nrestore inode to contain the original inline formatting but we forgot to\nset i_lenAlloc back. The mismatch between i_lenAlloc and i_size was then\ncausing further problems such as warnings and lost data down the line.\n\nReported-by: butt3rflyh4ck <butterflyhuangxx@gmail.com>\nCC: stable@vger.kernel.org\nFixes: 7e49b6f2480c (\"udf: Convert UDF to new truncate calling sequence\")\nReviewed-by: Christoph Hellwig <hch@lst.de>\nSigned-off-by: Jan Kara <jack@suse.cz>", "target": 1, "func": "int udf_expand_file_adinicb(struct inode *inode)\n{\n\tstruct page *page;\n\tchar *kaddr;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tint err;\n\n\tWARN_ON_ONCE(!inode_is_locked(inode));\n\tif (!iinfo->i_lenAlloc) {\n\t\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_SHORT_AD))\n\t\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_SHORT;\n\t\telse\n\t\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_LONG;\n\t\t/* from now on we have normal address_space methods */\n\t\tinode->i_data.a_ops = &udf_aops;\n\t\tup_write(&iinfo->i_data_sem);\n\t\tmark_inode_dirty(inode);\n\t\treturn 0;\n\t}\n\t/*\n\t * Release i_data_sem so that we can lock a page - page lock ranks\n\t * above i_data_sem. i_mutex still protects us against file changes.\n\t */\n\tup_write(&iinfo->i_data_sem);\n\n\tpage = find_or_create_page(inode->i_mapping, 0, GFP_NOFS);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tif (!PageUptodate(page)) {\n\t\tkaddr = kmap_atomic(page);\n\t\tmemset(kaddr + iinfo->i_lenAlloc, 0x00,\n\t\t       PAGE_SIZE - iinfo->i_lenAlloc);\n\t\tmemcpy(kaddr, iinfo->i_data + iinfo->i_lenEAttr,\n\t\t\tiinfo->i_lenAlloc);\n\t\tflush_dcache_page(page);\n\t\tSetPageUptodate(page);\n\t\tkunmap_atomic(kaddr);\n\t}\n\tdown_write(&iinfo->i_data_sem);\n\tmemset(iinfo->i_data + iinfo->i_lenEAttr, 0x00,\n\t       iinfo->i_lenAlloc);\n\tiinfo->i_lenAlloc = 0;\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_SHORT_AD))\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_SHORT;\n\telse\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_LONG;\n\t/* from now on we have normal address_space methods */\n\tinode->i_data.a_ops = &udf_aops;\n\tset_page_dirty(page);\n\tunlock_page(page);\n\tup_write(&iinfo->i_data_sem);\n\terr = filemap_fdatawrite(inode->i_mapping);\n\tif (err) {\n\t\t/* Restore everything back so that we don't lose data... */\n\t\tlock_page(page);\n\t\tdown_write(&iinfo->i_data_sem);\n\t\tkaddr = kmap_atomic(page);\n\t\tmemcpy(iinfo->i_data + iinfo->i_lenEAttr, kaddr, inode->i_size);\n\t\tkunmap_atomic(kaddr);\n\t\tunlock_page(page);\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_IN_ICB;\n\t\tinode->i_data.a_ops = &udf_adinicb_aops;\n\t\tup_write(&iinfo->i_data_sem);\n\t}\n\tput_page(page);\n\tmark_inode_dirty(inode);\n\n\treturn err;\n}", "func_hash": 151977926301006306483685572008692883310, "file_name": "inode.c", "file_hash": 299509065903875732825474013259696803505, "cwe": ["CWE-476"], "cve": "CVE-2022-0617", "cve_desc": "A flaw null pointer dereference in the Linux kernel UDF file system functionality was found in the way user triggers udf_file_write_iter function for the malicious UDF image. A local user could use this flaw to crash the system. Actual from Linux kernel 4.2-rc1 till 5.17-rc2.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-0617", "file_path": "fs/inode.c"}
{"idx": 386750, "project": "linux", "commit_id": "ea8569194b43f0f01f0a84c689388542c7254a1f", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=ea8569194b43f0f01f0a84c689388542c7254a1f", "commit_message": "udf: Restore i_lenAlloc when inode expansion fails\n\nWhen we fail to expand inode from inline format to a normal format, we\nrestore inode to contain the original inline formatting but we forgot to\nset i_lenAlloc back. The mismatch between i_lenAlloc and i_size was then\ncausing further problems such as warnings and lost data down the line.\n\nReported-by: butt3rflyh4ck <butterflyhuangxx@gmail.com>\nCC: stable@vger.kernel.org\nFixes: 7e49b6f2480c (\"udf: Convert UDF to new truncate calling sequence\")\nReviewed-by: Christoph Hellwig <hch@lst.de>\nSigned-off-by: Jan Kara <jack@suse.cz>", "target": 0, "func": "int udf_expand_file_adinicb(struct inode *inode)\n{\n\tstruct page *page;\n\tchar *kaddr;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tint err;\n\n\tWARN_ON_ONCE(!inode_is_locked(inode));\n\tif (!iinfo->i_lenAlloc) {\n\t\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_SHORT_AD))\n\t\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_SHORT;\n\t\telse\n\t\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_LONG;\n\t\t/* from now on we have normal address_space methods */\n\t\tinode->i_data.a_ops = &udf_aops;\n\t\tup_write(&iinfo->i_data_sem);\n\t\tmark_inode_dirty(inode);\n\t\treturn 0;\n\t}\n\t/*\n\t * Release i_data_sem so that we can lock a page - page lock ranks\n\t * above i_data_sem. i_mutex still protects us against file changes.\n\t */\n\tup_write(&iinfo->i_data_sem);\n\n\tpage = find_or_create_page(inode->i_mapping, 0, GFP_NOFS);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tif (!PageUptodate(page)) {\n\t\tkaddr = kmap_atomic(page);\n\t\tmemset(kaddr + iinfo->i_lenAlloc, 0x00,\n\t\t       PAGE_SIZE - iinfo->i_lenAlloc);\n\t\tmemcpy(kaddr, iinfo->i_data + iinfo->i_lenEAttr,\n\t\t\tiinfo->i_lenAlloc);\n\t\tflush_dcache_page(page);\n\t\tSetPageUptodate(page);\n\t\tkunmap_atomic(kaddr);\n\t}\n\tdown_write(&iinfo->i_data_sem);\n\tmemset(iinfo->i_data + iinfo->i_lenEAttr, 0x00,\n\t       iinfo->i_lenAlloc);\n\tiinfo->i_lenAlloc = 0;\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_SHORT_AD))\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_SHORT;\n\telse\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_LONG;\n\t/* from now on we have normal address_space methods */\n\tinode->i_data.a_ops = &udf_aops;\n\tset_page_dirty(page);\n\tunlock_page(page);\n\tup_write(&iinfo->i_data_sem);\n\terr = filemap_fdatawrite(inode->i_mapping);\n\tif (err) {\n\t\t/* Restore everything back so that we don't lose data... */\n\t\tlock_page(page);\n\t\tdown_write(&iinfo->i_data_sem);\n\t\tkaddr = kmap_atomic(page);\n\t\tmemcpy(iinfo->i_data + iinfo->i_lenEAttr, kaddr, inode->i_size);\n\t\tkunmap_atomic(kaddr);\n\t\tunlock_page(page);\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_IN_ICB;\n\t\tinode->i_data.a_ops = &udf_adinicb_aops;\n\t\tiinfo->i_lenAlloc = inode->i_size;\n\t\tup_write(&iinfo->i_data_sem);\n\t}\n\tput_page(page);\n\tmark_inode_dirty(inode);\n\n\treturn err;\n}", "func_hash": 191954099261759057406602593964899861240, "file_name": "inode.c", "file_hash": 50770462585650222153062698584720679665, "cwe": ["CWE-476"], "cve": "CVE-2022-0617", "cve_desc": "A flaw null pointer dereference in the Linux kernel UDF file system functionality was found in the way user triggers udf_file_write_iter function for the malicious UDF image. A local user could use this flaw to crash the system. Actual from Linux kernel 4.2-rc1 till 5.17-rc2.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-0617", "file_path": "fs/inode.c"}
{"idx": 206815, "project": "ImageMagick", "commit_id": "c111ed9b035532c2c81ea569f2d22fded9517287", "project_url": "https://github.com/ImageMagick/ImageMagick", "commit_url": "https://github.com/ImageMagick/ImageMagick/commit/c111ed9b035532c2c81ea569f2d22fded9517287", "commit_message": "https://github.com/ImageMagick/ImageMagick/issues/1540", "target": 1, "func": "static MagickBooleanType SetGrayscaleImage(Image *image,\n  ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  PixelInfo\n    *colormap;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    *colormap_index,\n    j,\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->type != GrayscaleType)\n    (void) TransformImageColorspace(image,GRAYColorspace,exception);\n  if (image->storage_class == PseudoClass)\n    colormap_index=(ssize_t *) AcquireQuantumMemory(image->colors+1,\n      sizeof(*colormap_index));\n  else\n    colormap_index=(ssize_t *) AcquireQuantumMemory(MaxColormapSize+1,\n      sizeof(*colormap_index));\n  if (colormap_index == (ssize_t *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  if (image->storage_class != PseudoClass)\n    {\n      (void) memset(colormap_index,(-1),MaxColormapSize*\n        sizeof(*colormap_index));\n      if (AcquireImageColormap(image,MaxColormapSize,exception) == MagickFalse)\n        {\n          colormap_index=(ssize_t *) RelinquishMagickMemory(colormap_index);\n          ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n            image->filename);\n        }\n      image->colors=0;\n      status=MagickTrue;\n      image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      #pragma omp parallel for schedule(static) shared(status) \\\n        magick_number_threads(image,image,image->rows,1)\n#endif\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        register Quantum\n          *magick_restrict q;\n\n        register ssize_t\n          x;\n\n        if (status == MagickFalse)\n          continue;\n        q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,\n          exception);\n        if (q == (Quantum *) NULL)\n          {\n            status=MagickFalse;\n            continue;\n          }\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          register size_t\n            intensity;\n\n          intensity=ScaleQuantumToMap(GetPixelRed(image,q));\n          if (colormap_index[intensity] < 0)\n            {\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n              #pragma omp critical (MagickCore_SetGrayscaleImage)\n#endif\n              if (colormap_index[intensity] < 0)\n                {\n                  colormap_index[intensity]=(ssize_t) image->colors;\n                  image->colormap[image->colors].red=(double)\n                    GetPixelRed(image,q);\n                  image->colormap[image->colors].green=(double)\n                    GetPixelGreen(image,q);\n                  image->colormap[image->colors].blue=(double)\n                    GetPixelBlue(image,q);\n                  image->colors++;\n               }\n            }\n          SetPixelIndex(image,(Quantum) colormap_index[intensity],q);\n          q+=GetPixelChannels(image);\n        }\n        if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n          status=MagickFalse;\n      }\n      image_view=DestroyCacheView(image_view);\n    }\n  for (i=0; i < (ssize_t) image->colors; i++)\n    image->colormap[i].alpha=(double) i;\n  qsort((void *) image->colormap,image->colors,sizeof(PixelInfo),\n    IntensityCompare);\n  colormap=(PixelInfo *) AcquireQuantumMemory(image->colors,sizeof(*colormap));\n  if (colormap == (PixelInfo *) NULL)\n    {\n      colormap_index=(ssize_t *) RelinquishMagickMemory(colormap_index);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n  j=0;\n  colormap[j]=image->colormap[0];\n  for (i=0; i < (ssize_t) image->colors; i++)\n  {\n    if (IsPixelInfoEquivalent(&colormap[j],&image->colormap[i]) == MagickFalse)\n      {\n        j++;\n        colormap[j]=image->colormap[i];\n      }\n    colormap_index[(ssize_t) image->colormap[i].alpha]=j;\n  }\n  image->colors=(size_t) (j+1);\n  image->colormap=(PixelInfo *) RelinquishMagickMemory(image->colormap);\n  image->colormap=colormap;\n  status=MagickTrue;\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(status) \\\n    magick_number_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      SetPixelIndex(image,(Quantum) colormap_index[ScaleQuantumToMap(\n        GetPixelIndex(image,q))],q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  image_view=DestroyCacheView(image_view);\n  colormap_index=(ssize_t *) RelinquishMagickMemory(colormap_index);\n  image->type=GrayscaleType;\n  if (SetImageMonochrome(image,exception) != MagickFalse)\n    image->type=BilevelType;\n  return(status);\n}", "func_hash": 31139316036408574839827699821440311605, "file_name": "quantize.c", "file_hash": 6776316156649379334956322163459365152, "cwe": ["CWE-125"], "cve": "CVE-2019-11598", "cve_desc": "In ImageMagick 7.0.8-40 Q16, there is a heap-based buffer over-read in the function WritePNMImage of coders/pnm.c, which allows an attacker to cause a denial of service or possibly information disclosure via a crafted image file. This is related to SetGrayscaleImage in MagickCore/quantize.c.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2019-11598", "file_path": "MagickCore/quantize.c"}
{"idx": 387149, "project": "ImageMagick", "commit_id": "c111ed9b035532c2c81ea569f2d22fded9517287", "project_url": "https://github.com/ImageMagick/ImageMagick", "commit_url": "https://github.com/ImageMagick/ImageMagick/commit/c111ed9b035532c2c81ea569f2d22fded9517287", "commit_message": "https://github.com/ImageMagick/ImageMagick/issues/1540", "target": 0, "func": "static MagickBooleanType SetGrayscaleImage(Image *image,\n  ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  PixelInfo\n    *colormap;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    *colormap_index,\n    j,\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->type != GrayscaleType)\n    (void) TransformImageColorspace(image,GRAYColorspace,exception);\n  if (image->storage_class == PseudoClass)\n    colormap_index=(ssize_t *) AcquireQuantumMemory(MagickMax(image->colors+1,\n      MaxMap),sizeof(*colormap_index));\n  else\n    colormap_index=(ssize_t *) AcquireQuantumMemory(MagickMax(MaxColormapSize+1,\n      MaxMap),sizeof(*colormap_index));\n  if (colormap_index == (ssize_t *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  if (image->storage_class != PseudoClass)\n    {\n      (void) memset(colormap_index,(-1),MaxColormapSize*\n        sizeof(*colormap_index));\n      if (AcquireImageColormap(image,MaxColormapSize,exception) == MagickFalse)\n        {\n          colormap_index=(ssize_t *) RelinquishMagickMemory(colormap_index);\n          ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n            image->filename);\n        }\n      image->colors=0;\n      status=MagickTrue;\n      image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      #pragma omp parallel for schedule(static) shared(status) \\\n        magick_number_threads(image,image,image->rows,1)\n#endif\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        register Quantum\n          *magick_restrict q;\n\n        register ssize_t\n          x;\n\n        if (status == MagickFalse)\n          continue;\n        q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,\n          exception);\n        if (q == (Quantum *) NULL)\n          {\n            status=MagickFalse;\n            continue;\n          }\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          register size_t\n            intensity;\n\n          intensity=ScaleQuantumToMap(GetPixelRed(image,q));\n          if (colormap_index[intensity] < 0)\n            {\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n              #pragma omp critical (MagickCore_SetGrayscaleImage)\n#endif\n              if (colormap_index[intensity] < 0)\n                {\n                  colormap_index[intensity]=(ssize_t) image->colors;\n                  image->colormap[image->colors].red=(double)\n                    GetPixelRed(image,q);\n                  image->colormap[image->colors].green=(double)\n                    GetPixelGreen(image,q);\n                  image->colormap[image->colors].blue=(double)\n                    GetPixelBlue(image,q);\n                  image->colors++;\n               }\n            }\n          SetPixelIndex(image,(Quantum) colormap_index[intensity],q);\n          q+=GetPixelChannels(image);\n        }\n        if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n          status=MagickFalse;\n      }\n      image_view=DestroyCacheView(image_view);\n    }\n  for (i=0; i < (ssize_t) image->colors; i++)\n    image->colormap[i].alpha=(double) i;\n  qsort((void *) image->colormap,image->colors,sizeof(PixelInfo),\n    IntensityCompare);\n  colormap=(PixelInfo *) AcquireQuantumMemory(image->colors,sizeof(*colormap));\n  if (colormap == (PixelInfo *) NULL)\n    {\n      colormap_index=(ssize_t *) RelinquishMagickMemory(colormap_index);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n  j=0;\n  colormap[j]=image->colormap[0];\n  for (i=0; i < (ssize_t) image->colors; i++)\n  {\n    if (IsPixelInfoEquivalent(&colormap[j],&image->colormap[i]) == MagickFalse)\n      {\n        j++;\n        colormap[j]=image->colormap[i];\n      }\n    colormap_index[(ssize_t) image->colormap[i].alpha]=j;\n  }\n  image->colors=(size_t) (j+1);\n  image->colormap=(PixelInfo *) RelinquishMagickMemory(image->colormap);\n  image->colormap=colormap;\n  status=MagickTrue;\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(status) \\\n    magick_number_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      SetPixelIndex(image,(Quantum) colormap_index[ScaleQuantumToMap(\n        GetPixelIndex(image,q))],q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  image_view=DestroyCacheView(image_view);\n  colormap_index=(ssize_t *) RelinquishMagickMemory(colormap_index);\n  image->type=GrayscaleType;\n  if (SetImageMonochrome(image,exception) != MagickFalse)\n    image->type=BilevelType;\n  return(status);\n}", "func_hash": 185597478640915810926254287356895046975, "file_name": "quantize.c", "file_hash": 90832018031567136939378750944649283392, "cwe": ["CWE-125"], "cve": "CVE-2019-11598", "cve_desc": "In ImageMagick 7.0.8-40 Q16, there is a heap-based buffer over-read in the function WritePNMImage of coders/pnm.c, which allows an attacker to cause a denial of service or possibly information disclosure via a crafted image file. This is related to SetGrayscaleImage in MagickCore/quantize.c.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2019-11598", "file_path": "MagickCore/quantize.c"}
{"idx": 206845, "project": "linux", "commit_id": "5934d9a0383619c14df91af8fd76261dc3de2f5f", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/5934d9a0383619c14df91af8fd76261dc3de2f5f", "commit_message": "ALSA: control: Re-order bounds checking in get_ctl_id_hash()\n\nThese two checks are in the reverse order so it might read one element\nbeyond the end of the array.  First check if the \"i\" is within bounds\nbefore using it.\n\nFixes: 6ab55ec0a938 (\"ALSA: control: Fix an out-of-bounds bug in get_ctl_id_hash()\")\nSigned-off-by: Dan Carpenter <dan.carpenter@oracle.com>\nLink: https://lore.kernel.org/r/YwjgNh/gkG1hH7po@kili\nSigned-off-by: Takashi Iwai <tiwai@suse.de>", "target": 1, "func": "static unsigned long get_ctl_id_hash(const struct snd_ctl_elem_id *id)\n{\n\tint i;\n\tunsigned long h;\n\n\th = id->iface;\n\th = MULTIPLIER * h + id->device;\n\th = MULTIPLIER * h + id->subdevice;\n\tfor (i = 0; id->name[i] && i < SNDRV_CTL_ELEM_ID_NAME_MAXLEN; i++)\n\t\th = MULTIPLIER * h + id->name[i];\n\th = MULTIPLIER * h + id->index;\n\th &= LONG_MAX;\n\treturn h;\n}", "func_hash": 131319443934908040237061712028017051028, "file_name": "control.c", "file_hash": 255950300769870224716949641453203743368, "cwe": ["CWE-125"], "cve": "CVE-2022-3170", "cve_desc": "An out-of-bounds access issue was found in the Linux kernel sound subsystem. It could occur when the 'id->name' provided by the user did not end with '\\0'. A privileged local user could pass a specially crafted name through ioctl() interface and crash the system or potentially escalate their privileges on the system.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-3170", "file_path": "drivers/greybus/control.c"}
{"idx": 387593, "project": "linux", "commit_id": "5934d9a0383619c14df91af8fd76261dc3de2f5f", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/5934d9a0383619c14df91af8fd76261dc3de2f5f", "commit_message": "ALSA: control: Re-order bounds checking in get_ctl_id_hash()\n\nThese two checks are in the reverse order so it might read one element\nbeyond the end of the array.  First check if the \"i\" is within bounds\nbefore using it.\n\nFixes: 6ab55ec0a938 (\"ALSA: control: Fix an out-of-bounds bug in get_ctl_id_hash()\")\nSigned-off-by: Dan Carpenter <dan.carpenter@oracle.com>\nLink: https://lore.kernel.org/r/YwjgNh/gkG1hH7po@kili\nSigned-off-by: Takashi Iwai <tiwai@suse.de>", "target": 0, "func": "static unsigned long get_ctl_id_hash(const struct snd_ctl_elem_id *id)\n{\n\tint i;\n\tunsigned long h;\n\n\th = id->iface;\n\th = MULTIPLIER * h + id->device;\n\th = MULTIPLIER * h + id->subdevice;\n\tfor (i = 0; i < SNDRV_CTL_ELEM_ID_NAME_MAXLEN && id->name[i]; i++)\n\t\th = MULTIPLIER * h + id->name[i];\n\th = MULTIPLIER * h + id->index;\n\th &= LONG_MAX;\n\treturn h;\n}", "func_hash": 34537843047622620480136251678937271731, "file_name": "control.c", "file_hash": 333017582912688268799367809880673073354, "cwe": ["CWE-125"], "cve": "CVE-2022-3170", "cve_desc": "An out-of-bounds access issue was found in the Linux kernel sound subsystem. It could occur when the 'id->name' provided by the user did not end with '\\0'. A privileged local user could pass a specially crafted name through ioctl() interface and crash the system or potentially escalate their privileges on the system.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-3170", "file_path": "drivers/greybus/control.c"}
{"idx": 206942, "project": "vim", "commit_id": "1e56bda9048a9625bce6e660938c834c5c15b07d", "project_url": "https://github.com/vim/vim", "commit_url": "https://github.com/vim/vim/commit/1e56bda9048a9625bce6e660938c834c5c15b07d", "commit_message": "patch 9.0.0104: going beyond allocated memory when evaluating string constant\n\nProblem:    Going beyond allocated memory when evaluating string constant.\nSolution:   Properly skip over <Key> form.", "target": 1, "func": "eval_string(char_u **arg, typval_T *rettv, int evaluate, int interpolate)\n{\n    char_u\t*p;\n    char_u\t*end;\n    int\t\textra = interpolate ? 1 : 0;\n    int\t\toff = interpolate ? 0 : 1;\n    int\t\tlen;\n\n    // Find the end of the string, skipping backslashed characters.\n    for (p = *arg + off; *p != NUL && *p != '\"'; MB_PTR_ADV(p))\n    {\n\tif (*p == '\\\\' && p[1] != NUL)\n\t{\n\t    ++p;\n\t    // A \"\\<x>\" form occupies at least 4 characters, and produces up\n\t    // to 9 characters (6 for the char and 3 for a modifier):\n\t    // reserve space for 5 extra.\n\t    if (*p == '<')\n\t\textra += 5;\n\t}\n\telse if (interpolate && (*p == '{' || *p == '}'))\n\t{\n\t    if (*p == '{' && p[1] != '{') // start of expression\n\t\tbreak;\n\t    ++p;\n\t    if (p[-1] == '}' && *p != '}') // single '}' is an error\n\t    {\n\t\tsemsg(_(e_stray_closing_curly_str), *arg);\n\t\treturn FAIL;\n\t    }\n\t    --extra;  // \"{{\" becomes \"{\", \"}}\" becomes \"}\"\n\t}\n    }\n\n    if (*p != '\"' && !(interpolate && *p == '{'))\n    {\n\tsemsg(_(e_missing_double_quote_str), *arg);\n\treturn FAIL;\n    }\n\n    // If only parsing, set *arg and return here\n    if (!evaluate)\n    {\n\t*arg = p + off;\n\treturn OK;\n    }\n\n    // Copy the string into allocated memory, handling backslashed\n    // characters.\n    rettv->v_type = VAR_STRING;\n    len = (int)(p - *arg + extra);\n    rettv->vval.v_string = alloc(len);\n    if (rettv->vval.v_string == NULL)\n\treturn FAIL;\n    end = rettv->vval.v_string;\n\n    for (p = *arg + off; *p != NUL && *p != '\"'; )\n    {\n\tif (*p == '\\\\')\n\t{\n\t    switch (*++p)\n\t    {\n\t\tcase 'b': *end++ = BS; ++p; break;\n\t\tcase 'e': *end++ = ESC; ++p; break;\n\t\tcase 'f': *end++ = FF; ++p; break;\n\t\tcase 'n': *end++ = NL; ++p; break;\n\t\tcase 'r': *end++ = CAR; ++p; break;\n\t\tcase 't': *end++ = TAB; ++p; break;\n\n\t\tcase 'X': // hex: \"\\x1\", \"\\x12\"\n\t\tcase 'x':\n\t\tcase 'u': // Unicode: \"\\u0023\"\n\t\tcase 'U':\n\t\t\t  if (vim_isxdigit(p[1]))\n\t\t\t  {\n\t\t\t      int\tn, nr;\n\t\t\t      int\tc = toupper(*p);\n\n\t\t\t      if (c == 'X')\n\t\t\t\t  n = 2;\n\t\t\t      else if (*p == 'u')\n\t\t\t\t  n = 4;\n\t\t\t      else\n\t\t\t\t  n = 8;\n\t\t\t      nr = 0;\n\t\t\t      while (--n >= 0 && vim_isxdigit(p[1]))\n\t\t\t      {\n\t\t\t\t  ++p;\n\t\t\t\t  nr = (nr << 4) + hex2nr(*p);\n\t\t\t      }\n\t\t\t      ++p;\n\t\t\t      // For \"\\u\" store the number according to\n\t\t\t      // 'encoding'.\n\t\t\t      if (c != 'X')\n\t\t\t\t  end += (*mb_char2bytes)(nr, end);\n\t\t\t      else\n\t\t\t\t  *end++ = nr;\n\t\t\t  }\n\t\t\t  break;\n\n\t\t\t  // octal: \"\\1\", \"\\12\", \"\\123\"\n\t\tcase '0':\n\t\tcase '1':\n\t\tcase '2':\n\t\tcase '3':\n\t\tcase '4':\n\t\tcase '5':\n\t\tcase '6':\n\t\tcase '7': *end = *p++ - '0';\n\t\t\t  if (*p >= '0' && *p <= '7')\n\t\t\t  {\n\t\t\t      *end = (*end << 3) + *p++ - '0';\n\t\t\t      if (*p >= '0' && *p <= '7')\n\t\t\t\t  *end = (*end << 3) + *p++ - '0';\n\t\t\t  }\n\t\t\t  ++end;\n\t\t\t  break;\n\n\t\t\t  // Special key, e.g.: \"\\<C-W>\"\n\t\tcase '<':\n\t\t\t  {\n\t\t\t      int flags = FSK_KEYCODE | FSK_IN_STRING;\n\n\t\t\t      if (p[1] != '*')\n\t\t\t\t  flags |= FSK_SIMPLIFY;\n\t\t\t      extra = trans_special(&p, end, flags, FALSE, NULL);\n\t\t\t      if (extra != 0)\n\t\t\t      {\n\t\t\t\t  end += extra;\n\t\t\t\t  if (end >= rettv->vval.v_string + len)\n\t\t\t\t      iemsg(\"eval_string() used more space than allocated\");\n\t\t\t\t  break;\n\t\t\t      }\n\t\t\t  }\n\t\t\t  // FALLTHROUGH\n\n\t\tdefault: MB_COPY_CHAR(p, end);\n\t\t\t  break;\n\t    }\n\t}\n\telse\n\t{\n\t    if (interpolate && (*p == '{' || *p == '}'))\n\t    {\n\t\tif (*p == '{' && p[1] != '{') // start of expression\n\t\t    break;\n\t\t++p;  // reduce \"{{\" to \"{\" and \"}}\" to \"}\"\n\t    }\n\t    MB_COPY_CHAR(p, end);\n\t}\n    }\n    *end = NUL;\n    if (*p == '\"' && !interpolate)\n\t++p;\n    *arg = p;\n\n    return OK;\n}", "func_hash": 338220226163490913152834959718974208239, "file_name": "typval.c", "file_hash": 328531951922388475683903891036611129511, "cwe": ["CWE-125"], "cve": "CVE-2022-2580", "cve_desc": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0102.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-2580", "file_path": "src/typval.c"}
{"idx": 389676, "project": "vim", "commit_id": "1e56bda9048a9625bce6e660938c834c5c15b07d", "project_url": "https://github.com/vim/vim", "commit_url": "https://github.com/vim/vim/commit/1e56bda9048a9625bce6e660938c834c5c15b07d", "commit_message": "patch 9.0.0104: going beyond allocated memory when evaluating string constant\n\nProblem:    Going beyond allocated memory when evaluating string constant.\nSolution:   Properly skip over <Key> form.", "target": 0, "func": "eval_string(char_u **arg, typval_T *rettv, int evaluate, int interpolate)\n{\n    char_u\t*p;\n    char_u\t*end;\n    int\t\textra = interpolate ? 1 : 0;\n    int\t\toff = interpolate ? 0 : 1;\n    int\t\tlen;\n\n    // Find the end of the string, skipping backslashed characters.\n    for (p = *arg + off; *p != NUL && *p != '\"'; MB_PTR_ADV(p))\n    {\n\tif (*p == '\\\\' && p[1] != NUL)\n\t{\n\t    ++p;\n\t    // A \"\\<x>\" form occupies at least 4 characters, and produces up\n\t    // to 9 characters (6 for the char and 3 for a modifier):\n\t    // reserve space for 5 extra.\n\t    if (*p == '<')\n\t    {\n\t\tint\t\tmodifiers = 0;\n\t\tint\t\tflags = FSK_KEYCODE | FSK_IN_STRING;\n\n\t\textra += 5;\n\n\t\t// Skip to the '>' to avoid using '{' inside for string\n\t\t// interpolation.\n\t\tif (p[1] != '*')\n\t\t    flags |= FSK_SIMPLIFY;\n\t\tif (find_special_key(&p, &modifiers, flags, NULL) != 0)\n\t\t    --p;  // leave \"p\" on the \">\"\n\t    }\n\t}\n\telse if (interpolate && (*p == '{' || *p == '}'))\n\t{\n\t    if (*p == '{' && p[1] != '{') // start of expression\n\t\tbreak;\n\t    ++p;\n\t    if (p[-1] == '}' && *p != '}') // single '}' is an error\n\t    {\n\t\tsemsg(_(e_stray_closing_curly_str), *arg);\n\t\treturn FAIL;\n\t    }\n\t    --extra;  // \"{{\" becomes \"{\", \"}}\" becomes \"}\"\n\t}\n    }\n\n    if (*p != '\"' && !(interpolate && *p == '{'))\n    {\n\tsemsg(_(e_missing_double_quote_str), *arg);\n\treturn FAIL;\n    }\n\n    // If only parsing, set *arg and return here\n    if (!evaluate)\n    {\n\t*arg = p + off;\n\treturn OK;\n    }\n\n    // Copy the string into allocated memory, handling backslashed\n    // characters.\n    rettv->v_type = VAR_STRING;\n    len = (int)(p - *arg + extra);\n    rettv->vval.v_string = alloc(len);\n    if (rettv->vval.v_string == NULL)\n\treturn FAIL;\n    end = rettv->vval.v_string;\n\n    for (p = *arg + off; *p != NUL && *p != '\"'; )\n    {\n\tif (*p == '\\\\')\n\t{\n\t    switch (*++p)\n\t    {\n\t\tcase 'b': *end++ = BS; ++p; break;\n\t\tcase 'e': *end++ = ESC; ++p; break;\n\t\tcase 'f': *end++ = FF; ++p; break;\n\t\tcase 'n': *end++ = NL; ++p; break;\n\t\tcase 'r': *end++ = CAR; ++p; break;\n\t\tcase 't': *end++ = TAB; ++p; break;\n\n\t\tcase 'X': // hex: \"\\x1\", \"\\x12\"\n\t\tcase 'x':\n\t\tcase 'u': // Unicode: \"\\u0023\"\n\t\tcase 'U':\n\t\t\t  if (vim_isxdigit(p[1]))\n\t\t\t  {\n\t\t\t      int\tn, nr;\n\t\t\t      int\tc = toupper(*p);\n\n\t\t\t      if (c == 'X')\n\t\t\t\t  n = 2;\n\t\t\t      else if (*p == 'u')\n\t\t\t\t  n = 4;\n\t\t\t      else\n\t\t\t\t  n = 8;\n\t\t\t      nr = 0;\n\t\t\t      while (--n >= 0 && vim_isxdigit(p[1]))\n\t\t\t      {\n\t\t\t\t  ++p;\n\t\t\t\t  nr = (nr << 4) + hex2nr(*p);\n\t\t\t      }\n\t\t\t      ++p;\n\t\t\t      // For \"\\u\" store the number according to\n\t\t\t      // 'encoding'.\n\t\t\t      if (c != 'X')\n\t\t\t\t  end += (*mb_char2bytes)(nr, end);\n\t\t\t      else\n\t\t\t\t  *end++ = nr;\n\t\t\t  }\n\t\t\t  break;\n\n\t\t\t  // octal: \"\\1\", \"\\12\", \"\\123\"\n\t\tcase '0':\n\t\tcase '1':\n\t\tcase '2':\n\t\tcase '3':\n\t\tcase '4':\n\t\tcase '5':\n\t\tcase '6':\n\t\tcase '7': *end = *p++ - '0';\n\t\t\t  if (*p >= '0' && *p <= '7')\n\t\t\t  {\n\t\t\t      *end = (*end << 3) + *p++ - '0';\n\t\t\t      if (*p >= '0' && *p <= '7')\n\t\t\t\t  *end = (*end << 3) + *p++ - '0';\n\t\t\t  }\n\t\t\t  ++end;\n\t\t\t  break;\n\n\t\t\t  // Special key, e.g.: \"\\<C-W>\"\n\t\tcase '<':\n\t\t\t  {\n\t\t\t      int flags = FSK_KEYCODE | FSK_IN_STRING;\n\n\t\t\t      if (p[1] != '*')\n\t\t\t\t  flags |= FSK_SIMPLIFY;\n\t\t\t      extra = trans_special(&p, end, flags, FALSE, NULL);\n\t\t\t      if (extra != 0)\n\t\t\t      {\n\t\t\t\t  end += extra;\n\t\t\t\t  if (end >= rettv->vval.v_string + len)\n\t\t\t\t      iemsg(\"eval_string() used more space than allocated\");\n\t\t\t\t  break;\n\t\t\t      }\n\t\t\t  }\n\t\t\t  // FALLTHROUGH\n\n\t\tdefault: MB_COPY_CHAR(p, end);\n\t\t\t  break;\n\t    }\n\t}\n\telse\n\t{\n\t    if (interpolate && (*p == '{' || *p == '}'))\n\t    {\n\t\tif (*p == '{' && p[1] != '{') // start of expression\n\t\t    break;\n\t\t++p;  // reduce \"{{\" to \"{\" and \"}}\" to \"}\"\n\t    }\n\t    MB_COPY_CHAR(p, end);\n\t}\n    }\n    *end = NUL;\n    if (*p == '\"' && !interpolate)\n\t++p;\n    *arg = p;\n\n    return OK;\n}", "func_hash": 300144927032379821054071112406007573706, "file_name": "typval.c", "file_hash": 264686639878036499427248365468285871356, "cwe": ["CWE-125"], "cve": "CVE-2022-2580", "cve_desc": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0102.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-2580", "file_path": "src/typval.c"}
{"idx": 206946, "project": "jasper", "commit_id": "d99636fad60629785efd1ef72da772a8ef68f54c", "project_url": "https://github.com/mdadams/jasper", "commit_url": "https://github.com/jasper-software/jasper/commit/d99636fad60629785efd1ef72da772a8ef68f54c", "commit_message": "fix memory leaks in function cmdopts_parse", "target": 1, "func": "cmdopts_t *cmdopts_parse(int argc, char **argv)\n{\n\tenum {\n\t\tCMDOPT_HELP = 0,\n\t\tCMDOPT_VERBOSE,\n\t\tCMDOPT_QUIET,\n\t\tCMDOPT_INFILE,\n\t\tCMDOPT_INFMT,\n\t\tCMDOPT_INOPT,\n\t\tCMDOPT_OUTFILE,\n\t\tCMDOPT_OUTFMT,\n\t\tCMDOPT_OUTOPT,\n\t\tCMDOPT_VERSION,\n\t\tCMDOPT_DEBUG,\n\t\tCMDOPT_CMPTNO,\n\t\tCMDOPT_SRGB,\n\t\tCMDOPT_MAXMEM,\n\t\tCMDOPT_LIST_ENABLED_CODECS,\n\t\tCMDOPT_LIST_ALL_CODECS,\n\t\tCMDOPT_ENABLE_FORMAT,\n\t\tCMDOPT_ENABLE_ALL_FORMATS,\n\t};\n\n\tstatic const jas_opt_t cmdoptions[] = {\n\t\t{CMDOPT_HELP, \"help\", 0},\n\t\t{CMDOPT_VERBOSE, \"verbose\", 0},\n\t\t{CMDOPT_QUIET, \"quiet\", 0},\n\t\t{CMDOPT_QUIET, \"q\", 0},\n\t\t{CMDOPT_INFILE, \"input\", JAS_OPT_HASARG},\n\t\t{CMDOPT_INFILE, \"f\", JAS_OPT_HASARG},\n\t\t{CMDOPT_INFMT, \"input-format\", JAS_OPT_HASARG},\n\t\t{CMDOPT_INFMT, \"t\", JAS_OPT_HASARG},\n\t\t{CMDOPT_INOPT, \"input-option\", JAS_OPT_HASARG},\n\t\t{CMDOPT_INOPT, \"o\", JAS_OPT_HASARG},\n\t\t{CMDOPT_OUTFILE, \"output\", JAS_OPT_HASARG},\n\t\t{CMDOPT_OUTFILE, \"F\", JAS_OPT_HASARG},\n\t\t{CMDOPT_OUTFMT, \"output-format\", JAS_OPT_HASARG},\n\t\t{CMDOPT_OUTFMT, \"T\", JAS_OPT_HASARG},\n\t\t{CMDOPT_OUTOPT, \"output-option\", JAS_OPT_HASARG},\n\t\t{CMDOPT_OUTOPT, \"O\", JAS_OPT_HASARG},\n\t\t{CMDOPT_VERSION, \"version\", 0},\n\t\t{CMDOPT_DEBUG, \"debug-level\", JAS_OPT_HASARG},\n\t\t{CMDOPT_CMPTNO, \"cmptno\", JAS_OPT_HASARG},\n\t\t{CMDOPT_SRGB, \"force-srgb\", 0},\n\t\t{CMDOPT_SRGB, \"S\", 0},\n\t\t{CMDOPT_MAXMEM, \"memory-limit\", JAS_OPT_HASARG},\n\t\t{CMDOPT_LIST_ENABLED_CODECS, \"list-enabled-formats\", 0},\n\t\t{CMDOPT_LIST_ALL_CODECS, \"list-all-formats\", 0},\n\t\t{CMDOPT_ENABLE_FORMAT, \"enable-format\", JAS_OPT_HASARG},\n\t\t{CMDOPT_ENABLE_ALL_FORMATS, \"enable-all-formats\", 0},\n\t\t{-1, 0, 0}\n\t};\n\n\tcmdopts_t *cmdopts;\n\tint c;\n\n\tif (!(cmdopts = malloc(sizeof(cmdopts_t)))) {\n\t\tfprintf(stderr, \"error: insufficient memory\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tcmdopts->infile = 0;\n\tcmdopts->infmt = -1;\n\tcmdopts->infmt_str = 0;\n\tcmdopts->inopts = 0;\n\tcmdopts->inoptsbuf[0] = '\\0';\n\tcmdopts->outfile = 0;\n\tcmdopts->outfmt = -1;\n\tcmdopts->outfmt_str = 0;\n\tcmdopts->outopts = 0;\n\tcmdopts->outoptsbuf[0] = '\\0';\n\tcmdopts->verbose = 0;\n\tcmdopts->version = 0;\n\tcmdopts->cmptno = -1;\n\tcmdopts->debug = 0;\n\tcmdopts->srgb = 0;\n\tcmdopts->list_codecs = 0;\n\tcmdopts->list_codecs_all = 0;\n\tcmdopts->help = 0;\n\tcmdopts->max_mem = get_default_max_mem_usage();\n\tcmdopts->enable_format = 0;\n\tcmdopts->enable_all_formats = 0;\n\n\twhile ((c = jas_getopt(argc, argv, cmdoptions)) != EOF) {\n\t\tswitch (c) {\n\t\tcase CMDOPT_HELP:\n\t\t\tcmdopts->help = 1;\n\t\t\tbreak;\n\t\tcase CMDOPT_VERBOSE:\n\t\t\tcmdopts->verbose = 1;\n\t\t\tbreak;\n\t\tcase CMDOPT_QUIET:\n\t\t\tcmdopts->verbose = -1;\n\t\t\tbreak;\n\t\tcase CMDOPT_VERSION:\n\t\t\tcmdopts->version = 1;\n\t\t\tbreak;\n\t\tcase CMDOPT_LIST_ENABLED_CODECS:\n\t\t\tcmdopts->list_codecs = 1;\n\t\t\tcmdopts->list_codecs_all = 0;\n\t\t\tbreak;\n\t\tcase CMDOPT_LIST_ALL_CODECS:\n\t\t\tcmdopts->list_codecs = 1;\n\t\t\tcmdopts->list_codecs_all = 1;\n\t\t\tbreak;\n\t\tcase CMDOPT_DEBUG:\n\t\t\tcmdopts->debug = atoi(jas_optarg);\n\t\t\tbreak;\n\t\tcase CMDOPT_INFILE:\n\t\t\tcmdopts->infile = jas_optarg;\n\t\t\tbreak;\n\t\tcase CMDOPT_INFMT:\n\t\t\tcmdopts->infmt_str= jas_optarg;\n\t\t\tbreak;\n\t\tcase CMDOPT_INOPT:\n\t\t\taddopt(cmdopts->inoptsbuf, OPTSMAX, jas_optarg);\n\t\t\tcmdopts->inopts = cmdopts->inoptsbuf;\n\t\t\tbreak;\n\t\tcase CMDOPT_OUTFILE:\n\t\t\tcmdopts->outfile = jas_optarg;\n\t\t\tbreak;\n\t\tcase CMDOPT_OUTFMT:\n\t\t\tcmdopts->outfmt_str = jas_optarg;\n\t\t\tbreak;\n\t\tcase CMDOPT_OUTOPT:\n\t\t\taddopt(cmdopts->outoptsbuf, OPTSMAX, jas_optarg);\n\t\t\tcmdopts->outopts = cmdopts->outoptsbuf;\n\t\t\tbreak;\n\t\tcase CMDOPT_CMPTNO:\n\t\t\tcmdopts->cmptno = atoi(jas_optarg);\n\t\t\tbreak;\n\t\tcase CMDOPT_SRGB:\n\t\t\tcmdopts->srgb = 1;\n\t\t\tbreak;\n\t\tcase CMDOPT_MAXMEM:\n\t\t\tcmdopts->max_mem = strtoull(jas_optarg, 0, 10);\n\t\t\tbreak;\n\t\tcase CMDOPT_ENABLE_FORMAT:\n\t\t\tcmdopts->enable_format = jas_optarg;\n\t\t\tbreak;\n\t\tcase CMDOPT_ENABLE_ALL_FORMATS:\n\t\t\tcmdopts->enable_all_formats = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbadusage();\n\t\t\tbreak;\n\t\t}\n\t}\n\n\twhile (jas_optind < argc) {\n\t\tfprintf(stderr,\n\t\t  \"warning: ignoring bogus command line argument %s\\n\",\n\t\t  argv[jas_optind]);\n\t\t++jas_optind;\n\t}\n\n\tif (cmdopts->version || cmdopts->list_codecs || cmdopts->help) {\n\t\tgoto done;\n\t}\n\n\tif (!cmdopts->outfmt_str && !cmdopts->outfile) {\n\t\tfprintf(stderr, \"error: cannot determine output format\\n\");\n\t\tbadusage();\n\t}\n\ndone:\n\treturn cmdopts;\n}", "func_hash": 93181291511681804073691200897709901657, "file_name": "jasper.c", "file_hash": 221565924886298462326836957771233686713, "cwe": ["CWE-703"], "cve": "CVE-2022-2963", "cve_desc": "A vulnerability found in jasper. This security vulnerability happens because of a memory leak bug in function cmdopts_parse that can cause a crash or segmentation fault.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-2963", "file_path": "src/app/jasper.c"}
{"idx": 389760, "project": "jasper", "commit_id": "d99636fad60629785efd1ef72da772a8ef68f54c", "project_url": "https://github.com/mdadams/jasper", "commit_url": "https://github.com/jasper-software/jasper/commit/d99636fad60629785efd1ef72da772a8ef68f54c", "commit_message": "fix memory leaks in function cmdopts_parse", "target": 0, "func": "cmdopts_t *cmdopts_parse(int argc, char **argv)\n{\n\tenum {\n\t\tCMDOPT_HELP = 0,\n\t\tCMDOPT_VERBOSE,\n\t\tCMDOPT_QUIET,\n\t\tCMDOPT_INFILE,\n\t\tCMDOPT_INFMT,\n\t\tCMDOPT_INOPT,\n\t\tCMDOPT_OUTFILE,\n\t\tCMDOPT_OUTFMT,\n\t\tCMDOPT_OUTOPT,\n\t\tCMDOPT_VERSION,\n\t\tCMDOPT_DEBUG,\n\t\tCMDOPT_CMPTNO,\n\t\tCMDOPT_SRGB,\n\t\tCMDOPT_MAXMEM,\n\t\tCMDOPT_LIST_ENABLED_CODECS,\n\t\tCMDOPT_LIST_ALL_CODECS,\n\t\tCMDOPT_ENABLE_FORMAT,\n\t\tCMDOPT_ENABLE_ALL_FORMATS,\n\t};\n\n\tstatic const jas_opt_t cmdoptions[] = {\n\t\t{CMDOPT_HELP, \"help\", 0},\n\t\t{CMDOPT_VERBOSE, \"verbose\", 0},\n\t\t{CMDOPT_QUIET, \"quiet\", 0},\n\t\t{CMDOPT_QUIET, \"q\", 0},\n\t\t{CMDOPT_INFILE, \"input\", JAS_OPT_HASARG},\n\t\t{CMDOPT_INFILE, \"f\", JAS_OPT_HASARG},\n\t\t{CMDOPT_INFMT, \"input-format\", JAS_OPT_HASARG},\n\t\t{CMDOPT_INFMT, \"t\", JAS_OPT_HASARG},\n\t\t{CMDOPT_INOPT, \"input-option\", JAS_OPT_HASARG},\n\t\t{CMDOPT_INOPT, \"o\", JAS_OPT_HASARG},\n\t\t{CMDOPT_OUTFILE, \"output\", JAS_OPT_HASARG},\n\t\t{CMDOPT_OUTFILE, \"F\", JAS_OPT_HASARG},\n\t\t{CMDOPT_OUTFMT, \"output-format\", JAS_OPT_HASARG},\n\t\t{CMDOPT_OUTFMT, \"T\", JAS_OPT_HASARG},\n\t\t{CMDOPT_OUTOPT, \"output-option\", JAS_OPT_HASARG},\n\t\t{CMDOPT_OUTOPT, \"O\", JAS_OPT_HASARG},\n\t\t{CMDOPT_VERSION, \"version\", 0},\n\t\t{CMDOPT_DEBUG, \"debug-level\", JAS_OPT_HASARG},\n\t\t{CMDOPT_CMPTNO, \"cmptno\", JAS_OPT_HASARG},\n\t\t{CMDOPT_SRGB, \"force-srgb\", 0},\n\t\t{CMDOPT_SRGB, \"S\", 0},\n\t\t{CMDOPT_MAXMEM, \"memory-limit\", JAS_OPT_HASARG},\n\t\t{CMDOPT_LIST_ENABLED_CODECS, \"list-enabled-formats\", 0},\n\t\t{CMDOPT_LIST_ALL_CODECS, \"list-all-formats\", 0},\n\t\t{CMDOPT_ENABLE_FORMAT, \"enable-format\", JAS_OPT_HASARG},\n\t\t{CMDOPT_ENABLE_ALL_FORMATS, \"enable-all-formats\", 0},\n\t\t{-1, 0, 0}\n\t};\n\n\tcmdopts_t *cmdopts;\n\tint c;\n\n\tif (!(cmdopts = malloc(sizeof(cmdopts_t)))) {\n\t\tfprintf(stderr, \"error: insufficient memory\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tcmdopts->infile = 0;\n\tcmdopts->infmt = -1;\n\tcmdopts->infmt_str = 0;\n\tcmdopts->inopts = 0;\n\tcmdopts->inoptsbuf[0] = '\\0';\n\tcmdopts->outfile = 0;\n\tcmdopts->outfmt = -1;\n\tcmdopts->outfmt_str = 0;\n\tcmdopts->outopts = 0;\n\tcmdopts->outoptsbuf[0] = '\\0';\n\tcmdopts->verbose = 0;\n\tcmdopts->version = 0;\n\tcmdopts->cmptno = -1;\n\tcmdopts->debug = 0;\n\tcmdopts->srgb = 0;\n\tcmdopts->list_codecs = 0;\n\tcmdopts->list_codecs_all = 0;\n\tcmdopts->help = 0;\n\tcmdopts->max_mem = get_default_max_mem_usage();\n\tcmdopts->enable_format = 0;\n\tcmdopts->enable_all_formats = 0;\n\n\twhile ((c = jas_getopt(argc, argv, cmdoptions)) != EOF) {\n\t\tswitch (c) {\n\t\tcase CMDOPT_HELP:\n\t\t\tcmdopts->help = 1;\n\t\t\tbreak;\n\t\tcase CMDOPT_VERBOSE:\n\t\t\tcmdopts->verbose = 1;\n\t\t\tbreak;\n\t\tcase CMDOPT_QUIET:\n\t\t\tcmdopts->verbose = -1;\n\t\t\tbreak;\n\t\tcase CMDOPT_VERSION:\n\t\t\tcmdopts->version = 1;\n\t\t\tbreak;\n\t\tcase CMDOPT_LIST_ENABLED_CODECS:\n\t\t\tcmdopts->list_codecs = 1;\n\t\t\tcmdopts->list_codecs_all = 0;\n\t\t\tbreak;\n\t\tcase CMDOPT_LIST_ALL_CODECS:\n\t\t\tcmdopts->list_codecs = 1;\n\t\t\tcmdopts->list_codecs_all = 1;\n\t\t\tbreak;\n\t\tcase CMDOPT_DEBUG:\n\t\t\tcmdopts->debug = atoi(jas_optarg);\n\t\t\tbreak;\n\t\tcase CMDOPT_INFILE:\n\t\t\tcmdopts->infile = jas_optarg;\n\t\t\tbreak;\n\t\tcase CMDOPT_INFMT:\n\t\t\tcmdopts->infmt_str= jas_optarg;\n\t\t\tbreak;\n\t\tcase CMDOPT_INOPT:\n\t\t\taddopt(cmdopts->inoptsbuf, OPTSMAX, jas_optarg);\n\t\t\tcmdopts->inopts = cmdopts->inoptsbuf;\n\t\t\tbreak;\n\t\tcase CMDOPT_OUTFILE:\n\t\t\tcmdopts->outfile = jas_optarg;\n\t\t\tbreak;\n\t\tcase CMDOPT_OUTFMT:\n\t\t\tcmdopts->outfmt_str = jas_optarg;\n\t\t\tbreak;\n\t\tcase CMDOPT_OUTOPT:\n\t\t\taddopt(cmdopts->outoptsbuf, OPTSMAX, jas_optarg);\n\t\t\tcmdopts->outopts = cmdopts->outoptsbuf;\n\t\t\tbreak;\n\t\tcase CMDOPT_CMPTNO:\n\t\t\tcmdopts->cmptno = atoi(jas_optarg);\n\t\t\tbreak;\n\t\tcase CMDOPT_SRGB:\n\t\t\tcmdopts->srgb = 1;\n\t\t\tbreak;\n\t\tcase CMDOPT_MAXMEM:\n\t\t\tcmdopts->max_mem = strtoull(jas_optarg, 0, 10);\n\t\t\tbreak;\n\t\tcase CMDOPT_ENABLE_FORMAT:\n\t\t\tcmdopts->enable_format = jas_optarg;\n\t\t\tbreak;\n\t\tcase CMDOPT_ENABLE_ALL_FORMATS:\n\t\t\tcmdopts->enable_all_formats = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcmdopts_destroy(cmdopts);\n\t\t\tbadusage();\n\t\t\tbreak;\n\t\t}\n\t}\n\n\twhile (jas_optind < argc) {\n\t\tfprintf(stderr,\n\t\t  \"warning: ignoring bogus command line argument %s\\n\",\n\t\t  argv[jas_optind]);\n\t\t++jas_optind;\n\t}\n\n\tif (cmdopts->version || cmdopts->list_codecs || cmdopts->help) {\n\t\tgoto done;\n\t}\n\n\tif (!cmdopts->outfmt_str && !cmdopts->outfile) {\n\t\tfprintf(stderr, \"error: cannot determine output format\\n\");\n\t\tcmdopts_destroy(cmdopts);\n\t\tbadusage();\n\t}\n\ndone:\n\treturn cmdopts;\n}", "func_hash": 102932853856682606703676466444383538610, "file_name": "jasper.c", "file_hash": 43318189901043805005058339060588403940, "cwe": ["CWE-703"], "cve": "CVE-2022-2963", "cve_desc": "A vulnerability found in jasper. This security vulnerability happens because of a memory leak bug in function cmdopts_parse that can cause a crash or segmentation fault.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-2963", "file_path": "src/app/jasper.c"}
{"idx": 207068, "project": "linux", "commit_id": "cc7a0bb058b85ea03db87169c60c7cfdd5d34678", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=cc7a0bb058b85ea03db87169c60c7cfdd5d34678", "commit_message": "PCI: rpadlpar: Fix potential drc_name corruption in store functions\n\nBoth add_slot_store() and remove_slot_store() try to fix up the\ndrc_name copied from the store buffer by placing a NUL terminator at\nnbyte + 1 or in place of a '\\n' if present. However, the static buffer\nthat we copy the drc_name data into is not zeroed and can contain\nanything past the n-th byte.\n\nThis is problematic if a '\\n' byte appears in that buffer after nbytes\nand the string copied into the store buffer was not NUL terminated to\nstart with as the strchr() search for a '\\n' byte will mark this\nincorrectly as the end of the drc_name string resulting in a drc_name\nstring that contains garbage data after the n-th byte.\n\nAdditionally it will cause us to overwrite that '\\n' byte on the stack\nwith NUL, potentially corrupting data on the stack.\n\nThe following debugging shows an example of the drmgr utility writing\n\"PHB 4543\" to the add_slot sysfs attribute, but add_slot_store()\nlogging a corrupted string value.\n\n  drmgr: drmgr: -c phb -a -s PHB 4543 -d 1\n  add_slot_store: drc_name = PHB 4543\u00b0|<82>!, rc = -19\n\nFix this by using strscpy() instead of memcpy() to ensure the string\nis NUL terminated when copied into the static drc_name buffer.\nFurther, since the string is now NUL terminated the code only needs to\nchange '\\n' to '\\0' when present.\n\nCc: stable@vger.kernel.org\nSigned-off-by: Tyrel Datwyler <tyreld@linux.ibm.com>\n[mpe: Reformat change log and add mention of possible stack corruption]\nSigned-off-by: Michael Ellerman <mpe@ellerman.id.au>\nLink: https://lore.kernel.org/r/20210315214821.452959-1-tyreld@linux.ibm.com", "target": 1, "func": "static ssize_t remove_slot_store(struct kobject *kobj,\n\t\t\t\t struct kobj_attribute *attr,\n\t\t\t\t const char *buf, size_t nbytes)\n{\n\tchar drc_name[MAX_DRC_NAME_LEN];\n\tint rc;\n\tchar *end;\n\n\tif (nbytes >= MAX_DRC_NAME_LEN)\n\t\treturn 0;\n\n\tmemcpy(drc_name, buf, nbytes);\n\n\tend = strchr(drc_name, '\\n');\n\tif (!end)\n\t\tend = &drc_name[nbytes];\n\t*end = '\\0';\n\n\trc = dlpar_remove_slot(drc_name);\n\tif (rc)\n\t\treturn rc;\n\n\treturn nbytes;\n}", "func_hash": 237293762490436147707541740545065202667, "file_name": "rpadlpar_sysfs.c", "file_hash": 143265511624763705093739678134289779335, "cwe": ["CWE-120"], "cve": "CVE-2021-28972", "cve_desc": "In drivers/pci/hotplug/rpadlpar_sysfs.c in the Linux kernel through 5.11.8, the RPA PCI Hotplug driver has a user-tolerable buffer overflow when writing a new device name to the driver from userspace, allowing userspace to write data to the kernel stack frame directly. This occurs because add_slot_store and remove_slot_store mishandle drc_name '\\0' termination, aka CID-cc7a0bb058b8.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-28972", "file_path": "drivers/pci/hotplug/rpadlpar_sysfs.c"}
{"idx": 391627, "project": "linux", "commit_id": "cc7a0bb058b85ea03db87169c60c7cfdd5d34678", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=cc7a0bb058b85ea03db87169c60c7cfdd5d34678", "commit_message": "PCI: rpadlpar: Fix potential drc_name corruption in store functions\n\nBoth add_slot_store() and remove_slot_store() try to fix up the\ndrc_name copied from the store buffer by placing a NUL terminator at\nnbyte + 1 or in place of a '\\n' if present. However, the static buffer\nthat we copy the drc_name data into is not zeroed and can contain\nanything past the n-th byte.\n\nThis is problematic if a '\\n' byte appears in that buffer after nbytes\nand the string copied into the store buffer was not NUL terminated to\nstart with as the strchr() search for a '\\n' byte will mark this\nincorrectly as the end of the drc_name string resulting in a drc_name\nstring that contains garbage data after the n-th byte.\n\nAdditionally it will cause us to overwrite that '\\n' byte on the stack\nwith NUL, potentially corrupting data on the stack.\n\nThe following debugging shows an example of the drmgr utility writing\n\"PHB 4543\" to the add_slot sysfs attribute, but add_slot_store()\nlogging a corrupted string value.\n\n  drmgr: drmgr: -c phb -a -s PHB 4543 -d 1\n  add_slot_store: drc_name = PHB 4543\u00b0|<82>!, rc = -19\n\nFix this by using strscpy() instead of memcpy() to ensure the string\nis NUL terminated when copied into the static drc_name buffer.\nFurther, since the string is now NUL terminated the code only needs to\nchange '\\n' to '\\0' when present.\n\nCc: stable@vger.kernel.org\nSigned-off-by: Tyrel Datwyler <tyreld@linux.ibm.com>\n[mpe: Reformat change log and add mention of possible stack corruption]\nSigned-off-by: Michael Ellerman <mpe@ellerman.id.au>\nLink: https://lore.kernel.org/r/20210315214821.452959-1-tyreld@linux.ibm.com", "target": 0, "func": "static ssize_t remove_slot_store(struct kobject *kobj,\n\t\t\t\t struct kobj_attribute *attr,\n\t\t\t\t const char *buf, size_t nbytes)\n{\n\tchar drc_name[MAX_DRC_NAME_LEN];\n\tint rc;\n\tchar *end;\n\n\tif (nbytes >= MAX_DRC_NAME_LEN)\n\t\treturn 0;\n\n\tstrscpy(drc_name, buf, nbytes + 1);\n\n\tend = strchr(drc_name, '\\n');\n\tif (end)\n\t\t*end = '\\0';\n\n\trc = dlpar_remove_slot(drc_name);\n\tif (rc)\n\t\treturn rc;\n\n\treturn nbytes;\n}", "func_hash": 228561592734793467772177551896912743936, "file_name": "rpadlpar_sysfs.c", "file_hash": 21668029196687947173345261458760783896, "cwe": ["CWE-120"], "cve": "CVE-2021-28972", "cve_desc": "In drivers/pci/hotplug/rpadlpar_sysfs.c in the Linux kernel through 5.11.8, the RPA PCI Hotplug driver has a user-tolerable buffer overflow when writing a new device name to the driver from userspace, allowing userspace to write data to the kernel stack frame directly. This occurs because add_slot_store and remove_slot_store mishandle drc_name '\\0' termination, aka CID-cc7a0bb058b8.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-28972", "file_path": "drivers/pci/hotplug/rpadlpar_sysfs.c"}
{"idx": 207069, "project": "linux", "commit_id": "cc7a0bb058b85ea03db87169c60c7cfdd5d34678", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=cc7a0bb058b85ea03db87169c60c7cfdd5d34678", "commit_message": "PCI: rpadlpar: Fix potential drc_name corruption in store functions\n\nBoth add_slot_store() and remove_slot_store() try to fix up the\ndrc_name copied from the store buffer by placing a NUL terminator at\nnbyte + 1 or in place of a '\\n' if present. However, the static buffer\nthat we copy the drc_name data into is not zeroed and can contain\nanything past the n-th byte.\n\nThis is problematic if a '\\n' byte appears in that buffer after nbytes\nand the string copied into the store buffer was not NUL terminated to\nstart with as the strchr() search for a '\\n' byte will mark this\nincorrectly as the end of the drc_name string resulting in a drc_name\nstring that contains garbage data after the n-th byte.\n\nAdditionally it will cause us to overwrite that '\\n' byte on the stack\nwith NUL, potentially corrupting data on the stack.\n\nThe following debugging shows an example of the drmgr utility writing\n\"PHB 4543\" to the add_slot sysfs attribute, but add_slot_store()\nlogging a corrupted string value.\n\n  drmgr: drmgr: -c phb -a -s PHB 4543 -d 1\n  add_slot_store: drc_name = PHB 4543\u00b0|<82>!, rc = -19\n\nFix this by using strscpy() instead of memcpy() to ensure the string\nis NUL terminated when copied into the static drc_name buffer.\nFurther, since the string is now NUL terminated the code only needs to\nchange '\\n' to '\\0' when present.\n\nCc: stable@vger.kernel.org\nSigned-off-by: Tyrel Datwyler <tyreld@linux.ibm.com>\n[mpe: Reformat change log and add mention of possible stack corruption]\nSigned-off-by: Michael Ellerman <mpe@ellerman.id.au>\nLink: https://lore.kernel.org/r/20210315214821.452959-1-tyreld@linux.ibm.com", "target": 1, "func": "static ssize_t add_slot_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t      const char *buf, size_t nbytes)\n{\n\tchar drc_name[MAX_DRC_NAME_LEN];\n\tchar *end;\n\tint rc;\n\n\tif (nbytes >= MAX_DRC_NAME_LEN)\n\t\treturn 0;\n\n\tmemcpy(drc_name, buf, nbytes);\n\n\tend = strchr(drc_name, '\\n');\n\tif (!end)\n\t\tend = &drc_name[nbytes];\n\t*end = '\\0';\n\n\trc = dlpar_add_slot(drc_name);\n\tif (rc)\n\t\treturn rc;\n\n\treturn nbytes;\n}", "func_hash": 262261814389997886159936729256803084500, "file_name": "rpadlpar_sysfs.c", "file_hash": 143265511624763705093739678134289779335, "cwe": ["CWE-120"], "cve": "CVE-2021-28972", "cve_desc": "In drivers/pci/hotplug/rpadlpar_sysfs.c in the Linux kernel through 5.11.8, the RPA PCI Hotplug driver has a user-tolerable buffer overflow when writing a new device name to the driver from userspace, allowing userspace to write data to the kernel stack frame directly. This occurs because add_slot_store and remove_slot_store mishandle drc_name '\\0' termination, aka CID-cc7a0bb058b8.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-28972", "file_path": "drivers/pci/hotplug/rpadlpar_sysfs.c"}
{"idx": 391628, "project": "linux", "commit_id": "cc7a0bb058b85ea03db87169c60c7cfdd5d34678", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=cc7a0bb058b85ea03db87169c60c7cfdd5d34678", "commit_message": "PCI: rpadlpar: Fix potential drc_name corruption in store functions\n\nBoth add_slot_store() and remove_slot_store() try to fix up the\ndrc_name copied from the store buffer by placing a NUL terminator at\nnbyte + 1 or in place of a '\\n' if present. However, the static buffer\nthat we copy the drc_name data into is not zeroed and can contain\nanything past the n-th byte.\n\nThis is problematic if a '\\n' byte appears in that buffer after nbytes\nand the string copied into the store buffer was not NUL terminated to\nstart with as the strchr() search for a '\\n' byte will mark this\nincorrectly as the end of the drc_name string resulting in a drc_name\nstring that contains garbage data after the n-th byte.\n\nAdditionally it will cause us to overwrite that '\\n' byte on the stack\nwith NUL, potentially corrupting data on the stack.\n\nThe following debugging shows an example of the drmgr utility writing\n\"PHB 4543\" to the add_slot sysfs attribute, but add_slot_store()\nlogging a corrupted string value.\n\n  drmgr: drmgr: -c phb -a -s PHB 4543 -d 1\n  add_slot_store: drc_name = PHB 4543\u00b0|<82>!, rc = -19\n\nFix this by using strscpy() instead of memcpy() to ensure the string\nis NUL terminated when copied into the static drc_name buffer.\nFurther, since the string is now NUL terminated the code only needs to\nchange '\\n' to '\\0' when present.\n\nCc: stable@vger.kernel.org\nSigned-off-by: Tyrel Datwyler <tyreld@linux.ibm.com>\n[mpe: Reformat change log and add mention of possible stack corruption]\nSigned-off-by: Michael Ellerman <mpe@ellerman.id.au>\nLink: https://lore.kernel.org/r/20210315214821.452959-1-tyreld@linux.ibm.com", "target": 0, "func": "static ssize_t add_slot_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t      const char *buf, size_t nbytes)\n{\n\tchar drc_name[MAX_DRC_NAME_LEN];\n\tchar *end;\n\tint rc;\n\n\tif (nbytes >= MAX_DRC_NAME_LEN)\n\t\treturn 0;\n\n\tstrscpy(drc_name, buf, nbytes + 1);\n\n\tend = strchr(drc_name, '\\n');\n\tif (end)\n\t\t*end = '\\0';\n\n\trc = dlpar_add_slot(drc_name);\n\tif (rc)\n\t\treturn rc;\n\n\treturn nbytes;\n}", "func_hash": 228230730882908285016023798985921663046, "file_name": "rpadlpar_sysfs.c", "file_hash": 21668029196687947173345261458760783896, "cwe": ["CWE-120"], "cve": "CVE-2021-28972", "cve_desc": "In drivers/pci/hotplug/rpadlpar_sysfs.c in the Linux kernel through 5.11.8, the RPA PCI Hotplug driver has a user-tolerable buffer overflow when writing a new device name to the driver from userspace, allowing userspace to write data to the kernel stack frame directly. This occurs because add_slot_store and remove_slot_store mishandle drc_name '\\0' termination, aka CID-cc7a0bb058b8.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-28972", "file_path": "drivers/pci/hotplug/rpadlpar_sysfs.c"}
{"idx": 207150, "project": "squirrel", "commit_id": "a6413aa690e0bdfef648c68693349a7b878fe60d", "project_url": "https://github.com/albertodemichelis/squirrel", "commit_url": "https://github.com/albertodemichelis/squirrel/commit/a6413aa690e0bdfef648c68693349a7b878fe60d", "commit_message": "fix in thread.call", "target": 1, "func": "static SQInteger thread_call(HSQUIRRELVM v)\n{\n    SQObjectPtr o = stack_get(v,1);\n    if(sq_type(o) == OT_THREAD) {\n        SQInteger nparams = sq_gettop(v);\n        _thread(o)->Push(_thread(o)->_roottable);\n        for(SQInteger i = 2; i<(nparams+1); i++)\n            sq_move(_thread(o),v,i);\n        if(SQ_SUCCEEDED(sq_call(_thread(o),nparams,SQTrue,SQTrue))) {\n            sq_move(v,_thread(o),-1);\n            sq_pop(_thread(o),1);\n            return 1;\n        }\n        v->_lasterror = _thread(o)->_lasterror;\n        return SQ_ERROR;\n    }\n    return sq_throwerror(v,_SC(\"wrong parameter\"));\n}", "func_hash": 39783972208477930534182111058478291044, "file_name": "sqbaselib.cpp", "file_hash": 22214130882110251892898581176850711195, "cwe": ["CWE-703"], "cve": "CVE-2022-30292", "cve_desc": "Heap-based buffer overflow in sqbaselib.cpp in SQUIRREL 3.2 due to lack of a certain sq_reservestack call.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-30292", "file_path": "squirrel/sqbaselib.cpp"}
{"idx": 393528, "project": "squirrel", "commit_id": "a6413aa690e0bdfef648c68693349a7b878fe60d", "project_url": "https://github.com/albertodemichelis/squirrel", "commit_url": "https://github.com/albertodemichelis/squirrel/commit/a6413aa690e0bdfef648c68693349a7b878fe60d", "commit_message": "fix in thread.call", "target": 0, "func": "static SQInteger thread_call(HSQUIRRELVM v)\n{\n    SQObjectPtr o = stack_get(v,1);\n    if(sq_type(o) == OT_THREAD) {\n        SQInteger nparams = sq_gettop(v);\n        sq_reservestack(_thread(o), nparams + 3);\n        _thread(o)->Push(_thread(o)->_roottable);\n        for(SQInteger i = 2; i<(nparams+1); i++)\n            sq_move(_thread(o),v,i);\n        if(SQ_SUCCEEDED(sq_call(_thread(o),nparams,SQTrue,SQTrue))) {\n            sq_move(v,_thread(o),-1);\n            sq_pop(_thread(o),1);\n            return 1;\n        }\n        v->_lasterror = _thread(o)->_lasterror;\n        return SQ_ERROR;\n    }\n    return sq_throwerror(v,_SC(\"wrong parameter\"));\n}", "func_hash": 185870701968227218426869749475686341047, "file_name": "sqbaselib.cpp", "file_hash": 167918424394936848193603192917033144376, "cwe": ["CWE-703"], "cve": "CVE-2022-30292", "cve_desc": "Heap-based buffer overflow in sqbaselib.cpp in SQUIRREL 3.2 due to lack of a certain sq_reservestack call.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-30292", "file_path": "squirrel/sqbaselib.cpp"}
{"idx": 207461, "project": "autotrace", "commit_id": "e96bffadc25ff0ba0e10745f8012efcc5f920ea9", "project_url": "https://github.com/autotrace/autotrace", "commit_url": "https://github.com/autotrace/autotrace/commit/e96bffadc25ff0ba0e10745f8012efcc5f920ea9", "commit_message": "input-bmp: Increase header buffer in some cases\n\nSigned-off-by: Peter Lemenkov <lemenkov@gmail.com>", "target": 1, "func": "at_bitmap input_bmp_reader(gchar * filename, at_input_opts_type * opts, at_msg_func msg_func, gpointer msg_data, gpointer user_data)\n{\n  FILE *fd;\n  unsigned char buffer[64];\n  int ColormapSize, rowbytes, Maps;\n  gboolean Grey = FALSE;\n  unsigned char ColorMap[256][3];\n  at_bitmap image = at_bitmap_init(0, 0, 0, 1);\n  unsigned char *image_storage;\n  at_exception_type exp = at_exception_new(msg_func, msg_data);\n  char magick[2];\n  Bitmap_Channel masks[4];\n\n  fd = fopen(filename, \"rb\");\n\n  if (!fd) {\n    LOG(\"Can't open \\\"%s\\\"\\n\", filename);\n    at_exception_fatal(&exp, \"bmp: cannot open input file\");\n    goto cleanup;\n  }\n\n  /* It is a File. Now is it a Bitmap? Read the shortest possible header. */\n\n  if (!ReadOK(fd, magick, 2) ||\n\t  !(!strncmp(magick, \"BA\", 2) ||\n\t\t  !strncmp(magick, \"BM\", 2) ||\n\t\t  !strncmp(magick, \"IC\", 2) ||\n\t\t  !strncmp(magick, \"PT\", 2) ||\n\t\t  !strncmp(magick, \"CI\", 2) ||\n\t\t  !strncmp(magick, \"CP\", 2)))\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n\n  while (!strncmp(magick, \"BA\", 2))\n  {\n\t  if (!ReadOK(fd, buffer, 12))\n\t  {\n\t\t  LOG(\"%s is not a valid BMP file\", filename);\n\t\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t\t  goto cleanup;\n\t  }\n\n\t  if (!ReadOK(fd, magick, 2))\n\t  {\n\t\t  LOG(\"%s is not a valid BMP file\", filename);\n\t\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t\t  goto cleanup;\n\t  }\n  }\n\n  if (!ReadOK(fd, buffer, 12))////\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n\n  /* bring them to the right byteorder. Not too nice, but it should work */\n\n  Bitmap_File_Head.bfSize = ToL(&buffer[0x00]);\n  Bitmap_File_Head.zzHotX = ToS(&buffer[0x04]);\n  Bitmap_File_Head.zzHotY = ToS(&buffer[0x06]);\n  Bitmap_File_Head.bfOffs = ToL(&buffer[0x08]);\n\n  if (!ReadOK(fd, buffer, 4))\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n\n  Bitmap_File_Head.biSize = ToL(&buffer[0x00]);\n\n  /* What kind of bitmap is it? */\n\n  if (Bitmap_File_Head.biSize == 12) {  /* OS/2 1.x ? */\n    if (!ReadOK(fd, buffer, 8)) {\n      LOG(\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n\n    Bitmap_Head.biWidth = ToS(&buffer[0x00]); /* 12 */\n    Bitmap_Head.biHeight = ToS(&buffer[0x02]);  /* 14 */\n    Bitmap_Head.biPlanes = ToS(&buffer[0x04]);  /* 16 */\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x06]);  /* 18 */\n    Bitmap_Head.biCompr = 0;\n    Bitmap_Head.biSizeIm = 0;\n    Bitmap_Head.biXPels = Bitmap_Head.biYPels = 0;\n    Bitmap_Head.biClrUsed = 0;\n    Bitmap_Head.biClrImp = 0;\n    Bitmap_Head.masks[0] = 0;\n    Bitmap_Head.masks[1] = 0;\n    Bitmap_Head.masks[2] = 0;\n    Bitmap_Head.masks[3] = 0;\n\n    memset(masks, 0, sizeof(masks));\n    Maps = 3;\n\n  } else if (Bitmap_File_Head.biSize == 40) { /* Windows 3.x */\n    if (!ReadOK(fd, buffer, 36))\n    {\n      LOG (\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n          \n\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]); /* 12 */\n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);  /* 16 */\n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);  /* 1A */\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);  /* 1C */\n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]); /* 1E */\n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);  /* 22 */\n    Bitmap_Head.biXPels = ToL(&buffer[0x14]); /* 26 */\n    Bitmap_Head.biYPels = ToL(&buffer[0x18]); /* 2A */\n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]); /* 2E */\n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);  /* 32 */\n    Bitmap_Head.masks[0] = 0;\n    Bitmap_Head.masks[1] = 0;\n    Bitmap_Head.masks[2] = 0;\n    Bitmap_Head.masks[3] = 0;\n\n    Maps = 4;\n    memset(masks, 0, sizeof(masks));\n\n    if (Bitmap_Head.biCompr == BI_BITFIELDS)\n      {\n\tif (!ReadOK(fd, buffer, 3 * sizeof(unsigned long)))\n\t  {\n\t    LOG(\"Error reading BMP file header\\n\");\n\t    at_exception_fatal(&exp, \"Error reading BMP file header\");\n\t    goto cleanup;\n\t  }\n\n\tBitmap_Head.masks[0] = ToL(&buffer[0x00]);\n\tBitmap_Head.masks[1] = ToL(&buffer[0x04]);\n\tBitmap_Head.masks[2] = ToL(&buffer[0x08]);\n\n\tReadChannelMasks(&Bitmap_Head.masks[0], masks, 3);\n      }\n    else if (Bitmap_Head.biCompr == BI_RGB)\n      {\n\tsetMasksDefault(Bitmap_Head.biBitCnt, masks);\n      }\n    else if ((Bitmap_Head.biCompr != BI_RLE4) &&\n\t     (Bitmap_Head.biCompr != BI_RLE8))\n      {\n\t/* BI_ALPHABITFIELDS, etc. */\n\tLOG(\"Unsupported compression in BMP file\\n\");\n\tat_exception_fatal(&exp, \"Unsupported compression in BMP file\");\n\tgoto cleanup;\n      }\n  }\n  else if (Bitmap_File_Head.biSize >= 56 &&\n\t   Bitmap_File_Head.biSize <= 64)\n  {\n    /* enhanced Windows format with bit masks */\n\n    if (!ReadOK (fd, buffer, Bitmap_File_Head.biSize - 4))\n    {\n\n      LOG(\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]); /* 12 */\n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);  /* 16 */\n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);  /* 1A */\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);  /* 1C */\n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]); /* 1E */\n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);  /* 22 */\n    Bitmap_Head.biXPels = ToL(&buffer[0x14]); /* 26 */\n    Bitmap_Head.biYPels = ToL(&buffer[0x18]); /* 2A */\n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]); /* 2E */\n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);  /* 32 */\n    Bitmap_Head.masks[0] = ToL(&buffer[0x24]);       /* 36 */\n    Bitmap_Head.masks[1] = ToL(&buffer[0x28]);       /* 3A */\n    Bitmap_Head.masks[2] = ToL(&buffer[0x2C]);       /* 3E */\n    Bitmap_Head.masks[3] = ToL(&buffer[0x30]);       /* 42 */\n\n    Maps = 4;\n    ReadChannelMasks(&Bitmap_Head.masks[0], masks, 4);\n  }\n  else if (Bitmap_File_Head.biSize == 108 ||\n           Bitmap_File_Head.biSize == 124)\n  {\n    /* BMP Version 4 or 5 */\n\n    if (!ReadOK(fd, buffer, Bitmap_File_Head.biSize - 4))\n    {\n\t    LOG(\"Error reading BMP file header\\n\");\n\t    at_exception_fatal(&exp, \"Error reading BMP file header\");\n\t    goto cleanup;\n    }\n\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]);\n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);\n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);\n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]);\n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);\n    Bitmap_Head.biXPels = ToL(&buffer[0x14]);\n    Bitmap_Head.biYPels = ToL(&buffer[0x18]);\n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]);\n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);\n    Bitmap_Head.masks[0] = ToL(&buffer[0x24]);\n    Bitmap_Head.masks[1] = ToL(&buffer[0x28]);\n    Bitmap_Head.masks[2] = ToL(&buffer[0x2C]);\n    Bitmap_Head.masks[3] = ToL(&buffer[0x30]);\n\n    Maps = 4;\n\n    if (Bitmap_Head.biCompr == BI_BITFIELDS)\n    {\n\t    ReadChannelMasks(&Bitmap_Head.masks[0], masks, 4);\n    }\n    else if (Bitmap_Head.biCompr == BI_RGB)\n    {\n\t    setMasksDefault(Bitmap_Head.biBitCnt, masks);\n    }\n  } else {\n    LOG(\"Error reading BMP file header\\n\");\n    at_exception_fatal(&exp, \"Error reading BMP file header\");\n    goto cleanup;\n  }\n\n  /* Valid options 1, 4, 8, 16, 24, 32 */\n  /* 16 is awful, we should probably shoot whoever invented it */\n\n  switch (Bitmap_Head.biBitCnt)\n  {\n  case 1:\n  case 2:\n  case 4:\n  case 8:\n  case 16:\n  case 24:\n  case 32:\n\t  break;\n  default:\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n\n  /* There should be some colors used! */\n\n  ColormapSize = (Bitmap_File_Head.bfOffs - Bitmap_File_Head.biSize - 14) / Maps;\n\n  if ((Bitmap_Head.biClrUsed == 0) &&\n      (Bitmap_Head.biBitCnt <= 8))\n  {\n\t  ColormapSize = Bitmap_Head.biClrUsed = 1 << Bitmap_Head.biBitCnt;\n  }\n\n  if (ColormapSize > 256)\n    ColormapSize = 256;\n\n  /* Sanity checks */\n\n  if (Bitmap_Head.biHeight == 0 ||\n\t  Bitmap_Head.biWidth == 0)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n\n  /* biHeight may be negative, but -2147483648 is dangerous because:\n\t -2147483648 == -(-2147483648) */\n  if (Bitmap_Head.biWidth < 0 ||\n\t  Bitmap_Head.biHeight == -2147483648)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n\n  if (Bitmap_Head.biPlanes != 1)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n\n  if (Bitmap_Head.biClrUsed > 256 &&\n\t  Bitmap_Head.biBitCnt <= 8)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n\n  /* protect against integer overflows caused by malicious BMPs */\n  /* use divisions in comparisons to avoid type overflows */\n\n  if (((unsigned long)Bitmap_Head.biWidth) > (unsigned int)0x7fffffff / Bitmap_Head.biBitCnt ||\n\t  ((unsigned long)Bitmap_Head.biWidth) > ((unsigned int)0x7fffffff /abs(Bitmap_Head.biHeight)) / 4)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n\n  /* Windows and OS/2 declare filler so that rows are a multiple of\n   * word length (32 bits == 4 bytes)\n   */\n   \n  unsigned long overflowTest = Bitmap_Head.biWidth * Bitmap_Head.biBitCnt;\n  if (overflowTest / Bitmap_Head.biWidth != Bitmap_Head.biBitCnt) {\n    LOG(\"Error reading BMP file header. Width is too large\\n\");\n    at_exception_fatal(&exp, \"Error reading BMP file header. Width is too large\");\n    goto cleanup;\n  }\n\n  rowbytes = ((Bitmap_Head.biWidth * Bitmap_Head.biBitCnt - 1) / 32) * 4 + 4;\n\n#ifdef DEBUG\n  printf(\"\\nSize: %u, Colors: %u, Bits: %u, Width: %u, Height: %u, Comp: %u, Zeile: %u\\n\", Bitmap_File_Head.bfSize, Bitmap_Head.biClrUsed, Bitmap_Head.biBitCnt, Bitmap_Head.biWidth, Bitmap_Head.biHeight, Bitmap_Head.biCompr, rowbytes);\n#endif\n\n\n  if (Bitmap_Head.biBitCnt <= 8)\n  {\n#ifdef DEBUG\n    printf(\"Colormap read\\n\");\n#endif\n\t  /* Get the Colormap */\n\t  if (!ReadColorMap(fd, ColorMap, ColormapSize, Maps, &Grey, &exp))\n\t\t  goto cleanup;\n  }\n\n  fseek(fd, Bitmap_File_Head.bfOffs, SEEK_SET);\n\n  /* Get the Image and return the ID or -1 on error */\n  image_storage = ReadImage(fd, \n\tBitmap_Head.biWidth, Bitmap_Head.biHeight,\n\tColorMap,\n        Bitmap_Head.biClrUsed,\n\tBitmap_Head.biBitCnt, Bitmap_Head.biCompr, rowbytes,\n        Grey,\n\tmasks,\n\t&exp);\n\n  image = at_bitmap_init(image_storage, (unsigned short)Bitmap_Head.biWidth, (unsigned short)Bitmap_Head.biHeight, Grey ? 1 : 3);\ncleanup:\n  fclose(fd);\n  return (image);\n}", "func_hash": 217805098145205715295086602544452101199, "file_name": "input-bmp.c", "file_hash": 38605146891124325135879659140059354528, "cwe": ["CWE-787"], "cve": "CVE-2022-32323", "cve_desc": "AutoTrace v0.40.0 was discovered to contain a heap overflow via the ReadImage function at input-bmp.c:660.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-32323", "file_path": "src/input-bmp.c"}
{"idx": 397644, "project": "autotrace", "commit_id": "e96bffadc25ff0ba0e10745f8012efcc5f920ea9", "project_url": "https://github.com/autotrace/autotrace", "commit_url": "https://github.com/autotrace/autotrace/commit/e96bffadc25ff0ba0e10745f8012efcc5f920ea9", "commit_message": "input-bmp: Increase header buffer in some cases\n\nSigned-off-by: Peter Lemenkov <lemenkov@gmail.com>", "target": 0, "func": "at_bitmap input_bmp_reader(gchar * filename, at_input_opts_type * opts, at_msg_func msg_func, gpointer msg_data, gpointer user_data)\n{\n  FILE *fd;\n  unsigned char buffer[128];\n  int ColormapSize, rowbytes, Maps;\n  gboolean Grey = FALSE;\n  unsigned char ColorMap[256][3];\n  at_bitmap image = at_bitmap_init(0, 0, 0, 1);\n  unsigned char *image_storage;\n  at_exception_type exp = at_exception_new(msg_func, msg_data);\n  char magick[2];\n  Bitmap_Channel masks[4];\n\n  fd = fopen(filename, \"rb\");\n\n  if (!fd) {\n    LOG(\"Can't open \\\"%s\\\"\\n\", filename);\n    at_exception_fatal(&exp, \"bmp: cannot open input file\");\n    goto cleanup;\n  }\n\n  /* It is a File. Now is it a Bitmap? Read the shortest possible header. */\n\n  if (!ReadOK(fd, magick, 2) ||\n\t  !(!strncmp(magick, \"BA\", 2) ||\n\t\t  !strncmp(magick, \"BM\", 2) ||\n\t\t  !strncmp(magick, \"IC\", 2) ||\n\t\t  !strncmp(magick, \"PT\", 2) ||\n\t\t  !strncmp(magick, \"CI\", 2) ||\n\t\t  !strncmp(magick, \"CP\", 2)))\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n\n  while (!strncmp(magick, \"BA\", 2))\n  {\n\t  if (!ReadOK(fd, buffer, 12))\n\t  {\n\t\t  LOG(\"%s is not a valid BMP file\", filename);\n\t\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t\t  goto cleanup;\n\t  }\n\n\t  if (!ReadOK(fd, magick, 2))\n\t  {\n\t\t  LOG(\"%s is not a valid BMP file\", filename);\n\t\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t\t  goto cleanup;\n\t  }\n  }\n\n  if (!ReadOK(fd, buffer, 12))////\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n\n  /* bring them to the right byteorder. Not too nice, but it should work */\n\n  Bitmap_File_Head.bfSize = ToL(&buffer[0x00]);\n  Bitmap_File_Head.zzHotX = ToS(&buffer[0x04]);\n  Bitmap_File_Head.zzHotY = ToS(&buffer[0x06]);\n  Bitmap_File_Head.bfOffs = ToL(&buffer[0x08]);\n\n  if (!ReadOK(fd, buffer, 4))\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n\n  Bitmap_File_Head.biSize = ToL(&buffer[0x00]);\n\n  /* What kind of bitmap is it? */\n\n  if (Bitmap_File_Head.biSize == 12) {  /* OS/2 1.x ? */\n    if (!ReadOK(fd, buffer, 8)) {\n      LOG(\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n\n    Bitmap_Head.biWidth = ToS(&buffer[0x00]); /* 12 */\n    Bitmap_Head.biHeight = ToS(&buffer[0x02]);  /* 14 */\n    Bitmap_Head.biPlanes = ToS(&buffer[0x04]);  /* 16 */\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x06]);  /* 18 */\n    Bitmap_Head.biCompr = 0;\n    Bitmap_Head.biSizeIm = 0;\n    Bitmap_Head.biXPels = Bitmap_Head.biYPels = 0;\n    Bitmap_Head.biClrUsed = 0;\n    Bitmap_Head.biClrImp = 0;\n    Bitmap_Head.masks[0] = 0;\n    Bitmap_Head.masks[1] = 0;\n    Bitmap_Head.masks[2] = 0;\n    Bitmap_Head.masks[3] = 0;\n\n    memset(masks, 0, sizeof(masks));\n    Maps = 3;\n\n  } else if (Bitmap_File_Head.biSize == 40) { /* Windows 3.x */\n    if (!ReadOK(fd, buffer, 36))\n    {\n      LOG (\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n          \n\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]); /* 12 */\n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);  /* 16 */\n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);  /* 1A */\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);  /* 1C */\n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]); /* 1E */\n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);  /* 22 */\n    Bitmap_Head.biXPels = ToL(&buffer[0x14]); /* 26 */\n    Bitmap_Head.biYPels = ToL(&buffer[0x18]); /* 2A */\n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]); /* 2E */\n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);  /* 32 */\n    Bitmap_Head.masks[0] = 0;\n    Bitmap_Head.masks[1] = 0;\n    Bitmap_Head.masks[2] = 0;\n    Bitmap_Head.masks[3] = 0;\n\n    Maps = 4;\n    memset(masks, 0, sizeof(masks));\n\n    if (Bitmap_Head.biCompr == BI_BITFIELDS)\n      {\n\tif (!ReadOK(fd, buffer, 3 * sizeof(unsigned long)))\n\t  {\n\t    LOG(\"Error reading BMP file header\\n\");\n\t    at_exception_fatal(&exp, \"Error reading BMP file header\");\n\t    goto cleanup;\n\t  }\n\n\tBitmap_Head.masks[0] = ToL(&buffer[0x00]);\n\tBitmap_Head.masks[1] = ToL(&buffer[0x04]);\n\tBitmap_Head.masks[2] = ToL(&buffer[0x08]);\n\n\tReadChannelMasks(&Bitmap_Head.masks[0], masks, 3);\n      }\n    else if (Bitmap_Head.biCompr == BI_RGB)\n      {\n\tsetMasksDefault(Bitmap_Head.biBitCnt, masks);\n      }\n    else if ((Bitmap_Head.biCompr != BI_RLE4) &&\n\t     (Bitmap_Head.biCompr != BI_RLE8))\n      {\n\t/* BI_ALPHABITFIELDS, etc. */\n\tLOG(\"Unsupported compression in BMP file\\n\");\n\tat_exception_fatal(&exp, \"Unsupported compression in BMP file\");\n\tgoto cleanup;\n      }\n  }\n  else if (Bitmap_File_Head.biSize >= 56 &&\n\t   Bitmap_File_Head.biSize <= 64)\n  {\n    /* enhanced Windows format with bit masks */\n\n    if (!ReadOK (fd, buffer, Bitmap_File_Head.biSize - 4))\n    {\n\n      LOG(\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]); /* 12 */\n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);  /* 16 */\n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);  /* 1A */\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);  /* 1C */\n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]); /* 1E */\n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);  /* 22 */\n    Bitmap_Head.biXPels = ToL(&buffer[0x14]); /* 26 */\n    Bitmap_Head.biYPels = ToL(&buffer[0x18]); /* 2A */\n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]); /* 2E */\n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);  /* 32 */\n    Bitmap_Head.masks[0] = ToL(&buffer[0x24]);       /* 36 */\n    Bitmap_Head.masks[1] = ToL(&buffer[0x28]);       /* 3A */\n    Bitmap_Head.masks[2] = ToL(&buffer[0x2C]);       /* 3E */\n    Bitmap_Head.masks[3] = ToL(&buffer[0x30]);       /* 42 */\n\n    Maps = 4;\n    ReadChannelMasks(&Bitmap_Head.masks[0], masks, 4);\n  }\n  else if (Bitmap_File_Head.biSize == 108 ||\n           Bitmap_File_Head.biSize == 124)\n  {\n    /* BMP Version 4 or 5 */\n\n    if (!ReadOK(fd, buffer, Bitmap_File_Head.biSize - 4))\n    {\n\t    LOG(\"Error reading BMP file header\\n\");\n\t    at_exception_fatal(&exp, \"Error reading BMP file header\");\n\t    goto cleanup;\n    }\n\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]);\n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);\n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);\n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]);\n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);\n    Bitmap_Head.biXPels = ToL(&buffer[0x14]);\n    Bitmap_Head.biYPels = ToL(&buffer[0x18]);\n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]);\n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);\n    Bitmap_Head.masks[0] = ToL(&buffer[0x24]);\n    Bitmap_Head.masks[1] = ToL(&buffer[0x28]);\n    Bitmap_Head.masks[2] = ToL(&buffer[0x2C]);\n    Bitmap_Head.masks[3] = ToL(&buffer[0x30]);\n\n    Maps = 4;\n\n    if (Bitmap_Head.biCompr == BI_BITFIELDS)\n    {\n\t    ReadChannelMasks(&Bitmap_Head.masks[0], masks, 4);\n    }\n    else if (Bitmap_Head.biCompr == BI_RGB)\n    {\n\t    setMasksDefault(Bitmap_Head.biBitCnt, masks);\n    }\n  } else {\n    LOG(\"Error reading BMP file header\\n\");\n    at_exception_fatal(&exp, \"Error reading BMP file header\");\n    goto cleanup;\n  }\n\n  /* Valid options 1, 4, 8, 16, 24, 32 */\n  /* 16 is awful, we should probably shoot whoever invented it */\n\n  switch (Bitmap_Head.biBitCnt)\n  {\n  case 1:\n  case 2:\n  case 4:\n  case 8:\n  case 16:\n  case 24:\n  case 32:\n\t  break;\n  default:\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n\n  /* There should be some colors used! */\n\n  ColormapSize = (Bitmap_File_Head.bfOffs - Bitmap_File_Head.biSize - 14) / Maps;\n\n  if ((Bitmap_Head.biClrUsed == 0) &&\n      (Bitmap_Head.biBitCnt <= 8))\n  {\n\t  ColormapSize = Bitmap_Head.biClrUsed = 1 << Bitmap_Head.biBitCnt;\n  }\n\n  if (ColormapSize > 256)\n    ColormapSize = 256;\n\n  /* Sanity checks */\n\n  if (Bitmap_Head.biHeight == 0 ||\n\t  Bitmap_Head.biWidth == 0)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n\n  /* biHeight may be negative, but -2147483648 is dangerous because:\n\t -2147483648 == -(-2147483648) */\n  if (Bitmap_Head.biWidth < 0 ||\n\t  Bitmap_Head.biHeight == -2147483648)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n\n  if (Bitmap_Head.biPlanes != 1)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n\n  if (Bitmap_Head.biClrUsed > 256 &&\n\t  Bitmap_Head.biBitCnt <= 8)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n\n  /* protect against integer overflows caused by malicious BMPs */\n  /* use divisions in comparisons to avoid type overflows */\n\n  if (((unsigned long)Bitmap_Head.biWidth) > (unsigned int)0x7fffffff / Bitmap_Head.biBitCnt ||\n\t  ((unsigned long)Bitmap_Head.biWidth) > ((unsigned int)0x7fffffff /abs(Bitmap_Head.biHeight)) / 4)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n\n  /* Windows and OS/2 declare filler so that rows are a multiple of\n   * word length (32 bits == 4 bytes)\n   */\n   \n  unsigned long overflowTest = Bitmap_Head.biWidth * Bitmap_Head.biBitCnt;\n  if (overflowTest / Bitmap_Head.biWidth != Bitmap_Head.biBitCnt) {\n    LOG(\"Error reading BMP file header. Width is too large\\n\");\n    at_exception_fatal(&exp, \"Error reading BMP file header. Width is too large\");\n    goto cleanup;\n  }\n\n  rowbytes = ((Bitmap_Head.biWidth * Bitmap_Head.biBitCnt - 1) / 32) * 4 + 4;\n\n#ifdef DEBUG\n  printf(\"\\nSize: %u, Colors: %u, Bits: %u, Width: %u, Height: %u, Comp: %u, Zeile: %u\\n\", Bitmap_File_Head.bfSize, Bitmap_Head.biClrUsed, Bitmap_Head.biBitCnt, Bitmap_Head.biWidth, Bitmap_Head.biHeight, Bitmap_Head.biCompr, rowbytes);\n#endif\n\n\n  if (Bitmap_Head.biBitCnt <= 8)\n  {\n#ifdef DEBUG\n    printf(\"Colormap read\\n\");\n#endif\n\t  /* Get the Colormap */\n\t  if (!ReadColorMap(fd, ColorMap, ColormapSize, Maps, &Grey, &exp))\n\t\t  goto cleanup;\n  }\n\n  fseek(fd, Bitmap_File_Head.bfOffs, SEEK_SET);\n\n  /* Get the Image and return the ID or -1 on error */\n  image_storage = ReadImage(fd, \n\tBitmap_Head.biWidth, Bitmap_Head.biHeight,\n\tColorMap,\n        Bitmap_Head.biClrUsed,\n\tBitmap_Head.biBitCnt, Bitmap_Head.biCompr, rowbytes,\n        Grey,\n\tmasks,\n\t&exp);\n\n  image = at_bitmap_init(image_storage, (unsigned short)Bitmap_Head.biWidth, (unsigned short)Bitmap_Head.biHeight, Grey ? 1 : 3);\ncleanup:\n  fclose(fd);\n  return (image);\n}", "func_hash": 18153038985911000449594893666433988306, "file_name": "input-bmp.c", "file_hash": 29852375577809733693857999744439179756, "cwe": ["CWE-787"], "cve": "CVE-2022-32323", "cve_desc": "AutoTrace v0.40.0 was discovered to contain a heap overflow via the ReadImage function at input-bmp.c:660.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-32323", "file_path": "src/input-bmp.c"}
